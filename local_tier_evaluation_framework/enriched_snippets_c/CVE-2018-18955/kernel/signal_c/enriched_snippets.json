[
  {
    "function_name": "kdb_send_sig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "4111-4140",
    "snippet": "void kdb_send_sig(struct task_struct *t, int sig)\n{\n\tstatic struct task_struct *kdb_prev_t;\n\tint new_t, ret;\n\tif (!spin_trylock(&t->sighand->siglock)) {\n\t\tkdb_printf(\"Can't do kill command now.\\n\"\n\t\t\t   \"The sigmask lock is held somewhere else in \"\n\t\t\t   \"kernel, try again later\\n\");\n\t\treturn;\n\t}\n\tnew_t = kdb_prev_t != t;\n\tkdb_prev_t = t;\n\tif (t->state != TASK_RUNNING && new_t) {\n\t\tspin_unlock(&t->sighand->siglock);\n\t\tkdb_printf(\"Process is not RUNNING, sending a signal from \"\n\t\t\t   \"kdb risks deadlock\\n\"\n\t\t\t   \"on the run queue locks. \"\n\t\t\t   \"The signal has _not_ been sent.\\n\"\n\t\t\t   \"Reissue the kill command if you want to risk \"\n\t\t\t   \"the deadlock.\\n\");\n\t\treturn;\n\t}\n\tret = send_signal(sig, SEND_SIG_PRIV, t, PIDTYPE_PID);\n\tspin_unlock(&t->sighand->siglock);\n\tif (ret)\n\t\tkdb_printf(\"Fail to deliver Signal %d to process %d.\\n\",\n\t\t\t   sig, t->pid);\n\telse\n\t\tkdb_printf(\"Signal %d is sent to process %d.\\n\", sig, t->pid);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kdb_printf",
          "args": [
            "\"Signal %d is sent to process %d.\\n\"",
            "sig",
            "t->pid"
          ],
          "line": 4139
        },
        "resolved": true,
        "details": {
          "function_name": "kdb_printf",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/debug/kdb/kdb_io.c",
          "lines": "852-862",
          "snippet": "int kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}",
          "includes": [
            "#include \"kdb_private.h\"",
            "#include <linux/kallsyms.h>",
            "#include <linux/kdb.h>",
            "#include <linux/kgdb.h>",
            "#include <linux/delay.h>",
            "#include <linux/nmi.h>",
            "#include <linux/smp.h>",
            "#include <linux/sched.h>",
            "#include <linux/string.h>",
            "#include <linux/console.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/ctype.h>",
            "#include <linux/types.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"kdb_private.h\"\n#include <linux/kallsyms.h>\n#include <linux/kdb.h>\n#include <linux/kgdb.h>\n#include <linux/delay.h>\n#include <linux/nmi.h>\n#include <linux/smp.h>\n#include <linux/sched.h>\n#include <linux/string.h>\n#include <linux/console.h>\n#include <linux/kdev_t.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/ctype.h>\n#include <linux/types.h>\n#include <linux/module.h>\n\nint kdb_printf(const char *fmt, ...)\n{\n\tva_list ap;\n\tint r;\n\n\tva_start(ap, fmt);\n\tr = vkdb_printf(KDB_MSGSRC_INTERNAL, fmt, ap);\n\tva_end(ap);\n\n\treturn r;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&t->sighand->siglock"
          ],
          "line": 4134
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_signal",
          "args": [
            "sig",
            "SEND_SIG_PRIV",
            "t",
            "PIDTYPE_PID"
          ],
          "line": 4133
        },
        "resolved": true,
        "details": {
          "function_name": "send_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1153-1164",
          "snippet": "static int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\tint from_ancestor_ns = 0;\n\n#ifdef CONFIG_PID_NS\n\tfrom_ancestor_ns = si_fromuser(info) &&\n\t\t\t   !task_pid_nr_ns(current, task_active_pid_ns(t));\n#endif\n\n\treturn __send_signal(sig, info, t, type, from_ancestor_ns);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\tint from_ancestor_ns = 0;\n\n#ifdef CONFIG_PID_NS\n\tfrom_ancestor_ns = si_fromuser(info) &&\n\t\t\t   !task_pid_nr_ns(current, task_active_pid_ns(t));\n#endif\n\n\treturn __send_signal(sig, info, t, type, from_ancestor_ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_trylock",
          "args": [
            "&t->sighand->siglock"
          ],
          "line": 4115
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_trylock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "134-137",
          "snippet": "int __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nint __lockfunc _raw_spin_trylock_bh(raw_spinlock_t *lock)\n{\n\treturn __raw_spin_trylock_bh(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid kdb_send_sig(struct task_struct *t, int sig)\n{\n\tstatic struct task_struct *kdb_prev_t;\n\tint new_t, ret;\n\tif (!spin_trylock(&t->sighand->siglock)) {\n\t\tkdb_printf(\"Can't do kill command now.\\n\"\n\t\t\t   \"The sigmask lock is held somewhere else in \"\n\t\t\t   \"kernel, try again later\\n\");\n\t\treturn;\n\t}\n\tnew_t = kdb_prev_t != t;\n\tkdb_prev_t = t;\n\tif (t->state != TASK_RUNNING && new_t) {\n\t\tspin_unlock(&t->sighand->siglock);\n\t\tkdb_printf(\"Process is not RUNNING, sending a signal from \"\n\t\t\t   \"kdb risks deadlock\\n\"\n\t\t\t   \"on the run queue locks. \"\n\t\t\t   \"The signal has _not_ been sent.\\n\"\n\t\t\t   \"Reissue the kill command if you want to risk \"\n\t\t\t   \"the deadlock.\\n\");\n\t\treturn;\n\t}\n\tret = send_signal(sig, SEND_SIG_PRIV, t, PIDTYPE_PID);\n\tspin_unlock(&t->sighand->siglock);\n\tif (ret)\n\t\tkdb_printf(\"Fail to deliver Signal %d to process %d.\\n\",\n\t\t\t   sig, t->pid);\n\telse\n\t\tkdb_printf(\"Signal %d is sent to process %d.\\n\", sig, t->pid);\n}"
  },
  {
    "function_name": "signals_init",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "4096-4101",
    "snippet": "void __init signals_init(void)\n{\n\tsiginfo_buildtime_checks();\n\n\tsigqueue_cachep = KMEM_CACHE(sigqueue, SLAB_PANIC);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *sigqueue_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "KMEM_CACHE",
          "args": [
            "sigqueue",
            "SLAB_PANIC"
          ],
          "line": 4100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "siginfo_buildtime_checks",
          "args": [],
          "line": 4098
        },
        "resolved": true,
        "details": {
          "function_name": "siginfo_buildtime_checks",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "4049-4094",
          "snippet": "static inline void siginfo_buildtime_checks(void)\n{\n\tBUILD_BUG_ON(sizeof(struct siginfo) != SI_MAX_SIZE);\n\n\t/* Verify the offsets in the two siginfos match */\n#define CHECK_OFFSET(field) \\\n\tBUILD_BUG_ON(offsetof(siginfo_t, field) != offsetof(kernel_siginfo_t, field))\n\n\t/* kill */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\n\t/* timer */\n\tCHECK_OFFSET(si_tid);\n\tCHECK_OFFSET(si_overrun);\n\tCHECK_OFFSET(si_value);\n\n\t/* rt */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\tCHECK_OFFSET(si_value);\n\n\t/* sigchld */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\tCHECK_OFFSET(si_status);\n\tCHECK_OFFSET(si_utime);\n\tCHECK_OFFSET(si_stime);\n\n\t/* sigfault */\n\tCHECK_OFFSET(si_addr);\n\tCHECK_OFFSET(si_addr_lsb);\n\tCHECK_OFFSET(si_lower);\n\tCHECK_OFFSET(si_upper);\n\tCHECK_OFFSET(si_pkey);\n\n\t/* sigpoll */\n\tCHECK_OFFSET(si_band);\n\tCHECK_OFFSET(si_fd);\n\n\t/* sigsys */\n\tCHECK_OFFSET(si_call_addr);\n\tCHECK_OFFSET(si_syscall);\n\tCHECK_OFFSET(si_arch);\n#undef CHECK_OFFSET\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline void siginfo_buildtime_checks(void)\n{\n\tBUILD_BUG_ON(sizeof(struct siginfo) != SI_MAX_SIZE);\n\n\t/* Verify the offsets in the two siginfos match */\n#define CHECK_OFFSET(field) \\\n\tBUILD_BUG_ON(offsetof(siginfo_t, field) != offsetof(kernel_siginfo_t, field))\n\n\t/* kill */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\n\t/* timer */\n\tCHECK_OFFSET(si_tid);\n\tCHECK_OFFSET(si_overrun);\n\tCHECK_OFFSET(si_value);\n\n\t/* rt */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\tCHECK_OFFSET(si_value);\n\n\t/* sigchld */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\tCHECK_OFFSET(si_status);\n\tCHECK_OFFSET(si_utime);\n\tCHECK_OFFSET(si_stime);\n\n\t/* sigfault */\n\tCHECK_OFFSET(si_addr);\n\tCHECK_OFFSET(si_addr_lsb);\n\tCHECK_OFFSET(si_lower);\n\tCHECK_OFFSET(si_upper);\n\tCHECK_OFFSET(si_pkey);\n\n\t/* sigpoll */\n\tCHECK_OFFSET(si_band);\n\tCHECK_OFFSET(si_fd);\n\n\t/* sigsys */\n\tCHECK_OFFSET(si_call_addr);\n\tCHECK_OFFSET(si_syscall);\n\tCHECK_OFFSET(si_arch);\n#undef CHECK_OFFSET\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nvoid __init signals_init(void)\n{\n\tsiginfo_buildtime_checks();\n\n\tsigqueue_cachep = KMEM_CACHE(sigqueue, SLAB_PANIC);\n}"
  },
  {
    "function_name": "siginfo_buildtime_checks",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "4049-4094",
    "snippet": "static inline void siginfo_buildtime_checks(void)\n{\n\tBUILD_BUG_ON(sizeof(struct siginfo) != SI_MAX_SIZE);\n\n\t/* Verify the offsets in the two siginfos match */\n#define CHECK_OFFSET(field) \\\n\tBUILD_BUG_ON(offsetof(siginfo_t, field) != offsetof(kernel_siginfo_t, field))\n\n\t/* kill */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\n\t/* timer */\n\tCHECK_OFFSET(si_tid);\n\tCHECK_OFFSET(si_overrun);\n\tCHECK_OFFSET(si_value);\n\n\t/* rt */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\tCHECK_OFFSET(si_value);\n\n\t/* sigchld */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\tCHECK_OFFSET(si_status);\n\tCHECK_OFFSET(si_utime);\n\tCHECK_OFFSET(si_stime);\n\n\t/* sigfault */\n\tCHECK_OFFSET(si_addr);\n\tCHECK_OFFSET(si_addr_lsb);\n\tCHECK_OFFSET(si_lower);\n\tCHECK_OFFSET(si_upper);\n\tCHECK_OFFSET(si_pkey);\n\n\t/* sigpoll */\n\tCHECK_OFFSET(si_band);\n\tCHECK_OFFSET(si_fd);\n\n\t/* sigsys */\n\tCHECK_OFFSET(si_call_addr);\n\tCHECK_OFFSET(si_syscall);\n\tCHECK_OFFSET(si_arch);\n#undef CHECK_OFFSET\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_arch"
          ],
          "line": 4092
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_syscall"
          ],
          "line": 4091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_call_addr"
          ],
          "line": 4090
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_fd"
          ],
          "line": 4087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_band"
          ],
          "line": 4086
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_pkey"
          ],
          "line": 4083
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_upper"
          ],
          "line": 4082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_lower"
          ],
          "line": 4081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_addr_lsb"
          ],
          "line": 4080
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_addr"
          ],
          "line": 4079
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_stime"
          ],
          "line": 4076
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_utime"
          ],
          "line": 4075
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_status"
          ],
          "line": 4074
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_uid"
          ],
          "line": 4073
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_pid"
          ],
          "line": 4072
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_value"
          ],
          "line": 4069
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_uid"
          ],
          "line": 4068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_pid"
          ],
          "line": 4067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_value"
          ],
          "line": 4064
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_overrun"
          ],
          "line": 4063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_tid"
          ],
          "line": 4062
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_uid"
          ],
          "line": 4059
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CHECK_OFFSET",
          "args": [
            "si_pid"
          ],
          "line": 4058
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUILD_BUG_ON",
          "args": [
            "sizeof(struct siginfo) != SI_MAX_SIZE"
          ],
          "line": 4051
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline void siginfo_buildtime_checks(void)\n{\n\tBUILD_BUG_ON(sizeof(struct siginfo) != SI_MAX_SIZE);\n\n\t/* Verify the offsets in the two siginfos match */\n#define CHECK_OFFSET(field) \\\n\tBUILD_BUG_ON(offsetof(siginfo_t, field) != offsetof(kernel_siginfo_t, field))\n\n\t/* kill */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\n\t/* timer */\n\tCHECK_OFFSET(si_tid);\n\tCHECK_OFFSET(si_overrun);\n\tCHECK_OFFSET(si_value);\n\n\t/* rt */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\tCHECK_OFFSET(si_value);\n\n\t/* sigchld */\n\tCHECK_OFFSET(si_pid);\n\tCHECK_OFFSET(si_uid);\n\tCHECK_OFFSET(si_status);\n\tCHECK_OFFSET(si_utime);\n\tCHECK_OFFSET(si_stime);\n\n\t/* sigfault */\n\tCHECK_OFFSET(si_addr);\n\tCHECK_OFFSET(si_addr_lsb);\n\tCHECK_OFFSET(si_lower);\n\tCHECK_OFFSET(si_upper);\n\tCHECK_OFFSET(si_pkey);\n\n\t/* sigpoll */\n\tCHECK_OFFSET(si_band);\n\tCHECK_OFFSET(si_fd);\n\n\t/* sigsys */\n\tCHECK_OFFSET(si_call_addr);\n\tCHECK_OFFSET(si_syscall);\n\tCHECK_OFFSET(si_arch);\n#undef CHECK_OFFSET\n}"
  },
  {
    "function_name": "arch_vma_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "4044-4047",
    "snippet": "__weak const char *arch_vma_name(struct vm_area_struct *vma)\n{\n\treturn NULL;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\n__weak const char *arch_vma_name(struct vm_area_struct *vma)\n{\n\treturn NULL;\n}"
  },
  {
    "function_name": "sigsuspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3980-3991",
    "snippet": "static int sigsuspend(sigset_t *set)\n{\n\tcurrent->saved_sigmask = current->blocked;\n\tset_current_blocked(set);\n\n\twhile (!signal_pending(current)) {\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule();\n\t}\n\tset_restore_sigmask();\n\treturn -ERESTARTNOHAND;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_restore_sigmask",
          "args": [],
          "line": 3989
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "schedule",
          "args": [],
          "line": 3987
        },
        "resolved": true,
        "details": {
          "function_name": "audit_schedule_prune",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/audit_tree.c",
          "lines": "919-922",
          "snippet": "static void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}",
          "includes": [
            "#include <linux/slab.h>",
            "#include <linux/refcount.h>",
            "#include <linux/kthread.h>",
            "#include <linux/mount.h>",
            "#include <linux/namei.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include \"audit.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static struct task_struct *prune_thread;",
            "static void audit_schedule_prune(void);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/slab.h>\n#include <linux/refcount.h>\n#include <linux/kthread.h>\n#include <linux/mount.h>\n#include <linux/namei.h>\n#include <linux/fsnotify_backend.h>\n#include \"audit.h\"\n\nstatic struct task_struct *prune_thread;\nstatic void audit_schedule_prune(void);\n\nstatic void audit_schedule_prune(void)\n{\n\twake_up_process(prune_thread);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 3986
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "current"
          ],
          "line": 3985
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_blocked",
          "args": [
            "set"
          ],
          "line": 3983
        },
        "resolved": true,
        "details": {
          "function_name": "__set_current_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "2686-2700",
          "snippet": "void __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int sigsuspend(sigset_t *set)\n{\n\tcurrent->saved_sigmask = current->blocked;\n\tset_current_blocked(set);\n\n\twhile (!signal_pending(current)) {\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule();\n\t}\n\tset_restore_sigmask();\n\treturn -ERESTARTNOHAND;\n}"
  },
  {
    "function_name": "__compat_save_altstack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3667-3680",
    "snippet": "int __compat_save_altstack(compat_stack_t __user *uss, unsigned long sp)\n{\n\tint err;\n\tstruct task_struct *t = current;\n\terr = __put_user(ptr_to_compat((void __user *)t->sas_ss_sp),\n\t\t\t &uss->ss_sp) |\n\t\t__put_user(t->sas_ss_flags, &uss->ss_flags) |\n\t\t__put_user(t->sas_ss_size, &uss->ss_size);\n\tif (err)\n\t\treturn err;\n\tif (t->sas_ss_flags & SS_AUTODISARM)\n\t\tsas_ss_reset(t);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sas_ss_reset",
          "args": [
            "t"
          ],
          "line": 3678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "t->sas_ss_size",
            "&uss->ss_size"
          ],
          "line": 3674
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "t->sas_ss_flags",
            "&uss->ss_flags"
          ],
          "line": 3673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "ptr_to_compat((void __user *)t->sas_ss_sp)",
            "&uss->ss_sp"
          ],
          "line": 3671
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "(void __user *)t->sas_ss_sp"
          ],
          "line": 3671
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint __compat_save_altstack(compat_stack_t __user *uss, unsigned long sp)\n{\n\tint err;\n\tstruct task_struct *t = current;\n\terr = __put_user(ptr_to_compat((void __user *)t->sas_ss_sp),\n\t\t\t &uss->ss_sp) |\n\t\t__put_user(t->sas_ss_flags, &uss->ss_flags) |\n\t\t__put_user(t->sas_ss_size, &uss->ss_size);\n\tif (err)\n\t\treturn err;\n\tif (t->sas_ss_flags & SS_AUTODISARM)\n\t\tsas_ss_reset(t);\n\treturn 0;\n}"
  },
  {
    "function_name": "compat_restore_altstack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3660-3665",
    "snippet": "int compat_restore_altstack(const compat_stack_t __user *uss)\n{\n\tint err = do_compat_sigaltstack(uss, NULL);\n\t/* squash all but -EFAULT for now */\n\treturn err == -EFAULT ? err : 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_compat_sigaltstack",
          "args": [
            "uss",
            "NULL"
          ],
          "line": 3662
        },
        "resolved": true,
        "details": {
          "function_name": "do_compat_sigaltstack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "3624-3651",
          "snippet": "static int do_compat_sigaltstack(const compat_stack_t __user *uss_ptr,\n\t\t\t\t compat_stack_t __user *uoss_ptr)\n{\n\tstack_t uss, uoss;\n\tint ret;\n\n\tif (uss_ptr) {\n\t\tcompat_stack_t uss32;\n\t\tif (copy_from_user(&uss32, uss_ptr, sizeof(compat_stack_t)))\n\t\t\treturn -EFAULT;\n\t\tuss.ss_sp = compat_ptr(uss32.ss_sp);\n\t\tuss.ss_flags = uss32.ss_flags;\n\t\tuss.ss_size = uss32.ss_size;\n\t}\n\tret = do_sigaltstack(uss_ptr ? &uss : NULL, &uoss,\n\t\t\t     compat_user_stack_pointer(),\n\t\t\t     COMPAT_MINSIGSTKSZ);\n\tif (ret >= 0 && uoss_ptr)  {\n\t\tcompat_stack_t old;\n\t\tmemset(&old, 0, sizeof(old));\n\t\told.ss_sp = ptr_to_compat(uoss.ss_sp);\n\t\told.ss_flags = uoss.ss_flags;\n\t\told.ss_size = uoss.ss_size;\n\t\tif (copy_to_user(uoss_ptr, &old, sizeof(compat_stack_t)))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int do_compat_sigaltstack(const compat_stack_t __user *uss_ptr,\n\t\t\t\t compat_stack_t __user *uoss_ptr)\n{\n\tstack_t uss, uoss;\n\tint ret;\n\n\tif (uss_ptr) {\n\t\tcompat_stack_t uss32;\n\t\tif (copy_from_user(&uss32, uss_ptr, sizeof(compat_stack_t)))\n\t\t\treturn -EFAULT;\n\t\tuss.ss_sp = compat_ptr(uss32.ss_sp);\n\t\tuss.ss_flags = uss32.ss_flags;\n\t\tuss.ss_size = uss32.ss_size;\n\t}\n\tret = do_sigaltstack(uss_ptr ? &uss : NULL, &uoss,\n\t\t\t     compat_user_stack_pointer(),\n\t\t\t     COMPAT_MINSIGSTKSZ);\n\tif (ret >= 0 && uoss_ptr)  {\n\t\tcompat_stack_t old;\n\t\tmemset(&old, 0, sizeof(old));\n\t\told.ss_sp = ptr_to_compat(uoss.ss_sp);\n\t\told.ss_flags = uoss.ss_flags;\n\t\told.ss_size = uoss.ss_size;\n\t\tif (copy_to_user(uoss_ptr, &old, sizeof(compat_stack_t)))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint compat_restore_altstack(const compat_stack_t __user *uss)\n{\n\tint err = do_compat_sigaltstack(uss, NULL);\n\t/* squash all but -EFAULT for now */\n\treturn err == -EFAULT ? err : 0;\n}"
  },
  {
    "function_name": "do_compat_sigaltstack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3624-3651",
    "snippet": "static int do_compat_sigaltstack(const compat_stack_t __user *uss_ptr,\n\t\t\t\t compat_stack_t __user *uoss_ptr)\n{\n\tstack_t uss, uoss;\n\tint ret;\n\n\tif (uss_ptr) {\n\t\tcompat_stack_t uss32;\n\t\tif (copy_from_user(&uss32, uss_ptr, sizeof(compat_stack_t)))\n\t\t\treturn -EFAULT;\n\t\tuss.ss_sp = compat_ptr(uss32.ss_sp);\n\t\tuss.ss_flags = uss32.ss_flags;\n\t\tuss.ss_size = uss32.ss_size;\n\t}\n\tret = do_sigaltstack(uss_ptr ? &uss : NULL, &uoss,\n\t\t\t     compat_user_stack_pointer(),\n\t\t\t     COMPAT_MINSIGSTKSZ);\n\tif (ret >= 0 && uoss_ptr)  {\n\t\tcompat_stack_t old;\n\t\tmemset(&old, 0, sizeof(old));\n\t\told.ss_sp = ptr_to_compat(uoss.ss_sp);\n\t\told.ss_flags = uoss.ss_flags;\n\t\told.ss_size = uoss.ss_size;\n\t\tif (copy_to_user(uoss_ptr, &old, sizeof(compat_stack_t)))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "uoss_ptr",
            "&old",
            "sizeof(compat_stack_t)"
          ],
          "line": 3647
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "uoss.ss_sp"
          ],
          "line": 3644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&old",
            "0",
            "sizeof(old)"
          ],
          "line": 3643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_sigaltstack",
          "args": [
            "uss_ptr ? &uss : NULL",
            "&uoss",
            "compat_user_stack_pointer()",
            "COMPAT_MINSIGSTKSZ"
          ],
          "line": 3638
        },
        "resolved": true,
        "details": {
          "function_name": "do_sigaltstack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "3542-3583",
          "snippet": "static int\ndo_sigaltstack (const stack_t *ss, stack_t *oss, unsigned long sp,\n\t\tsize_t min_ss_size)\n{\n\tstruct task_struct *t = current;\n\n\tif (oss) {\n\t\tmemset(oss, 0, sizeof(stack_t));\n\t\toss->ss_sp = (void __user *) t->sas_ss_sp;\n\t\toss->ss_size = t->sas_ss_size;\n\t\toss->ss_flags = sas_ss_flags(sp) |\n\t\t\t(current->sas_ss_flags & SS_FLAG_BITS);\n\t}\n\n\tif (ss) {\n\t\tvoid __user *ss_sp = ss->ss_sp;\n\t\tsize_t ss_size = ss->ss_size;\n\t\tunsigned ss_flags = ss->ss_flags;\n\t\tint ss_mode;\n\n\t\tif (unlikely(on_sig_stack(sp)))\n\t\t\treturn -EPERM;\n\n\t\tss_mode = ss_flags & ~SS_FLAG_BITS;\n\t\tif (unlikely(ss_mode != SS_DISABLE && ss_mode != SS_ONSTACK &&\n\t\t\t\tss_mode != 0))\n\t\t\treturn -EINVAL;\n\n\t\tif (ss_mode == SS_DISABLE) {\n\t\t\tss_size = 0;\n\t\t\tss_sp = NULL;\n\t\t} else {\n\t\t\tif (unlikely(ss_size < min_ss_size))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tt->sas_ss_sp = (unsigned long) ss_sp;\n\t\tt->sas_ss_size = ss_size;\n\t\tt->sas_ss_flags = ss_flags;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int\ndo_sigaltstack (const stack_t *ss, stack_t *oss, unsigned long sp,\n\t\tsize_t min_ss_size)\n{\n\tstruct task_struct *t = current;\n\n\tif (oss) {\n\t\tmemset(oss, 0, sizeof(stack_t));\n\t\toss->ss_sp = (void __user *) t->sas_ss_sp;\n\t\toss->ss_size = t->sas_ss_size;\n\t\toss->ss_flags = sas_ss_flags(sp) |\n\t\t\t(current->sas_ss_flags & SS_FLAG_BITS);\n\t}\n\n\tif (ss) {\n\t\tvoid __user *ss_sp = ss->ss_sp;\n\t\tsize_t ss_size = ss->ss_size;\n\t\tunsigned ss_flags = ss->ss_flags;\n\t\tint ss_mode;\n\n\t\tif (unlikely(on_sig_stack(sp)))\n\t\t\treturn -EPERM;\n\n\t\tss_mode = ss_flags & ~SS_FLAG_BITS;\n\t\tif (unlikely(ss_mode != SS_DISABLE && ss_mode != SS_ONSTACK &&\n\t\t\t\tss_mode != 0))\n\t\t\treturn -EINVAL;\n\n\t\tif (ss_mode == SS_DISABLE) {\n\t\t\tss_size = 0;\n\t\t\tss_sp = NULL;\n\t\t} else {\n\t\t\tif (unlikely(ss_size < min_ss_size))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tt->sas_ss_sp = (unsigned long) ss_sp;\n\t\tt->sas_ss_size = ss_size;\n\t\tt->sas_ss_flags = ss_flags;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "compat_user_stack_pointer",
          "args": [],
          "line": 3639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "uss32.ss_sp"
          ],
          "line": 3634
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&uss32",
            "uss_ptr",
            "sizeof(compat_stack_t)"
          ],
          "line": 3632
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int do_compat_sigaltstack(const compat_stack_t __user *uss_ptr,\n\t\t\t\t compat_stack_t __user *uoss_ptr)\n{\n\tstack_t uss, uoss;\n\tint ret;\n\n\tif (uss_ptr) {\n\t\tcompat_stack_t uss32;\n\t\tif (copy_from_user(&uss32, uss_ptr, sizeof(compat_stack_t)))\n\t\t\treturn -EFAULT;\n\t\tuss.ss_sp = compat_ptr(uss32.ss_sp);\n\t\tuss.ss_flags = uss32.ss_flags;\n\t\tuss.ss_size = uss32.ss_size;\n\t}\n\tret = do_sigaltstack(uss_ptr ? &uss : NULL, &uoss,\n\t\t\t     compat_user_stack_pointer(),\n\t\t\t     COMPAT_MINSIGSTKSZ);\n\tif (ret >= 0 && uoss_ptr)  {\n\t\tcompat_stack_t old;\n\t\tmemset(&old, 0, sizeof(old));\n\t\told.ss_sp = ptr_to_compat(uoss.ss_sp);\n\t\told.ss_flags = uoss.ss_flags;\n\t\told.ss_size = uoss.ss_size;\n\t\tif (copy_to_user(uoss_ptr, &old, sizeof(compat_stack_t)))\n\t\t\tret = -EFAULT;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "__save_altstack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3610-3621",
    "snippet": "int __save_altstack(stack_t __user *uss, unsigned long sp)\n{\n\tstruct task_struct *t = current;\n\tint err = __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |\n\t\t__put_user(t->sas_ss_flags, &uss->ss_flags) |\n\t\t__put_user(t->sas_ss_size, &uss->ss_size);\n\tif (err)\n\t\treturn err;\n\tif (t->sas_ss_flags & SS_AUTODISARM)\n\t\tsas_ss_reset(t);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sas_ss_reset",
          "args": [
            "t"
          ],
          "line": 3619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "t->sas_ss_size",
            "&uss->ss_size"
          ],
          "line": 3615
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "t->sas_ss_flags",
            "&uss->ss_flags"
          ],
          "line": 3614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__put_user",
          "args": [
            "(void __user *)t->sas_ss_sp",
            "&uss->ss_sp"
          ],
          "line": 3613
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint __save_altstack(stack_t __user *uss, unsigned long sp)\n{\n\tstruct task_struct *t = current;\n\tint err = __put_user((void __user *)t->sas_ss_sp, &uss->ss_sp) |\n\t\t__put_user(t->sas_ss_flags, &uss->ss_flags) |\n\t\t__put_user(t->sas_ss_size, &uss->ss_size);\n\tif (err)\n\t\treturn err;\n\tif (t->sas_ss_flags & SS_AUTODISARM)\n\t\tsas_ss_reset(t);\n\treturn 0;\n}"
  },
  {
    "function_name": "restore_altstack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3599-3608",
    "snippet": "int restore_altstack(const stack_t __user *uss)\n{\n\tstack_t new;\n\tif (copy_from_user(&new, uss, sizeof(stack_t)))\n\t\treturn -EFAULT;\n\t(void)do_sigaltstack(&new, NULL, current_user_stack_pointer(),\n\t\t\t     MINSIGSTKSZ);\n\t/* squash all but EFAULT for now */\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_sigaltstack",
          "args": [
            "&new",
            "NULL",
            "current_user_stack_pointer()",
            "MINSIGSTKSZ"
          ],
          "line": 3604
        },
        "resolved": true,
        "details": {
          "function_name": "do_sigaltstack",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "3542-3583",
          "snippet": "static int\ndo_sigaltstack (const stack_t *ss, stack_t *oss, unsigned long sp,\n\t\tsize_t min_ss_size)\n{\n\tstruct task_struct *t = current;\n\n\tif (oss) {\n\t\tmemset(oss, 0, sizeof(stack_t));\n\t\toss->ss_sp = (void __user *) t->sas_ss_sp;\n\t\toss->ss_size = t->sas_ss_size;\n\t\toss->ss_flags = sas_ss_flags(sp) |\n\t\t\t(current->sas_ss_flags & SS_FLAG_BITS);\n\t}\n\n\tif (ss) {\n\t\tvoid __user *ss_sp = ss->ss_sp;\n\t\tsize_t ss_size = ss->ss_size;\n\t\tunsigned ss_flags = ss->ss_flags;\n\t\tint ss_mode;\n\n\t\tif (unlikely(on_sig_stack(sp)))\n\t\t\treturn -EPERM;\n\n\t\tss_mode = ss_flags & ~SS_FLAG_BITS;\n\t\tif (unlikely(ss_mode != SS_DISABLE && ss_mode != SS_ONSTACK &&\n\t\t\t\tss_mode != 0))\n\t\t\treturn -EINVAL;\n\n\t\tif (ss_mode == SS_DISABLE) {\n\t\t\tss_size = 0;\n\t\t\tss_sp = NULL;\n\t\t} else {\n\t\t\tif (unlikely(ss_size < min_ss_size))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tt->sas_ss_sp = (unsigned long) ss_sp;\n\t\tt->sas_ss_size = ss_size;\n\t\tt->sas_ss_flags = ss_flags;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int\ndo_sigaltstack (const stack_t *ss, stack_t *oss, unsigned long sp,\n\t\tsize_t min_ss_size)\n{\n\tstruct task_struct *t = current;\n\n\tif (oss) {\n\t\tmemset(oss, 0, sizeof(stack_t));\n\t\toss->ss_sp = (void __user *) t->sas_ss_sp;\n\t\toss->ss_size = t->sas_ss_size;\n\t\toss->ss_flags = sas_ss_flags(sp) |\n\t\t\t(current->sas_ss_flags & SS_FLAG_BITS);\n\t}\n\n\tif (ss) {\n\t\tvoid __user *ss_sp = ss->ss_sp;\n\t\tsize_t ss_size = ss->ss_size;\n\t\tunsigned ss_flags = ss->ss_flags;\n\t\tint ss_mode;\n\n\t\tif (unlikely(on_sig_stack(sp)))\n\t\t\treturn -EPERM;\n\n\t\tss_mode = ss_flags & ~SS_FLAG_BITS;\n\t\tif (unlikely(ss_mode != SS_DISABLE && ss_mode != SS_ONSTACK &&\n\t\t\t\tss_mode != 0))\n\t\t\treturn -EINVAL;\n\n\t\tif (ss_mode == SS_DISABLE) {\n\t\t\tss_size = 0;\n\t\t\tss_sp = NULL;\n\t\t} else {\n\t\t\tif (unlikely(ss_size < min_ss_size))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tt->sas_ss_sp = (unsigned long) ss_sp;\n\t\tt->sas_ss_size = ss_size;\n\t\tt->sas_ss_flags = ss_flags;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_stack_pointer",
          "args": [],
          "line": 3604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&new",
            "uss",
            "sizeof(stack_t)"
          ],
          "line": 3602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint restore_altstack(const stack_t __user *uss)\n{\n\tstack_t new;\n\tif (copy_from_user(&new, uss, sizeof(stack_t)))\n\t\treturn -EFAULT;\n\t(void)do_sigaltstack(&new, NULL, current_user_stack_pointer(),\n\t\t\t     MINSIGSTKSZ);\n\t/* squash all but EFAULT for now */\n\treturn 0;\n}"
  },
  {
    "function_name": "do_sigaltstack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3542-3583",
    "snippet": "static int\ndo_sigaltstack (const stack_t *ss, stack_t *oss, unsigned long sp,\n\t\tsize_t min_ss_size)\n{\n\tstruct task_struct *t = current;\n\n\tif (oss) {\n\t\tmemset(oss, 0, sizeof(stack_t));\n\t\toss->ss_sp = (void __user *) t->sas_ss_sp;\n\t\toss->ss_size = t->sas_ss_size;\n\t\toss->ss_flags = sas_ss_flags(sp) |\n\t\t\t(current->sas_ss_flags & SS_FLAG_BITS);\n\t}\n\n\tif (ss) {\n\t\tvoid __user *ss_sp = ss->ss_sp;\n\t\tsize_t ss_size = ss->ss_size;\n\t\tunsigned ss_flags = ss->ss_flags;\n\t\tint ss_mode;\n\n\t\tif (unlikely(on_sig_stack(sp)))\n\t\t\treturn -EPERM;\n\n\t\tss_mode = ss_flags & ~SS_FLAG_BITS;\n\t\tif (unlikely(ss_mode != SS_DISABLE && ss_mode != SS_ONSTACK &&\n\t\t\t\tss_mode != 0))\n\t\t\treturn -EINVAL;\n\n\t\tif (ss_mode == SS_DISABLE) {\n\t\t\tss_size = 0;\n\t\t\tss_sp = NULL;\n\t\t} else {\n\t\t\tif (unlikely(ss_size < min_ss_size))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tt->sas_ss_sp = (unsigned long) ss_sp;\n\t\tt->sas_ss_size = ss_size;\n\t\tt->sas_ss_flags = ss_flags;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ss_size < min_ss_size"
          ],
          "line": 3574
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "ss_mode != SS_DISABLE && ss_mode != SS_ONSTACK &&\n\t\t\t\tss_mode != 0"
          ],
          "line": 3566
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "on_sig_stack(sp)"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "on_sig_stack",
          "args": [
            "sp"
          ],
          "line": 3562
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sas_ss_flags",
          "args": [
            "sp"
          ],
          "line": 3552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "oss",
            "0",
            "sizeof(stack_t)"
          ],
          "line": 3549
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int\ndo_sigaltstack (const stack_t *ss, stack_t *oss, unsigned long sp,\n\t\tsize_t min_ss_size)\n{\n\tstruct task_struct *t = current;\n\n\tif (oss) {\n\t\tmemset(oss, 0, sizeof(stack_t));\n\t\toss->ss_sp = (void __user *) t->sas_ss_sp;\n\t\toss->ss_size = t->sas_ss_size;\n\t\toss->ss_flags = sas_ss_flags(sp) |\n\t\t\t(current->sas_ss_flags & SS_FLAG_BITS);\n\t}\n\n\tif (ss) {\n\t\tvoid __user *ss_sp = ss->ss_sp;\n\t\tsize_t ss_size = ss->ss_size;\n\t\tunsigned ss_flags = ss->ss_flags;\n\t\tint ss_mode;\n\n\t\tif (unlikely(on_sig_stack(sp)))\n\t\t\treturn -EPERM;\n\n\t\tss_mode = ss_flags & ~SS_FLAG_BITS;\n\t\tif (unlikely(ss_mode != SS_DISABLE && ss_mode != SS_ONSTACK &&\n\t\t\t\tss_mode != 0))\n\t\t\treturn -EINVAL;\n\n\t\tif (ss_mode == SS_DISABLE) {\n\t\t\tss_size = 0;\n\t\t\tss_sp = NULL;\n\t\t} else {\n\t\t\tif (unlikely(ss_size < min_ss_size))\n\t\t\t\treturn -ENOMEM;\n\t\t}\n\n\t\tt->sas_ss_sp = (unsigned long) ss_sp;\n\t\tt->sas_ss_size = ss_size;\n\t\tt->sas_ss_flags = ss_flags;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "do_sigaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3497-3540",
    "snippet": "int do_sigaction(int sig, struct k_sigaction *act, struct k_sigaction *oact)\n{\n\tstruct task_struct *p = current, *t;\n\tstruct k_sigaction *k;\n\tsigset_t mask;\n\n\tif (!valid_signal(sig) || sig < 1 || (act && sig_kernel_only(sig)))\n\t\treturn -EINVAL;\n\n\tk = &p->sighand->action[sig-1];\n\n\tspin_lock_irq(&p->sighand->siglock);\n\tif (oact)\n\t\t*oact = *k;\n\n\tsigaction_compat_abi(act, oact);\n\n\tif (act) {\n\t\tsigdelsetmask(&act->sa.sa_mask,\n\t\t\t      sigmask(SIGKILL) | sigmask(SIGSTOP));\n\t\t*k = *act;\n\t\t/*\n\t\t * POSIX 3.3.1.3:\n\t\t *  \"Setting a signal action to SIG_IGN for a signal that is\n\t\t *   pending shall cause the pending signal to be discarded,\n\t\t *   whether or not it is blocked.\"\n\t\t *\n\t\t *  \"Setting a signal action to SIG_DFL for a signal that is\n\t\t *   pending and whose default action is to ignore the signal\n\t\t *   (for example, SIGCHLD), shall cause the pending signal to\n\t\t *   be discarded, whether or not it is blocked\"\n\t\t */\n\t\tif (sig_handler_ignored(sig_handler(p, sig), sig)) {\n\t\t\tsigemptyset(&mask);\n\t\t\tsigaddset(&mask, sig);\n\t\t\tflush_sigqueue_mask(&mask, &p->signal->shared_pending);\n\t\t\tfor_each_thread(p, t)\n\t\t\t\tflush_sigqueue_mask(&mask, &t->pending);\n\t\t}\n\t}\n\n\tspin_unlock_irq(&p->sighand->siglock);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&p->sighand->siglock"
          ],
          "line": 3538
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_sigqueue_mask",
          "args": [
            "&mask",
            "&t->pending"
          ],
          "line": 3534
        },
        "resolved": true,
        "details": {
          "function_name": "flush_sigqueue_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "722-738",
          "snippet": "static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn;\n\n\tsigandnsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn;\n\n\tsigandnsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 3533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&mask",
            "sig"
          ],
          "line": 3531
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&mask"
          ],
          "line": 3530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sig_handler_ignored",
          "args": [
            "sig_handler(p, sig)",
            "sig"
          ],
          "line": 3529
        },
        "resolved": true,
        "details": {
          "function_name": "sig_handler_ignored",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "68-73",
          "snippet": "static inline bool sig_handler_ignored(void __user *handler, int sig)\n{\n\t/* Is it explicitly or implicitly ignored? */\n\treturn handler == SIG_IGN ||\n\t       (handler == SIG_DFL && sig_kernel_ignore(sig));\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool sig_handler_ignored(void __user *handler, int sig)\n{\n\t/* Is it explicitly or implicitly ignored? */\n\treturn handler == SIG_IGN ||\n\t       (handler == SIG_DFL && sig_kernel_ignore(sig));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigdelsetmask",
          "args": [
            "&act->sa.sa_mask",
            "sigmask(SIGKILL) | sigmask(SIGSTOP)"
          ],
          "line": 3515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGSTOP"
          ],
          "line": 3516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGKILL"
          ],
          "line": 3516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaction_compat_abi",
          "args": [
            "act",
            "oact"
          ],
          "line": 3512
        },
        "resolved": true,
        "details": {
          "function_name": "sigaction_compat_abi",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "3492-3495",
          "snippet": "void __weak sigaction_compat_abi(struct k_sigaction *act,\n\t\tstruct k_sigaction *oact)\n{\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid __weak sigaction_compat_abi(struct k_sigaction *act,\n\t\tstruct k_sigaction *oact)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&p->sighand->siglock"
          ],
          "line": 3508
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sig_kernel_only",
          "args": [
            "sig"
          ],
          "line": 3503
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "valid_signal",
          "args": [
            "sig"
          ],
          "line": 3503
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint do_sigaction(int sig, struct k_sigaction *act, struct k_sigaction *oact)\n{\n\tstruct task_struct *p = current, *t;\n\tstruct k_sigaction *k;\n\tsigset_t mask;\n\n\tif (!valid_signal(sig) || sig < 1 || (act && sig_kernel_only(sig)))\n\t\treturn -EINVAL;\n\n\tk = &p->sighand->action[sig-1];\n\n\tspin_lock_irq(&p->sighand->siglock);\n\tif (oact)\n\t\t*oact = *k;\n\n\tsigaction_compat_abi(act, oact);\n\n\tif (act) {\n\t\tsigdelsetmask(&act->sa.sa_mask,\n\t\t\t      sigmask(SIGKILL) | sigmask(SIGSTOP));\n\t\t*k = *act;\n\t\t/*\n\t\t * POSIX 3.3.1.3:\n\t\t *  \"Setting a signal action to SIG_IGN for a signal that is\n\t\t *   pending shall cause the pending signal to be discarded,\n\t\t *   whether or not it is blocked.\"\n\t\t *\n\t\t *  \"Setting a signal action to SIG_DFL for a signal that is\n\t\t *   pending and whose default action is to ignore the signal\n\t\t *   (for example, SIGCHLD), shall cause the pending signal to\n\t\t *   be discarded, whether or not it is blocked\"\n\t\t */\n\t\tif (sig_handler_ignored(sig_handler(p, sig), sig)) {\n\t\t\tsigemptyset(&mask);\n\t\t\tsigaddset(&mask, sig);\n\t\t\tflush_sigqueue_mask(&mask, &p->signal->shared_pending);\n\t\t\tfor_each_thread(p, t)\n\t\t\t\tflush_sigqueue_mask(&mask, &t->pending);\n\t\t}\n\t}\n\n\tspin_unlock_irq(&p->sighand->siglock);\n\treturn 0;\n}"
  },
  {
    "function_name": "sigaction_compat_abi",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3492-3495",
    "snippet": "void __weak sigaction_compat_abi(struct k_sigaction *act,\n\t\tstruct k_sigaction *oact)\n{\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid __weak sigaction_compat_abi(struct k_sigaction *act,\n\t\tstruct k_sigaction *oact)\n{\n}"
  },
  {
    "function_name": "kernel_sigaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3474-3489",
    "snippet": "void kernel_sigaction(int sig, __sighandler_t action)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->sighand->action[sig - 1].sa.sa_handler = action;\n\tif (action == SIG_IGN) {\n\t\tsigset_t mask;\n\n\t\tsigemptyset(&mask);\n\t\tsigaddset(&mask, sig);\n\n\t\tflush_sigqueue_mask(&mask, &current->signal->shared_pending);\n\t\tflush_sigqueue_mask(&mask, &current->pending);\n\t\trecalc_sigpending();\n\t}\n\tspin_unlock_irq(&current->sighand->siglock);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 3488
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recalc_sigpending",
          "args": [],
          "line": 3486
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_sigpending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "172-178",
          "snippet": "void recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current) &&\n\t    !klp_patch_pending(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current) &&\n\t    !klp_patch_pending(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_sigqueue_mask",
          "args": [
            "&mask",
            "&current->pending"
          ],
          "line": 3485
        },
        "resolved": true,
        "details": {
          "function_name": "flush_sigqueue_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "722-738",
          "snippet": "static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn;\n\n\tsigandnsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn;\n\n\tsigandnsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&mask",
            "sig"
          ],
          "line": 3482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&mask"
          ],
          "line": 3481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 3476
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid kernel_sigaction(int sig, __sighandler_t action)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->sighand->action[sig - 1].sa.sa_handler = action;\n\tif (action == SIG_IGN) {\n\t\tsigset_t mask;\n\n\t\tsigemptyset(&mask);\n\t\tsigaddset(&mask, sig);\n\n\t\tflush_sigqueue_mask(&mask, &current->signal->shared_pending);\n\t\tflush_sigqueue_mask(&mask, &current->pending);\n\t\trecalc_sigpending();\n\t}\n\tspin_unlock_irq(&current->sighand->siglock);\n}"
  },
  {
    "function_name": "do_rt_tgsigqueueinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3430-3444",
    "snippet": "static int do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, kernel_siginfo_t *info)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\n\t/* Not even root can pretend to send signals from the kernel.\n\t * Nor can they impersonate a kill()/tgkill(), which adds source info.\n\t */\n\tif ((info->si_code >= 0 || info->si_code == SI_TKILL) &&\n\t    (task_pid_vnr(current) != pid))\n\t\treturn -EPERM;\n\n\treturn do_send_specific(tgid, pid, sig, info);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_send_specific",
          "args": [
            "tgid",
            "pid",
            "sig",
            "info"
          ],
          "line": 3443
        },
        "resolved": true,
        "details": {
          "function_name": "do_send_specific",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "3308-3336",
          "snippet": "static int\ndo_send_specific(pid_t tgid, pid_t pid, int sig, struct kernel_siginfo *info)\n{\n\tstruct task_struct *p;\n\tint error = -ESRCH;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (p && (tgid <= 0 || task_tgid_vnr(p) == tgid)) {\n\t\terror = check_kill_permission(sig, info, p);\n\t\t/*\n\t\t * The null signal is a permissions and process existence\n\t\t * probe.  No signal is actually delivered.\n\t\t */\n\t\tif (!error && sig) {\n\t\t\terror = do_send_sig_info(sig, info, p, PIDTYPE_PID);\n\t\t\t/*\n\t\t\t * If lock_task_sighand() failed we pretend the task\n\t\t\t * dies after receiving the signal. The window is tiny,\n\t\t\t * and the signal is private anyway.\n\t\t\t */\n\t\t\tif (unlikely(error == -ESRCH))\n\t\t\t\terror = 0;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int\ndo_send_specific(pid_t tgid, pid_t pid, int sig, struct kernel_siginfo *info)\n{\n\tstruct task_struct *p;\n\tint error = -ESRCH;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (p && (tgid <= 0 || task_tgid_vnr(p) == tgid)) {\n\t\terror = check_kill_permission(sig, info, p);\n\t\t/*\n\t\t * The null signal is a permissions and process existence\n\t\t * probe.  No signal is actually delivered.\n\t\t */\n\t\tif (!error && sig) {\n\t\t\terror = do_send_sig_info(sig, info, p, PIDTYPE_PID);\n\t\t\t/*\n\t\t\t * If lock_task_sighand() failed we pretend the task\n\t\t\t * dies after receiving the signal. The window is tiny,\n\t\t\t * and the signal is private anyway.\n\t\t\t */\n\t\t\tif (unlikely(error == -ESRCH))\n\t\t\t\terror = 0;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "current"
          ],
          "line": 3440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int do_rt_tgsigqueueinfo(pid_t tgid, pid_t pid, int sig, kernel_siginfo_t *info)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\n\t/* Not even root can pretend to send signals from the kernel.\n\t * Nor can they impersonate a kill()/tgkill(), which adds source info.\n\t */\n\tif ((info->si_code >= 0 || info->si_code == SI_TKILL) &&\n\t    (task_pid_vnr(current) != pid))\n\t\treturn -EPERM;\n\n\treturn do_send_specific(tgid, pid, sig, info);\n}"
  },
  {
    "function_name": "do_rt_sigqueueinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3387-3398",
    "snippet": "static int do_rt_sigqueueinfo(pid_t pid, int sig, kernel_siginfo_t *info)\n{\n\t/* Not even root can pretend to send signals from the kernel.\n\t * Nor can they impersonate a kill()/tgkill(), which adds source info.\n\t */\n\tif ((info->si_code >= 0 || info->si_code == SI_TKILL) &&\n\t    (task_pid_vnr(current) != pid))\n\t\treturn -EPERM;\n\n\t/* POSIX.1b doesn't mention process groups.  */\n\treturn kill_proc_info(sig, info, pid);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_proc_info",
          "args": [
            "sig",
            "info",
            "pid"
          ],
          "line": 3397
        },
        "resolved": true,
        "details": {
          "function_name": "kill_proc_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1376-1383",
          "snippet": "static int kill_proc_info(int sig, struct kernel_siginfo *info, pid_t pid)\n{\n\tint error;\n\trcu_read_lock();\n\terror = kill_pid_info(sig, info, find_vpid(pid));\n\trcu_read_unlock();\n\treturn error;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int kill_proc_info(int sig, struct kernel_siginfo *info, pid_t pid)\n{\n\tint error;\n\trcu_read_lock();\n\terror = kill_pid_info(sig, info, find_vpid(pid));\n\trcu_read_unlock();\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "current"
          ],
          "line": 3393
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int do_rt_sigqueueinfo(pid_t pid, int sig, kernel_siginfo_t *info)\n{\n\t/* Not even root can pretend to send signals from the kernel.\n\t * Nor can they impersonate a kill()/tgkill(), which adds source info.\n\t */\n\tif ((info->si_code >= 0 || info->si_code == SI_TKILL) &&\n\t    (task_pid_vnr(current) != pid))\n\t\treturn -EPERM;\n\n\t/* POSIX.1b doesn't mention process groups.  */\n\treturn kill_proc_info(sig, info, pid);\n}"
  },
  {
    "function_name": "do_tkill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3338-3350",
    "snippet": "static int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\treturn do_send_specific(tgid, pid, sig, &info);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_send_specific",
          "args": [
            "tgid",
            "pid",
            "sig",
            "&info"
          ],
          "line": 3349
        },
        "resolved": true,
        "details": {
          "function_name": "do_send_specific",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "3308-3336",
          "snippet": "static int\ndo_send_specific(pid_t tgid, pid_t pid, int sig, struct kernel_siginfo *info)\n{\n\tstruct task_struct *p;\n\tint error = -ESRCH;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (p && (tgid <= 0 || task_tgid_vnr(p) == tgid)) {\n\t\terror = check_kill_permission(sig, info, p);\n\t\t/*\n\t\t * The null signal is a permissions and process existence\n\t\t * probe.  No signal is actually delivered.\n\t\t */\n\t\tif (!error && sig) {\n\t\t\terror = do_send_sig_info(sig, info, p, PIDTYPE_PID);\n\t\t\t/*\n\t\t\t * If lock_task_sighand() failed we pretend the task\n\t\t\t * dies after receiving the signal. The window is tiny,\n\t\t\t * and the signal is private anyway.\n\t\t\t */\n\t\t\tif (unlikely(error == -ESRCH))\n\t\t\t\terror = 0;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int\ndo_send_specific(pid_t tgid, pid_t pid, int sig, struct kernel_siginfo *info)\n{\n\tstruct task_struct *p;\n\tint error = -ESRCH;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (p && (tgid <= 0 || task_tgid_vnr(p) == tgid)) {\n\t\terror = check_kill_permission(sig, info, p);\n\t\t/*\n\t\t * The null signal is a permissions and process existence\n\t\t * probe.  No signal is actually delivered.\n\t\t */\n\t\tif (!error && sig) {\n\t\t\terror = do_send_sig_info(sig, info, p, PIDTYPE_PID);\n\t\t\t/*\n\t\t\t * If lock_task_sighand() failed we pretend the task\n\t\t\t * dies after receiving the signal. The window is tiny,\n\t\t\t * and the signal is private anyway.\n\t\t\t */\n\t\t\tif (unlikely(error == -ESRCH))\n\t\t\t\terror = 0;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "current_uid()"
          ],
          "line": 3347
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 3347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 3347
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_vnr",
          "args": [
            "current"
          ],
          "line": 3346
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 3342
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int do_tkill(pid_t tgid, pid_t pid, int sig)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_TKILL;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\treturn do_send_specific(tgid, pid, sig, &info);\n}"
  },
  {
    "function_name": "do_send_specific",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3308-3336",
    "snippet": "static int\ndo_send_specific(pid_t tgid, pid_t pid, int sig, struct kernel_siginfo *info)\n{\n\tstruct task_struct *p;\n\tint error = -ESRCH;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (p && (tgid <= 0 || task_tgid_vnr(p) == tgid)) {\n\t\terror = check_kill_permission(sig, info, p);\n\t\t/*\n\t\t * The null signal is a permissions and process existence\n\t\t * probe.  No signal is actually delivered.\n\t\t */\n\t\tif (!error && sig) {\n\t\t\terror = do_send_sig_info(sig, info, p, PIDTYPE_PID);\n\t\t\t/*\n\t\t\t * If lock_task_sighand() failed we pretend the task\n\t\t\t * dies after receiving the signal. The window is tiny,\n\t\t\t * and the signal is private anyway.\n\t\t\t */\n\t\t\tif (unlikely(error == -ESRCH))\n\t\t\t\terror = 0;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 3333
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "error == -ESRCH"
          ],
          "line": 3329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_send_sig_info",
          "args": [
            "sig",
            "info",
            "p",
            "PIDTYPE_PID"
          ],
          "line": 3323
        },
        "resolved": true,
        "details": {
          "function_name": "do_send_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1205-1217",
          "snippet": "int do_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p,\n\t\t\tenum pid_type type)\n{\n\tunsigned long flags;\n\tint ret = -ESRCH;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tret = send_signal(sig, info, p, type);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint do_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p,\n\t\t\tenum pid_type type)\n{\n\tunsigned long flags;\n\tint ret = -ESRCH;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tret = send_signal(sig, info, p, type);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_kill_permission",
          "args": [
            "sig",
            "info",
            "p"
          ],
          "line": 3317
        },
        "resolved": true,
        "details": {
          "function_name": "check_kill_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "770-803",
          "snippet": "static int check_kill_permission(int sig, struct kernel_siginfo *info,\n\t\t\t\t struct task_struct *t)\n{\n\tstruct pid *sid;\n\tint error;\n\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\tif (!si_fromuser(info))\n\t\treturn 0;\n\n\terror = audit_signal_info(sig, t); /* Let audit system see the signal */\n\tif (error)\n\t\treturn error;\n\n\tif (!same_thread_group(current, t) &&\n\t    !kill_ok_by_cred(t)) {\n\t\tswitch (sig) {\n\t\tcase SIGCONT:\n\t\t\tsid = task_session(t);\n\t\t\t/*\n\t\t\t * We don't return the error if sid == NULL. The\n\t\t\t * task was unhashed, the caller must notice this.\n\t\t\t */\n\t\t\tif (!sid || sid == task_session(current))\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn security_task_kill(t, info, sig, NULL);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int check_kill_permission(int sig, struct kernel_siginfo *info,\n\t\t\t\t struct task_struct *t)\n{\n\tstruct pid *sid;\n\tint error;\n\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\tif (!si_fromuser(info))\n\t\treturn 0;\n\n\terror = audit_signal_info(sig, t); /* Let audit system see the signal */\n\tif (error)\n\t\treturn error;\n\n\tif (!same_thread_group(current, t) &&\n\t    !kill_ok_by_cred(t)) {\n\t\tswitch (sig) {\n\t\tcase SIGCONT:\n\t\t\tsid = task_session(t);\n\t\t\t/*\n\t\t\t * We don't return the error if sid == NULL. The\n\t\t\t * task was unhashed, the caller must notice this.\n\t\t\t */\n\t\t\tif (!sid || sid == task_session(current))\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn security_task_kill(t, info, sig, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_tgid_vnr",
          "args": [
            "p"
          ],
          "line": 3316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_task_by_vpid",
          "args": [
            "pid"
          ],
          "line": 3315
        },
        "resolved": true,
        "details": {
          "function_name": "find_task_by_vpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "348-351",
          "snippet": "struct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *find_task_by_vpid(pid_t vnr)\n{\n\treturn find_task_by_pid_ns(vnr, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 3314
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int\ndo_send_specific(pid_t tgid, pid_t pid, int sig, struct kernel_siginfo *info)\n{\n\tstruct task_struct *p;\n\tint error = -ESRCH;\n\n\trcu_read_lock();\n\tp = find_task_by_vpid(pid);\n\tif (p && (tgid <= 0 || task_tgid_vnr(p) == tgid)) {\n\t\terror = check_kill_permission(sig, info, p);\n\t\t/*\n\t\t * The null signal is a permissions and process existence\n\t\t * probe.  No signal is actually delivered.\n\t\t */\n\t\tif (!error && sig) {\n\t\t\terror = do_send_sig_info(sig, info, p, PIDTYPE_PID);\n\t\t\t/*\n\t\t\t * If lock_task_sighand() failed we pretend the task\n\t\t\t * dies after receiving the signal. The window is tiny,\n\t\t\t * and the signal is private anyway.\n\t\t\t */\n\t\t\tif (unlikely(error == -ESRCH))\n\t\t\t\terror = 0;\n\t\t}\n\t}\n\trcu_read_unlock();\n\n\treturn error;\n}"
  },
  {
    "function_name": "do_sigtimedwait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3167-3215",
    "snippet": "static int do_sigtimedwait(const sigset_t *which, kernel_siginfo_t *info,\n\t\t    const struct timespec64 *ts)\n{\n\tktime_t *to = NULL, timeout = KTIME_MAX;\n\tstruct task_struct *tsk = current;\n\tsigset_t mask = *which;\n\tint sig, ret = 0;\n\n\tif (ts) {\n\t\tif (!timespec64_valid(ts))\n\t\t\treturn -EINVAL;\n\t\ttimeout = timespec64_to_ktime(*ts);\n\t\tto = &timeout;\n\t}\n\n\t/*\n\t * Invert the set of allowed signals to get those we want to block.\n\t */\n\tsigdelsetmask(&mask, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\tsignotset(&mask);\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\tsig = dequeue_signal(tsk, &mask, info);\n\tif (!sig && timeout) {\n\t\t/*\n\t\t * None ready, temporarily unblock those we're interested\n\t\t * while we are sleeping in so that we'll be awakened when\n\t\t * they arrive. Unblocking is always fine, we can avoid\n\t\t * set_current_blocked().\n\t\t */\n\t\ttsk->real_blocked = tsk->blocked;\n\t\tsigandsets(&tsk->blocked, &tsk->blocked, &mask);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\tret = freezable_schedule_hrtimeout_range(to, tsk->timer_slack_ns,\n\t\t\t\t\t\t\t HRTIMER_MODE_REL);\n\t\tspin_lock_irq(&tsk->sighand->siglock);\n\t\t__set_task_blocked(tsk, &tsk->real_blocked);\n\t\tsigemptyset(&tsk->real_blocked);\n\t\tsig = dequeue_signal(tsk, &mask, info);\n\t}\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (sig)\n\t\treturn sig;\n\treturn ret ? -EINTR : -EAGAIN;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 3210
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "dequeue_signal",
          "args": [
            "tsk",
            "&mask",
            "info"
          ],
          "line": 3208
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "613-688",
          "snippet": "int dequeue_signal(struct task_struct *tsk, sigset_t *mask, kernel_siginfo_t *info)\n{\n\tbool resched_timer = false;\n\tint signr;\n\n\t/* We only dequeue private signals from ourselves, we don't let\n\t * signalfd steal them\n\t */\n\tsignr = __dequeue_signal(&tsk->pending, mask, info, &resched_timer);\n\tif (!signr) {\n\t\tsignr = __dequeue_signal(&tsk->signal->shared_pending,\n\t\t\t\t\t mask, info, &resched_timer);\n#ifdef CONFIG_POSIX_TIMERS\n\t\t/*\n\t\t * itimer signal ?\n\t\t *\n\t\t * itimers are process shared and we restart periodic\n\t\t * itimers in the signal delivery path to prevent DoS\n\t\t * attacks in the high resolution timer case. This is\n\t\t * compliant with the old way of self-restarting\n\t\t * itimers, as the SIGALRM is a legacy signal and only\n\t\t * queued once. Changing the restart behaviour to\n\t\t * restart the timer in the signal dequeue path is\n\t\t * reducing the timer noise on heavy loaded !highres\n\t\t * systems too.\n\t\t */\n\t\tif (unlikely(signr == SIGALRM)) {\n\t\t\tstruct hrtimer *tmr = &tsk->signal->real_timer;\n\n\t\t\tif (!hrtimer_is_queued(tmr) &&\n\t\t\t    tsk->signal->it_real_incr != 0) {\n\t\t\t\thrtimer_forward(tmr, tmr->base->get_time(),\n\t\t\t\t\t\ttsk->signal->it_real_incr);\n\t\t\t\thrtimer_restart(tmr);\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\trecalc_sigpending();\n\tif (!signr)\n\t\treturn 0;\n\n\tif (unlikely(sig_kernel_stop(signr))) {\n\t\t/*\n\t\t * Set a marker that we have dequeued a stop signal.  Our\n\t\t * caller might release the siglock and then the pending\n\t\t * stop signal it is about to process is no longer in the\n\t\t * pending bitmasks, but must still be cleared by a SIGCONT\n\t\t * (and overruled by a SIGKILL).  So those cases clear this\n\t\t * shared flag after we've set it.  Note that this flag may\n\t\t * remain set after the signal we return is ignored or\n\t\t * handled.  That doesn't matter because its only purpose\n\t\t * is to alert stop-signal processing code when another\n\t\t * processor has come along and cleared the flag.\n\t\t */\n\t\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;\n\t}\n#ifdef CONFIG_POSIX_TIMERS\n\tif (resched_timer) {\n\t\t/*\n\t\t * Release the siglock to ensure proper locking order\n\t\t * of timer locks outside of siglocks.  Note, we leave\n\t\t * irqs disabled here, since the posix-timers code is\n\t\t * about to disable them again anyway.\n\t\t */\n\t\tspin_unlock(&tsk->sighand->siglock);\n\t\tposixtimer_rearm(info);\n\t\tspin_lock(&tsk->sighand->siglock);\n\n\t\t/* Don't expose the si_sys_private value to userspace */\n\t\tinfo->si_sys_private = 0;\n\t}\n#endif\n\treturn signr;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint dequeue_signal(struct task_struct *tsk, sigset_t *mask, kernel_siginfo_t *info)\n{\n\tbool resched_timer = false;\n\tint signr;\n\n\t/* We only dequeue private signals from ourselves, we don't let\n\t * signalfd steal them\n\t */\n\tsignr = __dequeue_signal(&tsk->pending, mask, info, &resched_timer);\n\tif (!signr) {\n\t\tsignr = __dequeue_signal(&tsk->signal->shared_pending,\n\t\t\t\t\t mask, info, &resched_timer);\n#ifdef CONFIG_POSIX_TIMERS\n\t\t/*\n\t\t * itimer signal ?\n\t\t *\n\t\t * itimers are process shared and we restart periodic\n\t\t * itimers in the signal delivery path to prevent DoS\n\t\t * attacks in the high resolution timer case. This is\n\t\t * compliant with the old way of self-restarting\n\t\t * itimers, as the SIGALRM is a legacy signal and only\n\t\t * queued once. Changing the restart behaviour to\n\t\t * restart the timer in the signal dequeue path is\n\t\t * reducing the timer noise on heavy loaded !highres\n\t\t * systems too.\n\t\t */\n\t\tif (unlikely(signr == SIGALRM)) {\n\t\t\tstruct hrtimer *tmr = &tsk->signal->real_timer;\n\n\t\t\tif (!hrtimer_is_queued(tmr) &&\n\t\t\t    tsk->signal->it_real_incr != 0) {\n\t\t\t\thrtimer_forward(tmr, tmr->base->get_time(),\n\t\t\t\t\t\ttsk->signal->it_real_incr);\n\t\t\t\thrtimer_restart(tmr);\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\trecalc_sigpending();\n\tif (!signr)\n\t\treturn 0;\n\n\tif (unlikely(sig_kernel_stop(signr))) {\n\t\t/*\n\t\t * Set a marker that we have dequeued a stop signal.  Our\n\t\t * caller might release the siglock and then the pending\n\t\t * stop signal it is about to process is no longer in the\n\t\t * pending bitmasks, but must still be cleared by a SIGCONT\n\t\t * (and overruled by a SIGKILL).  So those cases clear this\n\t\t * shared flag after we've set it.  Note that this flag may\n\t\t * remain set after the signal we return is ignored or\n\t\t * handled.  That doesn't matter because its only purpose\n\t\t * is to alert stop-signal processing code when another\n\t\t * processor has come along and cleared the flag.\n\t\t */\n\t\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;\n\t}\n#ifdef CONFIG_POSIX_TIMERS\n\tif (resched_timer) {\n\t\t/*\n\t\t * Release the siglock to ensure proper locking order\n\t\t * of timer locks outside of siglocks.  Note, we leave\n\t\t * irqs disabled here, since the posix-timers code is\n\t\t * about to disable them again anyway.\n\t\t */\n\t\tspin_unlock(&tsk->sighand->siglock);\n\t\tposixtimer_rearm(info);\n\t\tspin_lock(&tsk->sighand->siglock);\n\n\t\t/* Don't expose the si_sys_private value to userspace */\n\t\tinfo->si_sys_private = 0;\n\t}\n#endif\n\treturn signr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&tsk->real_blocked"
          ],
          "line": 3207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_task_blocked",
          "args": [
            "tsk",
            "&tsk->real_blocked"
          ],
          "line": 3206
        },
        "resolved": true,
        "details": {
          "function_name": "__set_task_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "2661-2671",
          "snippet": "static void __set_task_blocked(struct task_struct *tsk, const sigset_t *newset)\n{\n\tif (signal_pending(tsk) && !thread_group_empty(tsk)) {\n\t\tsigset_t newblocked;\n\t\t/* A set of now blocked but previously unblocked signals. */\n\t\tsigandnsets(&newblocked, newset, &current->blocked);\n\t\tretarget_shared_pending(tsk, &newblocked);\n\t}\n\ttsk->blocked = *newset;\n\trecalc_sigpending();\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void __set_task_blocked(struct task_struct *tsk, const sigset_t *newset)\n{\n\tif (signal_pending(tsk) && !thread_group_empty(tsk)) {\n\t\tsigset_t newblocked;\n\t\t/* A set of now blocked but previously unblocked signals. */\n\t\tsigandnsets(&newblocked, newset, &current->blocked);\n\t\tretarget_shared_pending(tsk, &newblocked);\n\t}\n\ttsk->blocked = *newset;\n\trecalc_sigpending();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 3205
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezable_schedule_hrtimeout_range",
          "args": [
            "to",
            "tsk->timer_slack_ns",
            "HRTIMER_MODE_REL"
          ],
          "line": 3203
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_INTERRUPTIBLE"
          ],
          "line": 3202
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recalc_sigpending",
          "args": [],
          "line": 3199
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_sigpending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "172-178",
          "snippet": "void recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current) &&\n\t    !klp_patch_pending(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current) &&\n\t    !klp_patch_pending(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigandsets",
          "args": [
            "&tsk->blocked",
            "&tsk->blocked",
            "&mask"
          ],
          "line": 3198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signotset",
          "args": [
            "&mask"
          ],
          "line": 3186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelsetmask",
          "args": [
            "&mask",
            "sigmask(SIGKILL) | sigmask(SIGSTOP)"
          ],
          "line": 3185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGSTOP"
          ],
          "line": 3185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGKILL"
          ],
          "line": 3185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_to_ktime",
          "args": [
            "*ts"
          ],
          "line": 3178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timespec64_valid",
          "args": [
            "ts"
          ],
          "line": 3176
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int do_sigtimedwait(const sigset_t *which, kernel_siginfo_t *info,\n\t\t    const struct timespec64 *ts)\n{\n\tktime_t *to = NULL, timeout = KTIME_MAX;\n\tstruct task_struct *tsk = current;\n\tsigset_t mask = *which;\n\tint sig, ret = 0;\n\n\tif (ts) {\n\t\tif (!timespec64_valid(ts))\n\t\t\treturn -EINVAL;\n\t\ttimeout = timespec64_to_ktime(*ts);\n\t\tto = &timeout;\n\t}\n\n\t/*\n\t * Invert the set of allowed signals to get those we want to block.\n\t */\n\tsigdelsetmask(&mask, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\tsignotset(&mask);\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\tsig = dequeue_signal(tsk, &mask, info);\n\tif (!sig && timeout) {\n\t\t/*\n\t\t * None ready, temporarily unblock those we're interested\n\t\t * while we are sleeping in so that we'll be awakened when\n\t\t * they arrive. Unblocking is always fine, we can avoid\n\t\t * set_current_blocked().\n\t\t */\n\t\ttsk->real_blocked = tsk->blocked;\n\t\tsigandsets(&tsk->blocked, &tsk->blocked, &mask);\n\t\trecalc_sigpending();\n\t\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\tret = freezable_schedule_hrtimeout_range(to, tsk->timer_slack_ns,\n\t\t\t\t\t\t\t HRTIMER_MODE_REL);\n\t\tspin_lock_irq(&tsk->sighand->siglock);\n\t\t__set_task_blocked(tsk, &tsk->real_blocked);\n\t\tsigemptyset(&tsk->real_blocked);\n\t\tsig = dequeue_signal(tsk, &mask, info);\n\t}\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\tif (sig)\n\t\treturn sig;\n\treturn ret ? -EINTR : -EAGAIN;\n}"
  },
  {
    "function_name": "copy_siginfo_from_user32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3149-3158",
    "snippet": "int copy_siginfo_from_user32(struct kernel_siginfo *to,\n\t\t\t     const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn post_copy_siginfo_from_user32(to, &from);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "post_copy_siginfo_from_user32",
          "args": [
            "to",
            "&from"
          ],
          "line": 3157
        },
        "resolved": true,
        "details": {
          "function_name": "post_copy_siginfo_from_user32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "3059-3135",
          "snippet": "static int post_copy_siginfo_from_user32(kernel_siginfo_t *to,\n\t\t\t\t\t const struct compat_siginfo *from)\n{\n\tclear_siginfo(to);\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_lower = compat_ptr(from->si_lower);\n\t\tto->si_upper = compat_ptr(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid    = from->si_pid;\n\t\tto->si_uid    = from->si_uid;\n\t\tto->si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (in_x32_syscall()) {\n\t\t\tto->si_utime = from->_sifields._sigchld_x32._utime;\n\t\t\tto->si_stime = from->_sifields._sigchld_x32._stime;\n\t\t} else\n#endif\n\t\t{\n\t\t\tto->si_utime = from->si_utime;\n\t\t\tto->si_stime = from->si_stime;\n\t\t}\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = compat_ptr(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int post_copy_siginfo_from_user32(kernel_siginfo_t *to,\n\t\t\t\t\t const struct compat_siginfo *from)\n{\n\tclear_siginfo(to);\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_lower = compat_ptr(from->si_lower);\n\t\tto->si_upper = compat_ptr(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid    = from->si_pid;\n\t\tto->si_uid    = from->si_uid;\n\t\tto->si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (in_x32_syscall()) {\n\t\t\tto->si_utime = from->_sifields._sigchld_x32._utime;\n\t\t\tto->si_stime = from->_sifields._sigchld_x32._stime;\n\t\t} else\n#endif\n\t\t{\n\t\t\tto->si_utime = from->si_utime;\n\t\t\tto->si_stime = from->si_stime;\n\t\t}\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = compat_ptr(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&from",
            "ufrom",
            "sizeof(struct compat_siginfo)"
          ],
          "line": 3154
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint copy_siginfo_from_user32(struct kernel_siginfo *to,\n\t\t\t     const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn post_copy_siginfo_from_user32(to, &from);\n}"
  },
  {
    "function_name": "__copy_siginfo_from_user32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3137-3147",
    "snippet": "static int __copy_siginfo_from_user32(int signo, struct kernel_siginfo *to,\n\t\t\t\t      const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\tfrom.si_signo = signo;\n\treturn post_copy_siginfo_from_user32(to, &from);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "post_copy_siginfo_from_user32",
          "args": [
            "to",
            "&from"
          ],
          "line": 3146
        },
        "resolved": true,
        "details": {
          "function_name": "post_copy_siginfo_from_user32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "3059-3135",
          "snippet": "static int post_copy_siginfo_from_user32(kernel_siginfo_t *to,\n\t\t\t\t\t const struct compat_siginfo *from)\n{\n\tclear_siginfo(to);\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_lower = compat_ptr(from->si_lower);\n\t\tto->si_upper = compat_ptr(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid    = from->si_pid;\n\t\tto->si_uid    = from->si_uid;\n\t\tto->si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (in_x32_syscall()) {\n\t\t\tto->si_utime = from->_sifields._sigchld_x32._utime;\n\t\t\tto->si_stime = from->_sifields._sigchld_x32._stime;\n\t\t} else\n#endif\n\t\t{\n\t\t\tto->si_utime = from->si_utime;\n\t\t\tto->si_stime = from->si_stime;\n\t\t}\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = compat_ptr(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int post_copy_siginfo_from_user32(kernel_siginfo_t *to,\n\t\t\t\t\t const struct compat_siginfo *from)\n{\n\tclear_siginfo(to);\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_lower = compat_ptr(from->si_lower);\n\t\tto->si_upper = compat_ptr(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid    = from->si_pid;\n\t\tto->si_uid    = from->si_uid;\n\t\tto->si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (in_x32_syscall()) {\n\t\t\tto->si_utime = from->_sifields._sigchld_x32._utime;\n\t\t\tto->si_stime = from->_sifields._sigchld_x32._stime;\n\t\t} else\n#endif\n\t\t{\n\t\t\tto->si_utime = from->si_utime;\n\t\t\tto->si_stime = from->si_stime;\n\t\t}\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = compat_ptr(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&from",
            "ufrom",
            "sizeof(struct compat_siginfo)"
          ],
          "line": 3142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int __copy_siginfo_from_user32(int signo, struct kernel_siginfo *to,\n\t\t\t\t      const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\tfrom.si_signo = signo;\n\treturn post_copy_siginfo_from_user32(to, &from);\n}"
  },
  {
    "function_name": "post_copy_siginfo_from_user32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3059-3135",
    "snippet": "static int post_copy_siginfo_from_user32(kernel_siginfo_t *to,\n\t\t\t\t\t const struct compat_siginfo *from)\n{\n\tclear_siginfo(to);\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_lower = compat_ptr(from->si_lower);\n\t\tto->si_upper = compat_ptr(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid    = from->si_pid;\n\t\tto->si_uid    = from->si_uid;\n\t\tto->si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (in_x32_syscall()) {\n\t\t\tto->si_utime = from->_sifields._sigchld_x32._utime;\n\t\t\tto->si_stime = from->_sifields._sigchld_x32._stime;\n\t\t} else\n#endif\n\t\t{\n\t\t\tto->si_utime = from->si_utime;\n\t\t\tto->si_stime = from->si_stime;\n\t\t}\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = compat_ptr(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "from->si_call_addr"
          ],
          "line": 3129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "in_x32_syscall",
          "args": [],
          "line": 3113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "from->si_addr"
          ],
          "line": 3102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "from->si_upper"
          ],
          "line": 3099
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "from->si_lower"
          ],
          "line": 3098
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "from->si_addr"
          ],
          "line": 3094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "from->si_addr"
          ],
          "line": 3087
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "compat_ptr",
          "args": [
            "from->si_addr"
          ],
          "line": 3081
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "siginfo_layout",
          "args": [
            "from->si_signo",
            "from->si_code"
          ],
          "line": 3066
        },
        "resolved": true,
        "details": {
          "function_name": "siginfo_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "2882-2911",
          "snippet": "enum siginfo_layout siginfo_layout(unsigned sig, int si_code)\n{\n\tenum siginfo_layout layout = SIL_KILL;\n\tif ((si_code > SI_USER) && (si_code < SI_KERNEL)) {\n\t\tif ((sig < ARRAY_SIZE(sig_sicodes)) &&\n\t\t    (si_code <= sig_sicodes[sig].limit)) {\n\t\t\tlayout = sig_sicodes[sig].layout;\n\t\t\t/* Handle the exceptions */\n\t\t\tif ((sig == SIGBUS) &&\n\t\t\t    (si_code >= BUS_MCEERR_AR) && (si_code <= BUS_MCEERR_AO))\n\t\t\t\tlayout = SIL_FAULT_MCEERR;\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_BNDERR))\n\t\t\t\tlayout = SIL_FAULT_BNDERR;\n#ifdef SEGV_PKUERR\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_PKUERR))\n\t\t\t\tlayout = SIL_FAULT_PKUERR;\n#endif\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\tlayout = SIL_POLL;\n\t} else {\n\t\tif (si_code == SI_TIMER)\n\t\t\tlayout = SIL_TIMER;\n\t\telse if (si_code == SI_SIGIO)\n\t\t\tlayout = SIL_POLL;\n\t\telse if (si_code < 0)\n\t\t\tlayout = SIL_RT;\n\t}\n\treturn layout;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};\n\nenum siginfo_layout siginfo_layout(unsigned sig, int si_code)\n{\n\tenum siginfo_layout layout = SIL_KILL;\n\tif ((si_code > SI_USER) && (si_code < SI_KERNEL)) {\n\t\tif ((sig < ARRAY_SIZE(sig_sicodes)) &&\n\t\t    (si_code <= sig_sicodes[sig].limit)) {\n\t\t\tlayout = sig_sicodes[sig].layout;\n\t\t\t/* Handle the exceptions */\n\t\t\tif ((sig == SIGBUS) &&\n\t\t\t    (si_code >= BUS_MCEERR_AR) && (si_code <= BUS_MCEERR_AO))\n\t\t\t\tlayout = SIL_FAULT_MCEERR;\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_BNDERR))\n\t\t\t\tlayout = SIL_FAULT_BNDERR;\n#ifdef SEGV_PKUERR\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_PKUERR))\n\t\t\t\tlayout = SIL_FAULT_PKUERR;\n#endif\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\tlayout = SIL_POLL;\n\t} else {\n\t\tif (si_code == SI_TIMER)\n\t\t\tlayout = SIL_TIMER;\n\t\telse if (si_code == SI_SIGIO)\n\t\t\tlayout = SIL_POLL;\n\t\telse if (si_code < 0)\n\t\t\tlayout = SIL_RT;\n\t}\n\treturn layout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "to"
          ],
          "line": 3062
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int post_copy_siginfo_from_user32(kernel_siginfo_t *to,\n\t\t\t\t\t const struct compat_siginfo *from)\n{\n\tclear_siginfo(to);\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_lower = compat_ptr(from->si_lower);\n\t\tto->si_upper = compat_ptr(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid    = from->si_pid;\n\t\tto->si_uid    = from->si_uid;\n\t\tto->si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (in_x32_syscall()) {\n\t\t\tto->si_utime = from->_sifields._sigchld_x32._utime;\n\t\t\tto->si_stime = from->_sifields._sigchld_x32._stime;\n\t\t} else\n#endif\n\t\t{\n\t\t\tto->si_utime = from->si_utime;\n\t\t\tto->si_stime = from->si_stime;\n\t\t}\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = compat_ptr(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "__copy_siginfo_to_user32",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2974-3057",
    "snippet": "int __copy_siginfo_to_user32(struct compat_siginfo __user *to,\n\t\t\t     const struct kernel_siginfo *from, bool x32_ABI)\n#endif\n{\n\tstruct compat_siginfo new;\n\tmemset(&new, 0, sizeof(new));\n\n\tnew.si_signo = from->si_signo;\n\tnew.si_errno = from->si_errno;\n\tnew.si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tnew.si_pid = from->si_pid;\n\t\tnew.si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tnew.si_tid     = from->si_tid;\n\t\tnew.si_overrun = from->si_overrun;\n\t\tnew.si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tnew.si_band = from->si_band;\n\t\tnew.si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tnew.si_addr = ptr_to_compat(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tnew.si_trapno = from->si_trapno;\n#endif\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tnew.si_addr = ptr_to_compat(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tnew.si_trapno = from->si_trapno;\n#endif\n\t\tnew.si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tnew.si_addr = ptr_to_compat(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tnew.si_trapno = from->si_trapno;\n#endif\n\t\tnew.si_lower = ptr_to_compat(from->si_lower);\n\t\tnew.si_upper = ptr_to_compat(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tnew.si_addr = ptr_to_compat(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tnew.si_trapno = from->si_trapno;\n#endif\n\t\tnew.si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tnew.si_pid    = from->si_pid;\n\t\tnew.si_uid    = from->si_uid;\n\t\tnew.si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (x32_ABI) {\n\t\t\tnew._sifields._sigchld_x32._utime = from->si_utime;\n\t\t\tnew._sifields._sigchld_x32._stime = from->si_stime;\n\t\t} else\n#endif\n\t\t{\n\t\t\tnew.si_utime = from->si_utime;\n\t\t\tnew.si_stime = from->si_stime;\n\t\t}\n\t\tbreak;\n\tcase SIL_RT:\n\t\tnew.si_pid = from->si_pid;\n\t\tnew.si_uid = from->si_uid;\n\t\tnew.si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tnew.si_call_addr = ptr_to_compat(from->si_call_addr);\n\t\tnew.si_syscall   = from->si_syscall;\n\t\tnew.si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n\n\tif (copy_to_user(to, &new, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "to",
            "&new",
            "sizeof(struct compat_siginfo)"
          ],
          "line": 3053
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "from->si_call_addr"
          ],
          "line": 3047
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "from->si_addr"
          ],
          "line": 3020
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "from->si_upper"
          ],
          "line": 3017
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "from->si_lower"
          ],
          "line": 3016
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "from->si_addr"
          ],
          "line": 3012
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "from->si_addr"
          ],
          "line": 3005
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptr_to_compat",
          "args": [
            "from->si_addr"
          ],
          "line": 2999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "siginfo_layout",
          "args": [
            "from->si_signo",
            "from->si_code"
          ],
          "line": 2984
        },
        "resolved": true,
        "details": {
          "function_name": "siginfo_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "2882-2911",
          "snippet": "enum siginfo_layout siginfo_layout(unsigned sig, int si_code)\n{\n\tenum siginfo_layout layout = SIL_KILL;\n\tif ((si_code > SI_USER) && (si_code < SI_KERNEL)) {\n\t\tif ((sig < ARRAY_SIZE(sig_sicodes)) &&\n\t\t    (si_code <= sig_sicodes[sig].limit)) {\n\t\t\tlayout = sig_sicodes[sig].layout;\n\t\t\t/* Handle the exceptions */\n\t\t\tif ((sig == SIGBUS) &&\n\t\t\t    (si_code >= BUS_MCEERR_AR) && (si_code <= BUS_MCEERR_AO))\n\t\t\t\tlayout = SIL_FAULT_MCEERR;\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_BNDERR))\n\t\t\t\tlayout = SIL_FAULT_BNDERR;\n#ifdef SEGV_PKUERR\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_PKUERR))\n\t\t\t\tlayout = SIL_FAULT_PKUERR;\n#endif\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\tlayout = SIL_POLL;\n\t} else {\n\t\tif (si_code == SI_TIMER)\n\t\t\tlayout = SIL_TIMER;\n\t\telse if (si_code == SI_SIGIO)\n\t\t\tlayout = SIL_POLL;\n\t\telse if (si_code < 0)\n\t\t\tlayout = SIL_RT;\n\t}\n\treturn layout;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};\n\nenum siginfo_layout siginfo_layout(unsigned sig, int si_code)\n{\n\tenum siginfo_layout layout = SIL_KILL;\n\tif ((si_code > SI_USER) && (si_code < SI_KERNEL)) {\n\t\tif ((sig < ARRAY_SIZE(sig_sicodes)) &&\n\t\t    (si_code <= sig_sicodes[sig].limit)) {\n\t\t\tlayout = sig_sicodes[sig].layout;\n\t\t\t/* Handle the exceptions */\n\t\t\tif ((sig == SIGBUS) &&\n\t\t\t    (si_code >= BUS_MCEERR_AR) && (si_code <= BUS_MCEERR_AO))\n\t\t\t\tlayout = SIL_FAULT_MCEERR;\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_BNDERR))\n\t\t\t\tlayout = SIL_FAULT_BNDERR;\n#ifdef SEGV_PKUERR\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_PKUERR))\n\t\t\t\tlayout = SIL_FAULT_PKUERR;\n#endif\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\tlayout = SIL_POLL;\n\t} else {\n\t\tif (si_code == SI_TIMER)\n\t\t\tlayout = SIL_TIMER;\n\t\telse if (si_code == SI_SIGIO)\n\t\t\tlayout = SIL_POLL;\n\t\telse if (si_code < 0)\n\t\t\tlayout = SIL_RT;\n\t}\n\treturn layout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "memset",
          "args": [
            "&new",
            "0",
            "sizeof(new)"
          ],
          "line": 2979
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint __copy_siginfo_to_user32(struct compat_siginfo __user *to,\n\t\t\t     const struct kernel_siginfo *from, bool x32_ABI)\n#endif\n{\n\tstruct compat_siginfo new;\n\tmemset(&new, 0, sizeof(new));\n\n\tnew.si_signo = from->si_signo;\n\tnew.si_errno = from->si_errno;\n\tnew.si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tnew.si_pid = from->si_pid;\n\t\tnew.si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tnew.si_tid     = from->si_tid;\n\t\tnew.si_overrun = from->si_overrun;\n\t\tnew.si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tnew.si_band = from->si_band;\n\t\tnew.si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tnew.si_addr = ptr_to_compat(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tnew.si_trapno = from->si_trapno;\n#endif\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tnew.si_addr = ptr_to_compat(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tnew.si_trapno = from->si_trapno;\n#endif\n\t\tnew.si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tnew.si_addr = ptr_to_compat(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tnew.si_trapno = from->si_trapno;\n#endif\n\t\tnew.si_lower = ptr_to_compat(from->si_lower);\n\t\tnew.si_upper = ptr_to_compat(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tnew.si_addr = ptr_to_compat(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tnew.si_trapno = from->si_trapno;\n#endif\n\t\tnew.si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tnew.si_pid    = from->si_pid;\n\t\tnew.si_uid    = from->si_uid;\n\t\tnew.si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (x32_ABI) {\n\t\t\tnew._sifields._sigchld_x32._utime = from->si_utime;\n\t\t\tnew._sifields._sigchld_x32._stime = from->si_stime;\n\t\t} else\n#endif\n\t\t{\n\t\t\tnew.si_utime = from->si_utime;\n\t\t\tnew.si_stime = from->si_stime;\n\t\t}\n\t\tbreak;\n\tcase SIL_RT:\n\t\tnew.si_pid = from->si_pid;\n\t\tnew.si_uid = from->si_uid;\n\t\tnew.si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tnew.si_call_addr = ptr_to_compat(from->si_call_addr);\n\t\tnew.si_syscall   = from->si_syscall;\n\t\tnew.si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n\n\tif (copy_to_user(to, &new, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_siginfo_from_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2960-2965",
    "snippet": "int copy_siginfo_from_user(kernel_siginfo_t *to, const siginfo_t __user *from)\n{\n\tif (copy_from_user(to, from, sizeof(struct kernel_siginfo)))\n\t\treturn -EFAULT;\n\treturn post_copy_siginfo_from_user(to, from);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "post_copy_siginfo_from_user",
          "args": [
            "to",
            "from"
          ],
          "line": 2964
        },
        "resolved": true,
        "details": {
          "function_name": "post_copy_siginfo_from_user32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "3059-3135",
          "snippet": "static int post_copy_siginfo_from_user32(kernel_siginfo_t *to,\n\t\t\t\t\t const struct compat_siginfo *from)\n{\n\tclear_siginfo(to);\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_lower = compat_ptr(from->si_lower);\n\t\tto->si_upper = compat_ptr(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid    = from->si_pid;\n\t\tto->si_uid    = from->si_uid;\n\t\tto->si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (in_x32_syscall()) {\n\t\t\tto->si_utime = from->_sifields._sigchld_x32._utime;\n\t\t\tto->si_stime = from->_sifields._sigchld_x32._stime;\n\t\t} else\n#endif\n\t\t{\n\t\t\tto->si_utime = from->si_utime;\n\t\t\tto->si_stime = from->si_stime;\n\t\t}\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = compat_ptr(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int post_copy_siginfo_from_user32(kernel_siginfo_t *to,\n\t\t\t\t\t const struct compat_siginfo *from)\n{\n\tclear_siginfo(to);\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_lower = compat_ptr(from->si_lower);\n\t\tto->si_upper = compat_ptr(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid    = from->si_pid;\n\t\tto->si_uid    = from->si_uid;\n\t\tto->si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (in_x32_syscall()) {\n\t\t\tto->si_utime = from->_sifields._sigchld_x32._utime;\n\t\t\tto->si_stime = from->_sifields._sigchld_x32._stime;\n\t\t} else\n#endif\n\t\t{\n\t\t\tto->si_utime = from->si_utime;\n\t\t\tto->si_stime = from->si_stime;\n\t\t}\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = compat_ptr(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "to",
            "from",
            "sizeof(struct kernel_siginfo)"
          ],
          "line": 2962
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint copy_siginfo_from_user(kernel_siginfo_t *to, const siginfo_t __user *from)\n{\n\tif (copy_from_user(to, from, sizeof(struct kernel_siginfo)))\n\t\treturn -EFAULT;\n\treturn post_copy_siginfo_from_user(to, from);\n}"
  },
  {
    "function_name": "__copy_siginfo_from_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2951-2958",
    "snippet": "static int __copy_siginfo_from_user(int signo, kernel_siginfo_t *to,\n\t\t\t\t    const siginfo_t __user *from)\n{\n\tif (copy_from_user(to, from, sizeof(struct kernel_siginfo)))\n\t\treturn -EFAULT;\n\tto->si_signo = signo;\n\treturn post_copy_siginfo_from_user(to, from);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "post_copy_siginfo_from_user",
          "args": [
            "to",
            "from"
          ],
          "line": 2957
        },
        "resolved": true,
        "details": {
          "function_name": "post_copy_siginfo_from_user32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "3059-3135",
          "snippet": "static int post_copy_siginfo_from_user32(kernel_siginfo_t *to,\n\t\t\t\t\t const struct compat_siginfo *from)\n{\n\tclear_siginfo(to);\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_lower = compat_ptr(from->si_lower);\n\t\tto->si_upper = compat_ptr(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid    = from->si_pid;\n\t\tto->si_uid    = from->si_uid;\n\t\tto->si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (in_x32_syscall()) {\n\t\t\tto->si_utime = from->_sifields._sigchld_x32._utime;\n\t\t\tto->si_stime = from->_sifields._sigchld_x32._stime;\n\t\t} else\n#endif\n\t\t{\n\t\t\tto->si_utime = from->si_utime;\n\t\t\tto->si_stime = from->si_stime;\n\t\t}\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = compat_ptr(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n\treturn 0;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int post_copy_siginfo_from_user32(kernel_siginfo_t *to,\n\t\t\t\t\t const struct compat_siginfo *from)\n{\n\tclear_siginfo(to);\n\tto->si_signo = from->si_signo;\n\tto->si_errno = from->si_errno;\n\tto->si_code  = from->si_code;\n\tswitch(siginfo_layout(from->si_signo, from->si_code)) {\n\tcase SIL_KILL:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tbreak;\n\tcase SIL_TIMER:\n\t\tto->si_tid     = from->si_tid;\n\t\tto->si_overrun = from->si_overrun;\n\t\tto->si_int     = from->si_int;\n\t\tbreak;\n\tcase SIL_POLL:\n\t\tto->si_band = from->si_band;\n\t\tto->si_fd   = from->si_fd;\n\t\tbreak;\n\tcase SIL_FAULT:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tbreak;\n\tcase SIL_FAULT_MCEERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_addr_lsb = from->si_addr_lsb;\n\t\tbreak;\n\tcase SIL_FAULT_BNDERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_lower = compat_ptr(from->si_lower);\n\t\tto->si_upper = compat_ptr(from->si_upper);\n\t\tbreak;\n\tcase SIL_FAULT_PKUERR:\n\t\tto->si_addr = compat_ptr(from->si_addr);\n#ifdef __ARCH_SI_TRAPNO\n\t\tto->si_trapno = from->si_trapno;\n#endif\n\t\tto->si_pkey = from->si_pkey;\n\t\tbreak;\n\tcase SIL_CHLD:\n\t\tto->si_pid    = from->si_pid;\n\t\tto->si_uid    = from->si_uid;\n\t\tto->si_status = from->si_status;\n#ifdef CONFIG_X86_X32_ABI\n\t\tif (in_x32_syscall()) {\n\t\t\tto->si_utime = from->_sifields._sigchld_x32._utime;\n\t\t\tto->si_stime = from->_sifields._sigchld_x32._stime;\n\t\t} else\n#endif\n\t\t{\n\t\t\tto->si_utime = from->si_utime;\n\t\t\tto->si_stime = from->si_stime;\n\t\t}\n\t\tbreak;\n\tcase SIL_RT:\n\t\tto->si_pid = from->si_pid;\n\t\tto->si_uid = from->si_uid;\n\t\tto->si_int = from->si_int;\n\t\tbreak;\n\tcase SIL_SYS:\n\t\tto->si_call_addr = compat_ptr(from->si_call_addr);\n\t\tto->si_syscall   = from->si_syscall;\n\t\tto->si_arch      = from->si_arch;\n\t\tbreak;\n\t}\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "to",
            "from",
            "sizeof(struct kernel_siginfo)"
          ],
          "line": 2954
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic int __copy_siginfo_from_user(int signo, kernel_siginfo_t *to,\n\t\t\t\t    const siginfo_t __user *from)\n{\n\tif (copy_from_user(to, from, sizeof(struct kernel_siginfo)))\n\t\treturn -EFAULT;\n\tto->si_signo = signo;\n\treturn post_copy_siginfo_from_user(to, from);\n}"
  },
  {
    "function_name": "post_copy_siginfo_from_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2928-2949",
    "snippet": "static int post_copy_siginfo_from_user(kernel_siginfo_t *info,\n\t\t\t\t       const siginfo_t __user *from)\n{\n\tif (unlikely(!known_siginfo_layout(info->si_signo, info->si_code))) {\n\t\tchar __user *expansion = si_expansion(from);\n\t\tchar buf[SI_EXPANSION_SIZE];\n\t\tint i;\n\t\t/*\n\t\t * An unknown si_code might need more than\n\t\t * sizeof(struct kernel_siginfo) bytes.  Verify all of the\n\t\t * extra bytes are 0.  This guarantees copy_siginfo_to_user\n\t\t * will return this data to userspace exactly.\n\t\t */\n\t\tif (copy_from_user(&buf, expansion, SI_EXPANSION_SIZE))\n\t\t\treturn -EFAULT;\n\t\tfor (i = 0; i < SI_EXPANSION_SIZE; i++) {\n\t\t\tif (buf[i] != 0)\n\t\t\t\treturn -E2BIG;\n\t\t}\n\t}\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "copy_from_user",
          "args": [
            "&buf",
            "expansion",
            "SI_EXPANSION_SIZE"
          ],
          "line": 2941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "si_expansion",
          "args": [
            "from"
          ],
          "line": 2932
        },
        "resolved": true,
        "details": {
          "function_name": "si_expansion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "2913-2916",
          "snippet": "static inline char __user *si_expansion(const siginfo_t __user *info)\n{\n\treturn ((char __user *)info) + sizeof(struct kernel_siginfo);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic inline char __user *si_expansion(const siginfo_t __user *info)\n{\n\treturn ((char __user *)info) + sizeof(struct kernel_siginfo);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!known_siginfo_layout(info->si_signo, info->si_code)"
          ],
          "line": 2931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "known_siginfo_layout",
          "args": [
            "info->si_signo",
            "info->si_code"
          ],
          "line": 2931
        },
        "resolved": true,
        "details": {
          "function_name": "known_siginfo_layout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "2863-2880",
          "snippet": "static bool known_siginfo_layout(unsigned sig, int si_code)\n{\n\tif (si_code == SI_KERNEL)\n\t\treturn true;\n\telse if ((si_code > SI_USER)) {\n\t\tif (sig_specific_sicodes(sig)) {\n\t\t\tif (si_code <= sig_sicodes[sig].limit)\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\treturn true;\n\t}\n\telse if (si_code >= SI_DETHREAD)\n\t\treturn true;\n\telse if (si_code == SI_ASYNCNL)\n\t\treturn true;\n\treturn false;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};\n\nstatic bool known_siginfo_layout(unsigned sig, int si_code)\n{\n\tif (si_code == SI_KERNEL)\n\t\treturn true;\n\telse if ((si_code > SI_USER)) {\n\t\tif (sig_specific_sicodes(sig)) {\n\t\t\tif (si_code <= sig_sicodes[sig].limit)\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\treturn true;\n\t}\n\telse if (si_code >= SI_DETHREAD)\n\t\treturn true;\n\telse if (si_code == SI_ASYNCNL)\n\t\treturn true;\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int post_copy_siginfo_from_user(kernel_siginfo_t *info,\n\t\t\t\t       const siginfo_t __user *from)\n{\n\tif (unlikely(!known_siginfo_layout(info->si_signo, info->si_code))) {\n\t\tchar __user *expansion = si_expansion(from);\n\t\tchar buf[SI_EXPANSION_SIZE];\n\t\tint i;\n\t\t/*\n\t\t * An unknown si_code might need more than\n\t\t * sizeof(struct kernel_siginfo) bytes.  Verify all of the\n\t\t * extra bytes are 0.  This guarantees copy_siginfo_to_user\n\t\t * will return this data to userspace exactly.\n\t\t */\n\t\tif (copy_from_user(&buf, expansion, SI_EXPANSION_SIZE))\n\t\t\treturn -EFAULT;\n\t\tfor (i = 0; i < SI_EXPANSION_SIZE; i++) {\n\t\t\tif (buf[i] != 0)\n\t\t\t\treturn -E2BIG;\n\t\t}\n\t}\n\treturn 0;\n}"
  },
  {
    "function_name": "copy_siginfo_to_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2918-2926",
    "snippet": "int copy_siginfo_to_user(siginfo_t __user *to, const kernel_siginfo_t *from)\n{\n\tchar __user *expansion = si_expansion(to);\n\tif (copy_to_user(to, from , sizeof(struct kernel_siginfo)))\n\t\treturn -EFAULT;\n\tif (clear_user(expansion, SI_EXPANSION_SIZE))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_user",
          "args": [
            "expansion",
            "SI_EXPANSION_SIZE"
          ],
          "line": 2923
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "copy_to_user",
          "args": [
            "to",
            "from",
            "sizeof(struct kernel_siginfo)"
          ],
          "line": 2921
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_prog_array_copy_to_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/core.c",
          "lines": "1639-1669",
          "snippet": "int bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <asm/unaligned.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/kallsyms.h>",
            "#include <linux/rbtree_latch.h>",
            "#include <linux/frame.h>",
            "#include <linux/bpf.h>",
            "#include <linux/moduleloader.h>",
            "#include <linux/random.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/skbuff.h>",
            "#include <linux/filter.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <asm/unaligned.h>\n#include <linux/perf_event.h>\n#include <linux/rcupdate.h>\n#include <linux/kallsyms.h>\n#include <linux/rbtree_latch.h>\n#include <linux/frame.h>\n#include <linux/bpf.h>\n#include <linux/moduleloader.h>\n#include <linux/random.h>\n#include <linux/vmalloc.h>\n#include <linux/skbuff.h>\n#include <linux/filter.h>\n\nint bpf_prog_array_copy_to_user(struct bpf_prog_array __rcu *array,\n\t\t\t\t__u32 __user *prog_ids, u32 cnt)\n{\n\tunsigned long err = 0;\n\tbool nospc;\n\tu32 *ids;\n\n\t/* users of this function are doing:\n\t * cnt = bpf_prog_array_length();\n\t * if (cnt > 0)\n\t *     bpf_prog_array_copy_to_user(..., cnt);\n\t * so below kcalloc doesn't need extra cnt > 0 check, but\n\t * bpf_prog_array_length() releases rcu lock and\n\t * prog array could have been swapped with empty or larger array,\n\t * so always copy 'cnt' prog_ids to the user.\n\t * In a rare race the user will see zero prog_ids\n\t */\n\tids = kcalloc(cnt, sizeof(u32), GFP_USER | __GFP_NOWARN);\n\tif (!ids)\n\t\treturn -ENOMEM;\n\trcu_read_lock();\n\tnospc = bpf_prog_array_copy_core(array, ids, cnt);\n\trcu_read_unlock();\n\terr = copy_to_user(prog_ids, ids, cnt * sizeof(u32));\n\tkfree(ids);\n\tif (err)\n\t\treturn -EFAULT;\n\tif (nospc)\n\t\treturn -ENOSPC;\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "si_expansion",
          "args": [
            "to"
          ],
          "line": 2920
        },
        "resolved": true,
        "details": {
          "function_name": "si_expansion",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "2913-2916",
          "snippet": "static inline char __user *si_expansion(const siginfo_t __user *info)\n{\n\treturn ((char __user *)info) + sizeof(struct kernel_siginfo);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic inline char __user *si_expansion(const siginfo_t __user *info)\n{\n\treturn ((char __user *)info) + sizeof(struct kernel_siginfo);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint copy_siginfo_to_user(siginfo_t __user *to, const kernel_siginfo_t *from)\n{\n\tchar __user *expansion = si_expansion(to);\n\tif (copy_to_user(to, from , sizeof(struct kernel_siginfo)))\n\t\treturn -EFAULT;\n\tif (clear_user(expansion, SI_EXPANSION_SIZE))\n\t\treturn -EFAULT;\n\treturn 0;\n}"
  },
  {
    "function_name": "si_expansion",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2913-2916",
    "snippet": "static inline char __user *si_expansion(const siginfo_t __user *info)\n{\n\treturn ((char __user *)info) + sizeof(struct kernel_siginfo);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic inline char __user *si_expansion(const siginfo_t __user *info)\n{\n\treturn ((char __user *)info) + sizeof(struct kernel_siginfo);\n}"
  },
  {
    "function_name": "siginfo_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2882-2911",
    "snippet": "enum siginfo_layout siginfo_layout(unsigned sig, int si_code)\n{\n\tenum siginfo_layout layout = SIL_KILL;\n\tif ((si_code > SI_USER) && (si_code < SI_KERNEL)) {\n\t\tif ((sig < ARRAY_SIZE(sig_sicodes)) &&\n\t\t    (si_code <= sig_sicodes[sig].limit)) {\n\t\t\tlayout = sig_sicodes[sig].layout;\n\t\t\t/* Handle the exceptions */\n\t\t\tif ((sig == SIGBUS) &&\n\t\t\t    (si_code >= BUS_MCEERR_AR) && (si_code <= BUS_MCEERR_AO))\n\t\t\t\tlayout = SIL_FAULT_MCEERR;\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_BNDERR))\n\t\t\t\tlayout = SIL_FAULT_BNDERR;\n#ifdef SEGV_PKUERR\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_PKUERR))\n\t\t\t\tlayout = SIL_FAULT_PKUERR;\n#endif\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\tlayout = SIL_POLL;\n\t} else {\n\t\tif (si_code == SI_TIMER)\n\t\t\tlayout = SIL_TIMER;\n\t\telse if (si_code == SI_SIGIO)\n\t\t\tlayout = SIL_POLL;\n\t\telse if (si_code < 0)\n\t\t\tlayout = SIL_RT;\n\t}\n\treturn layout;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ARRAY_SIZE",
          "args": [
            "sig_sicodes"
          ],
          "line": 2886
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};\n\nenum siginfo_layout siginfo_layout(unsigned sig, int si_code)\n{\n\tenum siginfo_layout layout = SIL_KILL;\n\tif ((si_code > SI_USER) && (si_code < SI_KERNEL)) {\n\t\tif ((sig < ARRAY_SIZE(sig_sicodes)) &&\n\t\t    (si_code <= sig_sicodes[sig].limit)) {\n\t\t\tlayout = sig_sicodes[sig].layout;\n\t\t\t/* Handle the exceptions */\n\t\t\tif ((sig == SIGBUS) &&\n\t\t\t    (si_code >= BUS_MCEERR_AR) && (si_code <= BUS_MCEERR_AO))\n\t\t\t\tlayout = SIL_FAULT_MCEERR;\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_BNDERR))\n\t\t\t\tlayout = SIL_FAULT_BNDERR;\n#ifdef SEGV_PKUERR\n\t\t\telse if ((sig == SIGSEGV) && (si_code == SEGV_PKUERR))\n\t\t\t\tlayout = SIL_FAULT_PKUERR;\n#endif\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\tlayout = SIL_POLL;\n\t} else {\n\t\tif (si_code == SI_TIMER)\n\t\t\tlayout = SIL_TIMER;\n\t\telse if (si_code == SI_SIGIO)\n\t\t\tlayout = SIL_POLL;\n\t\telse if (si_code < 0)\n\t\t\tlayout = SIL_RT;\n\t}\n\treturn layout;\n}"
  },
  {
    "function_name": "known_siginfo_layout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2863-2880",
    "snippet": "static bool known_siginfo_layout(unsigned sig, int si_code)\n{\n\tif (si_code == SI_KERNEL)\n\t\treturn true;\n\telse if ((si_code > SI_USER)) {\n\t\tif (sig_specific_sicodes(sig)) {\n\t\t\tif (si_code <= sig_sicodes[sig].limit)\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\treturn true;\n\t}\n\telse if (si_code >= SI_DETHREAD)\n\t\treturn true;\n\telse if (si_code == SI_ASYNCNL)\n\t\treturn true;\n\treturn false;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sig_specific_sicodes",
          "args": [
            "sig"
          ],
          "line": 2868
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic const struct {\n\tunsigned char limit, layout;\n} sig_sicodes[] = {\n\t[SIGILL]  = { NSIGILL,  SIL_FAULT },\n\t[SIGFPE]  = { NSIGFPE,  SIL_FAULT },\n\t[SIGSEGV] = { NSIGSEGV, SIL_FAULT },\n\t[SIGBUS]  = { NSIGBUS,  SIL_FAULT },\n\t[SIGTRAP] = { NSIGTRAP, SIL_FAULT },\n#if defined(SIGEMT)\n\t[SIGEMT]  = { NSIGEMT,  SIL_FAULT },\n#endif\n\t[SIGCHLD] = { NSIGCHLD, SIL_CHLD },\n\t[SIGPOLL] = { NSIGPOLL, SIL_POLL },\n\t[SIGSYS]  = { NSIGSYS,  SIL_SYS },\n};\n\nstatic bool known_siginfo_layout(unsigned sig, int si_code)\n{\n\tif (si_code == SI_KERNEL)\n\t\treturn true;\n\telse if ((si_code > SI_USER)) {\n\t\tif (sig_specific_sicodes(sig)) {\n\t\t\tif (si_code <= sig_sicodes[sig].limit)\n\t\t\t\treturn true;\n\t\t}\n\t\telse if (si_code <= NSIGPOLL)\n\t\t\treturn true;\n\t}\n\telse if (si_code >= SI_DETHREAD)\n\t\treturn true;\n\telse if (si_code == SI_ASYNCNL)\n\t\treturn true;\n\treturn false;\n}"
  },
  {
    "function_name": "do_sigpending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2800-2809",
    "snippet": "static void do_sigpending(sigset_t *set)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\tsigorsets(set, &current->pending.signal,\n\t\t  &current->signal->shared_pending.signal);\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\t/* Outside the lock because only this thread touches it.  */\n\tsigandsets(set, &current->blocked, set);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigandsets",
          "args": [
            "set",
            "&current->blocked",
            "set"
          ],
          "line": 2808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 2805
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigorsets",
          "args": [
            "set",
            "&current->pending.signal",
            "&current->signal->shared_pending.signal"
          ],
          "line": 2803
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 2802
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void do_sigpending(sigset_t *set)\n{\n\tspin_lock_irq(&current->sighand->siglock);\n\tsigorsets(set, &current->pending.signal,\n\t\t  &current->signal->shared_pending.signal);\n\tspin_unlock_irq(&current->sighand->siglock);\n\n\t/* Outside the lock because only this thread touches it.  */\n\tsigandsets(set, &current->blocked, set);\n}"
  },
  {
    "function_name": "sigprocmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2710-2735",
    "snippet": "int sigprocmask(int how, sigset_t *set, sigset_t *oldset)\n{\n\tstruct task_struct *tsk = current;\n\tsigset_t newset;\n\n\t/* Lockless, only current can change ->blocked, never from irq */\n\tif (oldset)\n\t\t*oldset = tsk->blocked;\n\n\tswitch (how) {\n\tcase SIG_BLOCK:\n\t\tsigorsets(&newset, &tsk->blocked, set);\n\t\tbreak;\n\tcase SIG_UNBLOCK:\n\t\tsigandnsets(&newset, &tsk->blocked, set);\n\t\tbreak;\n\tcase SIG_SETMASK:\n\t\tnewset = *set;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t__set_current_blocked(&newset);\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_current_blocked",
          "args": [
            "&newset"
          ],
          "line": 2733
        },
        "resolved": true,
        "details": {
          "function_name": "__set_current_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "2686-2700",
          "snippet": "void __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigandnsets",
          "args": [
            "&newset",
            "&tsk->blocked",
            "set"
          ],
          "line": 2724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigorsets",
          "args": [
            "&newset",
            "&tsk->blocked",
            "set"
          ],
          "line": 2721
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint sigprocmask(int how, sigset_t *set, sigset_t *oldset)\n{\n\tstruct task_struct *tsk = current;\n\tsigset_t newset;\n\n\t/* Lockless, only current can change ->blocked, never from irq */\n\tif (oldset)\n\t\t*oldset = tsk->blocked;\n\n\tswitch (how) {\n\tcase SIG_BLOCK:\n\t\tsigorsets(&newset, &tsk->blocked, set);\n\t\tbreak;\n\tcase SIG_UNBLOCK:\n\t\tsigandnsets(&newset, &tsk->blocked, set);\n\t\tbreak;\n\tcase SIG_SETMASK:\n\t\tnewset = *set;\n\t\tbreak;\n\tdefault:\n\t\treturn -EINVAL;\n\t}\n\n\t__set_current_blocked(&newset);\n\treturn 0;\n}"
  },
  {
    "function_name": "__set_current_blocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2686-2700",
    "snippet": "void __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 2699
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_task_blocked",
          "args": [
            "tsk",
            "newset"
          ],
          "line": 2698
        },
        "resolved": true,
        "details": {
          "function_name": "__set_task_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "2661-2671",
          "snippet": "static void __set_task_blocked(struct task_struct *tsk, const sigset_t *newset)\n{\n\tif (signal_pending(tsk) && !thread_group_empty(tsk)) {\n\t\tsigset_t newblocked;\n\t\t/* A set of now blocked but previously unblocked signals. */\n\t\tsigandnsets(&newblocked, newset, &current->blocked);\n\t\tretarget_shared_pending(tsk, &newblocked);\n\t}\n\ttsk->blocked = *newset;\n\trecalc_sigpending();\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void __set_task_blocked(struct task_struct *tsk, const sigset_t *newset)\n{\n\tif (signal_pending(tsk) && !thread_group_empty(tsk)) {\n\t\tsigset_t newblocked;\n\t\t/* A set of now blocked but previously unblocked signals. */\n\t\tsigandnsets(&newblocked, newset, &current->blocked);\n\t\tretarget_shared_pending(tsk, &newblocked);\n\t}\n\ttsk->blocked = *newset;\n\trecalc_sigpending();\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 2697
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigequalsets",
          "args": [
            "&tsk->blocked",
            "newset"
          ],
          "line": 2694
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}"
  },
  {
    "function_name": "set_current_blocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2680-2684",
    "snippet": "void set_current_blocked(sigset_t *newset)\n{\n\tsigdelsetmask(newset, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\t__set_current_blocked(newset);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__set_current_blocked",
          "args": [
            "newset"
          ],
          "line": 2683
        },
        "resolved": true,
        "details": {
          "function_name": "__set_current_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "2686-2700",
          "snippet": "void __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigdelsetmask",
          "args": [
            "newset",
            "sigmask(SIGKILL) | sigmask(SIGSTOP)"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGSTOP"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGKILL"
          ],
          "line": 2682
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid set_current_blocked(sigset_t *newset)\n{\n\tsigdelsetmask(newset, sigmask(SIGKILL) | sigmask(SIGSTOP));\n\t__set_current_blocked(newset);\n}"
  },
  {
    "function_name": "__set_task_blocked",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2661-2671",
    "snippet": "static void __set_task_blocked(struct task_struct *tsk, const sigset_t *newset)\n{\n\tif (signal_pending(tsk) && !thread_group_empty(tsk)) {\n\t\tsigset_t newblocked;\n\t\t/* A set of now blocked but previously unblocked signals. */\n\t\tsigandnsets(&newblocked, newset, &current->blocked);\n\t\tretarget_shared_pending(tsk, &newblocked);\n\t}\n\ttsk->blocked = *newset;\n\trecalc_sigpending();\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalc_sigpending",
          "args": [],
          "line": 2670
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_sigpending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "172-178",
          "snippet": "void recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current) &&\n\t    !klp_patch_pending(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current) &&\n\t    !klp_patch_pending(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "retarget_shared_pending",
          "args": [
            "tsk",
            "&newblocked"
          ],
          "line": 2667
        },
        "resolved": true,
        "details": {
          "function_name": "retarget_shared_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "2566-2591",
          "snippet": "static void retarget_shared_pending(struct task_struct *tsk, sigset_t *which)\n{\n\tsigset_t retarget;\n\tstruct task_struct *t;\n\n\tsigandsets(&retarget, &tsk->signal->shared_pending.signal, which);\n\tif (sigisemptyset(&retarget))\n\t\treturn;\n\n\tt = tsk;\n\twhile_each_thread(tsk, t) {\n\t\tif (t->flags & PF_EXITING)\n\t\t\tcontinue;\n\n\t\tif (!has_pending_signals(&retarget, &t->blocked))\n\t\t\tcontinue;\n\t\t/* Remove the signals this thread can handle. */\n\t\tsigandsets(&retarget, &retarget, &t->blocked);\n\n\t\tif (!signal_pending(t))\n\t\t\tsignal_wake_up(t, 0);\n\n\t\tif (sigisemptyset(&retarget))\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void retarget_shared_pending(struct task_struct *tsk, sigset_t *which)\n{\n\tsigset_t retarget;\n\tstruct task_struct *t;\n\n\tsigandsets(&retarget, &tsk->signal->shared_pending.signal, which);\n\tif (sigisemptyset(&retarget))\n\t\treturn;\n\n\tt = tsk;\n\twhile_each_thread(tsk, t) {\n\t\tif (t->flags & PF_EXITING)\n\t\t\tcontinue;\n\n\t\tif (!has_pending_signals(&retarget, &t->blocked))\n\t\t\tcontinue;\n\t\t/* Remove the signals this thread can handle. */\n\t\tsigandsets(&retarget, &retarget, &t->blocked);\n\n\t\tif (!signal_pending(t))\n\t\t\tsignal_wake_up(t, 0);\n\n\t\tif (sigisemptyset(&retarget))\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigandnsets",
          "args": [
            "&newblocked",
            "newset",
            "&current->blocked"
          ],
          "line": 2666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "tsk"
          ],
          "line": 2663
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "tsk"
          ],
          "line": 2663
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void __set_task_blocked(struct task_struct *tsk, const sigset_t *newset)\n{\n\tif (signal_pending(tsk) && !thread_group_empty(tsk)) {\n\t\tsigset_t newblocked;\n\t\t/* A set of now blocked but previously unblocked signals. */\n\t\tsigandnsets(&newblocked, newset, &current->blocked);\n\t\tretarget_shared_pending(tsk, &newblocked);\n\t}\n\ttsk->blocked = *newset;\n\trecalc_sigpending();\n}"
  },
  {
    "function_name": "do_no_restart_syscall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2656-2659",
    "snippet": "long do_no_restart_syscall(struct restart_block *param)\n{\n\treturn -EINTR;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nlong do_no_restart_syscall(struct restart_block *param)\n{\n\treturn -EINTR;\n}"
  },
  {
    "function_name": "exit_signals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2593-2641",
    "snippet": "void exit_signals(struct task_struct *tsk)\n{\n\tint group_stop = 0;\n\tsigset_t unblocked;\n\n\t/*\n\t * @tsk is about to have PF_EXITING set - lock out users which\n\t * expect stable threadgroup.\n\t */\n\tcgroup_threadgroup_change_begin(tsk);\n\n\tif (thread_group_empty(tsk) || signal_group_exit(tsk->signal)) {\n\t\ttsk->flags |= PF_EXITING;\n\t\tcgroup_threadgroup_change_end(tsk);\n\t\treturn;\n\t}\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t/*\n\t * From now this task is not visible for group-wide signals,\n\t * see wants_signal(), do_signal_stop().\n\t */\n\ttsk->flags |= PF_EXITING;\n\n\tcgroup_threadgroup_change_end(tsk);\n\n\tif (!signal_pending(tsk))\n\t\tgoto out;\n\n\tunblocked = tsk->blocked;\n\tsignotset(&unblocked);\n\tretarget_shared_pending(tsk, &unblocked);\n\n\tif (unlikely(tsk->jobctl & JOBCTL_STOP_PENDING) &&\n\t    task_participate_group_stop(tsk))\n\t\tgroup_stop = CLD_STOPPED;\nout:\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\t/*\n\t * If group stop has completed, deliver the notification.  This\n\t * should always go to the real parent of the group leader.\n\t */\n\tif (unlikely(group_stop)) {\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(tsk, false, group_stop);\n\t\tread_unlock(&tasklist_lock);\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 2639
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_notify_parent_cldstop",
          "args": [
            "tsk",
            "false",
            "group_stop"
          ],
          "line": 2638
        },
        "resolved": true,
        "details": {
          "function_name": "do_notify_parent_cldstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1871-1927",
          "snippet": "static void do_notify_parent_cldstop(struct task_struct *tsk,\n\t\t\t\t     bool for_ptracer, int why)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\tu64 utime, stime;\n\n\tif (for_ptracer) {\n\t\tparent = tsk->parent;\n\t} else {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\t/*\n\t * see comment in do_notify_parent() about the following 4 lines\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime);\n\tinfo.si_stime = nsec_to_clock_t(stime);\n\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t/*\n\t * Even if SIGCHLD is not generated, we must wake up wait4 calls.\n\t */\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic void do_notify_parent_cldstop(struct task_struct *tsk,\n\t\t\t\t     bool for_ptracer, int why)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\tu64 utime, stime;\n\n\tif (for_ptracer) {\n\t\tparent = tsk->parent;\n\t} else {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\t/*\n\t * see comment in do_notify_parent() about the following 4 lines\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime);\n\tinfo.si_stime = nsec_to_clock_t(stime);\n\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t/*\n\t * Even if SIGCHLD is not generated, we must wake up wait4 calls.\n\t */\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 2637
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "group_stop"
          ],
          "line": 2636
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 2630
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_participate_group_stop",
          "args": [
            "tsk"
          ],
          "line": 2627
        },
        "resolved": true,
        "details": {
          "function_name": "task_participate_group_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "356-380",
          "snippet": "static bool task_participate_group_stop(struct task_struct *task)\n{\n\tstruct signal_struct *sig = task->signal;\n\tbool consume = task->jobctl & JOBCTL_STOP_CONSUME;\n\n\tWARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING));\n\n\ttask_clear_jobctl_pending(task, JOBCTL_STOP_PENDING);\n\n\tif (!consume)\n\t\treturn false;\n\n\tif (!WARN_ON_ONCE(sig->group_stop_count == 0))\n\t\tsig->group_stop_count--;\n\n\t/*\n\t * Tell the caller to notify completion iff we are entering into a\n\t * fresh group stop.  Read comment in do_signal_stop() for details.\n\t */\n\tif (!sig->group_stop_count && !(sig->flags & SIGNAL_STOP_STOPPED)) {\n\t\tsignal_set_stop_flags(sig, SIGNAL_STOP_STOPPED);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool task_participate_group_stop(struct task_struct *task)\n{\n\tstruct signal_struct *sig = task->signal;\n\tbool consume = task->jobctl & JOBCTL_STOP_CONSUME;\n\n\tWARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING));\n\n\ttask_clear_jobctl_pending(task, JOBCTL_STOP_PENDING);\n\n\tif (!consume)\n\t\treturn false;\n\n\tif (!WARN_ON_ONCE(sig->group_stop_count == 0))\n\t\tsig->group_stop_count--;\n\n\t/*\n\t * Tell the caller to notify completion iff we are entering into a\n\t * fresh group stop.  Read comment in do_signal_stop() for details.\n\t */\n\tif (!sig->group_stop_count && !(sig->flags & SIGNAL_STOP_STOPPED)) {\n\t\tsignal_set_stop_flags(sig, SIGNAL_STOP_STOPPED);\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "tsk->jobctl & JOBCTL_STOP_PENDING"
          ],
          "line": 2626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "retarget_shared_pending",
          "args": [
            "tsk",
            "&unblocked"
          ],
          "line": 2624
        },
        "resolved": true,
        "details": {
          "function_name": "retarget_shared_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "2566-2591",
          "snippet": "static void retarget_shared_pending(struct task_struct *tsk, sigset_t *which)\n{\n\tsigset_t retarget;\n\tstruct task_struct *t;\n\n\tsigandsets(&retarget, &tsk->signal->shared_pending.signal, which);\n\tif (sigisemptyset(&retarget))\n\t\treturn;\n\n\tt = tsk;\n\twhile_each_thread(tsk, t) {\n\t\tif (t->flags & PF_EXITING)\n\t\t\tcontinue;\n\n\t\tif (!has_pending_signals(&retarget, &t->blocked))\n\t\t\tcontinue;\n\t\t/* Remove the signals this thread can handle. */\n\t\tsigandsets(&retarget, &retarget, &t->blocked);\n\n\t\tif (!signal_pending(t))\n\t\t\tsignal_wake_up(t, 0);\n\n\t\tif (sigisemptyset(&retarget))\n\t\t\tbreak;\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void retarget_shared_pending(struct task_struct *tsk, sigset_t *which)\n{\n\tsigset_t retarget;\n\tstruct task_struct *t;\n\n\tsigandsets(&retarget, &tsk->signal->shared_pending.signal, which);\n\tif (sigisemptyset(&retarget))\n\t\treturn;\n\n\tt = tsk;\n\twhile_each_thread(tsk, t) {\n\t\tif (t->flags & PF_EXITING)\n\t\t\tcontinue;\n\n\t\tif (!has_pending_signals(&retarget, &t->blocked))\n\t\t\tcontinue;\n\t\t/* Remove the signals this thread can handle. */\n\t\tsigandsets(&retarget, &retarget, &t->blocked);\n\n\t\tif (!signal_pending(t))\n\t\t\tsignal_wake_up(t, 0);\n\n\t\tif (sigisemptyset(&retarget))\n\t\t\tbreak;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "signotset",
          "args": [
            "&unblocked"
          ],
          "line": 2623
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "tsk"
          ],
          "line": 2619
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_threadgroup_change_end",
          "args": [
            "tsk"
          ],
          "line": 2617
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 2610
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "cgroup_threadgroup_change_end",
          "args": [
            "tsk"
          ],
          "line": 2606
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_group_exit",
          "args": [
            "tsk->signal"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "tsk"
          ],
          "line": 2604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cgroup_threadgroup_change_begin",
          "args": [
            "tsk"
          ],
          "line": 2602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid exit_signals(struct task_struct *tsk)\n{\n\tint group_stop = 0;\n\tsigset_t unblocked;\n\n\t/*\n\t * @tsk is about to have PF_EXITING set - lock out users which\n\t * expect stable threadgroup.\n\t */\n\tcgroup_threadgroup_change_begin(tsk);\n\n\tif (thread_group_empty(tsk) || signal_group_exit(tsk->signal)) {\n\t\ttsk->flags |= PF_EXITING;\n\t\tcgroup_threadgroup_change_end(tsk);\n\t\treturn;\n\t}\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t/*\n\t * From now this task is not visible for group-wide signals,\n\t * see wants_signal(), do_signal_stop().\n\t */\n\ttsk->flags |= PF_EXITING;\n\n\tcgroup_threadgroup_change_end(tsk);\n\n\tif (!signal_pending(tsk))\n\t\tgoto out;\n\n\tunblocked = tsk->blocked;\n\tsignotset(&unblocked);\n\tretarget_shared_pending(tsk, &unblocked);\n\n\tif (unlikely(tsk->jobctl & JOBCTL_STOP_PENDING) &&\n\t    task_participate_group_stop(tsk))\n\t\tgroup_stop = CLD_STOPPED;\nout:\n\tspin_unlock_irq(&tsk->sighand->siglock);\n\n\t/*\n\t * If group stop has completed, deliver the notification.  This\n\t * should always go to the real parent of the group leader.\n\t */\n\tif (unlikely(group_stop)) {\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(tsk, false, group_stop);\n\t\tread_unlock(&tasklist_lock);\n\t}\n}"
  },
  {
    "function_name": "retarget_shared_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2566-2591",
    "snippet": "static void retarget_shared_pending(struct task_struct *tsk, sigset_t *which)\n{\n\tsigset_t retarget;\n\tstruct task_struct *t;\n\n\tsigandsets(&retarget, &tsk->signal->shared_pending.signal, which);\n\tif (sigisemptyset(&retarget))\n\t\treturn;\n\n\tt = tsk;\n\twhile_each_thread(tsk, t) {\n\t\tif (t->flags & PF_EXITING)\n\t\t\tcontinue;\n\n\t\tif (!has_pending_signals(&retarget, &t->blocked))\n\t\t\tcontinue;\n\t\t/* Remove the signals this thread can handle. */\n\t\tsigandsets(&retarget, &retarget, &t->blocked);\n\n\t\tif (!signal_pending(t))\n\t\t\tsignal_wake_up(t, 0);\n\n\t\tif (sigisemptyset(&retarget))\n\t\t\tbreak;\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigisemptyset",
          "args": [
            "&retarget"
          ],
          "line": 2588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_wake_up",
          "args": [
            "t",
            "0"
          ],
          "line": 2586
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "702-714",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "t"
          ],
          "line": 2585
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigandsets",
          "args": [
            "&retarget",
            "&retarget",
            "&t->blocked"
          ],
          "line": 2583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_pending_signals",
          "args": [
            "&retarget",
            "&t->blocked"
          ],
          "line": 2580
        },
        "resolved": true,
        "details": {
          "function_name": "has_pending_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "117-141",
          "snippet": "static inline bool has_pending_signals(sigset_t *signal, sigset_t *blocked)\n{\n\tunsigned long ready;\n\tlong i;\n\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tfor (i = _NSIG_WORDS, ready = 0; --i >= 0 ;)\n\t\t\tready |= signal->sig[i] &~ blocked->sig[i];\n\t\tbreak;\n\n\tcase 4: ready  = signal->sig[3] &~ blocked->sig[3];\n\t\tready |= signal->sig[2] &~ blocked->sig[2];\n\t\tready |= signal->sig[1] &~ blocked->sig[1];\n\t\tready |= signal->sig[0] &~ blocked->sig[0];\n\t\tbreak;\n\n\tcase 2: ready  = signal->sig[1] &~ blocked->sig[1];\n\t\tready |= signal->sig[0] &~ blocked->sig[0];\n\t\tbreak;\n\n\tcase 1: ready  = signal->sig[0] &~ blocked->sig[0];\n\t}\n\treturn ready !=\t0;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool has_pending_signals(sigset_t *signal, sigset_t *blocked)\n{\n\tunsigned long ready;\n\tlong i;\n\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tfor (i = _NSIG_WORDS, ready = 0; --i >= 0 ;)\n\t\t\tready |= signal->sig[i] &~ blocked->sig[i];\n\t\tbreak;\n\n\tcase 4: ready  = signal->sig[3] &~ blocked->sig[3];\n\t\tready |= signal->sig[2] &~ blocked->sig[2];\n\t\tready |= signal->sig[1] &~ blocked->sig[1];\n\t\tready |= signal->sig[0] &~ blocked->sig[0];\n\t\tbreak;\n\n\tcase 2: ready  = signal->sig[1] &~ blocked->sig[1];\n\t\tready |= signal->sig[0] &~ blocked->sig[0];\n\t\tbreak;\n\n\tcase 1: ready  = signal->sig[0] &~ blocked->sig[0];\n\t}\n\treturn ready !=\t0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_each_thread",
          "args": [
            "tsk",
            "t"
          ],
          "line": 2576
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigisemptyset",
          "args": [
            "&retarget"
          ],
          "line": 2572
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigandsets",
          "args": [
            "&retarget",
            "&tsk->signal->shared_pending.signal",
            "which"
          ],
          "line": 2571
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void retarget_shared_pending(struct task_struct *tsk, sigset_t *which)\n{\n\tsigset_t retarget;\n\tstruct task_struct *t;\n\n\tsigandsets(&retarget, &tsk->signal->shared_pending.signal, which);\n\tif (sigisemptyset(&retarget))\n\t\treturn;\n\n\tt = tsk;\n\twhile_each_thread(tsk, t) {\n\t\tif (t->flags & PF_EXITING)\n\t\t\tcontinue;\n\n\t\tif (!has_pending_signals(&retarget, &t->blocked))\n\t\t\tcontinue;\n\t\t/* Remove the signals this thread can handle. */\n\t\tsigandsets(&retarget, &retarget, &t->blocked);\n\n\t\tif (!signal_pending(t))\n\t\t\tsignal_wake_up(t, 0);\n\n\t\tif (sigisemptyset(&retarget))\n\t\t\tbreak;\n\t}\n}"
  },
  {
    "function_name": "signal_setup_done",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2553-2559",
    "snippet": "void signal_setup_done(int failed, struct ksignal *ksig, int stepping)\n{\n\tif (failed)\n\t\tforce_sigsegv(ksig->sig, current);\n\telse\n\t\tsignal_delivered(ksig, stepping);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_delivered",
          "args": [
            "ksig",
            "stepping"
          ],
          "line": 2558
        },
        "resolved": true,
        "details": {
          "function_name": "signal_delivered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "2536-2551",
          "snippet": "static void signal_delivered(struct ksignal *ksig, int stepping)\n{\n\tsigset_t blocked;\n\n\t/* A signal was successfully delivered, and the\n\t   saved sigmask was stored on the signal frame,\n\t   and will be restored by sigreturn.  So we can\n\t   simply clear the restore sigmask flag.  */\n\tclear_restore_sigmask();\n\n\tsigorsets(&blocked, &current->blocked, &ksig->ka.sa.sa_mask);\n\tif (!(ksig->ka.sa.sa_flags & SA_NODEFER))\n\t\tsigaddset(&blocked, ksig->sig);\n\tset_current_blocked(&blocked);\n\ttracehook_signal_handler(stepping);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void signal_delivered(struct ksignal *ksig, int stepping)\n{\n\tsigset_t blocked;\n\n\t/* A signal was successfully delivered, and the\n\t   saved sigmask was stored on the signal frame,\n\t   and will be restored by sigreturn.  So we can\n\t   simply clear the restore sigmask flag.  */\n\tclear_restore_sigmask();\n\n\tsigorsets(&blocked, &current->blocked, &ksig->ka.sa.sa_mask);\n\tif (!(ksig->ka.sa.sa_flags & SA_NODEFER))\n\t\tsigaddset(&blocked, ksig->sig);\n\tset_current_blocked(&blocked);\n\ttracehook_signal_handler(stepping);\n}"
        }
      },
      {
        "call_info": {
          "callee": "force_sigsegv",
          "args": [
            "ksig->sig",
            "current"
          ],
          "line": 2556
        },
        "resolved": true,
        "details": {
          "function_name": "force_sigsegv",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1520-1529",
          "snippet": "void force_sigsegv(int sig, struct task_struct *p)\n{\n\tif (sig == SIGSEGV) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&p->sighand->siglock, flags);\n\t\tp->sighand->action[sig - 1].sa.sa_handler = SIG_DFL;\n\t\tspin_unlock_irqrestore(&p->sighand->siglock, flags);\n\t}\n\tforce_sig(SIGSEGV, p);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid force_sigsegv(int sig, struct task_struct *p)\n{\n\tif (sig == SIGSEGV) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&p->sighand->siglock, flags);\n\t\tp->sighand->action[sig - 1].sa.sa_handler = SIG_DFL;\n\t\tspin_unlock_irqrestore(&p->sighand->siglock, flags);\n\t}\n\tforce_sig(SIGSEGV, p);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_setup_done(int failed, struct ksignal *ksig, int stepping)\n{\n\tif (failed)\n\t\tforce_sigsegv(ksig->sig, current);\n\telse\n\t\tsignal_delivered(ksig, stepping);\n}"
  },
  {
    "function_name": "signal_delivered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2536-2551",
    "snippet": "static void signal_delivered(struct ksignal *ksig, int stepping)\n{\n\tsigset_t blocked;\n\n\t/* A signal was successfully delivered, and the\n\t   saved sigmask was stored on the signal frame,\n\t   and will be restored by sigreturn.  So we can\n\t   simply clear the restore sigmask flag.  */\n\tclear_restore_sigmask();\n\n\tsigorsets(&blocked, &current->blocked, &ksig->ka.sa.sa_mask);\n\tif (!(ksig->ka.sa.sa_flags & SA_NODEFER))\n\t\tsigaddset(&blocked, ksig->sig);\n\tset_current_blocked(&blocked);\n\ttracehook_signal_handler(stepping);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "tracehook_signal_handler",
          "args": [
            "stepping"
          ],
          "line": 2550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_current_blocked",
          "args": [
            "&blocked"
          ],
          "line": 2549
        },
        "resolved": true,
        "details": {
          "function_name": "__set_current_blocked",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "2686-2700",
          "snippet": "void __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid __set_current_blocked(const sigset_t *newset)\n{\n\tstruct task_struct *tsk = current;\n\n\t/*\n\t * In case the signal mask hasn't changed, there is nothing we need\n\t * to do. The current->blocked shouldn't be modified by other task.\n\t */\n\tif (sigequalsets(&tsk->blocked, newset))\n\t\treturn;\n\n\tspin_lock_irq(&tsk->sighand->siglock);\n\t__set_task_blocked(tsk, newset);\n\tspin_unlock_irq(&tsk->sighand->siglock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&blocked",
            "ksig->sig"
          ],
          "line": 2548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigorsets",
          "args": [
            "&blocked",
            "&current->blocked",
            "&ksig->ka.sa.sa_mask"
          ],
          "line": 2546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_restore_sigmask",
          "args": [],
          "line": 2544
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void signal_delivered(struct ksignal *ksig, int stepping)\n{\n\tsigset_t blocked;\n\n\t/* A signal was successfully delivered, and the\n\t   saved sigmask was stored on the signal frame,\n\t   and will be restored by sigreturn.  So we can\n\t   simply clear the restore sigmask flag.  */\n\tclear_restore_sigmask();\n\n\tsigorsets(&blocked, &current->blocked, &ksig->ka.sa.sa_mask);\n\tif (!(ksig->ka.sa.sa_flags & SA_NODEFER))\n\t\tsigaddset(&blocked, ksig->sig);\n\tset_current_blocked(&blocked);\n\ttracehook_signal_handler(stepping);\n}"
  },
  {
    "function_name": "get_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2340-2524",
    "snippet": "bool get_signal(struct ksignal *ksig)\n{\n\tstruct sighand_struct *sighand = current->sighand;\n\tstruct signal_struct *signal = current->signal;\n\tint signr;\n\n\tif (unlikely(current->task_works))\n\t\ttask_work_run();\n\n\tif (unlikely(uprobe_deny_signal()))\n\t\treturn false;\n\n\t/*\n\t * Do this once, we can't return to user-mode if freezing() == T.\n\t * do_signal_stop() and ptrace_stop() do freezable_schedule() and\n\t * thus do not need another check after return.\n\t */\n\ttry_to_freeze();\n\nrelock:\n\tspin_lock_irq(&sighand->siglock);\n\t/*\n\t * Every stopped thread goes here after wakeup. Check to see if\n\t * we should notify the parent, prepare_signal(SIGCONT) encodes\n\t * the CLD_ si_code into SIGNAL_CLD_MASK bits.\n\t */\n\tif (unlikely(signal->flags & SIGNAL_CLD_MASK)) {\n\t\tint why;\n\n\t\tif (signal->flags & SIGNAL_CLD_CONTINUED)\n\t\t\twhy = CLD_CONTINUED;\n\t\telse\n\t\t\twhy = CLD_STOPPED;\n\n\t\tsignal->flags &= ~SIGNAL_CLD_MASK;\n\n\t\tspin_unlock_irq(&sighand->siglock);\n\n\t\t/*\n\t\t * Notify the parent that we're continuing.  This event is\n\t\t * always per-process and doesn't make whole lot of sense\n\t\t * for ptracers, who shouldn't consume the state via\n\t\t * wait(2) either, but, for backward compatibility, notify\n\t\t * the ptracer of the group leader too unless it's gonna be\n\t\t * a duplicate.\n\t\t */\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\tif (ptrace_reparented(current->group_leader))\n\t\t\tdo_notify_parent_cldstop(current->group_leader,\n\t\t\t\t\t\ttrue, why);\n\t\tread_unlock(&tasklist_lock);\n\n\t\tgoto relock;\n\t}\n\n\tfor (;;) {\n\t\tstruct k_sigaction *ka;\n\n\t\tif (unlikely(current->jobctl & JOBCTL_STOP_PENDING) &&\n\t\t    do_signal_stop(0))\n\t\t\tgoto relock;\n\n\t\tif (unlikely(current->jobctl & JOBCTL_TRAP_MASK)) {\n\t\t\tdo_jobctl_trap();\n\t\t\tspin_unlock_irq(&sighand->siglock);\n\t\t\tgoto relock;\n\t\t}\n\n\t\tsignr = dequeue_signal(current, &current->blocked, &ksig->info);\n\n\t\tif (!signr)\n\t\t\tbreak; /* will return 0 */\n\n\t\tif (unlikely(current->ptrace) && signr != SIGKILL) {\n\t\t\tsignr = ptrace_signal(signr, &ksig->info);\n\t\t\tif (!signr)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tka = &sighand->action[signr-1];\n\n\t\t/* Trace actually delivered signals. */\n\t\ttrace_signal_deliver(signr, &ksig->info, ka);\n\n\t\tif (ka->sa.sa_handler == SIG_IGN) /* Do nothing.  */\n\t\t\tcontinue;\n\t\tif (ka->sa.sa_handler != SIG_DFL) {\n\t\t\t/* Run the handler.  */\n\t\t\tksig->ka = *ka;\n\n\t\t\tif (ka->sa.sa_flags & SA_ONESHOT)\n\t\t\t\tka->sa.sa_handler = SIG_DFL;\n\n\t\t\tbreak; /* will return non-zero \"signr\" value */\n\t\t}\n\n\t\t/*\n\t\t * Now we are doing the default action for this signal.\n\t\t */\n\t\tif (sig_kernel_ignore(signr)) /* Default is nothing. */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Global init gets no signals it doesn't want.\n\t\t * Container-init gets no signals it doesn't want from same\n\t\t * container.\n\t\t *\n\t\t * Note that if global/container-init sees a sig_kernel_only()\n\t\t * signal here, the signal must have been generated internally\n\t\t * or must have come from an ancestor namespace. In either\n\t\t * case, the signal cannot be dropped.\n\t\t */\n\t\tif (unlikely(signal->flags & SIGNAL_UNKILLABLE) &&\n\t\t\t\t!sig_kernel_only(signr))\n\t\t\tcontinue;\n\n\t\tif (sig_kernel_stop(signr)) {\n\t\t\t/*\n\t\t\t * The default action is to stop all threads in\n\t\t\t * the thread group.  The job control signals\n\t\t\t * do nothing in an orphaned pgrp, but SIGSTOP\n\t\t\t * always works.  Note that siglock needs to be\n\t\t\t * dropped during the call to is_orphaned_pgrp()\n\t\t\t * because of lock ordering with tasklist_lock.\n\t\t\t * This allows an intervening SIGCONT to be posted.\n\t\t\t * We need to check for that and bail out if necessary.\n\t\t\t */\n\t\t\tif (signr != SIGSTOP) {\n\t\t\t\tspin_unlock_irq(&sighand->siglock);\n\n\t\t\t\t/* signals can be posted during this window */\n\n\t\t\t\tif (is_current_pgrp_orphaned())\n\t\t\t\t\tgoto relock;\n\n\t\t\t\tspin_lock_irq(&sighand->siglock);\n\t\t\t}\n\n\t\t\tif (likely(do_signal_stop(ksig->info.si_signo))) {\n\t\t\t\t/* It released the siglock.  */\n\t\t\t\tgoto relock;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We didn't actually stop, due to a race\n\t\t\t * with SIGCONT or something like that.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\tspin_unlock_irq(&sighand->siglock);\n\n\t\t/*\n\t\t * Anything else is fatal, maybe with a core dump.\n\t\t */\n\t\tcurrent->flags |= PF_SIGNALED;\n\n\t\tif (sig_kernel_coredump(signr)) {\n\t\t\tif (print_fatal_signals)\n\t\t\t\tprint_fatal_signal(ksig->info.si_signo);\n\t\t\tproc_coredump_connector(current);\n\t\t\t/*\n\t\t\t * If it was able to dump core, this kills all\n\t\t\t * other threads in the group and synchronizes with\n\t\t\t * their demise.  If we lost the race with another\n\t\t\t * thread getting here, it set group_exit_code\n\t\t\t * first and our do_group_exit call below will use\n\t\t\t * that value and ignore the one we pass it.\n\t\t\t */\n\t\t\tdo_coredump(&ksig->info);\n\t\t}\n\n\t\t/*\n\t\t * Death signals, no core dump.\n\t\t */\n\t\tdo_group_exit(ksig->info.si_signo);\n\t\t/* NOTREACHED */\n\t}\n\tspin_unlock_irq(&sighand->siglock);\n\n\tksig->sig = signr;\n\treturn ksig->sig > 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int print_fatal_signals",
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&sighand->siglock"
          ],
          "line": 2520
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_group_exit",
          "args": [
            "ksig->info.si_signo"
          ],
          "line": 2517
        },
        "resolved": true,
        "details": {
          "function_name": "do_group_exit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "946-972",
          "snippet": "void\ndo_group_exit(int exit_code)\n{\n\tstruct signal_struct *sig = current->signal;\n\n\tBUG_ON(exit_code & 0x80); /* core dumps don't get here */\n\n\tif (signal_group_exit(sig))\n\t\texit_code = sig->group_exit_code;\n\telse if (!thread_group_empty(current)) {\n\t\tstruct sighand_struct *const sighand = current->sighand;\n\n\t\tspin_lock_irq(&sighand->siglock);\n\t\tif (signal_group_exit(sig))\n\t\t\t/* Another thread got here before we took the lock.  */\n\t\t\texit_code = sig->group_exit_code;\n\t\telse {\n\t\t\tsig->group_exit_code = exit_code;\n\t\t\tsig->flags = SIGNAL_GROUP_EXIT;\n\t\t\tzap_other_threads(current);\n\t\t}\n\t\tspin_unlock_irq(&sighand->siglock);\n\t}\n\n\tdo_exit(exit_code);\n\t/* NOTREACHED */\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid\ndo_group_exit(int exit_code)\n{\n\tstruct signal_struct *sig = current->signal;\n\n\tBUG_ON(exit_code & 0x80); /* core dumps don't get here */\n\n\tif (signal_group_exit(sig))\n\t\texit_code = sig->group_exit_code;\n\telse if (!thread_group_empty(current)) {\n\t\tstruct sighand_struct *const sighand = current->sighand;\n\n\t\tspin_lock_irq(&sighand->siglock);\n\t\tif (signal_group_exit(sig))\n\t\t\t/* Another thread got here before we took the lock.  */\n\t\t\texit_code = sig->group_exit_code;\n\t\telse {\n\t\t\tsig->group_exit_code = exit_code;\n\t\t\tsig->flags = SIGNAL_GROUP_EXIT;\n\t\t\tzap_other_threads(current);\n\t\t}\n\t\tspin_unlock_irq(&sighand->siglock);\n\t}\n\n\tdo_exit(exit_code);\n\t/* NOTREACHED */\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_coredump",
          "args": [
            "&ksig->info"
          ],
          "line": 2511
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "proc_coredump_connector",
          "args": [
            "current"
          ],
          "line": 2502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_fatal_signal",
          "args": [
            "ksig->info.si_signo"
          ],
          "line": 2501
        },
        "resolved": true,
        "details": {
          "function_name": "setup_print_fatal_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1190-1195",
          "snippet": "static int __init setup_print_fatal_signals(char *str)\n{\n\tget_option (&str, &print_fatal_signals);\n\n\treturn 1;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int print_fatal_signals"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint print_fatal_signals;\n\nstatic int __init setup_print_fatal_signals(char *str)\n{\n\tget_option (&str, &print_fatal_signals);\n\n\treturn 1;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sig_kernel_coredump",
          "args": [
            "signr"
          ],
          "line": 2499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "do_signal_stop(ksig->info.si_signo)"
          ],
          "line": 2480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_signal_stop",
          "args": [
            "ksig->info.si_signo"
          ],
          "line": 2480
        },
        "resolved": true,
        "details": {
          "function_name": "do_signal_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "2156-2256",
          "snippet": "static bool do_signal_stop(int signr)\n\t__releases(&current->sighand->siglock)\n{\n\tstruct signal_struct *sig = current->signal;\n\n\tif (!(current->jobctl & JOBCTL_STOP_PENDING)) {\n\t\tunsigned long gstop = JOBCTL_STOP_PENDING | JOBCTL_STOP_CONSUME;\n\t\tstruct task_struct *t;\n\n\t\t/* signr will be recorded in task->jobctl for retries */\n\t\tWARN_ON_ONCE(signr & ~JOBCTL_STOP_SIGMASK);\n\n\t\tif (!likely(current->jobctl & JOBCTL_STOP_DEQUEUED) ||\n\t\t    unlikely(signal_group_exit(sig)))\n\t\t\treturn false;\n\t\t/*\n\t\t * There is no group stop already in progress.  We must\n\t\t * initiate one now.\n\t\t *\n\t\t * While ptraced, a task may be resumed while group stop is\n\t\t * still in effect and then receive a stop signal and\n\t\t * initiate another group stop.  This deviates from the\n\t\t * usual behavior as two consecutive stop signals can't\n\t\t * cause two group stops when !ptraced.  That is why we\n\t\t * also check !task_is_stopped(t) below.\n\t\t *\n\t\t * The condition can be distinguished by testing whether\n\t\t * SIGNAL_STOP_STOPPED is already set.  Don't generate\n\t\t * group_exit_code in such case.\n\t\t *\n\t\t * This is not necessary for SIGNAL_STOP_CONTINUED because\n\t\t * an intervening stop signal is required to cause two\n\t\t * continued events regardless of ptrace.\n\t\t */\n\t\tif (!(sig->flags & SIGNAL_STOP_STOPPED))\n\t\t\tsig->group_exit_code = signr;\n\n\t\tsig->group_stop_count = 0;\n\n\t\tif (task_set_jobctl_pending(current, signr | gstop))\n\t\t\tsig->group_stop_count++;\n\n\t\tt = current;\n\t\twhile_each_thread(current, t) {\n\t\t\t/*\n\t\t\t * Setting state to TASK_STOPPED for a group\n\t\t\t * stop is always done with the siglock held,\n\t\t\t * so this check has no races.\n\t\t\t */\n\t\t\tif (!task_is_stopped(t) &&\n\t\t\t    task_set_jobctl_pending(t, signr | gstop)) {\n\t\t\t\tsig->group_stop_count++;\n\t\t\t\tif (likely(!(t->ptrace & PT_SEIZED)))\n\t\t\t\t\tsignal_wake_up(t, 0);\n\t\t\t\telse\n\t\t\t\t\tptrace_trap_notify(t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (likely(!current->ptrace)) {\n\t\tint notify = 0;\n\n\t\t/*\n\t\t * If there are no other threads in the group, or if there\n\t\t * is a group stop in progress and we are the last to stop,\n\t\t * report to the parent.\n\t\t */\n\t\tif (task_participate_group_stop(current))\n\t\t\tnotify = CLD_STOPPED;\n\n\t\tset_special_state(TASK_STOPPED);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\n\t\t/*\n\t\t * Notify the parent of the group stop completion.  Because\n\t\t * we're not holding either the siglock or tasklist_lock\n\t\t * here, ptracer may attach inbetween; however, this is for\n\t\t * group stop and should always be delivered to the real\n\t\t * parent of the group leader.  The new ptracer will get\n\t\t * its notification when this task transitions into\n\t\t * TASK_TRACED.\n\t\t */\n\t\tif (notify) {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tdo_notify_parent_cldstop(current, false, notify);\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\n\t\t/* Now we don't run again until woken by SIGCONT or SIGKILL */\n\t\tfreezable_schedule();\n\t\treturn true;\n\t} else {\n\t\t/*\n\t\t * While ptraced, group stop is handled by STOP trap.\n\t\t * Schedule it and let the caller deal with it.\n\t\t */\n\t\ttask_set_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\t\treturn false;\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool do_signal_stop(int signr)\n\t__releases(&current->sighand->siglock)\n{\n\tstruct signal_struct *sig = current->signal;\n\n\tif (!(current->jobctl & JOBCTL_STOP_PENDING)) {\n\t\tunsigned long gstop = JOBCTL_STOP_PENDING | JOBCTL_STOP_CONSUME;\n\t\tstruct task_struct *t;\n\n\t\t/* signr will be recorded in task->jobctl for retries */\n\t\tWARN_ON_ONCE(signr & ~JOBCTL_STOP_SIGMASK);\n\n\t\tif (!likely(current->jobctl & JOBCTL_STOP_DEQUEUED) ||\n\t\t    unlikely(signal_group_exit(sig)))\n\t\t\treturn false;\n\t\t/*\n\t\t * There is no group stop already in progress.  We must\n\t\t * initiate one now.\n\t\t *\n\t\t * While ptraced, a task may be resumed while group stop is\n\t\t * still in effect and then receive a stop signal and\n\t\t * initiate another group stop.  This deviates from the\n\t\t * usual behavior as two consecutive stop signals can't\n\t\t * cause two group stops when !ptraced.  That is why we\n\t\t * also check !task_is_stopped(t) below.\n\t\t *\n\t\t * The condition can be distinguished by testing whether\n\t\t * SIGNAL_STOP_STOPPED is already set.  Don't generate\n\t\t * group_exit_code in such case.\n\t\t *\n\t\t * This is not necessary for SIGNAL_STOP_CONTINUED because\n\t\t * an intervening stop signal is required to cause two\n\t\t * continued events regardless of ptrace.\n\t\t */\n\t\tif (!(sig->flags & SIGNAL_STOP_STOPPED))\n\t\t\tsig->group_exit_code = signr;\n\n\t\tsig->group_stop_count = 0;\n\n\t\tif (task_set_jobctl_pending(current, signr | gstop))\n\t\t\tsig->group_stop_count++;\n\n\t\tt = current;\n\t\twhile_each_thread(current, t) {\n\t\t\t/*\n\t\t\t * Setting state to TASK_STOPPED for a group\n\t\t\t * stop is always done with the siglock held,\n\t\t\t * so this check has no races.\n\t\t\t */\n\t\t\tif (!task_is_stopped(t) &&\n\t\t\t    task_set_jobctl_pending(t, signr | gstop)) {\n\t\t\t\tsig->group_stop_count++;\n\t\t\t\tif (likely(!(t->ptrace & PT_SEIZED)))\n\t\t\t\t\tsignal_wake_up(t, 0);\n\t\t\t\telse\n\t\t\t\t\tptrace_trap_notify(t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (likely(!current->ptrace)) {\n\t\tint notify = 0;\n\n\t\t/*\n\t\t * If there are no other threads in the group, or if there\n\t\t * is a group stop in progress and we are the last to stop,\n\t\t * report to the parent.\n\t\t */\n\t\tif (task_participate_group_stop(current))\n\t\t\tnotify = CLD_STOPPED;\n\n\t\tset_special_state(TASK_STOPPED);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\n\t\t/*\n\t\t * Notify the parent of the group stop completion.  Because\n\t\t * we're not holding either the siglock or tasklist_lock\n\t\t * here, ptracer may attach inbetween; however, this is for\n\t\t * group stop and should always be delivered to the real\n\t\t * parent of the group leader.  The new ptracer will get\n\t\t * its notification when this task transitions into\n\t\t * TASK_TRACED.\n\t\t */\n\t\tif (notify) {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tdo_notify_parent_cldstop(current, false, notify);\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\n\t\t/* Now we don't run again until woken by SIGCONT or SIGKILL */\n\t\tfreezable_schedule();\n\t\treturn true;\n\t} else {\n\t\t/*\n\t\t * While ptraced, group stop is handled by STOP trap.\n\t\t * Schedule it and let the caller deal with it.\n\t\t */\n\t\ttask_set_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\t\treturn false;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&sighand->siglock"
          ],
          "line": 2477
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_current_pgrp_orphaned",
          "args": [],
          "line": 2474
        },
        "resolved": true,
        "details": {
          "function_name": "is_current_pgrp_orphaned",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "349-358",
          "snippet": "int is_current_pgrp_orphaned(void)\n{\n\tint retval;\n\n\tread_lock(&tasklist_lock);\n\tretval = will_become_orphaned_pgrp(task_pgrp(current), NULL);\n\tread_unlock(&tasklist_lock);\n\n\treturn retval;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nint is_current_pgrp_orphaned(void)\n{\n\tint retval;\n\n\tread_lock(&tasklist_lock);\n\tretval = will_become_orphaned_pgrp(task_pgrp(current), NULL);\n\tread_unlock(&tasklist_lock);\n\n\treturn retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sig_kernel_stop",
          "args": [
            "signr"
          ],
          "line": 2458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sig_kernel_only",
          "args": [
            "signr"
          ],
          "line": 2455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "signal->flags & SIGNAL_UNKILLABLE"
          ],
          "line": 2454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sig_kernel_ignore",
          "args": [
            "signr"
          ],
          "line": 2441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_signal_deliver",
          "args": [
            "signr",
            "&ksig->info",
            "ka"
          ],
          "line": 2424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_signal",
          "args": [
            "signr",
            "&ksig->info"
          ],
          "line": 2416
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "2292-2338",
          "snippet": "static int ptrace_signal(int signr, kernel_siginfo_t *info)\n{\n\t/*\n\t * We do not check sig_kernel_stop(signr) but set this marker\n\t * unconditionally because we do not know whether debugger will\n\t * change signr. This flag has no meaning unless we are going\n\t * to stop after return from ptrace_stop(). In this case it will\n\t * be checked in do_signal_stop(), we should only stop if it was\n\t * not cleared by SIGCONT while we were sleeping. See also the\n\t * comment in dequeue_signal().\n\t */\n\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;\n\tptrace_stop(signr, CLD_TRAPPED, 0, info);\n\n\t/* We're back.  Did the debugger cancel the sig?  */\n\tsignr = current->exit_code;\n\tif (signr == 0)\n\t\treturn signr;\n\n\tcurrent->exit_code = 0;\n\n\t/*\n\t * Update the siginfo structure if the signal has\n\t * changed.  If the debugger wanted something\n\t * specific in the siginfo structure then it should\n\t * have updated *info via PTRACE_SETSIGINFO.\n\t */\n\tif (signr != info->si_signo) {\n\t\tclear_siginfo(info);\n\t\tinfo->si_signo = signr;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\trcu_read_lock();\n\t\tinfo->si_pid = task_pid_vnr(current->parent);\n\t\tinfo->si_uid = from_kuid_munged(current_user_ns(),\n\t\t\t\t\t\ttask_uid(current->parent));\n\t\trcu_read_unlock();\n\t}\n\n\t/* If the (new) signal is now blocked, requeue it.  */\n\tif (sigismember(&current->blocked, signr)) {\n\t\tsend_signal(signr, info, current, PIDTYPE_PID);\n\t\tsignr = 0;\n\t}\n\n\treturn signr;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int ptrace_signal(int signr, kernel_siginfo_t *info)\n{\n\t/*\n\t * We do not check sig_kernel_stop(signr) but set this marker\n\t * unconditionally because we do not know whether debugger will\n\t * change signr. This flag has no meaning unless we are going\n\t * to stop after return from ptrace_stop(). In this case it will\n\t * be checked in do_signal_stop(), we should only stop if it was\n\t * not cleared by SIGCONT while we were sleeping. See also the\n\t * comment in dequeue_signal().\n\t */\n\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;\n\tptrace_stop(signr, CLD_TRAPPED, 0, info);\n\n\t/* We're back.  Did the debugger cancel the sig?  */\n\tsignr = current->exit_code;\n\tif (signr == 0)\n\t\treturn signr;\n\n\tcurrent->exit_code = 0;\n\n\t/*\n\t * Update the siginfo structure if the signal has\n\t * changed.  If the debugger wanted something\n\t * specific in the siginfo structure then it should\n\t * have updated *info via PTRACE_SETSIGINFO.\n\t */\n\tif (signr != info->si_signo) {\n\t\tclear_siginfo(info);\n\t\tinfo->si_signo = signr;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\trcu_read_lock();\n\t\tinfo->si_pid = task_pid_vnr(current->parent);\n\t\tinfo->si_uid = from_kuid_munged(current_user_ns(),\n\t\t\t\t\t\ttask_uid(current->parent));\n\t\trcu_read_unlock();\n\t}\n\n\t/* If the (new) signal is now blocked, requeue it.  */\n\tif (sigismember(&current->blocked, signr)) {\n\t\tsend_signal(signr, info, current, PIDTYPE_PID);\n\t\tsignr = 0;\n\t}\n\n\treturn signr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->ptrace"
          ],
          "line": 2415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "dequeue_signal",
          "args": [
            "current",
            "&current->blocked",
            "&ksig->info"
          ],
          "line": 2410
        },
        "resolved": true,
        "details": {
          "function_name": "dequeue_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "613-688",
          "snippet": "int dequeue_signal(struct task_struct *tsk, sigset_t *mask, kernel_siginfo_t *info)\n{\n\tbool resched_timer = false;\n\tint signr;\n\n\t/* We only dequeue private signals from ourselves, we don't let\n\t * signalfd steal them\n\t */\n\tsignr = __dequeue_signal(&tsk->pending, mask, info, &resched_timer);\n\tif (!signr) {\n\t\tsignr = __dequeue_signal(&tsk->signal->shared_pending,\n\t\t\t\t\t mask, info, &resched_timer);\n#ifdef CONFIG_POSIX_TIMERS\n\t\t/*\n\t\t * itimer signal ?\n\t\t *\n\t\t * itimers are process shared and we restart periodic\n\t\t * itimers in the signal delivery path to prevent DoS\n\t\t * attacks in the high resolution timer case. This is\n\t\t * compliant with the old way of self-restarting\n\t\t * itimers, as the SIGALRM is a legacy signal and only\n\t\t * queued once. Changing the restart behaviour to\n\t\t * restart the timer in the signal dequeue path is\n\t\t * reducing the timer noise on heavy loaded !highres\n\t\t * systems too.\n\t\t */\n\t\tif (unlikely(signr == SIGALRM)) {\n\t\t\tstruct hrtimer *tmr = &tsk->signal->real_timer;\n\n\t\t\tif (!hrtimer_is_queued(tmr) &&\n\t\t\t    tsk->signal->it_real_incr != 0) {\n\t\t\t\thrtimer_forward(tmr, tmr->base->get_time(),\n\t\t\t\t\t\ttsk->signal->it_real_incr);\n\t\t\t\thrtimer_restart(tmr);\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\trecalc_sigpending();\n\tif (!signr)\n\t\treturn 0;\n\n\tif (unlikely(sig_kernel_stop(signr))) {\n\t\t/*\n\t\t * Set a marker that we have dequeued a stop signal.  Our\n\t\t * caller might release the siglock and then the pending\n\t\t * stop signal it is about to process is no longer in the\n\t\t * pending bitmasks, but must still be cleared by a SIGCONT\n\t\t * (and overruled by a SIGKILL).  So those cases clear this\n\t\t * shared flag after we've set it.  Note that this flag may\n\t\t * remain set after the signal we return is ignored or\n\t\t * handled.  That doesn't matter because its only purpose\n\t\t * is to alert stop-signal processing code when another\n\t\t * processor has come along and cleared the flag.\n\t\t */\n\t\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;\n\t}\n#ifdef CONFIG_POSIX_TIMERS\n\tif (resched_timer) {\n\t\t/*\n\t\t * Release the siglock to ensure proper locking order\n\t\t * of timer locks outside of siglocks.  Note, we leave\n\t\t * irqs disabled here, since the posix-timers code is\n\t\t * about to disable them again anyway.\n\t\t */\n\t\tspin_unlock(&tsk->sighand->siglock);\n\t\tposixtimer_rearm(info);\n\t\tspin_lock(&tsk->sighand->siglock);\n\n\t\t/* Don't expose the si_sys_private value to userspace */\n\t\tinfo->si_sys_private = 0;\n\t}\n#endif\n\treturn signr;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint dequeue_signal(struct task_struct *tsk, sigset_t *mask, kernel_siginfo_t *info)\n{\n\tbool resched_timer = false;\n\tint signr;\n\n\t/* We only dequeue private signals from ourselves, we don't let\n\t * signalfd steal them\n\t */\n\tsignr = __dequeue_signal(&tsk->pending, mask, info, &resched_timer);\n\tif (!signr) {\n\t\tsignr = __dequeue_signal(&tsk->signal->shared_pending,\n\t\t\t\t\t mask, info, &resched_timer);\n#ifdef CONFIG_POSIX_TIMERS\n\t\t/*\n\t\t * itimer signal ?\n\t\t *\n\t\t * itimers are process shared and we restart periodic\n\t\t * itimers in the signal delivery path to prevent DoS\n\t\t * attacks in the high resolution timer case. This is\n\t\t * compliant with the old way of self-restarting\n\t\t * itimers, as the SIGALRM is a legacy signal and only\n\t\t * queued once. Changing the restart behaviour to\n\t\t * restart the timer in the signal dequeue path is\n\t\t * reducing the timer noise on heavy loaded !highres\n\t\t * systems too.\n\t\t */\n\t\tif (unlikely(signr == SIGALRM)) {\n\t\t\tstruct hrtimer *tmr = &tsk->signal->real_timer;\n\n\t\t\tif (!hrtimer_is_queued(tmr) &&\n\t\t\t    tsk->signal->it_real_incr != 0) {\n\t\t\t\thrtimer_forward(tmr, tmr->base->get_time(),\n\t\t\t\t\t\ttsk->signal->it_real_incr);\n\t\t\t\thrtimer_restart(tmr);\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\trecalc_sigpending();\n\tif (!signr)\n\t\treturn 0;\n\n\tif (unlikely(sig_kernel_stop(signr))) {\n\t\t/*\n\t\t * Set a marker that we have dequeued a stop signal.  Our\n\t\t * caller might release the siglock and then the pending\n\t\t * stop signal it is about to process is no longer in the\n\t\t * pending bitmasks, but must still be cleared by a SIGCONT\n\t\t * (and overruled by a SIGKILL).  So those cases clear this\n\t\t * shared flag after we've set it.  Note that this flag may\n\t\t * remain set after the signal we return is ignored or\n\t\t * handled.  That doesn't matter because its only purpose\n\t\t * is to alert stop-signal processing code when another\n\t\t * processor has come along and cleared the flag.\n\t\t */\n\t\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;\n\t}\n#ifdef CONFIG_POSIX_TIMERS\n\tif (resched_timer) {\n\t\t/*\n\t\t * Release the siglock to ensure proper locking order\n\t\t * of timer locks outside of siglocks.  Note, we leave\n\t\t * irqs disabled here, since the posix-timers code is\n\t\t * about to disable them again anyway.\n\t\t */\n\t\tspin_unlock(&tsk->sighand->siglock);\n\t\tposixtimer_rearm(info);\n\t\tspin_lock(&tsk->sighand->siglock);\n\n\t\t/* Don't expose the si_sys_private value to userspace */\n\t\tinfo->si_sys_private = 0;\n\t}\n#endif\n\treturn signr;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_jobctl_trap",
          "args": [],
          "line": 2405
        },
        "resolved": true,
        "details": {
          "function_name": "do_jobctl_trap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "2273-2290",
          "snippet": "static void do_jobctl_trap(void)\n{\n\tstruct signal_struct *signal = current->signal;\n\tint signr = current->jobctl & JOBCTL_STOP_SIGMASK;\n\n\tif (current->ptrace & PT_SEIZED) {\n\t\tif (!signal->group_stop_count &&\n\t\t    !(signal->flags & SIGNAL_STOP_STOPPED))\n\t\t\tsignr = SIGTRAP;\n\t\tWARN_ON_ONCE(!signr);\n\t\tptrace_do_notify(signr, signr | (PTRACE_EVENT_STOP << 8),\n\t\t\t\t CLD_STOPPED);\n\t} else {\n\t\tWARN_ON_ONCE(!signr);\n\t\tptrace_stop(signr, CLD_STOPPED, 0, NULL);\n\t\tcurrent->exit_code = 0;\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void do_jobctl_trap(void)\n{\n\tstruct signal_struct *signal = current->signal;\n\tint signr = current->jobctl & JOBCTL_STOP_SIGMASK;\n\n\tif (current->ptrace & PT_SEIZED) {\n\t\tif (!signal->group_stop_count &&\n\t\t    !(signal->flags & SIGNAL_STOP_STOPPED))\n\t\t\tsignr = SIGTRAP;\n\t\tWARN_ON_ONCE(!signr);\n\t\tptrace_do_notify(signr, signr | (PTRACE_EVENT_STOP << 8),\n\t\t\t\t CLD_STOPPED);\n\t} else {\n\t\tWARN_ON_ONCE(!signr);\n\t\tptrace_stop(signr, CLD_STOPPED, 0, NULL);\n\t\tcurrent->exit_code = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->jobctl & JOBCTL_TRAP_MASK"
          ],
          "line": 2404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->jobctl & JOBCTL_STOP_PENDING"
          ],
          "line": 2400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 2392
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_notify_parent_cldstop",
          "args": [
            "current->group_leader",
            "true",
            "why"
          ],
          "line": 2390
        },
        "resolved": true,
        "details": {
          "function_name": "do_notify_parent_cldstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1871-1927",
          "snippet": "static void do_notify_parent_cldstop(struct task_struct *tsk,\n\t\t\t\t     bool for_ptracer, int why)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\tu64 utime, stime;\n\n\tif (for_ptracer) {\n\t\tparent = tsk->parent;\n\t} else {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\t/*\n\t * see comment in do_notify_parent() about the following 4 lines\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime);\n\tinfo.si_stime = nsec_to_clock_t(stime);\n\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t/*\n\t * Even if SIGCHLD is not generated, we must wake up wait4 calls.\n\t */\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic void do_notify_parent_cldstop(struct task_struct *tsk,\n\t\t\t\t     bool for_ptracer, int why)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\tu64 utime, stime;\n\n\tif (for_ptracer) {\n\t\tparent = tsk->parent;\n\t} else {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\t/*\n\t * see comment in do_notify_parent() about the following 4 lines\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime);\n\tinfo.si_stime = nsec_to_clock_t(stime);\n\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t/*\n\t * Even if SIGCHLD is not generated, we must wake up wait4 calls.\n\t */\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_reparented",
          "args": [
            "current->group_leader"
          ],
          "line": 2389
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 2386
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "signal->flags & SIGNAL_CLD_MASK"
          ],
          "line": 2366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_to_freeze",
          "args": [],
          "line": 2357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "uprobe_deny_signal()"
          ],
          "line": 2349
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uprobe_deny_signal",
          "args": [],
          "line": 2349
        },
        "resolved": true,
        "details": {
          "function_name": "uprobe_deny_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/uprobes.c",
          "lines": "1925-1947",
          "snippet": "bool uprobe_deny_signal(void)\n{\n\tstruct task_struct *t = current;\n\tstruct uprobe_task *utask = t->utask;\n\n\tif (likely(!utask || !utask->active_uprobe))\n\t\treturn false;\n\n\tWARN_ON_ONCE(utask->state != UTASK_SSTEP);\n\n\tif (signal_pending(t)) {\n\t\tspin_lock_irq(&t->sighand->siglock);\n\t\tclear_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\tspin_unlock_irq(&t->sighand->siglock);\n\n\t\tif (__fatal_signal_pending(t) || arch_uprobe_xol_was_trapped(t)) {\n\t\t\tutask->state = UTASK_SSTEP_TRAPPED;\n\t\t\tset_tsk_thread_flag(t, TIF_UPROBE);\n\t\t}\n\t}\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/uprobes.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/task_work.h>",
            "#include <linux/percpu-rwsem.h>",
            "#include \"../../mm/internal.h\"\t/* munlock_vma_page */",
            "#include <linux/kdebug.h>\t/* notifier mechanism */",
            "#include <linux/ptrace.h>\t/* user_enable_single_step */",
            "#include <linux/swap.h>\t\t/* try_to_free_swap */",
            "#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */",
            "#include <linux/rmap.h>\t\t/* anon_vma_prepare */",
            "#include <linux/export.h>",
            "#include <linux/sched/coredump.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched.h>",
            "#include <linux/slab.h>",
            "#include <linux/pagemap.h>\t/* read_mapping_page */",
            "#include <linux/highmem.h>",
            "#include <linux/kernel.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uprobes.h>\n#include <linux/shmem_fs.h>\n#include <linux/task_work.h>\n#include <linux/percpu-rwsem.h>\n#include \"../../mm/internal.h\"\t/* munlock_vma_page */\n#include <linux/kdebug.h>\t/* notifier mechanism */\n#include <linux/ptrace.h>\t/* user_enable_single_step */\n#include <linux/swap.h>\t\t/* try_to_free_swap */\n#include <linux/mmu_notifier.h>\t/* set_pte_at_notify */\n#include <linux/rmap.h>\t\t/* anon_vma_prepare */\n#include <linux/export.h>\n#include <linux/sched/coredump.h>\n#include <linux/sched/mm.h>\n#include <linux/sched.h>\n#include <linux/slab.h>\n#include <linux/pagemap.h>\t/* read_mapping_page */\n#include <linux/highmem.h>\n#include <linux/kernel.h>\n\nbool uprobe_deny_signal(void)\n{\n\tstruct task_struct *t = current;\n\tstruct uprobe_task *utask = t->utask;\n\n\tif (likely(!utask || !utask->active_uprobe))\n\t\treturn false;\n\n\tWARN_ON_ONCE(utask->state != UTASK_SSTEP);\n\n\tif (signal_pending(t)) {\n\t\tspin_lock_irq(&t->sighand->siglock);\n\t\tclear_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\tspin_unlock_irq(&t->sighand->siglock);\n\n\t\tif (__fatal_signal_pending(t) || arch_uprobe_xol_was_trapped(t)) {\n\t\t\tutask->state = UTASK_SSTEP_TRAPPED;\n\t\t\tset_tsk_thread_flag(t, TIF_UPROBE);\n\t\t}\n\t}\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_work_run",
          "args": [],
          "line": 2347
        },
        "resolved": true,
        "details": {
          "function_name": "task_work_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/task_work.c",
          "lines": "90-118",
          "snippet": "void task_work_run(void)\n{\n\tstruct task_struct *task = current;\n\tstruct callback_head *work, *head, *next;\n\n\tfor (;;) {\n\t\t/*\n\t\t * work->func() can do task_work_add(), do not set\n\t\t * work_exited unless the list is empty.\n\t\t */\n\t\traw_spin_lock_irq(&task->pi_lock);\n\t\tdo {\n\t\t\twork = READ_ONCE(task->task_works);\n\t\t\thead = !work && (task->flags & PF_EXITING) ?\n\t\t\t\t&work_exited : NULL;\n\t\t} while (cmpxchg(&task->task_works, work, head) != work);\n\t\traw_spin_unlock_irq(&task->pi_lock);\n\n\t\tif (!work)\n\t\t\tbreak;\n\n\t\tdo {\n\t\t\tnext = work->next;\n\t\t\twork->func(work);\n\t\t\twork = next;\n\t\t\tcond_resched();\n\t\t} while (work);\n\t}\n}",
          "includes": [
            "#include <linux/tracehook.h>",
            "#include <linux/task_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct callback_head work_exited;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracehook.h>\n#include <linux/task_work.h>\n#include <linux/spinlock.h>\n\nstatic struct callback_head work_exited;\n\nvoid task_work_run(void)\n{\n\tstruct task_struct *task = current;\n\tstruct callback_head *work, *head, *next;\n\n\tfor (;;) {\n\t\t/*\n\t\t * work->func() can do task_work_add(), do not set\n\t\t * work_exited unless the list is empty.\n\t\t */\n\t\traw_spin_lock_irq(&task->pi_lock);\n\t\tdo {\n\t\t\twork = READ_ONCE(task->task_works);\n\t\t\thead = !work && (task->flags & PF_EXITING) ?\n\t\t\t\t&work_exited : NULL;\n\t\t} while (cmpxchg(&task->task_works, work, head) != work);\n\t\traw_spin_unlock_irq(&task->pi_lock);\n\n\t\tif (!work)\n\t\t\tbreak;\n\n\t\tdo {\n\t\t\tnext = work->next;\n\t\t\twork->func(work);\n\t\t\twork = next;\n\t\t\tcond_resched();\n\t\t} while (work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->task_works"
          ],
          "line": 2346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint print_fatal_signals;\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nbool get_signal(struct ksignal *ksig)\n{\n\tstruct sighand_struct *sighand = current->sighand;\n\tstruct signal_struct *signal = current->signal;\n\tint signr;\n\n\tif (unlikely(current->task_works))\n\t\ttask_work_run();\n\n\tif (unlikely(uprobe_deny_signal()))\n\t\treturn false;\n\n\t/*\n\t * Do this once, we can't return to user-mode if freezing() == T.\n\t * do_signal_stop() and ptrace_stop() do freezable_schedule() and\n\t * thus do not need another check after return.\n\t */\n\ttry_to_freeze();\n\nrelock:\n\tspin_lock_irq(&sighand->siglock);\n\t/*\n\t * Every stopped thread goes here after wakeup. Check to see if\n\t * we should notify the parent, prepare_signal(SIGCONT) encodes\n\t * the CLD_ si_code into SIGNAL_CLD_MASK bits.\n\t */\n\tif (unlikely(signal->flags & SIGNAL_CLD_MASK)) {\n\t\tint why;\n\n\t\tif (signal->flags & SIGNAL_CLD_CONTINUED)\n\t\t\twhy = CLD_CONTINUED;\n\t\telse\n\t\t\twhy = CLD_STOPPED;\n\n\t\tsignal->flags &= ~SIGNAL_CLD_MASK;\n\n\t\tspin_unlock_irq(&sighand->siglock);\n\n\t\t/*\n\t\t * Notify the parent that we're continuing.  This event is\n\t\t * always per-process and doesn't make whole lot of sense\n\t\t * for ptracers, who shouldn't consume the state via\n\t\t * wait(2) either, but, for backward compatibility, notify\n\t\t * the ptracer of the group leader too unless it's gonna be\n\t\t * a duplicate.\n\t\t */\n\t\tread_lock(&tasklist_lock);\n\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\tif (ptrace_reparented(current->group_leader))\n\t\t\tdo_notify_parent_cldstop(current->group_leader,\n\t\t\t\t\t\ttrue, why);\n\t\tread_unlock(&tasklist_lock);\n\n\t\tgoto relock;\n\t}\n\n\tfor (;;) {\n\t\tstruct k_sigaction *ka;\n\n\t\tif (unlikely(current->jobctl & JOBCTL_STOP_PENDING) &&\n\t\t    do_signal_stop(0))\n\t\t\tgoto relock;\n\n\t\tif (unlikely(current->jobctl & JOBCTL_TRAP_MASK)) {\n\t\t\tdo_jobctl_trap();\n\t\t\tspin_unlock_irq(&sighand->siglock);\n\t\t\tgoto relock;\n\t\t}\n\n\t\tsignr = dequeue_signal(current, &current->blocked, &ksig->info);\n\n\t\tif (!signr)\n\t\t\tbreak; /* will return 0 */\n\n\t\tif (unlikely(current->ptrace) && signr != SIGKILL) {\n\t\t\tsignr = ptrace_signal(signr, &ksig->info);\n\t\t\tif (!signr)\n\t\t\t\tcontinue;\n\t\t}\n\n\t\tka = &sighand->action[signr-1];\n\n\t\t/* Trace actually delivered signals. */\n\t\ttrace_signal_deliver(signr, &ksig->info, ka);\n\n\t\tif (ka->sa.sa_handler == SIG_IGN) /* Do nothing.  */\n\t\t\tcontinue;\n\t\tif (ka->sa.sa_handler != SIG_DFL) {\n\t\t\t/* Run the handler.  */\n\t\t\tksig->ka = *ka;\n\n\t\t\tif (ka->sa.sa_flags & SA_ONESHOT)\n\t\t\t\tka->sa.sa_handler = SIG_DFL;\n\n\t\t\tbreak; /* will return non-zero \"signr\" value */\n\t\t}\n\n\t\t/*\n\t\t * Now we are doing the default action for this signal.\n\t\t */\n\t\tif (sig_kernel_ignore(signr)) /* Default is nothing. */\n\t\t\tcontinue;\n\n\t\t/*\n\t\t * Global init gets no signals it doesn't want.\n\t\t * Container-init gets no signals it doesn't want from same\n\t\t * container.\n\t\t *\n\t\t * Note that if global/container-init sees a sig_kernel_only()\n\t\t * signal here, the signal must have been generated internally\n\t\t * or must have come from an ancestor namespace. In either\n\t\t * case, the signal cannot be dropped.\n\t\t */\n\t\tif (unlikely(signal->flags & SIGNAL_UNKILLABLE) &&\n\t\t\t\t!sig_kernel_only(signr))\n\t\t\tcontinue;\n\n\t\tif (sig_kernel_stop(signr)) {\n\t\t\t/*\n\t\t\t * The default action is to stop all threads in\n\t\t\t * the thread group.  The job control signals\n\t\t\t * do nothing in an orphaned pgrp, but SIGSTOP\n\t\t\t * always works.  Note that siglock needs to be\n\t\t\t * dropped during the call to is_orphaned_pgrp()\n\t\t\t * because of lock ordering with tasklist_lock.\n\t\t\t * This allows an intervening SIGCONT to be posted.\n\t\t\t * We need to check for that and bail out if necessary.\n\t\t\t */\n\t\t\tif (signr != SIGSTOP) {\n\t\t\t\tspin_unlock_irq(&sighand->siglock);\n\n\t\t\t\t/* signals can be posted during this window */\n\n\t\t\t\tif (is_current_pgrp_orphaned())\n\t\t\t\t\tgoto relock;\n\n\t\t\t\tspin_lock_irq(&sighand->siglock);\n\t\t\t}\n\n\t\t\tif (likely(do_signal_stop(ksig->info.si_signo))) {\n\t\t\t\t/* It released the siglock.  */\n\t\t\t\tgoto relock;\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * We didn't actually stop, due to a race\n\t\t\t * with SIGCONT or something like that.\n\t\t\t */\n\t\t\tcontinue;\n\t\t}\n\n\t\tspin_unlock_irq(&sighand->siglock);\n\n\t\t/*\n\t\t * Anything else is fatal, maybe with a core dump.\n\t\t */\n\t\tcurrent->flags |= PF_SIGNALED;\n\n\t\tif (sig_kernel_coredump(signr)) {\n\t\t\tif (print_fatal_signals)\n\t\t\t\tprint_fatal_signal(ksig->info.si_signo);\n\t\t\tproc_coredump_connector(current);\n\t\t\t/*\n\t\t\t * If it was able to dump core, this kills all\n\t\t\t * other threads in the group and synchronizes with\n\t\t\t * their demise.  If we lost the race with another\n\t\t\t * thread getting here, it set group_exit_code\n\t\t\t * first and our do_group_exit call below will use\n\t\t\t * that value and ignore the one we pass it.\n\t\t\t */\n\t\t\tdo_coredump(&ksig->info);\n\t\t}\n\n\t\t/*\n\t\t * Death signals, no core dump.\n\t\t */\n\t\tdo_group_exit(ksig->info.si_signo);\n\t\t/* NOTREACHED */\n\t}\n\tspin_unlock_irq(&sighand->siglock);\n\n\tksig->sig = signr;\n\treturn ksig->sig > 0;\n}"
  },
  {
    "function_name": "ptrace_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2292-2338",
    "snippet": "static int ptrace_signal(int signr, kernel_siginfo_t *info)\n{\n\t/*\n\t * We do not check sig_kernel_stop(signr) but set this marker\n\t * unconditionally because we do not know whether debugger will\n\t * change signr. This flag has no meaning unless we are going\n\t * to stop after return from ptrace_stop(). In this case it will\n\t * be checked in do_signal_stop(), we should only stop if it was\n\t * not cleared by SIGCONT while we were sleeping. See also the\n\t * comment in dequeue_signal().\n\t */\n\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;\n\tptrace_stop(signr, CLD_TRAPPED, 0, info);\n\n\t/* We're back.  Did the debugger cancel the sig?  */\n\tsignr = current->exit_code;\n\tif (signr == 0)\n\t\treturn signr;\n\n\tcurrent->exit_code = 0;\n\n\t/*\n\t * Update the siginfo structure if the signal has\n\t * changed.  If the debugger wanted something\n\t * specific in the siginfo structure then it should\n\t * have updated *info via PTRACE_SETSIGINFO.\n\t */\n\tif (signr != info->si_signo) {\n\t\tclear_siginfo(info);\n\t\tinfo->si_signo = signr;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\trcu_read_lock();\n\t\tinfo->si_pid = task_pid_vnr(current->parent);\n\t\tinfo->si_uid = from_kuid_munged(current_user_ns(),\n\t\t\t\t\t\ttask_uid(current->parent));\n\t\trcu_read_unlock();\n\t}\n\n\t/* If the (new) signal is now blocked, requeue it.  */\n\tif (sigismember(&current->blocked, signr)) {\n\t\tsend_signal(signr, info, current, PIDTYPE_PID);\n\t\tsignr = 0;\n\t}\n\n\treturn signr;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_signal",
          "args": [
            "signr",
            "info",
            "current",
            "PIDTYPE_PID"
          ],
          "line": 2333
        },
        "resolved": true,
        "details": {
          "function_name": "send_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1153-1164",
          "snippet": "static int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\tint from_ancestor_ns = 0;\n\n#ifdef CONFIG_PID_NS\n\tfrom_ancestor_ns = si_fromuser(info) &&\n\t\t\t   !task_pid_nr_ns(current, task_active_pid_ns(t));\n#endif\n\n\treturn __send_signal(sig, info, t, type, from_ancestor_ns);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\tint from_ancestor_ns = 0;\n\n#ifdef CONFIG_PID_NS\n\tfrom_ancestor_ns = si_fromuser(info) &&\n\t\t\t   !task_pid_nr_ns(current, task_active_pid_ns(t));\n#endif\n\n\treturn __send_signal(sig, info, t, type, from_ancestor_ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigismember",
          "args": [
            "&current->blocked",
            "signr"
          ],
          "line": 2332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 2328
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "task_uid(current->parent)"
          ],
          "line": 2326
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_uid",
          "args": [
            "current->parent"
          ],
          "line": 2327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 2326
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "current->parent"
          ],
          "line": 2325
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 2324
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "info"
          ],
          "line": 2320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_stop",
          "args": [
            "signr",
            "CLD_TRAPPED",
            "0",
            "info"
          ],
          "line": 2304
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1974-2107",
          "snippet": "static void ptrace_stop(int exit_code, int why, int clear_code, kernel_siginfo_t *info)\n\t__releases(&current->sighand->siglock)\n\t__acquires(&current->sighand->siglock)\n{\n\tbool gstop_done = false;\n\n\tif (arch_ptrace_stop_needed(exit_code, info)) {\n\t\t/*\n\t\t * The arch code has something special to do before a\n\t\t * ptrace stop.  This is allowed to block, e.g. for faults\n\t\t * on user stack pages.  We can't keep the siglock while\n\t\t * calling arch_ptrace_stop, so we must release it now.\n\t\t * To preserve proper semantics, we must do this before\n\t\t * any signal bookkeeping like checking group_stop_count.\n\t\t * Meanwhile, a SIGKILL could come in before we retake the\n\t\t * siglock.  That must prevent us from sleeping in TASK_TRACED.\n\t\t * So after regaining the lock, we must check for SIGKILL.\n\t\t */\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop(exit_code, info);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tif (sigkill_pending(current))\n\t\t\treturn;\n\t}\n\n\tset_special_state(TASK_TRACED);\n\n\t/*\n\t * We're committing to trapping.  TRACED should be visible before\n\t * TRAPPING is cleared; otherwise, the tracer might fail do_wait().\n\t * Also, transition to TRACED and updates to ->jobctl should be\n\t * atomic with respect to siglock and should be done after the arch\n\t * hook as siglock is released and regrabbed across it.\n\t *\n\t *     TRACER\t\t\t\t    TRACEE\n\t *\n\t *     ptrace_attach()\n\t * [L]   wait_on_bit(JOBCTL_TRAPPING)\t[S] set_special_state(TRACED)\n\t *     do_wait()\n\t *       set_current_state()                smp_wmb();\n\t *       ptrace_do_wait()\n\t *         wait_task_stopped()\n\t *           task_stopped_code()\n\t * [L]         task_is_traced()\t\t[S] task_clear_jobctl_trapping();\n\t */\n\tsmp_wmb();\n\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\n\t/*\n\t * If @why is CLD_STOPPED, we're trapping to participate in a group\n\t * stop.  Do the bookkeeping.  Note that if SIGCONT was delievered\n\t * across siglock relocks since INTERRUPT was scheduled, PENDING\n\t * could be clear now.  We act as if SIGCONT is received after\n\t * TASK_TRACED is entered - ignore it.\n\t */\n\tif (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))\n\t\tgstop_done = task_participate_group_stop(current);\n\n\t/* any trap clears pending STOP trap, STOP trap clears NOTIFY */\n\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\tif (info && info->si_code >> 8 == PTRACE_EVENT_STOP)\n\t\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY);\n\n\t/* entering a trap, clear TRAPPING */\n\ttask_clear_jobctl_trapping(current);\n\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (may_ptrace_stop()) {\n\t\t/*\n\t\t * Notify parents of the stop.\n\t\t *\n\t\t * While ptraced, there are two parents - the ptracer and\n\t\t * the real_parent of the group_leader.  The ptracer should\n\t\t * know about every stop while the real parent is only\n\t\t * interested in the completion of group stop.  The states\n\t\t * for the two don't interact with each other.  Notify\n\t\t * separately unless they're gonna be duplicates.\n\t\t */\n\t\tdo_notify_parent_cldstop(current, true, why);\n\t\tif (gstop_done && ptrace_reparented(current))\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/*\n\t\t * Don't want to allow preemption here, because\n\t\t * sys_ptrace() needs this task to be inactive.\n\t\t *\n\t\t * XXX: implement read_unlock_no_resched().\n\t\t */\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tpreempt_enable_no_resched();\n\t\tfreezable_schedule();\n\t} else {\n\t\t/*\n\t\t * By the time we got the lock, our tracer went away.\n\t\t * Don't drop the lock yet, another tracer may come.\n\t\t *\n\t\t * If @gstop_done, the ptracer went away between group stop\n\t\t * completion and here.  During detach, it would have set\n\t\t * JOBCTL_STOP_PENDING on us and we'll re-enter\n\t\t * TASK_STOPPED in do_signal_stop() on return, so notifying\n\t\t * the real parent of the group stop completion is enough.\n\t\t */\n\t\tif (gstop_done)\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/* tasklist protects us from ptrace_freeze_traced() */\n\t\t__set_current_state(TASK_RUNNING);\n\t\tif (clear_code)\n\t\t\tcurrent->exit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * We are back.  Now reacquire the siglock before touching\n\t * last_siginfo, so that we are sure to have synchronized with\n\t * any signal-sending on another CPU that wants to examine it.\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->last_siginfo = NULL;\n\n\t/* LISTENING can be set only during STOP traps, clear it */\n\tcurrent->jobctl &= ~JOBCTL_LISTENING;\n\n\t/*\n\t * Queued signals ignored us while we were stopped for tracing.\n\t * So check for any that we should take before resuming user mode.\n\t * This sets TIF_SIGPENDING, but never clears it.\n\t */\n\trecalc_sigpending_tsk(current);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic void ptrace_stop(int exit_code, int why, int clear_code, kernel_siginfo_t *info)\n\t__releases(&current->sighand->siglock)\n\t__acquires(&current->sighand->siglock)\n{\n\tbool gstop_done = false;\n\n\tif (arch_ptrace_stop_needed(exit_code, info)) {\n\t\t/*\n\t\t * The arch code has something special to do before a\n\t\t * ptrace stop.  This is allowed to block, e.g. for faults\n\t\t * on user stack pages.  We can't keep the siglock while\n\t\t * calling arch_ptrace_stop, so we must release it now.\n\t\t * To preserve proper semantics, we must do this before\n\t\t * any signal bookkeeping like checking group_stop_count.\n\t\t * Meanwhile, a SIGKILL could come in before we retake the\n\t\t * siglock.  That must prevent us from sleeping in TASK_TRACED.\n\t\t * So after regaining the lock, we must check for SIGKILL.\n\t\t */\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop(exit_code, info);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tif (sigkill_pending(current))\n\t\t\treturn;\n\t}\n\n\tset_special_state(TASK_TRACED);\n\n\t/*\n\t * We're committing to trapping.  TRACED should be visible before\n\t * TRAPPING is cleared; otherwise, the tracer might fail do_wait().\n\t * Also, transition to TRACED and updates to ->jobctl should be\n\t * atomic with respect to siglock and should be done after the arch\n\t * hook as siglock is released and regrabbed across it.\n\t *\n\t *     TRACER\t\t\t\t    TRACEE\n\t *\n\t *     ptrace_attach()\n\t * [L]   wait_on_bit(JOBCTL_TRAPPING)\t[S] set_special_state(TRACED)\n\t *     do_wait()\n\t *       set_current_state()                smp_wmb();\n\t *       ptrace_do_wait()\n\t *         wait_task_stopped()\n\t *           task_stopped_code()\n\t * [L]         task_is_traced()\t\t[S] task_clear_jobctl_trapping();\n\t */\n\tsmp_wmb();\n\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\n\t/*\n\t * If @why is CLD_STOPPED, we're trapping to participate in a group\n\t * stop.  Do the bookkeeping.  Note that if SIGCONT was delievered\n\t * across siglock relocks since INTERRUPT was scheduled, PENDING\n\t * could be clear now.  We act as if SIGCONT is received after\n\t * TASK_TRACED is entered - ignore it.\n\t */\n\tif (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))\n\t\tgstop_done = task_participate_group_stop(current);\n\n\t/* any trap clears pending STOP trap, STOP trap clears NOTIFY */\n\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\tif (info && info->si_code >> 8 == PTRACE_EVENT_STOP)\n\t\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY);\n\n\t/* entering a trap, clear TRAPPING */\n\ttask_clear_jobctl_trapping(current);\n\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (may_ptrace_stop()) {\n\t\t/*\n\t\t * Notify parents of the stop.\n\t\t *\n\t\t * While ptraced, there are two parents - the ptracer and\n\t\t * the real_parent of the group_leader.  The ptracer should\n\t\t * know about every stop while the real parent is only\n\t\t * interested in the completion of group stop.  The states\n\t\t * for the two don't interact with each other.  Notify\n\t\t * separately unless they're gonna be duplicates.\n\t\t */\n\t\tdo_notify_parent_cldstop(current, true, why);\n\t\tif (gstop_done && ptrace_reparented(current))\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/*\n\t\t * Don't want to allow preemption here, because\n\t\t * sys_ptrace() needs this task to be inactive.\n\t\t *\n\t\t * XXX: implement read_unlock_no_resched().\n\t\t */\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tpreempt_enable_no_resched();\n\t\tfreezable_schedule();\n\t} else {\n\t\t/*\n\t\t * By the time we got the lock, our tracer went away.\n\t\t * Don't drop the lock yet, another tracer may come.\n\t\t *\n\t\t * If @gstop_done, the ptracer went away between group stop\n\t\t * completion and here.  During detach, it would have set\n\t\t * JOBCTL_STOP_PENDING on us and we'll re-enter\n\t\t * TASK_STOPPED in do_signal_stop() on return, so notifying\n\t\t * the real parent of the group stop completion is enough.\n\t\t */\n\t\tif (gstop_done)\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/* tasklist protects us from ptrace_freeze_traced() */\n\t\t__set_current_state(TASK_RUNNING);\n\t\tif (clear_code)\n\t\t\tcurrent->exit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * We are back.  Now reacquire the siglock before touching\n\t * last_siginfo, so that we are sure to have synchronized with\n\t * any signal-sending on another CPU that wants to examine it.\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->last_siginfo = NULL;\n\n\t/* LISTENING can be set only during STOP traps, clear it */\n\tcurrent->jobctl &= ~JOBCTL_LISTENING;\n\n\t/*\n\t * Queued signals ignored us while we were stopped for tracing.\n\t * So check for any that we should take before resuming user mode.\n\t * This sets TIF_SIGPENDING, but never clears it.\n\t */\n\trecalc_sigpending_tsk(current);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int ptrace_signal(int signr, kernel_siginfo_t *info)\n{\n\t/*\n\t * We do not check sig_kernel_stop(signr) but set this marker\n\t * unconditionally because we do not know whether debugger will\n\t * change signr. This flag has no meaning unless we are going\n\t * to stop after return from ptrace_stop(). In this case it will\n\t * be checked in do_signal_stop(), we should only stop if it was\n\t * not cleared by SIGCONT while we were sleeping. See also the\n\t * comment in dequeue_signal().\n\t */\n\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;\n\tptrace_stop(signr, CLD_TRAPPED, 0, info);\n\n\t/* We're back.  Did the debugger cancel the sig?  */\n\tsignr = current->exit_code;\n\tif (signr == 0)\n\t\treturn signr;\n\n\tcurrent->exit_code = 0;\n\n\t/*\n\t * Update the siginfo structure if the signal has\n\t * changed.  If the debugger wanted something\n\t * specific in the siginfo structure then it should\n\t * have updated *info via PTRACE_SETSIGINFO.\n\t */\n\tif (signr != info->si_signo) {\n\t\tclear_siginfo(info);\n\t\tinfo->si_signo = signr;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\trcu_read_lock();\n\t\tinfo->si_pid = task_pid_vnr(current->parent);\n\t\tinfo->si_uid = from_kuid_munged(current_user_ns(),\n\t\t\t\t\t\ttask_uid(current->parent));\n\t\trcu_read_unlock();\n\t}\n\n\t/* If the (new) signal is now blocked, requeue it.  */\n\tif (sigismember(&current->blocked, signr)) {\n\t\tsend_signal(signr, info, current, PIDTYPE_PID);\n\t\tsignr = 0;\n\t}\n\n\treturn signr;\n}"
  },
  {
    "function_name": "do_jobctl_trap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2273-2290",
    "snippet": "static void do_jobctl_trap(void)\n{\n\tstruct signal_struct *signal = current->signal;\n\tint signr = current->jobctl & JOBCTL_STOP_SIGMASK;\n\n\tif (current->ptrace & PT_SEIZED) {\n\t\tif (!signal->group_stop_count &&\n\t\t    !(signal->flags & SIGNAL_STOP_STOPPED))\n\t\t\tsignr = SIGTRAP;\n\t\tWARN_ON_ONCE(!signr);\n\t\tptrace_do_notify(signr, signr | (PTRACE_EVENT_STOP << 8),\n\t\t\t\t CLD_STOPPED);\n\t} else {\n\t\tWARN_ON_ONCE(!signr);\n\t\tptrace_stop(signr, CLD_STOPPED, 0, NULL);\n\t\tcurrent->exit_code = 0;\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptrace_stop",
          "args": [
            "signr",
            "CLD_STOPPED",
            "0",
            "NULL"
          ],
          "line": 2287
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1974-2107",
          "snippet": "static void ptrace_stop(int exit_code, int why, int clear_code, kernel_siginfo_t *info)\n\t__releases(&current->sighand->siglock)\n\t__acquires(&current->sighand->siglock)\n{\n\tbool gstop_done = false;\n\n\tif (arch_ptrace_stop_needed(exit_code, info)) {\n\t\t/*\n\t\t * The arch code has something special to do before a\n\t\t * ptrace stop.  This is allowed to block, e.g. for faults\n\t\t * on user stack pages.  We can't keep the siglock while\n\t\t * calling arch_ptrace_stop, so we must release it now.\n\t\t * To preserve proper semantics, we must do this before\n\t\t * any signal bookkeeping like checking group_stop_count.\n\t\t * Meanwhile, a SIGKILL could come in before we retake the\n\t\t * siglock.  That must prevent us from sleeping in TASK_TRACED.\n\t\t * So after regaining the lock, we must check for SIGKILL.\n\t\t */\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop(exit_code, info);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tif (sigkill_pending(current))\n\t\t\treturn;\n\t}\n\n\tset_special_state(TASK_TRACED);\n\n\t/*\n\t * We're committing to trapping.  TRACED should be visible before\n\t * TRAPPING is cleared; otherwise, the tracer might fail do_wait().\n\t * Also, transition to TRACED and updates to ->jobctl should be\n\t * atomic with respect to siglock and should be done after the arch\n\t * hook as siglock is released and regrabbed across it.\n\t *\n\t *     TRACER\t\t\t\t    TRACEE\n\t *\n\t *     ptrace_attach()\n\t * [L]   wait_on_bit(JOBCTL_TRAPPING)\t[S] set_special_state(TRACED)\n\t *     do_wait()\n\t *       set_current_state()                smp_wmb();\n\t *       ptrace_do_wait()\n\t *         wait_task_stopped()\n\t *           task_stopped_code()\n\t * [L]         task_is_traced()\t\t[S] task_clear_jobctl_trapping();\n\t */\n\tsmp_wmb();\n\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\n\t/*\n\t * If @why is CLD_STOPPED, we're trapping to participate in a group\n\t * stop.  Do the bookkeeping.  Note that if SIGCONT was delievered\n\t * across siglock relocks since INTERRUPT was scheduled, PENDING\n\t * could be clear now.  We act as if SIGCONT is received after\n\t * TASK_TRACED is entered - ignore it.\n\t */\n\tif (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))\n\t\tgstop_done = task_participate_group_stop(current);\n\n\t/* any trap clears pending STOP trap, STOP trap clears NOTIFY */\n\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\tif (info && info->si_code >> 8 == PTRACE_EVENT_STOP)\n\t\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY);\n\n\t/* entering a trap, clear TRAPPING */\n\ttask_clear_jobctl_trapping(current);\n\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (may_ptrace_stop()) {\n\t\t/*\n\t\t * Notify parents of the stop.\n\t\t *\n\t\t * While ptraced, there are two parents - the ptracer and\n\t\t * the real_parent of the group_leader.  The ptracer should\n\t\t * know about every stop while the real parent is only\n\t\t * interested in the completion of group stop.  The states\n\t\t * for the two don't interact with each other.  Notify\n\t\t * separately unless they're gonna be duplicates.\n\t\t */\n\t\tdo_notify_parent_cldstop(current, true, why);\n\t\tif (gstop_done && ptrace_reparented(current))\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/*\n\t\t * Don't want to allow preemption here, because\n\t\t * sys_ptrace() needs this task to be inactive.\n\t\t *\n\t\t * XXX: implement read_unlock_no_resched().\n\t\t */\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tpreempt_enable_no_resched();\n\t\tfreezable_schedule();\n\t} else {\n\t\t/*\n\t\t * By the time we got the lock, our tracer went away.\n\t\t * Don't drop the lock yet, another tracer may come.\n\t\t *\n\t\t * If @gstop_done, the ptracer went away between group stop\n\t\t * completion and here.  During detach, it would have set\n\t\t * JOBCTL_STOP_PENDING on us and we'll re-enter\n\t\t * TASK_STOPPED in do_signal_stop() on return, so notifying\n\t\t * the real parent of the group stop completion is enough.\n\t\t */\n\t\tif (gstop_done)\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/* tasklist protects us from ptrace_freeze_traced() */\n\t\t__set_current_state(TASK_RUNNING);\n\t\tif (clear_code)\n\t\t\tcurrent->exit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * We are back.  Now reacquire the siglock before touching\n\t * last_siginfo, so that we are sure to have synchronized with\n\t * any signal-sending on another CPU that wants to examine it.\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->last_siginfo = NULL;\n\n\t/* LISTENING can be set only during STOP traps, clear it */\n\tcurrent->jobctl &= ~JOBCTL_LISTENING;\n\n\t/*\n\t * Queued signals ignored us while we were stopped for tracing.\n\t * So check for any that we should take before resuming user mode.\n\t * This sets TIF_SIGPENDING, but never clears it.\n\t */\n\trecalc_sigpending_tsk(current);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic void ptrace_stop(int exit_code, int why, int clear_code, kernel_siginfo_t *info)\n\t__releases(&current->sighand->siglock)\n\t__acquires(&current->sighand->siglock)\n{\n\tbool gstop_done = false;\n\n\tif (arch_ptrace_stop_needed(exit_code, info)) {\n\t\t/*\n\t\t * The arch code has something special to do before a\n\t\t * ptrace stop.  This is allowed to block, e.g. for faults\n\t\t * on user stack pages.  We can't keep the siglock while\n\t\t * calling arch_ptrace_stop, so we must release it now.\n\t\t * To preserve proper semantics, we must do this before\n\t\t * any signal bookkeeping like checking group_stop_count.\n\t\t * Meanwhile, a SIGKILL could come in before we retake the\n\t\t * siglock.  That must prevent us from sleeping in TASK_TRACED.\n\t\t * So after regaining the lock, we must check for SIGKILL.\n\t\t */\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop(exit_code, info);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tif (sigkill_pending(current))\n\t\t\treturn;\n\t}\n\n\tset_special_state(TASK_TRACED);\n\n\t/*\n\t * We're committing to trapping.  TRACED should be visible before\n\t * TRAPPING is cleared; otherwise, the tracer might fail do_wait().\n\t * Also, transition to TRACED and updates to ->jobctl should be\n\t * atomic with respect to siglock and should be done after the arch\n\t * hook as siglock is released and regrabbed across it.\n\t *\n\t *     TRACER\t\t\t\t    TRACEE\n\t *\n\t *     ptrace_attach()\n\t * [L]   wait_on_bit(JOBCTL_TRAPPING)\t[S] set_special_state(TRACED)\n\t *     do_wait()\n\t *       set_current_state()                smp_wmb();\n\t *       ptrace_do_wait()\n\t *         wait_task_stopped()\n\t *           task_stopped_code()\n\t * [L]         task_is_traced()\t\t[S] task_clear_jobctl_trapping();\n\t */\n\tsmp_wmb();\n\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\n\t/*\n\t * If @why is CLD_STOPPED, we're trapping to participate in a group\n\t * stop.  Do the bookkeeping.  Note that if SIGCONT was delievered\n\t * across siglock relocks since INTERRUPT was scheduled, PENDING\n\t * could be clear now.  We act as if SIGCONT is received after\n\t * TASK_TRACED is entered - ignore it.\n\t */\n\tif (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))\n\t\tgstop_done = task_participate_group_stop(current);\n\n\t/* any trap clears pending STOP trap, STOP trap clears NOTIFY */\n\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\tif (info && info->si_code >> 8 == PTRACE_EVENT_STOP)\n\t\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY);\n\n\t/* entering a trap, clear TRAPPING */\n\ttask_clear_jobctl_trapping(current);\n\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (may_ptrace_stop()) {\n\t\t/*\n\t\t * Notify parents of the stop.\n\t\t *\n\t\t * While ptraced, there are two parents - the ptracer and\n\t\t * the real_parent of the group_leader.  The ptracer should\n\t\t * know about every stop while the real parent is only\n\t\t * interested in the completion of group stop.  The states\n\t\t * for the two don't interact with each other.  Notify\n\t\t * separately unless they're gonna be duplicates.\n\t\t */\n\t\tdo_notify_parent_cldstop(current, true, why);\n\t\tif (gstop_done && ptrace_reparented(current))\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/*\n\t\t * Don't want to allow preemption here, because\n\t\t * sys_ptrace() needs this task to be inactive.\n\t\t *\n\t\t * XXX: implement read_unlock_no_resched().\n\t\t */\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tpreempt_enable_no_resched();\n\t\tfreezable_schedule();\n\t} else {\n\t\t/*\n\t\t * By the time we got the lock, our tracer went away.\n\t\t * Don't drop the lock yet, another tracer may come.\n\t\t *\n\t\t * If @gstop_done, the ptracer went away between group stop\n\t\t * completion and here.  During detach, it would have set\n\t\t * JOBCTL_STOP_PENDING on us and we'll re-enter\n\t\t * TASK_STOPPED in do_signal_stop() on return, so notifying\n\t\t * the real parent of the group stop completion is enough.\n\t\t */\n\t\tif (gstop_done)\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/* tasklist protects us from ptrace_freeze_traced() */\n\t\t__set_current_state(TASK_RUNNING);\n\t\tif (clear_code)\n\t\t\tcurrent->exit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * We are back.  Now reacquire the siglock before touching\n\t * last_siginfo, so that we are sure to have synchronized with\n\t * any signal-sending on another CPU that wants to examine it.\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->last_siginfo = NULL;\n\n\t/* LISTENING can be set only during STOP traps, clear it */\n\tcurrent->jobctl &= ~JOBCTL_LISTENING;\n\n\t/*\n\t * Queued signals ignored us while we were stopped for tracing.\n\t * So check for any that we should take before resuming user mode.\n\t * This sets TIF_SIGPENDING, but never clears it.\n\t */\n\trecalc_sigpending_tsk(current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!signr"
          ],
          "line": 2286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_do_notify",
          "args": [
            "signr",
            "signr | (PTRACE_EVENT_STOP << 8)",
            "CLD_STOPPED"
          ],
          "line": 2283
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_do_notify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "2109-2121",
          "snippet": "static void ptrace_do_notify(int signr, int exit_code, int why)\n{\n\tkernel_siginfo_t info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = signr;\n\tinfo.si_code = exit_code;\n\tinfo.si_pid = task_pid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\t/* Let the debugger run.  */\n\tptrace_stop(exit_code, why, 1, &info);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic void ptrace_do_notify(int signr, int exit_code, int why)\n{\n\tkernel_siginfo_t info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = signr;\n\tinfo.si_code = exit_code;\n\tinfo.si_pid = task_pid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\t/* Let the debugger run.  */\n\tptrace_stop(exit_code, why, 1, &info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!signr"
          ],
          "line": 2282
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void do_jobctl_trap(void)\n{\n\tstruct signal_struct *signal = current->signal;\n\tint signr = current->jobctl & JOBCTL_STOP_SIGMASK;\n\n\tif (current->ptrace & PT_SEIZED) {\n\t\tif (!signal->group_stop_count &&\n\t\t    !(signal->flags & SIGNAL_STOP_STOPPED))\n\t\t\tsignr = SIGTRAP;\n\t\tWARN_ON_ONCE(!signr);\n\t\tptrace_do_notify(signr, signr | (PTRACE_EVENT_STOP << 8),\n\t\t\t\t CLD_STOPPED);\n\t} else {\n\t\tWARN_ON_ONCE(!signr);\n\t\tptrace_stop(signr, CLD_STOPPED, 0, NULL);\n\t\tcurrent->exit_code = 0;\n\t}\n}"
  },
  {
    "function_name": "do_signal_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2156-2256",
    "snippet": "static bool do_signal_stop(int signr)\n\t__releases(&current->sighand->siglock)\n{\n\tstruct signal_struct *sig = current->signal;\n\n\tif (!(current->jobctl & JOBCTL_STOP_PENDING)) {\n\t\tunsigned long gstop = JOBCTL_STOP_PENDING | JOBCTL_STOP_CONSUME;\n\t\tstruct task_struct *t;\n\n\t\t/* signr will be recorded in task->jobctl for retries */\n\t\tWARN_ON_ONCE(signr & ~JOBCTL_STOP_SIGMASK);\n\n\t\tif (!likely(current->jobctl & JOBCTL_STOP_DEQUEUED) ||\n\t\t    unlikely(signal_group_exit(sig)))\n\t\t\treturn false;\n\t\t/*\n\t\t * There is no group stop already in progress.  We must\n\t\t * initiate one now.\n\t\t *\n\t\t * While ptraced, a task may be resumed while group stop is\n\t\t * still in effect and then receive a stop signal and\n\t\t * initiate another group stop.  This deviates from the\n\t\t * usual behavior as two consecutive stop signals can't\n\t\t * cause two group stops when !ptraced.  That is why we\n\t\t * also check !task_is_stopped(t) below.\n\t\t *\n\t\t * The condition can be distinguished by testing whether\n\t\t * SIGNAL_STOP_STOPPED is already set.  Don't generate\n\t\t * group_exit_code in such case.\n\t\t *\n\t\t * This is not necessary for SIGNAL_STOP_CONTINUED because\n\t\t * an intervening stop signal is required to cause two\n\t\t * continued events regardless of ptrace.\n\t\t */\n\t\tif (!(sig->flags & SIGNAL_STOP_STOPPED))\n\t\t\tsig->group_exit_code = signr;\n\n\t\tsig->group_stop_count = 0;\n\n\t\tif (task_set_jobctl_pending(current, signr | gstop))\n\t\t\tsig->group_stop_count++;\n\n\t\tt = current;\n\t\twhile_each_thread(current, t) {\n\t\t\t/*\n\t\t\t * Setting state to TASK_STOPPED for a group\n\t\t\t * stop is always done with the siglock held,\n\t\t\t * so this check has no races.\n\t\t\t */\n\t\t\tif (!task_is_stopped(t) &&\n\t\t\t    task_set_jobctl_pending(t, signr | gstop)) {\n\t\t\t\tsig->group_stop_count++;\n\t\t\t\tif (likely(!(t->ptrace & PT_SEIZED)))\n\t\t\t\t\tsignal_wake_up(t, 0);\n\t\t\t\telse\n\t\t\t\t\tptrace_trap_notify(t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (likely(!current->ptrace)) {\n\t\tint notify = 0;\n\n\t\t/*\n\t\t * If there are no other threads in the group, or if there\n\t\t * is a group stop in progress and we are the last to stop,\n\t\t * report to the parent.\n\t\t */\n\t\tif (task_participate_group_stop(current))\n\t\t\tnotify = CLD_STOPPED;\n\n\t\tset_special_state(TASK_STOPPED);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\n\t\t/*\n\t\t * Notify the parent of the group stop completion.  Because\n\t\t * we're not holding either the siglock or tasklist_lock\n\t\t * here, ptracer may attach inbetween; however, this is for\n\t\t * group stop and should always be delivered to the real\n\t\t * parent of the group leader.  The new ptracer will get\n\t\t * its notification when this task transitions into\n\t\t * TASK_TRACED.\n\t\t */\n\t\tif (notify) {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tdo_notify_parent_cldstop(current, false, notify);\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\n\t\t/* Now we don't run again until woken by SIGCONT or SIGKILL */\n\t\tfreezable_schedule();\n\t\treturn true;\n\t} else {\n\t\t/*\n\t\t * While ptraced, group stop is handled by STOP trap.\n\t\t * Schedule it and let the caller deal with it.\n\t\t */\n\t\ttask_set_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\t\treturn false;\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_set_jobctl_pending",
          "args": [
            "current",
            "JOBCTL_TRAP_STOP"
          ],
          "line": 2253
        },
        "resolved": true,
        "details": {
          "function_name": "task_set_jobctl_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "275-289",
          "snippet": "bool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\n\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n\t\treturn false;\n\n\tif (mask & JOBCTL_STOP_SIGMASK)\n\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\n\ttask->jobctl |= mask;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nbool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\n\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n\t\treturn false;\n\n\tif (mask & JOBCTL_STOP_SIGMASK)\n\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\n\ttask->jobctl |= mask;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezable_schedule",
          "args": [],
          "line": 2246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 2242
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_notify_parent_cldstop",
          "args": [
            "current",
            "false",
            "notify"
          ],
          "line": 2241
        },
        "resolved": true,
        "details": {
          "function_name": "do_notify_parent_cldstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1871-1927",
          "snippet": "static void do_notify_parent_cldstop(struct task_struct *tsk,\n\t\t\t\t     bool for_ptracer, int why)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\tu64 utime, stime;\n\n\tif (for_ptracer) {\n\t\tparent = tsk->parent;\n\t} else {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\t/*\n\t * see comment in do_notify_parent() about the following 4 lines\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime);\n\tinfo.si_stime = nsec_to_clock_t(stime);\n\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t/*\n\t * Even if SIGCHLD is not generated, we must wake up wait4 calls.\n\t */\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic void do_notify_parent_cldstop(struct task_struct *tsk,\n\t\t\t\t     bool for_ptracer, int why)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\tu64 utime, stime;\n\n\tif (for_ptracer) {\n\t\tparent = tsk->parent;\n\t} else {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\t/*\n\t * see comment in do_notify_parent() about the following 4 lines\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime);\n\tinfo.si_stime = nsec_to_clock_t(stime);\n\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t/*\n\t * Even if SIGCHLD is not generated, we must wake up wait4 calls.\n\t */\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 2240
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 2228
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_special_state",
          "args": [
            "TASK_STOPPED"
          ],
          "line": 2227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_participate_group_stop",
          "args": [
            "current"
          ],
          "line": 2224
        },
        "resolved": true,
        "details": {
          "function_name": "task_participate_group_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "356-380",
          "snippet": "static bool task_participate_group_stop(struct task_struct *task)\n{\n\tstruct signal_struct *sig = task->signal;\n\tbool consume = task->jobctl & JOBCTL_STOP_CONSUME;\n\n\tWARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING));\n\n\ttask_clear_jobctl_pending(task, JOBCTL_STOP_PENDING);\n\n\tif (!consume)\n\t\treturn false;\n\n\tif (!WARN_ON_ONCE(sig->group_stop_count == 0))\n\t\tsig->group_stop_count--;\n\n\t/*\n\t * Tell the caller to notify completion iff we are entering into a\n\t * fresh group stop.  Read comment in do_signal_stop() for details.\n\t */\n\tif (!sig->group_stop_count && !(sig->flags & SIGNAL_STOP_STOPPED)) {\n\t\tsignal_set_stop_flags(sig, SIGNAL_STOP_STOPPED);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool task_participate_group_stop(struct task_struct *task)\n{\n\tstruct signal_struct *sig = task->signal;\n\tbool consume = task->jobctl & JOBCTL_STOP_CONSUME;\n\n\tWARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING));\n\n\ttask_clear_jobctl_pending(task, JOBCTL_STOP_PENDING);\n\n\tif (!consume)\n\t\treturn false;\n\n\tif (!WARN_ON_ONCE(sig->group_stop_count == 0))\n\t\tsig->group_stop_count--;\n\n\t/*\n\t * Tell the caller to notify completion iff we are entering into a\n\t * fresh group stop.  Read comment in do_signal_stop() for details.\n\t */\n\tif (!sig->group_stop_count && !(sig->flags & SIGNAL_STOP_STOPPED)) {\n\t\tsignal_set_stop_flags(sig, SIGNAL_STOP_STOPPED);\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!current->ptrace"
          ],
          "line": 2216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_trap_notify",
          "args": [
            "t"
          ],
          "line": 2211
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_trap_notify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "822-829",
          "snippet": "static void ptrace_trap_notify(struct task_struct *t)\n{\n\tWARN_ON_ONCE(!(t->ptrace & PT_SEIZED));\n\tassert_spin_locked(&t->sighand->siglock);\n\n\ttask_set_jobctl_pending(t, JOBCTL_TRAP_NOTIFY);\n\tptrace_signal_wake_up(t, t->jobctl & JOBCTL_LISTENING);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void ptrace_trap_notify(struct task_struct *t)\n{\n\tWARN_ON_ONCE(!(t->ptrace & PT_SEIZED));\n\tassert_spin_locked(&t->sighand->siglock);\n\n\ttask_set_jobctl_pending(t, JOBCTL_TRAP_NOTIFY);\n\tptrace_signal_wake_up(t, t->jobctl & JOBCTL_LISTENING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_wake_up",
          "args": [
            "t",
            "0"
          ],
          "line": 2209
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "702-714",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(t->ptrace & PT_SEIZED)"
          ],
          "line": 2208
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_is_stopped",
          "args": [
            "t"
          ],
          "line": 2205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "while_each_thread",
          "args": [
            "current",
            "t"
          ],
          "line": 2199
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "signal_group_exit(sig)"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_group_exit",
          "args": [
            "sig"
          ],
          "line": 2169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "current->jobctl & JOBCTL_STOP_DEQUEUED"
          ],
          "line": 2168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "signr & ~JOBCTL_STOP_SIGMASK"
          ],
          "line": 2166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 2157
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool do_signal_stop(int signr)\n\t__releases(&current->sighand->siglock)\n{\n\tstruct signal_struct *sig = current->signal;\n\n\tif (!(current->jobctl & JOBCTL_STOP_PENDING)) {\n\t\tunsigned long gstop = JOBCTL_STOP_PENDING | JOBCTL_STOP_CONSUME;\n\t\tstruct task_struct *t;\n\n\t\t/* signr will be recorded in task->jobctl for retries */\n\t\tWARN_ON_ONCE(signr & ~JOBCTL_STOP_SIGMASK);\n\n\t\tif (!likely(current->jobctl & JOBCTL_STOP_DEQUEUED) ||\n\t\t    unlikely(signal_group_exit(sig)))\n\t\t\treturn false;\n\t\t/*\n\t\t * There is no group stop already in progress.  We must\n\t\t * initiate one now.\n\t\t *\n\t\t * While ptraced, a task may be resumed while group stop is\n\t\t * still in effect and then receive a stop signal and\n\t\t * initiate another group stop.  This deviates from the\n\t\t * usual behavior as two consecutive stop signals can't\n\t\t * cause two group stops when !ptraced.  That is why we\n\t\t * also check !task_is_stopped(t) below.\n\t\t *\n\t\t * The condition can be distinguished by testing whether\n\t\t * SIGNAL_STOP_STOPPED is already set.  Don't generate\n\t\t * group_exit_code in such case.\n\t\t *\n\t\t * This is not necessary for SIGNAL_STOP_CONTINUED because\n\t\t * an intervening stop signal is required to cause two\n\t\t * continued events regardless of ptrace.\n\t\t */\n\t\tif (!(sig->flags & SIGNAL_STOP_STOPPED))\n\t\t\tsig->group_exit_code = signr;\n\n\t\tsig->group_stop_count = 0;\n\n\t\tif (task_set_jobctl_pending(current, signr | gstop))\n\t\t\tsig->group_stop_count++;\n\n\t\tt = current;\n\t\twhile_each_thread(current, t) {\n\t\t\t/*\n\t\t\t * Setting state to TASK_STOPPED for a group\n\t\t\t * stop is always done with the siglock held,\n\t\t\t * so this check has no races.\n\t\t\t */\n\t\t\tif (!task_is_stopped(t) &&\n\t\t\t    task_set_jobctl_pending(t, signr | gstop)) {\n\t\t\t\tsig->group_stop_count++;\n\t\t\t\tif (likely(!(t->ptrace & PT_SEIZED)))\n\t\t\t\t\tsignal_wake_up(t, 0);\n\t\t\t\telse\n\t\t\t\t\tptrace_trap_notify(t);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (likely(!current->ptrace)) {\n\t\tint notify = 0;\n\n\t\t/*\n\t\t * If there are no other threads in the group, or if there\n\t\t * is a group stop in progress and we are the last to stop,\n\t\t * report to the parent.\n\t\t */\n\t\tif (task_participate_group_stop(current))\n\t\t\tnotify = CLD_STOPPED;\n\n\t\tset_special_state(TASK_STOPPED);\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\n\t\t/*\n\t\t * Notify the parent of the group stop completion.  Because\n\t\t * we're not holding either the siglock or tasklist_lock\n\t\t * here, ptracer may attach inbetween; however, this is for\n\t\t * group stop and should always be delivered to the real\n\t\t * parent of the group leader.  The new ptracer will get\n\t\t * its notification when this task transitions into\n\t\t * TASK_TRACED.\n\t\t */\n\t\tif (notify) {\n\t\t\tread_lock(&tasklist_lock);\n\t\t\tdo_notify_parent_cldstop(current, false, notify);\n\t\t\tread_unlock(&tasklist_lock);\n\t\t}\n\n\t\t/* Now we don't run again until woken by SIGCONT or SIGKILL */\n\t\tfreezable_schedule();\n\t\treturn true;\n\t} else {\n\t\t/*\n\t\t * While ptraced, group stop is handled by STOP trap.\n\t\t * Schedule it and let the caller deal with it.\n\t\t */\n\t\ttask_set_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\t\treturn false;\n\t}\n}"
  },
  {
    "function_name": "ptrace_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2123-2132",
    "snippet": "void ptrace_notify(int exit_code)\n{\n\tBUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);\n\tif (unlikely(current->task_works))\n\t\ttask_work_run();\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tptrace_do_notify(SIGTRAP, exit_code, CLD_TRAPPED);\n\tspin_unlock_irq(&current->sighand->siglock);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 2131
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_do_notify",
          "args": [
            "SIGTRAP",
            "exit_code",
            "CLD_TRAPPED"
          ],
          "line": 2130
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_do_notify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "2109-2121",
          "snippet": "static void ptrace_do_notify(int signr, int exit_code, int why)\n{\n\tkernel_siginfo_t info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = signr;\n\tinfo.si_code = exit_code;\n\tinfo.si_pid = task_pid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\t/* Let the debugger run.  */\n\tptrace_stop(exit_code, why, 1, &info);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic void ptrace_do_notify(int signr, int exit_code, int why)\n{\n\tkernel_siginfo_t info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = signr;\n\tinfo.si_code = exit_code;\n\tinfo.si_pid = task_pid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\t/* Let the debugger run.  */\n\tptrace_stop(exit_code, why, 1, &info);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 2129
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_work_run",
          "args": [],
          "line": 2127
        },
        "resolved": true,
        "details": {
          "function_name": "task_work_run",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/task_work.c",
          "lines": "90-118",
          "snippet": "void task_work_run(void)\n{\n\tstruct task_struct *task = current;\n\tstruct callback_head *work, *head, *next;\n\n\tfor (;;) {\n\t\t/*\n\t\t * work->func() can do task_work_add(), do not set\n\t\t * work_exited unless the list is empty.\n\t\t */\n\t\traw_spin_lock_irq(&task->pi_lock);\n\t\tdo {\n\t\t\twork = READ_ONCE(task->task_works);\n\t\t\thead = !work && (task->flags & PF_EXITING) ?\n\t\t\t\t&work_exited : NULL;\n\t\t} while (cmpxchg(&task->task_works, work, head) != work);\n\t\traw_spin_unlock_irq(&task->pi_lock);\n\n\t\tif (!work)\n\t\t\tbreak;\n\n\t\tdo {\n\t\t\tnext = work->next;\n\t\t\twork->func(work);\n\t\t\twork = next;\n\t\t\tcond_resched();\n\t\t} while (work);\n\t}\n}",
          "includes": [
            "#include <linux/tracehook.h>",
            "#include <linux/task_work.h>",
            "#include <linux/spinlock.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct callback_head work_exited;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/tracehook.h>\n#include <linux/task_work.h>\n#include <linux/spinlock.h>\n\nstatic struct callback_head work_exited;\n\nvoid task_work_run(void)\n{\n\tstruct task_struct *task = current;\n\tstruct callback_head *work, *head, *next;\n\n\tfor (;;) {\n\t\t/*\n\t\t * work->func() can do task_work_add(), do not set\n\t\t * work_exited unless the list is empty.\n\t\t */\n\t\traw_spin_lock_irq(&task->pi_lock);\n\t\tdo {\n\t\t\twork = READ_ONCE(task->task_works);\n\t\t\thead = !work && (task->flags & PF_EXITING) ?\n\t\t\t\t&work_exited : NULL;\n\t\t} while (cmpxchg(&task->task_works, work, head) != work);\n\t\traw_spin_unlock_irq(&task->pi_lock);\n\n\t\tif (!work)\n\t\t\tbreak;\n\n\t\tdo {\n\t\t\tnext = work->next;\n\t\t\twork->func(work);\n\t\t\twork = next;\n\t\t\tcond_resched();\n\t\t} while (work);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->task_works"
          ],
          "line": 2126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(exit_code & (0x7f | ~0xffff)) != SIGTRAP"
          ],
          "line": 2125
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid ptrace_notify(int exit_code)\n{\n\tBUG_ON((exit_code & (0x7f | ~0xffff)) != SIGTRAP);\n\tif (unlikely(current->task_works))\n\t\ttask_work_run();\n\n\tspin_lock_irq(&current->sighand->siglock);\n\tptrace_do_notify(SIGTRAP, exit_code, CLD_TRAPPED);\n\tspin_unlock_irq(&current->sighand->siglock);\n}"
  },
  {
    "function_name": "ptrace_do_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2109-2121",
    "snippet": "static void ptrace_do_notify(int signr, int exit_code, int why)\n{\n\tkernel_siginfo_t info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = signr;\n\tinfo.si_code = exit_code;\n\tinfo.si_pid = task_pid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\t/* Let the debugger run.  */\n\tptrace_stop(exit_code, why, 1, &info);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptrace_stop",
          "args": [
            "exit_code",
            "why",
            "1",
            "&info"
          ],
          "line": 2120
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1974-2107",
          "snippet": "static void ptrace_stop(int exit_code, int why, int clear_code, kernel_siginfo_t *info)\n\t__releases(&current->sighand->siglock)\n\t__acquires(&current->sighand->siglock)\n{\n\tbool gstop_done = false;\n\n\tif (arch_ptrace_stop_needed(exit_code, info)) {\n\t\t/*\n\t\t * The arch code has something special to do before a\n\t\t * ptrace stop.  This is allowed to block, e.g. for faults\n\t\t * on user stack pages.  We can't keep the siglock while\n\t\t * calling arch_ptrace_stop, so we must release it now.\n\t\t * To preserve proper semantics, we must do this before\n\t\t * any signal bookkeeping like checking group_stop_count.\n\t\t * Meanwhile, a SIGKILL could come in before we retake the\n\t\t * siglock.  That must prevent us from sleeping in TASK_TRACED.\n\t\t * So after regaining the lock, we must check for SIGKILL.\n\t\t */\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop(exit_code, info);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tif (sigkill_pending(current))\n\t\t\treturn;\n\t}\n\n\tset_special_state(TASK_TRACED);\n\n\t/*\n\t * We're committing to trapping.  TRACED should be visible before\n\t * TRAPPING is cleared; otherwise, the tracer might fail do_wait().\n\t * Also, transition to TRACED and updates to ->jobctl should be\n\t * atomic with respect to siglock and should be done after the arch\n\t * hook as siglock is released and regrabbed across it.\n\t *\n\t *     TRACER\t\t\t\t    TRACEE\n\t *\n\t *     ptrace_attach()\n\t * [L]   wait_on_bit(JOBCTL_TRAPPING)\t[S] set_special_state(TRACED)\n\t *     do_wait()\n\t *       set_current_state()                smp_wmb();\n\t *       ptrace_do_wait()\n\t *         wait_task_stopped()\n\t *           task_stopped_code()\n\t * [L]         task_is_traced()\t\t[S] task_clear_jobctl_trapping();\n\t */\n\tsmp_wmb();\n\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\n\t/*\n\t * If @why is CLD_STOPPED, we're trapping to participate in a group\n\t * stop.  Do the bookkeeping.  Note that if SIGCONT was delievered\n\t * across siglock relocks since INTERRUPT was scheduled, PENDING\n\t * could be clear now.  We act as if SIGCONT is received after\n\t * TASK_TRACED is entered - ignore it.\n\t */\n\tif (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))\n\t\tgstop_done = task_participate_group_stop(current);\n\n\t/* any trap clears pending STOP trap, STOP trap clears NOTIFY */\n\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\tif (info && info->si_code >> 8 == PTRACE_EVENT_STOP)\n\t\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY);\n\n\t/* entering a trap, clear TRAPPING */\n\ttask_clear_jobctl_trapping(current);\n\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (may_ptrace_stop()) {\n\t\t/*\n\t\t * Notify parents of the stop.\n\t\t *\n\t\t * While ptraced, there are two parents - the ptracer and\n\t\t * the real_parent of the group_leader.  The ptracer should\n\t\t * know about every stop while the real parent is only\n\t\t * interested in the completion of group stop.  The states\n\t\t * for the two don't interact with each other.  Notify\n\t\t * separately unless they're gonna be duplicates.\n\t\t */\n\t\tdo_notify_parent_cldstop(current, true, why);\n\t\tif (gstop_done && ptrace_reparented(current))\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/*\n\t\t * Don't want to allow preemption here, because\n\t\t * sys_ptrace() needs this task to be inactive.\n\t\t *\n\t\t * XXX: implement read_unlock_no_resched().\n\t\t */\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tpreempt_enable_no_resched();\n\t\tfreezable_schedule();\n\t} else {\n\t\t/*\n\t\t * By the time we got the lock, our tracer went away.\n\t\t * Don't drop the lock yet, another tracer may come.\n\t\t *\n\t\t * If @gstop_done, the ptracer went away between group stop\n\t\t * completion and here.  During detach, it would have set\n\t\t * JOBCTL_STOP_PENDING on us and we'll re-enter\n\t\t * TASK_STOPPED in do_signal_stop() on return, so notifying\n\t\t * the real parent of the group stop completion is enough.\n\t\t */\n\t\tif (gstop_done)\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/* tasklist protects us from ptrace_freeze_traced() */\n\t\t__set_current_state(TASK_RUNNING);\n\t\tif (clear_code)\n\t\t\tcurrent->exit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * We are back.  Now reacquire the siglock before touching\n\t * last_siginfo, so that we are sure to have synchronized with\n\t * any signal-sending on another CPU that wants to examine it.\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->last_siginfo = NULL;\n\n\t/* LISTENING can be set only during STOP traps, clear it */\n\tcurrent->jobctl &= ~JOBCTL_LISTENING;\n\n\t/*\n\t * Queued signals ignored us while we were stopped for tracing.\n\t * So check for any that we should take before resuming user mode.\n\t * This sets TIF_SIGPENDING, but never clears it.\n\t */\n\trecalc_sigpending_tsk(current);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic void ptrace_stop(int exit_code, int why, int clear_code, kernel_siginfo_t *info)\n\t__releases(&current->sighand->siglock)\n\t__acquires(&current->sighand->siglock)\n{\n\tbool gstop_done = false;\n\n\tif (arch_ptrace_stop_needed(exit_code, info)) {\n\t\t/*\n\t\t * The arch code has something special to do before a\n\t\t * ptrace stop.  This is allowed to block, e.g. for faults\n\t\t * on user stack pages.  We can't keep the siglock while\n\t\t * calling arch_ptrace_stop, so we must release it now.\n\t\t * To preserve proper semantics, we must do this before\n\t\t * any signal bookkeeping like checking group_stop_count.\n\t\t * Meanwhile, a SIGKILL could come in before we retake the\n\t\t * siglock.  That must prevent us from sleeping in TASK_TRACED.\n\t\t * So after regaining the lock, we must check for SIGKILL.\n\t\t */\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop(exit_code, info);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tif (sigkill_pending(current))\n\t\t\treturn;\n\t}\n\n\tset_special_state(TASK_TRACED);\n\n\t/*\n\t * We're committing to trapping.  TRACED should be visible before\n\t * TRAPPING is cleared; otherwise, the tracer might fail do_wait().\n\t * Also, transition to TRACED and updates to ->jobctl should be\n\t * atomic with respect to siglock and should be done after the arch\n\t * hook as siglock is released and regrabbed across it.\n\t *\n\t *     TRACER\t\t\t\t    TRACEE\n\t *\n\t *     ptrace_attach()\n\t * [L]   wait_on_bit(JOBCTL_TRAPPING)\t[S] set_special_state(TRACED)\n\t *     do_wait()\n\t *       set_current_state()                smp_wmb();\n\t *       ptrace_do_wait()\n\t *         wait_task_stopped()\n\t *           task_stopped_code()\n\t * [L]         task_is_traced()\t\t[S] task_clear_jobctl_trapping();\n\t */\n\tsmp_wmb();\n\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\n\t/*\n\t * If @why is CLD_STOPPED, we're trapping to participate in a group\n\t * stop.  Do the bookkeeping.  Note that if SIGCONT was delievered\n\t * across siglock relocks since INTERRUPT was scheduled, PENDING\n\t * could be clear now.  We act as if SIGCONT is received after\n\t * TASK_TRACED is entered - ignore it.\n\t */\n\tif (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))\n\t\tgstop_done = task_participate_group_stop(current);\n\n\t/* any trap clears pending STOP trap, STOP trap clears NOTIFY */\n\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\tif (info && info->si_code >> 8 == PTRACE_EVENT_STOP)\n\t\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY);\n\n\t/* entering a trap, clear TRAPPING */\n\ttask_clear_jobctl_trapping(current);\n\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (may_ptrace_stop()) {\n\t\t/*\n\t\t * Notify parents of the stop.\n\t\t *\n\t\t * While ptraced, there are two parents - the ptracer and\n\t\t * the real_parent of the group_leader.  The ptracer should\n\t\t * know about every stop while the real parent is only\n\t\t * interested in the completion of group stop.  The states\n\t\t * for the two don't interact with each other.  Notify\n\t\t * separately unless they're gonna be duplicates.\n\t\t */\n\t\tdo_notify_parent_cldstop(current, true, why);\n\t\tif (gstop_done && ptrace_reparented(current))\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/*\n\t\t * Don't want to allow preemption here, because\n\t\t * sys_ptrace() needs this task to be inactive.\n\t\t *\n\t\t * XXX: implement read_unlock_no_resched().\n\t\t */\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tpreempt_enable_no_resched();\n\t\tfreezable_schedule();\n\t} else {\n\t\t/*\n\t\t * By the time we got the lock, our tracer went away.\n\t\t * Don't drop the lock yet, another tracer may come.\n\t\t *\n\t\t * If @gstop_done, the ptracer went away between group stop\n\t\t * completion and here.  During detach, it would have set\n\t\t * JOBCTL_STOP_PENDING on us and we'll re-enter\n\t\t * TASK_STOPPED in do_signal_stop() on return, so notifying\n\t\t * the real parent of the group stop completion is enough.\n\t\t */\n\t\tif (gstop_done)\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/* tasklist protects us from ptrace_freeze_traced() */\n\t\t__set_current_state(TASK_RUNNING);\n\t\tif (clear_code)\n\t\t\tcurrent->exit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * We are back.  Now reacquire the siglock before touching\n\t * last_siginfo, so that we are sure to have synchronized with\n\t * any signal-sending on another CPU that wants to examine it.\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->last_siginfo = NULL;\n\n\t/* LISTENING can be set only during STOP traps, clear it */\n\tcurrent->jobctl &= ~JOBCTL_LISTENING;\n\n\t/*\n\t * Queued signals ignored us while we were stopped for tracing.\n\t * So check for any that we should take before resuming user mode.\n\t * This sets TIF_SIGPENDING, but never clears it.\n\t */\n\trecalc_sigpending_tsk(current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "current_uid()"
          ],
          "line": 2117
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 2117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "current"
          ],
          "line": 2116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 2113
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic void ptrace_do_notify(int signr, int exit_code, int why)\n{\n\tkernel_siginfo_t info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = signr;\n\tinfo.si_code = exit_code;\n\tinfo.si_pid = task_pid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\t/* Let the debugger run.  */\n\tptrace_stop(exit_code, why, 1, &info);\n}"
  },
  {
    "function_name": "ptrace_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1974-2107",
    "snippet": "static void ptrace_stop(int exit_code, int why, int clear_code, kernel_siginfo_t *info)\n\t__releases(&current->sighand->siglock)\n\t__acquires(&current->sighand->siglock)\n{\n\tbool gstop_done = false;\n\n\tif (arch_ptrace_stop_needed(exit_code, info)) {\n\t\t/*\n\t\t * The arch code has something special to do before a\n\t\t * ptrace stop.  This is allowed to block, e.g. for faults\n\t\t * on user stack pages.  We can't keep the siglock while\n\t\t * calling arch_ptrace_stop, so we must release it now.\n\t\t * To preserve proper semantics, we must do this before\n\t\t * any signal bookkeeping like checking group_stop_count.\n\t\t * Meanwhile, a SIGKILL could come in before we retake the\n\t\t * siglock.  That must prevent us from sleeping in TASK_TRACED.\n\t\t * So after regaining the lock, we must check for SIGKILL.\n\t\t */\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop(exit_code, info);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tif (sigkill_pending(current))\n\t\t\treturn;\n\t}\n\n\tset_special_state(TASK_TRACED);\n\n\t/*\n\t * We're committing to trapping.  TRACED should be visible before\n\t * TRAPPING is cleared; otherwise, the tracer might fail do_wait().\n\t * Also, transition to TRACED and updates to ->jobctl should be\n\t * atomic with respect to siglock and should be done after the arch\n\t * hook as siglock is released and regrabbed across it.\n\t *\n\t *     TRACER\t\t\t\t    TRACEE\n\t *\n\t *     ptrace_attach()\n\t * [L]   wait_on_bit(JOBCTL_TRAPPING)\t[S] set_special_state(TRACED)\n\t *     do_wait()\n\t *       set_current_state()                smp_wmb();\n\t *       ptrace_do_wait()\n\t *         wait_task_stopped()\n\t *           task_stopped_code()\n\t * [L]         task_is_traced()\t\t[S] task_clear_jobctl_trapping();\n\t */\n\tsmp_wmb();\n\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\n\t/*\n\t * If @why is CLD_STOPPED, we're trapping to participate in a group\n\t * stop.  Do the bookkeeping.  Note that if SIGCONT was delievered\n\t * across siglock relocks since INTERRUPT was scheduled, PENDING\n\t * could be clear now.  We act as if SIGCONT is received after\n\t * TASK_TRACED is entered - ignore it.\n\t */\n\tif (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))\n\t\tgstop_done = task_participate_group_stop(current);\n\n\t/* any trap clears pending STOP trap, STOP trap clears NOTIFY */\n\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\tif (info && info->si_code >> 8 == PTRACE_EVENT_STOP)\n\t\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY);\n\n\t/* entering a trap, clear TRAPPING */\n\ttask_clear_jobctl_trapping(current);\n\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (may_ptrace_stop()) {\n\t\t/*\n\t\t * Notify parents of the stop.\n\t\t *\n\t\t * While ptraced, there are two parents - the ptracer and\n\t\t * the real_parent of the group_leader.  The ptracer should\n\t\t * know about every stop while the real parent is only\n\t\t * interested in the completion of group stop.  The states\n\t\t * for the two don't interact with each other.  Notify\n\t\t * separately unless they're gonna be duplicates.\n\t\t */\n\t\tdo_notify_parent_cldstop(current, true, why);\n\t\tif (gstop_done && ptrace_reparented(current))\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/*\n\t\t * Don't want to allow preemption here, because\n\t\t * sys_ptrace() needs this task to be inactive.\n\t\t *\n\t\t * XXX: implement read_unlock_no_resched().\n\t\t */\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tpreempt_enable_no_resched();\n\t\tfreezable_schedule();\n\t} else {\n\t\t/*\n\t\t * By the time we got the lock, our tracer went away.\n\t\t * Don't drop the lock yet, another tracer may come.\n\t\t *\n\t\t * If @gstop_done, the ptracer went away between group stop\n\t\t * completion and here.  During detach, it would have set\n\t\t * JOBCTL_STOP_PENDING on us and we'll re-enter\n\t\t * TASK_STOPPED in do_signal_stop() on return, so notifying\n\t\t * the real parent of the group stop completion is enough.\n\t\t */\n\t\tif (gstop_done)\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/* tasklist protects us from ptrace_freeze_traced() */\n\t\t__set_current_state(TASK_RUNNING);\n\t\tif (clear_code)\n\t\t\tcurrent->exit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * We are back.  Now reacquire the siglock before touching\n\t * last_siginfo, so that we are sure to have synchronized with\n\t * any signal-sending on another CPU that wants to examine it.\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->last_siginfo = NULL;\n\n\t/* LISTENING can be set only during STOP traps, clear it */\n\tcurrent->jobctl &= ~JOBCTL_LISTENING;\n\n\t/*\n\t * Queued signals ignored us while we were stopped for tracing.\n\t * So check for any that we should take before resuming user mode.\n\t * This sets TIF_SIGPENDING, but never clears it.\n\t */\n\trecalc_sigpending_tsk(current);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "recalc_sigpending_tsk",
          "args": [
            "current"
          ],
          "line": 2106
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_sigpending_tsk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "145-160",
          "snippet": "static bool recalc_sigpending_tsk(struct task_struct *t)\n{\n\tif ((t->jobctl & JOBCTL_PENDING_MASK) ||\n\t    PENDING(&t->pending, &t->blocked) ||\n\t    PENDING(&t->signal->shared_pending, &t->blocked)) {\n\t\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\treturn true;\n\t}\n\n\t/*\n\t * We must never clear the flag in another thread, or in current\n\t * when it's possible the current syscall is returning -ERESTART*.\n\t * So we don't clear it here, and only callers who know they should do.\n\t */\n\treturn false;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool recalc_sigpending_tsk(struct task_struct *t)\n{\n\tif ((t->jobctl & JOBCTL_PENDING_MASK) ||\n\t    PENDING(&t->pending, &t->blocked) ||\n\t    PENDING(&t->signal->shared_pending, &t->blocked)) {\n\t\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\treturn true;\n\t}\n\n\t/*\n\t * We must never clear the flag in another thread, or in current\n\t * when it's possible the current syscall is returning -ERESTART*.\n\t * So we don't clear it here, and only callers who know they should do.\n\t */\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 2095
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 2087
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "__set_current_state",
          "args": [
            "TASK_RUNNING"
          ],
          "line": 2084
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_notify_parent_cldstop",
          "args": [
            "current",
            "false",
            "why"
          ],
          "line": 2081
        },
        "resolved": true,
        "details": {
          "function_name": "do_notify_parent_cldstop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1871-1927",
          "snippet": "static void do_notify_parent_cldstop(struct task_struct *tsk,\n\t\t\t\t     bool for_ptracer, int why)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\tu64 utime, stime;\n\n\tif (for_ptracer) {\n\t\tparent = tsk->parent;\n\t} else {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\t/*\n\t * see comment in do_notify_parent() about the following 4 lines\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime);\n\tinfo.si_stime = nsec_to_clock_t(stime);\n\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t/*\n\t * Even if SIGCHLD is not generated, we must wake up wait4 calls.\n\t */\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic void do_notify_parent_cldstop(struct task_struct *tsk,\n\t\t\t\t     bool for_ptracer, int why)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\tu64 utime, stime;\n\n\tif (for_ptracer) {\n\t\tparent = tsk->parent;\n\t} else {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\t/*\n\t * see comment in do_notify_parent() about the following 4 lines\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime);\n\tinfo.si_stime = nsec_to_clock_t(stime);\n\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t/*\n\t * Even if SIGCHLD is not generated, we must wake up wait4 calls.\n\t */\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "freezable_schedule",
          "args": [],
          "line": 2068
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_enable_no_resched",
          "args": [],
          "line": 2067
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 2065
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "ptrace_reparented",
          "args": [
            "current"
          ],
          "line": 2056
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "may_ptrace_stop",
          "args": [],
          "line": 2044
        },
        "resolved": true,
        "details": {
          "function_name": "may_ptrace_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1929-1951",
          "snippet": "static inline bool may_ptrace_stop(void)\n{\n\tif (!likely(current->ptrace))\n\t\treturn false;\n\t/*\n\t * Are we in the middle of do_coredump?\n\t * If so and our tracer is also part of the coredump stopping\n\t * is a deadlock situation, and pointless because our tracer\n\t * is dead so don't allow us to stop.\n\t * If SIGKILL was already sent before the caller unlocked\n\t * ->siglock we must see ->core_state != NULL. Otherwise it\n\t * is safe to enter schedule().\n\t *\n\t * This is almost outdated, a task with the pending SIGKILL can't\n\t * block in TASK_TRACED. But PTRACE_EVENT_EXIT can be reported\n\t * after SIGKILL was already dequeued.\n\t */\n\tif (unlikely(current->mm->core_state) &&\n\t    unlikely(current->mm == current->parent->mm))\n\t\treturn false;\n\n\treturn true;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool may_ptrace_stop(void)\n{\n\tif (!likely(current->ptrace))\n\t\treturn false;\n\t/*\n\t * Are we in the middle of do_coredump?\n\t * If so and our tracer is also part of the coredump stopping\n\t * is a deadlock situation, and pointless because our tracer\n\t * is dead so don't allow us to stop.\n\t * If SIGKILL was already sent before the caller unlocked\n\t * ->siglock we must see ->core_state != NULL. Otherwise it\n\t * is safe to enter schedule().\n\t *\n\t * This is almost outdated, a task with the pending SIGKILL can't\n\t * block in TASK_TRACED. But PTRACE_EVENT_EXIT can be reported\n\t * after SIGKILL was already dequeued.\n\t */\n\tif (unlikely(current->mm->core_state) &&\n\t    unlikely(current->mm == current->parent->mm))\n\t\treturn false;\n\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 2043
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 2042
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_clear_jobctl_trapping",
          "args": [
            "current"
          ],
          "line": 2040
        },
        "resolved": true,
        "details": {
          "function_name": "task_clear_jobctl_trapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "303-310",
          "snippet": "void task_clear_jobctl_trapping(struct task_struct *task)\n{\n\tif (unlikely(task->jobctl & JOBCTL_TRAPPING)) {\n\t\ttask->jobctl &= ~JOBCTL_TRAPPING;\n\t\tsmp_mb();\t/* advised by wake_up_bit() */\n\t\twake_up_bit(&task->jobctl, JOBCTL_TRAPPING_BIT);\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid task_clear_jobctl_trapping(struct task_struct *task)\n{\n\tif (unlikely(task->jobctl & JOBCTL_TRAPPING)) {\n\t\ttask->jobctl &= ~JOBCTL_TRAPPING;\n\t\tsmp_mb();\t/* advised by wake_up_bit() */\n\t\twake_up_bit(&task->jobctl, JOBCTL_TRAPPING_BIT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_clear_jobctl_pending",
          "args": [
            "current",
            "JOBCTL_TRAP_NOTIFY"
          ],
          "line": 2037
        },
        "resolved": true,
        "details": {
          "function_name": "task_clear_jobctl_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "327-338",
          "snippet": "void task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_participate_group_stop",
          "args": [
            "current"
          ],
          "line": 2032
        },
        "resolved": true,
        "details": {
          "function_name": "task_participate_group_stop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "356-380",
          "snippet": "static bool task_participate_group_stop(struct task_struct *task)\n{\n\tstruct signal_struct *sig = task->signal;\n\tbool consume = task->jobctl & JOBCTL_STOP_CONSUME;\n\n\tWARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING));\n\n\ttask_clear_jobctl_pending(task, JOBCTL_STOP_PENDING);\n\n\tif (!consume)\n\t\treturn false;\n\n\tif (!WARN_ON_ONCE(sig->group_stop_count == 0))\n\t\tsig->group_stop_count--;\n\n\t/*\n\t * Tell the caller to notify completion iff we are entering into a\n\t * fresh group stop.  Read comment in do_signal_stop() for details.\n\t */\n\tif (!sig->group_stop_count && !(sig->flags & SIGNAL_STOP_STOPPED)) {\n\t\tsignal_set_stop_flags(sig, SIGNAL_STOP_STOPPED);\n\t\treturn true;\n\t}\n\treturn false;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool task_participate_group_stop(struct task_struct *task)\n{\n\tstruct signal_struct *sig = task->signal;\n\tbool consume = task->jobctl & JOBCTL_STOP_CONSUME;\n\n\tWARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING));\n\n\ttask_clear_jobctl_pending(task, JOBCTL_STOP_PENDING);\n\n\tif (!consume)\n\t\treturn false;\n\n\tif (!WARN_ON_ONCE(sig->group_stop_count == 0))\n\t\tsig->group_stop_count--;\n\n\t/*\n\t * Tell the caller to notify completion iff we are entering into a\n\t * fresh group stop.  Read comment in do_signal_stop() for details.\n\t */\n\tif (!sig->group_stop_count && !(sig->flags & SIGNAL_STOP_STOPPED)) {\n\t\tsignal_set_stop_flags(sig, SIGNAL_STOP_STOPPED);\n\t\treturn true;\n\t}\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_wmb",
          "args": [],
          "line": 2019
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "set_special_state",
          "args": [
            "TASK_TRACED"
          ],
          "line": 1999
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigkill_pending",
          "args": [
            "current"
          ],
          "line": 1995
        },
        "resolved": true,
        "details": {
          "function_name": "sigkill_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1957-1961",
          "snippet": "static bool sigkill_pending(struct task_struct *tsk)\n{\n\treturn sigismember(&tsk->pending.signal, SIGKILL) ||\n\t       sigismember(&tsk->signal->shared_pending.signal, SIGKILL);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool sigkill_pending(struct task_struct *tsk)\n{\n\treturn sigismember(&tsk->pending.signal, SIGKILL) ||\n\t       sigismember(&tsk->signal->shared_pending.signal, SIGKILL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "arch_ptrace_stop",
          "args": [
            "exit_code",
            "info"
          ],
          "line": 1993
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "arch_ptrace_stop_needed",
          "args": [
            "exit_code",
            "info"
          ],
          "line": 1980
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__acquires",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 1976
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__releases",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 1975
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic void ptrace_stop(int exit_code, int why, int clear_code, kernel_siginfo_t *info)\n\t__releases(&current->sighand->siglock)\n\t__acquires(&current->sighand->siglock)\n{\n\tbool gstop_done = false;\n\n\tif (arch_ptrace_stop_needed(exit_code, info)) {\n\t\t/*\n\t\t * The arch code has something special to do before a\n\t\t * ptrace stop.  This is allowed to block, e.g. for faults\n\t\t * on user stack pages.  We can't keep the siglock while\n\t\t * calling arch_ptrace_stop, so we must release it now.\n\t\t * To preserve proper semantics, we must do this before\n\t\t * any signal bookkeeping like checking group_stop_count.\n\t\t * Meanwhile, a SIGKILL could come in before we retake the\n\t\t * siglock.  That must prevent us from sleeping in TASK_TRACED.\n\t\t * So after regaining the lock, we must check for SIGKILL.\n\t\t */\n\t\tspin_unlock_irq(&current->sighand->siglock);\n\t\tarch_ptrace_stop(exit_code, info);\n\t\tspin_lock_irq(&current->sighand->siglock);\n\t\tif (sigkill_pending(current))\n\t\t\treturn;\n\t}\n\n\tset_special_state(TASK_TRACED);\n\n\t/*\n\t * We're committing to trapping.  TRACED should be visible before\n\t * TRAPPING is cleared; otherwise, the tracer might fail do_wait().\n\t * Also, transition to TRACED and updates to ->jobctl should be\n\t * atomic with respect to siglock and should be done after the arch\n\t * hook as siglock is released and regrabbed across it.\n\t *\n\t *     TRACER\t\t\t\t    TRACEE\n\t *\n\t *     ptrace_attach()\n\t * [L]   wait_on_bit(JOBCTL_TRAPPING)\t[S] set_special_state(TRACED)\n\t *     do_wait()\n\t *       set_current_state()                smp_wmb();\n\t *       ptrace_do_wait()\n\t *         wait_task_stopped()\n\t *           task_stopped_code()\n\t * [L]         task_is_traced()\t\t[S] task_clear_jobctl_trapping();\n\t */\n\tsmp_wmb();\n\n\tcurrent->last_siginfo = info;\n\tcurrent->exit_code = exit_code;\n\n\t/*\n\t * If @why is CLD_STOPPED, we're trapping to participate in a group\n\t * stop.  Do the bookkeeping.  Note that if SIGCONT was delievered\n\t * across siglock relocks since INTERRUPT was scheduled, PENDING\n\t * could be clear now.  We act as if SIGCONT is received after\n\t * TASK_TRACED is entered - ignore it.\n\t */\n\tif (why == CLD_STOPPED && (current->jobctl & JOBCTL_STOP_PENDING))\n\t\tgstop_done = task_participate_group_stop(current);\n\n\t/* any trap clears pending STOP trap, STOP trap clears NOTIFY */\n\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_STOP);\n\tif (info && info->si_code >> 8 == PTRACE_EVENT_STOP)\n\t\ttask_clear_jobctl_pending(current, JOBCTL_TRAP_NOTIFY);\n\n\t/* entering a trap, clear TRAPPING */\n\ttask_clear_jobctl_trapping(current);\n\n\tspin_unlock_irq(&current->sighand->siglock);\n\tread_lock(&tasklist_lock);\n\tif (may_ptrace_stop()) {\n\t\t/*\n\t\t * Notify parents of the stop.\n\t\t *\n\t\t * While ptraced, there are two parents - the ptracer and\n\t\t * the real_parent of the group_leader.  The ptracer should\n\t\t * know about every stop while the real parent is only\n\t\t * interested in the completion of group stop.  The states\n\t\t * for the two don't interact with each other.  Notify\n\t\t * separately unless they're gonna be duplicates.\n\t\t */\n\t\tdo_notify_parent_cldstop(current, true, why);\n\t\tif (gstop_done && ptrace_reparented(current))\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/*\n\t\t * Don't want to allow preemption here, because\n\t\t * sys_ptrace() needs this task to be inactive.\n\t\t *\n\t\t * XXX: implement read_unlock_no_resched().\n\t\t */\n\t\tpreempt_disable();\n\t\tread_unlock(&tasklist_lock);\n\t\tpreempt_enable_no_resched();\n\t\tfreezable_schedule();\n\t} else {\n\t\t/*\n\t\t * By the time we got the lock, our tracer went away.\n\t\t * Don't drop the lock yet, another tracer may come.\n\t\t *\n\t\t * If @gstop_done, the ptracer went away between group stop\n\t\t * completion and here.  During detach, it would have set\n\t\t * JOBCTL_STOP_PENDING on us and we'll re-enter\n\t\t * TASK_STOPPED in do_signal_stop() on return, so notifying\n\t\t * the real parent of the group stop completion is enough.\n\t\t */\n\t\tif (gstop_done)\n\t\t\tdo_notify_parent_cldstop(current, false, why);\n\n\t\t/* tasklist protects us from ptrace_freeze_traced() */\n\t\t__set_current_state(TASK_RUNNING);\n\t\tif (clear_code)\n\t\t\tcurrent->exit_code = 0;\n\t\tread_unlock(&tasklist_lock);\n\t}\n\n\t/*\n\t * We are back.  Now reacquire the siglock before touching\n\t * last_siginfo, so that we are sure to have synchronized with\n\t * any signal-sending on another CPU that wants to examine it.\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tcurrent->last_siginfo = NULL;\n\n\t/* LISTENING can be set only during STOP traps, clear it */\n\tcurrent->jobctl &= ~JOBCTL_LISTENING;\n\n\t/*\n\t * Queued signals ignored us while we were stopped for tracing.\n\t * So check for any that we should take before resuming user mode.\n\t * This sets TIF_SIGPENDING, but never clears it.\n\t */\n\trecalc_sigpending_tsk(current);\n}"
  },
  {
    "function_name": "sigkill_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1957-1961",
    "snippet": "static bool sigkill_pending(struct task_struct *tsk)\n{\n\treturn sigismember(&tsk->pending.signal, SIGKILL) ||\n\t       sigismember(&tsk->signal->shared_pending.signal, SIGKILL);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigismember",
          "args": [
            "&tsk->signal->shared_pending.signal",
            "SIGKILL"
          ],
          "line": 1960
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigismember",
          "args": [
            "&tsk->pending.signal",
            "SIGKILL"
          ],
          "line": 1959
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool sigkill_pending(struct task_struct *tsk)\n{\n\treturn sigismember(&tsk->pending.signal, SIGKILL) ||\n\t       sigismember(&tsk->signal->shared_pending.signal, SIGKILL);\n}"
  },
  {
    "function_name": "may_ptrace_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1929-1951",
    "snippet": "static inline bool may_ptrace_stop(void)\n{\n\tif (!likely(current->ptrace))\n\t\treturn false;\n\t/*\n\t * Are we in the middle of do_coredump?\n\t * If so and our tracer is also part of the coredump stopping\n\t * is a deadlock situation, and pointless because our tracer\n\t * is dead so don't allow us to stop.\n\t * If SIGKILL was already sent before the caller unlocked\n\t * ->siglock we must see ->core_state != NULL. Otherwise it\n\t * is safe to enter schedule().\n\t *\n\t * This is almost outdated, a task with the pending SIGKILL can't\n\t * block in TASK_TRACED. But PTRACE_EVENT_EXIT can be reported\n\t * after SIGKILL was already dequeued.\n\t */\n\tif (unlikely(current->mm->core_state) &&\n\t    unlikely(current->mm == current->parent->mm))\n\t\treturn false;\n\n\treturn true;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->mm == current->parent->mm"
          ],
          "line": 1947
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "current->mm->core_state"
          ],
          "line": 1946
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "current->ptrace"
          ],
          "line": 1931
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool may_ptrace_stop(void)\n{\n\tif (!likely(current->ptrace))\n\t\treturn false;\n\t/*\n\t * Are we in the middle of do_coredump?\n\t * If so and our tracer is also part of the coredump stopping\n\t * is a deadlock situation, and pointless because our tracer\n\t * is dead so don't allow us to stop.\n\t * If SIGKILL was already sent before the caller unlocked\n\t * ->siglock we must see ->core_state != NULL. Otherwise it\n\t * is safe to enter schedule().\n\t *\n\t * This is almost outdated, a task with the pending SIGKILL can't\n\t * block in TASK_TRACED. But PTRACE_EVENT_EXIT can be reported\n\t * after SIGKILL was already dequeued.\n\t */\n\tif (unlikely(current->mm->core_state) &&\n\t    unlikely(current->mm == current->parent->mm))\n\t\treturn false;\n\n\treturn true;\n}"
  },
  {
    "function_name": "do_notify_parent_cldstop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1871-1927",
    "snippet": "static void do_notify_parent_cldstop(struct task_struct *tsk,\n\t\t\t\t     bool for_ptracer, int why)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\tu64 utime, stime;\n\n\tif (for_ptracer) {\n\t\tparent = tsk->parent;\n\t} else {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\t/*\n\t * see comment in do_notify_parent() about the following 4 lines\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime);\n\tinfo.si_stime = nsec_to_clock_t(stime);\n\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t/*\n\t * Even if SIGCHLD is not generated, we must wake up wait4 calls.\n\t */\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&sighand->siglock",
            "flags"
          ],
          "line": 1926
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wake_up_parent",
          "args": [
            "tsk",
            "parent"
          ],
          "line": 1925
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "1484-1488",
          "snippet": "void __wake_up_parent(struct task_struct *p, struct task_struct *parent)\n{\n\t__wake_up_sync_key(&parent->signal->wait_chldexit,\n\t\t\t\tTASK_INTERRUPTIBLE, 1, p);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __wake_up_parent(struct task_struct *p, struct task_struct *parent)\n{\n\t__wake_up_sync_key(&parent->signal->wait_chldexit,\n\t\t\t\tTASK_INTERRUPTIBLE, 1, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__group_send_sig_info",
          "args": [
            "SIGCHLD",
            "&info",
            "parent"
          ],
          "line": 1921
        },
        "resolved": true,
        "details": {
          "function_name": "__group_send_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1199-1203",
          "snippet": "int\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&sighand->siglock",
            "flags"
          ],
          "line": 1918
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG",
          "args": [],
          "line": 1914
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "nsec_to_clock_t",
          "args": [
            "stime"
          ],
          "line": 1900
        },
        "resolved": true,
        "details": {
          "function_name": "nsec_to_clock_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "735-749",
          "snippet": "u64 nsec_to_clock_t(u64 x)\n{\n#if (NSEC_PER_SEC % USER_HZ) == 0\n\treturn div_u64(x, NSEC_PER_SEC / USER_HZ);\n#elif (USER_HZ % 512) == 0\n\treturn div_u64(x * USER_HZ / 512, NSEC_PER_SEC / 512);\n#else\n\t/*\n         * max relative error 5.7e-8 (1.8s per year) for USER_HZ <= 1024,\n         * overflow after 64.99 years.\n         * exact for HZ=60, 72, 90, 120, 144, 180, 300, 600, 900, ...\n         */\n\treturn div_u64(x * 9, (9ull * NSEC_PER_SEC + (USER_HZ / 2)) / USER_HZ);\n#endif\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nu64 nsec_to_clock_t(u64 x)\n{\n#if (NSEC_PER_SEC % USER_HZ) == 0\n\treturn div_u64(x, NSEC_PER_SEC / USER_HZ);\n#elif (USER_HZ % 512) == 0\n\treturn div_u64(x * USER_HZ / 512, NSEC_PER_SEC / 512);\n#else\n\t/*\n         * max relative error 5.7e-8 (1.8s per year) for USER_HZ <= 1024,\n         * overflow after 64.99 years.\n         * exact for HZ=60, 72, 90, 120, 144, 180, 300, 600, 900, ...\n         */\n\treturn div_u64(x * 9, (9ull * NSEC_PER_SEC + (USER_HZ / 2)) / USER_HZ);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cputime",
          "args": [
            "tsk",
            "&utime",
            "&stime"
          ],
          "line": 1898
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "861-894",
          "snippet": "void task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping, nothing to add */\n\t\tif (vtime->state == VTIME_INACTIVE || is_idle_task(t))\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user or kernel space, add pending nohz time to\n\t\t * the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_USER || t->flags & PF_VCPU)\n\t\t\t*utime += vtime->utime + delta;\n\t\telse if (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping, nothing to add */\n\t\tif (vtime->state == VTIME_INACTIVE || is_idle_task(t))\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user or kernel space, add pending nohz time to\n\t\t * the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_USER || t->flags & PF_VCPU)\n\t\t\t*utime += vtime->utime + delta;\n\t\telse if (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1896
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "task_cred_xxx(parent, user_ns)",
            "task_uid(tsk)"
          ],
          "line": 1895
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_uid",
          "args": [
            "tsk"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cred_xxx",
          "args": [
            "parent",
            "user_ns"
          ],
          "line": 1895
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr_ns",
          "args": [
            "tsk",
            "task_active_pid_ns(parent)"
          ],
          "line": 1894
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "parent"
          ],
          "line": 1894
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "436-439",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1893
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 1887
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic void do_notify_parent_cldstop(struct task_struct *tsk,\n\t\t\t\t     bool for_ptracer, int why)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct task_struct *parent;\n\tstruct sighand_struct *sighand;\n\tu64 utime, stime;\n\n\tif (for_ptracer) {\n\t\tparent = tsk->parent;\n\t} else {\n\t\ttsk = tsk->group_leader;\n\t\tparent = tsk->real_parent;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGCHLD;\n\tinfo.si_errno = 0;\n\t/*\n\t * see comment in do_notify_parent() about the following 4 lines\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(parent, user_ns), task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime);\n\tinfo.si_stime = nsec_to_clock_t(stime);\n\n \tinfo.si_code = why;\n \tswitch (why) {\n \tcase CLD_CONTINUED:\n \t\tinfo.si_status = SIGCONT;\n \t\tbreak;\n \tcase CLD_STOPPED:\n \t\tinfo.si_status = tsk->signal->group_exit_code & 0x7f;\n \t\tbreak;\n \tcase CLD_TRAPPED:\n \t\tinfo.si_status = tsk->exit_code & 0x7f;\n \t\tbreak;\n \tdefault:\n \t\tBUG();\n \t}\n\n\tsighand = parent->sighand;\n\tspin_lock_irqsave(&sighand->siglock, flags);\n\tif (sighand->action[SIGCHLD-1].sa.sa_handler != SIG_IGN &&\n\t    !(sighand->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDSTOP))\n\t\t__group_send_sig_info(SIGCHLD, &info, parent);\n\t/*\n\t * Even if SIGCHLD is not generated, we must wake up wait4 calls.\n\t */\n\t__wake_up_parent(tsk, parent);\n\tspin_unlock_irqrestore(&sighand->siglock, flags);\n}"
  },
  {
    "function_name": "do_notify_parent",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1767-1856",
    "snippet": "bool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != tsk->parent->self_exec_id)\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\tif (valid_signal(sig) && sig)\n\t\t__group_send_sig_info(sig, &info, tsk->parent);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&psig->siglock",
            "flags"
          ],
          "line": 1853
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__wake_up_parent",
          "args": [
            "tsk",
            "tsk->parent"
          ],
          "line": 1852
        },
        "resolved": true,
        "details": {
          "function_name": "__wake_up_parent",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "1484-1488",
          "snippet": "void __wake_up_parent(struct task_struct *p, struct task_struct *parent)\n{\n\t__wake_up_sync_key(&parent->signal->wait_chldexit,\n\t\t\t\tTASK_INTERRUPTIBLE, 1, p);\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nvoid __wake_up_parent(struct task_struct *p, struct task_struct *parent)\n{\n\t__wake_up_sync_key(&parent->signal->wait_chldexit,\n\t\t\t\tTASK_INTERRUPTIBLE, 1, p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__group_send_sig_info",
          "args": [
            "sig",
            "&info",
            "tsk->parent"
          ],
          "line": 1851
        },
        "resolved": true,
        "details": {
          "function_name": "__group_send_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1199-1203",
          "snippet": "int\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_signal",
          "args": [
            "sig"
          ],
          "line": 1850
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&psig->siglock",
            "flags"
          ],
          "line": 1827
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "nsec_to_clock_t",
          "args": [
            "stime + tsk->signal->stime"
          ],
          "line": 1814
        },
        "resolved": true,
        "details": {
          "function_name": "nsec_to_clock_t",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/time.c",
          "lines": "735-749",
          "snippet": "u64 nsec_to_clock_t(u64 x)\n{\n#if (NSEC_PER_SEC % USER_HZ) == 0\n\treturn div_u64(x, NSEC_PER_SEC / USER_HZ);\n#elif (USER_HZ % 512) == 0\n\treturn div_u64(x * USER_HZ / 512, NSEC_PER_SEC / 512);\n#else\n\t/*\n         * max relative error 5.7e-8 (1.8s per year) for USER_HZ <= 1024,\n         * overflow after 64.99 years.\n         * exact for HZ=60, 72, 90, 120, 144, 180, 300, 600, 900, ...\n         */\n\treturn div_u64(x * 9, (9ull * NSEC_PER_SEC + (USER_HZ / 2)) / USER_HZ);\n#endif\n}",
          "includes": [
            "#include \"timekeeping.h\"",
            "#include <generated/timeconst.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compat.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/math64.h>",
            "#include <linux/fs.h>",
            "#include <linux/security.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/errno.h>",
            "#include <linux/timekeeper_internal.h>",
            "#include <linux/capability.h>",
            "#include <linux/timex.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"timekeeping.h\"\n#include <generated/timeconst.h>\n#include <asm/unistd.h>\n#include <linux/compat.h>\n#include <linux/uaccess.h>\n#include <linux/ptrace.h>\n#include <linux/math64.h>\n#include <linux/fs.h>\n#include <linux/security.h>\n#include <linux/syscalls.h>\n#include <linux/errno.h>\n#include <linux/timekeeper_internal.h>\n#include <linux/capability.h>\n#include <linux/timex.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nu64 nsec_to_clock_t(u64 x)\n{\n#if (NSEC_PER_SEC % USER_HZ) == 0\n\treturn div_u64(x, NSEC_PER_SEC / USER_HZ);\n#elif (USER_HZ % 512) == 0\n\treturn div_u64(x * USER_HZ / 512, NSEC_PER_SEC / 512);\n#else\n\t/*\n         * max relative error 5.7e-8 (1.8s per year) for USER_HZ <= 1024,\n         * overflow after 64.99 years.\n         * exact for HZ=60, 72, 90, 120, 144, 180, 300, 600, 900, ...\n         */\n\treturn div_u64(x * 9, (9ull * NSEC_PER_SEC + (USER_HZ / 2)) / USER_HZ);\n#endif\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_cputime",
          "args": [
            "tsk",
            "&utime",
            "&stime"
          ],
          "line": 1812
        },
        "resolved": true,
        "details": {
          "function_name": "task_cputime",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/cputime.c",
          "lines": "861-894",
          "snippet": "void task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping, nothing to add */\n\t\tif (vtime->state == VTIME_INACTIVE || is_idle_task(t))\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user or kernel space, add pending nohz time to\n\t\t * the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_USER || t->flags & PF_VCPU)\n\t\t\t*utime += vtime->utime + delta;\n\t\telse if (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid task_cputime(struct task_struct *t, u64 *utime, u64 *stime)\n{\n\tstruct vtime *vtime = &t->vtime;\n\tunsigned int seq;\n\tu64 delta;\n\n\tif (!vtime_accounting_enabled()) {\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\t\treturn;\n\t}\n\n\tdo {\n\t\tseq = read_seqcount_begin(&vtime->seqcount);\n\n\t\t*utime = t->utime;\n\t\t*stime = t->stime;\n\n\t\t/* Task is sleeping, nothing to add */\n\t\tif (vtime->state == VTIME_INACTIVE || is_idle_task(t))\n\t\t\tcontinue;\n\n\t\tdelta = vtime_delta(vtime);\n\n\t\t/*\n\t\t * Task runs either in user or kernel space, add pending nohz time to\n\t\t * the right place.\n\t\t */\n\t\tif (vtime->state == VTIME_USER || t->flags & PF_VCPU)\n\t\t\t*utime += vtime->utime + delta;\n\t\telse if (vtime->state == VTIME_SYS)\n\t\t\t*stime += vtime->stime + delta;\n\t} while (read_seqcount_retry(&vtime->seqcount, seq));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1810
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "task_cred_xxx(tsk->parent, user_ns)",
            "task_uid(tsk)"
          ],
          "line": 1808
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_uid",
          "args": [
            "tsk"
          ],
          "line": 1809
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cred_xxx",
          "args": [
            "tsk->parent",
            "user_ns"
          ],
          "line": 1808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_nr_ns",
          "args": [
            "tsk",
            "task_active_pid_ns(tsk->parent)"
          ],
          "line": 1807
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "tsk->parent"
          ],
          "line": 1807
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "436-439",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1806
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 1792
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk))"
          ],
          "line": 1780
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "tsk"
          ],
          "line": 1781
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "task_is_stopped_or_traced(tsk)"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_is_stopped_or_traced",
          "args": [
            "tsk"
          ],
          "line": 1778
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "sig == -1"
          ],
          "line": 1775
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nbool do_notify_parent(struct task_struct *tsk, int sig)\n{\n\tstruct kernel_siginfo info;\n\tunsigned long flags;\n\tstruct sighand_struct *psig;\n\tbool autoreap = false;\n\tu64 utime, stime;\n\n\tBUG_ON(sig == -1);\n\n \t/* do_notify_parent_cldstop should have been called instead.  */\n \tBUG_ON(task_is_stopped_or_traced(tsk));\n\n\tBUG_ON(!tsk->ptrace &&\n\t       (tsk->group_leader != tsk || !thread_group_empty(tsk)));\n\n\tif (sig != SIGCHLD) {\n\t\t/*\n\t\t * This is only possible if parent == real_parent.\n\t\t * Check if it has changed security domain.\n\t\t */\n\t\tif (tsk->parent_exec_id != tsk->parent->self_exec_id)\n\t\t\tsig = SIGCHLD;\n\t}\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\t/*\n\t * We are under tasklist_lock here so our parent is tied to\n\t * us and cannot change.\n\t *\n\t * task_active_pid_ns will always return the same pid namespace\n\t * until a task passes through release_task.\n\t *\n\t * write_lock() currently calls preempt_disable() which is the\n\t * same as rcu_read_lock(), but according to Oleg, this is not\n\t * correct to rely on this\n\t */\n\trcu_read_lock();\n\tinfo.si_pid = task_pid_nr_ns(tsk, task_active_pid_ns(tsk->parent));\n\tinfo.si_uid = from_kuid_munged(task_cred_xxx(tsk->parent, user_ns),\n\t\t\t\t       task_uid(tsk));\n\trcu_read_unlock();\n\n\ttask_cputime(tsk, &utime, &stime);\n\tinfo.si_utime = nsec_to_clock_t(utime + tsk->signal->utime);\n\tinfo.si_stime = nsec_to_clock_t(stime + tsk->signal->stime);\n\n\tinfo.si_status = tsk->exit_code & 0x7f;\n\tif (tsk->exit_code & 0x80)\n\t\tinfo.si_code = CLD_DUMPED;\n\telse if (tsk->exit_code & 0x7f)\n\t\tinfo.si_code = CLD_KILLED;\n\telse {\n\t\tinfo.si_code = CLD_EXITED;\n\t\tinfo.si_status = tsk->exit_code >> 8;\n\t}\n\n\tpsig = tsk->parent->sighand;\n\tspin_lock_irqsave(&psig->siglock, flags);\n\tif (!tsk->ptrace && sig == SIGCHLD &&\n\t    (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN ||\n\t     (psig->action[SIGCHLD-1].sa.sa_flags & SA_NOCLDWAIT))) {\n\t\t/*\n\t\t * We are exiting and our parent doesn't care.  POSIX.1\n\t\t * defines special semantics for setting SIGCHLD to SIG_IGN\n\t\t * or setting the SA_NOCLDWAIT flag: we should be reaped\n\t\t * automatically and not left for our parent's wait4 call.\n\t\t * Rather than having the parent do it as a magic kind of\n\t\t * signal handler, we just set this to tell do_exit that we\n\t\t * can be cleaned up without becoming a zombie.  Note that\n\t\t * we still call __wake_up_parent in this case, because a\n\t\t * blocked sys_wait4 might now return -ECHILD.\n\t\t *\n\t\t * Whether we send SIGCHLD or not for SA_NOCLDWAIT\n\t\t * is implementation-defined: we do (if you don't want\n\t\t * it, just use SIG_IGN instead).\n\t\t */\n\t\tautoreap = true;\n\t\tif (psig->action[SIGCHLD-1].sa.sa_handler == SIG_IGN)\n\t\t\tsig = 0;\n\t}\n\tif (valid_signal(sig) && sig)\n\t\t__group_send_sig_info(sig, &info, tsk->parent);\n\t__wake_up_parent(tsk, tsk->parent);\n\tspin_unlock_irqrestore(&psig->siglock, flags);\n\n\treturn autoreap;\n}"
  },
  {
    "function_name": "send_sigqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1712-1758",
    "snippet": "int send_sigqueue(struct sigqueue *q, struct pid *pid, enum pid_type type)\n{\n\tint sig = q->info.si_signo;\n\tstruct sigpending *pending;\n\tstruct task_struct *t;\n\tunsigned long flags;\n\tint ret, result;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\n\tret = -1;\n\trcu_read_lock();\n\tt = pid_task(pid, type);\n\tif (!t || !likely(lock_task_sighand(t, &flags)))\n\t\tgoto ret;\n\n\tret = 1; /* the signal is ignored */\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, false))\n\t\tgoto out;\n\n\tret = 0;\n\tif (unlikely(!list_empty(&q->list))) {\n\t\t/*\n\t\t * If an SI_TIMER entry is already queue just increment\n\t\t * the overrun count.\n\t\t */\n\t\tBUG_ON(q->info.si_code != SI_TIMER);\n\t\tq->info.si_overrun++;\n\t\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\t\tgoto out;\n\t}\n\tq->info.si_overrun = 0;\n\n\tsignalfd_notify(t, sig);\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\tlist_add_tail(&q->list, &pending->list);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, type);\n\tresult = TRACE_SIGNAL_DELIVERED;\nout:\n\ttrace_signal_generate(sig, &q->info, t, type != PIDTYPE_PID, result);\n\tunlock_task_sighand(t, &flags);\nret:\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1756
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "t",
            "&flags"
          ],
          "line": 1754
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "trace_signal_generate",
          "args": [
            "sig",
            "&q->info",
            "t",
            "type != PIDTYPE_PID",
            "result"
          ],
          "line": 1753
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete_signal",
          "args": [
            "sig",
            "t",
            "type"
          ],
          "line": 1750
        },
        "resolved": true,
        "details": {
          "function_name": "complete_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "931-1005",
          "snippet": "static void complete_signal(int sig, struct task_struct *p, enum pid_type type)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\n\t/*\n\t * Now find a thread we can wake up to take the signal off the queue.\n\t *\n\t * If the main thread wants the signal, it gets first crack.\n\t * Probably the least surprising to the average bear.\n\t */\n\tif (wants_signal(sig, p))\n\t\tt = p;\n\telse if ((type == PIDTYPE_PID) || thread_group_empty(p))\n\t\t/*\n\t\t * There is just one thread and it does not need to be woken.\n\t\t * It will dequeue unblocked signals before it runs again.\n\t\t */\n\t\treturn;\n\telse {\n\t\t/*\n\t\t * Otherwise try to find a suitable thread.\n\t\t */\n\t\tt = signal->curr_target;\n\t\twhile (!wants_signal(sig, t)) {\n\t\t\tt = next_thread(t);\n\t\t\tif (t == signal->curr_target)\n\t\t\t\t/*\n\t\t\t\t * No thread needs to be woken.\n\t\t\t\t * Any eligible threads will see\n\t\t\t\t * the signal in the queue soon.\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t}\n\t\tsignal->curr_target = t;\n\t}\n\n\t/*\n\t * Found a killable thread.  If the signal will be fatal,\n\t * then start taking the whole group down immediately.\n\t */\n\tif (sig_fatal(p, sig) &&\n\t    !(signal->flags & SIGNAL_GROUP_EXIT) &&\n\t    !sigismember(&t->real_blocked, sig) &&\n\t    (sig == SIGKILL || !p->ptrace)) {\n\t\t/*\n\t\t * This signal will be fatal to the whole group.\n\t\t */\n\t\tif (!sig_kernel_coredump(sig)) {\n\t\t\t/*\n\t\t\t * Start a group exit and wake everybody up.\n\t\t\t * This way we don't have other threads\n\t\t\t * running and doing things after a slower\n\t\t\t * thread has the fatal signal pending.\n\t\t\t */\n\t\t\tsignal->flags = SIGNAL_GROUP_EXIT;\n\t\t\tsignal->group_exit_code = sig;\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tt = p;\n\t\t\tdo {\n\t\t\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\t\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\t\t\tsignal_wake_up(t, 1);\n\t\t\t} while_each_thread(p, t);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * The signal is already in the shared-pending queue.\n\t * Tell the chosen thread to wake up and dequeue it.\n\t */\n\tsignal_wake_up(t, sig == SIGKILL);\n\treturn;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void complete_signal(int sig, struct task_struct *p, enum pid_type type)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\n\t/*\n\t * Now find a thread we can wake up to take the signal off the queue.\n\t *\n\t * If the main thread wants the signal, it gets first crack.\n\t * Probably the least surprising to the average bear.\n\t */\n\tif (wants_signal(sig, p))\n\t\tt = p;\n\telse if ((type == PIDTYPE_PID) || thread_group_empty(p))\n\t\t/*\n\t\t * There is just one thread and it does not need to be woken.\n\t\t * It will dequeue unblocked signals before it runs again.\n\t\t */\n\t\treturn;\n\telse {\n\t\t/*\n\t\t * Otherwise try to find a suitable thread.\n\t\t */\n\t\tt = signal->curr_target;\n\t\twhile (!wants_signal(sig, t)) {\n\t\t\tt = next_thread(t);\n\t\t\tif (t == signal->curr_target)\n\t\t\t\t/*\n\t\t\t\t * No thread needs to be woken.\n\t\t\t\t * Any eligible threads will see\n\t\t\t\t * the signal in the queue soon.\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t}\n\t\tsignal->curr_target = t;\n\t}\n\n\t/*\n\t * Found a killable thread.  If the signal will be fatal,\n\t * then start taking the whole group down immediately.\n\t */\n\tif (sig_fatal(p, sig) &&\n\t    !(signal->flags & SIGNAL_GROUP_EXIT) &&\n\t    !sigismember(&t->real_blocked, sig) &&\n\t    (sig == SIGKILL || !p->ptrace)) {\n\t\t/*\n\t\t * This signal will be fatal to the whole group.\n\t\t */\n\t\tif (!sig_kernel_coredump(sig)) {\n\t\t\t/*\n\t\t\t * Start a group exit and wake everybody up.\n\t\t\t * This way we don't have other threads\n\t\t\t * running and doing things after a slower\n\t\t\t * thread has the fatal signal pending.\n\t\t\t */\n\t\t\tsignal->flags = SIGNAL_GROUP_EXIT;\n\t\t\tsignal->group_exit_code = sig;\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tt = p;\n\t\t\tdo {\n\t\t\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\t\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\t\t\tsignal_wake_up(t, 1);\n\t\t\t} while_each_thread(p, t);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * The signal is already in the shared-pending queue.\n\t * Tell the chosen thread to wake up and dequeue it.\n\t */\n\tsignal_wake_up(t, sig == SIGKILL);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&pending->signal",
            "sig"
          ],
          "line": 1749
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&q->list",
            "&pending->list"
          ],
          "line": 1748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signalfd_notify",
          "args": [
            "t",
            "sig"
          ],
          "line": 1746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "q->info.si_code != SI_TIMER"
          ],
          "line": 1739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "!list_empty(&q->list)"
          ],
          "line": 1734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&q->list"
          ],
          "line": 1734
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_signal",
          "args": [
            "sig",
            "t",
            "false"
          ],
          "line": 1730
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "841-904",
          "snippet": "static bool prepare_signal(int sig, struct task_struct *p, bool force)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\tsigset_t flush;\n\n\tif (signal->flags & (SIGNAL_GROUP_EXIT | SIGNAL_GROUP_COREDUMP)) {\n\t\tif (!(signal->flags & SIGNAL_GROUP_EXIT))\n\t\t\treturn sig == SIGKILL;\n\t\t/*\n\t\t * The process is in the middle of dying, nothing to do.\n\t\t */\n\t} else if (sig_kernel_stop(sig)) {\n\t\t/*\n\t\t * This is a stop signal.  Remove SIGCONT from all queues.\n\t\t */\n\t\tsiginitset(&flush, sigmask(SIGCONT));\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t)\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t} else if (sig == SIGCONT) {\n\t\tunsigned int why;\n\t\t/*\n\t\t * Remove all stop signals from all queues, wake all threads.\n\t\t */\n\t\tsiginitset(&flush, SIG_KERNEL_STOP_MASK);\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t) {\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t\t\ttask_clear_jobctl_pending(t, JOBCTL_STOP_PENDING);\n\t\t\tif (likely(!(t->ptrace & PT_SEIZED)))\n\t\t\t\twake_up_state(t, __TASK_STOPPED);\n\t\t\telse\n\t\t\t\tptrace_trap_notify(t);\n\t\t}\n\n\t\t/*\n\t\t * Notify the parent with CLD_CONTINUED if we were stopped.\n\t\t *\n\t\t * If we were in the middle of a group stop, we pretend it\n\t\t * was already finished, and then continued. Since SIGCHLD\n\t\t * doesn't queue we report only CLD_STOPPED, as if the next\n\t\t * CLD_CONTINUED was dropped.\n\t\t */\n\t\twhy = 0;\n\t\tif (signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\twhy |= SIGNAL_CLD_CONTINUED;\n\t\telse if (signal->group_stop_count)\n\t\t\twhy |= SIGNAL_CLD_STOPPED;\n\n\t\tif (why) {\n\t\t\t/*\n\t\t\t * The first thread which returns from do_signal_stop()\n\t\t\t * will take ->siglock, notice SIGNAL_CLD_MASK, and\n\t\t\t * notify its parent. See get_signal().\n\t\t\t */\n\t\t\tsignal_set_stop_flags(signal, why | SIGNAL_STOP_CONTINUED);\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tsignal->group_exit_code = 0;\n\t\t}\n\t}\n\n\treturn !sig_ignored(p, sig, force);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool prepare_signal(int sig, struct task_struct *p, bool force)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\tsigset_t flush;\n\n\tif (signal->flags & (SIGNAL_GROUP_EXIT | SIGNAL_GROUP_COREDUMP)) {\n\t\tif (!(signal->flags & SIGNAL_GROUP_EXIT))\n\t\t\treturn sig == SIGKILL;\n\t\t/*\n\t\t * The process is in the middle of dying, nothing to do.\n\t\t */\n\t} else if (sig_kernel_stop(sig)) {\n\t\t/*\n\t\t * This is a stop signal.  Remove SIGCONT from all queues.\n\t\t */\n\t\tsiginitset(&flush, sigmask(SIGCONT));\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t)\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t} else if (sig == SIGCONT) {\n\t\tunsigned int why;\n\t\t/*\n\t\t * Remove all stop signals from all queues, wake all threads.\n\t\t */\n\t\tsiginitset(&flush, SIG_KERNEL_STOP_MASK);\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t) {\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t\t\ttask_clear_jobctl_pending(t, JOBCTL_STOP_PENDING);\n\t\t\tif (likely(!(t->ptrace & PT_SEIZED)))\n\t\t\t\twake_up_state(t, __TASK_STOPPED);\n\t\t\telse\n\t\t\t\tptrace_trap_notify(t);\n\t\t}\n\n\t\t/*\n\t\t * Notify the parent with CLD_CONTINUED if we were stopped.\n\t\t *\n\t\t * If we were in the middle of a group stop, we pretend it\n\t\t * was already finished, and then continued. Since SIGCHLD\n\t\t * doesn't queue we report only CLD_STOPPED, as if the next\n\t\t * CLD_CONTINUED was dropped.\n\t\t */\n\t\twhy = 0;\n\t\tif (signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\twhy |= SIGNAL_CLD_CONTINUED;\n\t\telse if (signal->group_stop_count)\n\t\t\twhy |= SIGNAL_CLD_STOPPED;\n\n\t\tif (why) {\n\t\t\t/*\n\t\t\t * The first thread which returns from do_signal_stop()\n\t\t\t * will take ->siglock, notice SIGNAL_CLD_MASK, and\n\t\t\t * notify its parent. See get_signal().\n\t\t\t */\n\t\t\tsignal_set_stop_flags(signal, why | SIGNAL_STOP_CONTINUED);\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tsignal->group_exit_code = 0;\n\t\t}\n\t}\n\n\treturn !sig_ignored(p, sig, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "lock_task_sighand(t, &flags)"
          ],
          "line": 1725
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "t",
            "&flags"
          ],
          "line": 1725
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1284-1314",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "pid",
            "type"
          ],
          "line": 1724
        },
        "resolved": true,
        "details": {
          "function_name": "get_pid_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "376-385",
          "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1723
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(q->flags & SIGQUEUE_PREALLOC)"
          ],
          "line": 1720
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint send_sigqueue(struct sigqueue *q, struct pid *pid, enum pid_type type)\n{\n\tint sig = q->info.si_signo;\n\tstruct sigpending *pending;\n\tstruct task_struct *t;\n\tunsigned long flags;\n\tint ret, result;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\n\tret = -1;\n\trcu_read_lock();\n\tt = pid_task(pid, type);\n\tif (!t || !likely(lock_task_sighand(t, &flags)))\n\t\tgoto ret;\n\n\tret = 1; /* the signal is ignored */\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t, false))\n\t\tgoto out;\n\n\tret = 0;\n\tif (unlikely(!list_empty(&q->list))) {\n\t\t/*\n\t\t * If an SI_TIMER entry is already queue just increment\n\t\t * the overrun count.\n\t\t */\n\t\tBUG_ON(q->info.si_code != SI_TIMER);\n\t\tq->info.si_overrun++;\n\t\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\t\tgoto out;\n\t}\n\tq->info.si_overrun = 0;\n\n\tsignalfd_notify(t, sig);\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\tlist_add_tail(&q->list, &pending->list);\n\tsigaddset(&pending->signal, sig);\n\tcomplete_signal(sig, t, type);\n\tresult = TRACE_SIGNAL_DELIVERED;\nout:\n\ttrace_signal_generate(sig, &q->info, t, type != PIDTYPE_PID, result);\n\tunlock_task_sighand(t, &flags);\nret:\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "sigqueue_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1687-1710",
    "snippet": "void sigqueue_free(struct sigqueue *q)\n{\n\tunsigned long flags;\n\tspinlock_t *lock = &current->sighand->siglock;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\t/*\n\t * We must hold ->siglock while testing q->list\n\t * to serialize with collect_signal() or with\n\t * __exit_signal()->flush_sigqueue().\n\t */\n\tspin_lock_irqsave(lock, flags);\n\tq->flags &= ~SIGQUEUE_PREALLOC;\n\t/*\n\t * If it is queued it will be freed when dequeued,\n\t * like the \"regular\" sigqueue.\n\t */\n\tif (!list_empty(&q->list))\n\t\tq = NULL;\n\tspin_unlock_irqrestore(lock, flags);\n\n\tif (q)\n\t\t__sigqueue_free(q);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sigqueue_free",
          "args": [
            "q"
          ],
          "line": 1709
        },
        "resolved": true,
        "details": {
          "function_name": "__sigqueue_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "436-443",
          "snippet": "static void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tatomic_dec(&q->user->sigpending);\n\tfree_uid(q->user);\n\tkmem_cache_free(sigqueue_cachep, q);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sigqueue_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nstatic void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tatomic_dec(&q->user->sigpending);\n\tfree_uid(q->user);\n\tkmem_cache_free(sigqueue_cachep, q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "lock",
            "flags"
          ],
          "line": 1706
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&q->list"
          ],
          "line": 1704
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "lock",
            "flags"
          ],
          "line": 1698
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "!(q->flags & SIGQUEUE_PREALLOC)"
          ],
          "line": 1692
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid sigqueue_free(struct sigqueue *q)\n{\n\tunsigned long flags;\n\tspinlock_t *lock = &current->sighand->siglock;\n\n\tBUG_ON(!(q->flags & SIGQUEUE_PREALLOC));\n\t/*\n\t * We must hold ->siglock while testing q->list\n\t * to serialize with collect_signal() or with\n\t * __exit_signal()->flush_sigqueue().\n\t */\n\tspin_lock_irqsave(lock, flags);\n\tq->flags &= ~SIGQUEUE_PREALLOC;\n\t/*\n\t * If it is queued it will be freed when dequeued,\n\t * like the \"regular\" sigqueue.\n\t */\n\tif (!list_empty(&q->list))\n\t\tq = NULL;\n\tspin_unlock_irqrestore(lock, flags);\n\n\tif (q)\n\t\t__sigqueue_free(q);\n}"
  },
  {
    "function_name": "sigqueue_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1677-1685",
    "snippet": "struct sigqueue *sigqueue_alloc(void)\n{\n\tstruct sigqueue *q = __sigqueue_alloc(-1, current, GFP_KERNEL, 0);\n\n\tif (q)\n\t\tq->flags |= SIGQUEUE_PREALLOC;\n\n\treturn q;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sigqueue_alloc",
          "args": [
            "-1",
            "current",
            "GFP_KERNEL",
            "0"
          ],
          "line": 1679
        },
        "resolved": true,
        "details": {
          "function_name": "__sigqueue_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "401-434",
          "snippet": "static struct sigqueue *\n__sigqueue_alloc(int sig, struct task_struct *t, gfp_t flags, int override_rlimit)\n{\n\tstruct sigqueue *q = NULL;\n\tstruct user_struct *user;\n\n\t/*\n\t * Protect access to @t credentials. This can go away when all\n\t * callers hold rcu read lock.\n\t */\n\trcu_read_lock();\n\tuser = get_uid(__task_cred(t)->user);\n\tatomic_inc(&user->sigpending);\n\trcu_read_unlock();\n\n\tif (override_rlimit ||\n\t    atomic_read(&user->sigpending) <=\n\t\t\ttask_rlimit(t, RLIMIT_SIGPENDING)) {\n\t\tq = kmem_cache_alloc(sigqueue_cachep, flags);\n\t} else {\n\t\tprint_dropped_signal(sig);\n\t}\n\n\tif (unlikely(q == NULL)) {\n\t\tatomic_dec(&user->sigpending);\n\t\tfree_uid(user);\n\t} else {\n\t\tINIT_LIST_HEAD(&q->list);\n\t\tq->flags = 0;\n\t\tq->user = user;\n\t}\n\n\treturn q;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sigqueue_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nstatic struct sigqueue *\n__sigqueue_alloc(int sig, struct task_struct *t, gfp_t flags, int override_rlimit)\n{\n\tstruct sigqueue *q = NULL;\n\tstruct user_struct *user;\n\n\t/*\n\t * Protect access to @t credentials. This can go away when all\n\t * callers hold rcu read lock.\n\t */\n\trcu_read_lock();\n\tuser = get_uid(__task_cred(t)->user);\n\tatomic_inc(&user->sigpending);\n\trcu_read_unlock();\n\n\tif (override_rlimit ||\n\t    atomic_read(&user->sigpending) <=\n\t\t\ttask_rlimit(t, RLIMIT_SIGPENDING)) {\n\t\tq = kmem_cache_alloc(sigqueue_cachep, flags);\n\t} else {\n\t\tprint_dropped_signal(sig);\n\t}\n\n\tif (unlikely(q == NULL)) {\n\t\tatomic_dec(&user->sigpending);\n\t\tfree_uid(user);\n\t} else {\n\t\tINIT_LIST_HEAD(&q->list);\n\t\tq->flags = 0;\n\t\tq->user = user;\n\t}\n\n\treturn q;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sigqueue *sigqueue_alloc(void)\n{\n\tstruct sigqueue *q = __sigqueue_alloc(-1, current, GFP_KERNEL, 0);\n\n\tif (q)\n\t\tq->flags |= SIGQUEUE_PREALLOC;\n\n\treturn q;\n}"
  },
  {
    "function_name": "kill_pid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1662-1665",
    "snippet": "int kill_pid(struct pid *pid, int sig, int priv)\n{\n\treturn kill_pid_info(sig, __si_special(priv), pid);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kill_pid_info",
          "args": [
            "sig",
            "__si_special(priv)",
            "pid"
          ],
          "line": 1664
        },
        "resolved": true,
        "details": {
          "function_name": "kill_pid_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1354-1374",
          "snippet": "int kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\terror = group_send_sig_info(sig, info, p, PIDTYPE_TGID);\n\t\trcu_read_unlock();\n\t\tif (likely(!p || error != -ESRCH))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * The task was unhashed in between, try again.  If it\n\t\t * is dead, pid_task() will return NULL, if we race with\n\t\t * de_thread() it will find the new leader.\n\t\t */\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\terror = group_send_sig_info(sig, info, p, PIDTYPE_TGID);\n\t\trcu_read_unlock();\n\t\tif (likely(!p || error != -ESRCH))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * The task was unhashed in between, try again.  If it\n\t\t * is dead, pid_task() will return NULL, if we race with\n\t\t * de_thread() it will find the new leader.\n\t\t */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "__si_special",
          "args": [
            "priv"
          ],
          "line": 1664
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint kill_pid(struct pid *pid, int sig, int priv)\n{\n\treturn kill_pid_info(sig, __si_special(priv), pid);\n}"
  },
  {
    "function_name": "kill_pgrp",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1650-1659",
    "snippet": "int kill_pgrp(struct pid *pid, int sig, int priv)\n{\n\tint ret;\n\n\tread_lock(&tasklist_lock);\n\tret = __kill_pgrp_info(sig, __si_special(priv), pid);\n\tread_unlock(&tasklist_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1656
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "__kill_pgrp_info",
          "args": [
            "sig",
            "__si_special(priv)",
            "pid"
          ],
          "line": 1655
        },
        "resolved": true,
        "details": {
          "function_name": "__kill_pgrp_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1339-1352",
          "snippet": "int __kill_pgrp_info(int sig, struct kernel_siginfo *info, struct pid *pgrp)\n{\n\tstruct task_struct *p = NULL;\n\tint retval, success;\n\n\tsuccess = 0;\n\tretval = -ESRCH;\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tint err = group_send_sig_info(sig, info, p, PIDTYPE_PGID);\n\t\tsuccess |= !err;\n\t\tretval = err;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\treturn success ? 0 : retval;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint __kill_pgrp_info(int sig, struct kernel_siginfo *info, struct pid *pgrp)\n{\n\tstruct task_struct *p = NULL;\n\tint retval, success;\n\n\tsuccess = 0;\n\tretval = -ESRCH;\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tint err = group_send_sig_info(sig, info, p, PIDTYPE_PGID);\n\t\tsuccess |= !err;\n\t\tretval = err;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\treturn success ? 0 : retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "__si_special",
          "args": [
            "priv"
          ],
          "line": 1655
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1654
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint kill_pgrp(struct pid *pid, int sig, int priv)\n{\n\tint ret;\n\n\tread_lock(&tasklist_lock);\n\tret = __kill_pgrp_info(sig, __si_special(priv), pid);\n\tread_unlock(&tasklist_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "force_sig_ptrace_errno_trap",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1638-1648",
    "snippet": "int force_sig_ptrace_errno_trap(int errno, void __user *addr)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_errno = errno;\n\tinfo.si_code  = TRAP_HWBKPT;\n\tinfo.si_addr  = addr;\n\treturn force_sig_info(info.si_signo, &info, current);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_info",
          "args": [
            "info.si_signo",
            "&info",
            "current"
          ],
          "line": 1647
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1230-1258",
          "snippet": "int\nforce_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *t)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint\nforce_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *t)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 1642
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint force_sig_ptrace_errno_trap(int errno, void __user *addr)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_errno = errno;\n\tinfo.si_code  = TRAP_HWBKPT;\n\tinfo.si_addr  = addr;\n\treturn force_sig_info(info.si_signo, &info, current);\n}"
  },
  {
    "function_name": "force_sig_pkuerr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1621-1632",
    "snippet": "int force_sig_pkuerr(void __user *addr, u32 pkey)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGSEGV;\n\tinfo.si_errno = 0;\n\tinfo.si_code  = SEGV_PKUERR;\n\tinfo.si_addr  = addr;\n\tinfo.si_pkey  = pkey;\n\treturn force_sig_info(info.si_signo, &info, current);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_info",
          "args": [
            "info.si_signo",
            "&info",
            "current"
          ],
          "line": 1631
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1230-1258",
          "snippet": "int\nforce_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *t)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint\nforce_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *t)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 1625
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint force_sig_pkuerr(void __user *addr, u32 pkey)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGSEGV;\n\tinfo.si_errno = 0;\n\tinfo.si_code  = SEGV_PKUERR;\n\tinfo.si_addr  = addr;\n\tinfo.si_pkey  = pkey;\n\treturn force_sig_info(info.si_signo, &info, current);\n}"
  },
  {
    "function_name": "force_sig_bnderr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1606-1618",
    "snippet": "int force_sig_bnderr(void __user *addr, void __user *lower, void __user *upper)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGSEGV;\n\tinfo.si_errno = 0;\n\tinfo.si_code  = SEGV_BNDERR;\n\tinfo.si_addr  = addr;\n\tinfo.si_lower = lower;\n\tinfo.si_upper = upper;\n\treturn force_sig_info(info.si_signo, &info, current);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_info",
          "args": [
            "info.si_signo",
            "&info",
            "current"
          ],
          "line": 1617
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1230-1258",
          "snippet": "int\nforce_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *t)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint\nforce_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *t)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 1610
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint force_sig_bnderr(void __user *addr, void __user *lower, void __user *upper)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGSEGV;\n\tinfo.si_errno = 0;\n\tinfo.si_code  = SEGV_BNDERR;\n\tinfo.si_addr  = addr;\n\tinfo.si_lower = lower;\n\tinfo.si_upper = upper;\n\treturn force_sig_info(info.si_signo, &info, current);\n}"
  },
  {
    "function_name": "send_sig_mceerr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1591-1603",
    "snippet": "int send_sig_mceerr(int code, void __user *addr, short lsb, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\n\tWARN_ON((code != BUS_MCEERR_AO) && (code != BUS_MCEERR_AR));\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGBUS;\n\tinfo.si_errno = 0;\n\tinfo.si_code = code;\n\tinfo.si_addr = addr;\n\tinfo.si_addr_lsb = lsb;\n\treturn send_sig_info(info.si_signo, &info, t);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_sig_info",
          "args": [
            "info.si_signo",
            "&info",
            "t"
          ],
          "line": 1602
        },
        "resolved": true,
        "details": {
          "function_name": "send_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1485-1495",
          "snippet": "int send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 1596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "(code != BUS_MCEERR_AO) && (code != BUS_MCEERR_AR)"
          ],
          "line": 1595
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint send_sig_mceerr(int code, void __user *addr, short lsb, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\n\tWARN_ON((code != BUS_MCEERR_AO) && (code != BUS_MCEERR_AR));\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGBUS;\n\tinfo.si_errno = 0;\n\tinfo.si_code = code;\n\tinfo.si_addr = addr;\n\tinfo.si_addr_lsb = lsb;\n\treturn send_sig_info(info.si_signo, &info, t);\n}"
  },
  {
    "function_name": "force_sig_mceerr",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1577-1589",
    "snippet": "int force_sig_mceerr(int code, void __user *addr, short lsb, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\n\tWARN_ON((code != BUS_MCEERR_AO) && (code != BUS_MCEERR_AR));\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGBUS;\n\tinfo.si_errno = 0;\n\tinfo.si_code = code;\n\tinfo.si_addr = addr;\n\tinfo.si_addr_lsb = lsb;\n\treturn force_sig_info(info.si_signo, &info, t);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_info",
          "args": [
            "info.si_signo",
            "&info",
            "t"
          ],
          "line": 1588
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1230-1258",
          "snippet": "int\nforce_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *t)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint\nforce_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *t)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&info"
          ],
          "line": 1582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON",
          "args": [
            "(code != BUS_MCEERR_AO) && (code != BUS_MCEERR_AR)"
          ],
          "line": 1581
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint force_sig_mceerr(int code, void __user *addr, short lsb, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\n\tWARN_ON((code != BUS_MCEERR_AO) && (code != BUS_MCEERR_AR));\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGBUS;\n\tinfo.si_errno = 0;\n\tinfo.si_code = code;\n\tinfo.si_addr = addr;\n\tinfo.si_addr_lsb = lsb;\n\treturn force_sig_info(info.si_signo, &info, t);\n}"
  },
  {
    "function_name": "force_sigsegv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1520-1529",
    "snippet": "void force_sigsegv(int sig, struct task_struct *p)\n{\n\tif (sig == SIGSEGV) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&p->sighand->siglock, flags);\n\t\tp->sighand->action[sig - 1].sa.sa_handler = SIG_DFL;\n\t\tspin_unlock_irqrestore(&p->sighand->siglock, flags);\n\t}\n\tforce_sig(SIGSEGV, p);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig",
          "args": [
            "SIGSEGV",
            "p"
          ],
          "line": 1528
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_ptrace_errno_trap",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1638-1648",
          "snippet": "int force_sig_ptrace_errno_trap(int errno, void __user *addr)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_errno = errno;\n\tinfo.si_code  = TRAP_HWBKPT;\n\tinfo.si_addr  = addr;\n\treturn force_sig_info(info.si_signo, &info, current);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint force_sig_ptrace_errno_trap(int errno, void __user *addr)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = SIGTRAP;\n\tinfo.si_errno = errno;\n\tinfo.si_code  = TRAP_HWBKPT;\n\tinfo.si_addr  = addr;\n\treturn force_sig_info(info.si_signo, &info, current);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&p->sighand->siglock",
            "flags"
          ],
          "line": 1526
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&p->sighand->siglock",
            "flags"
          ],
          "line": 1524
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid force_sigsegv(int sig, struct task_struct *p)\n{\n\tif (sig == SIGSEGV) {\n\t\tunsigned long flags;\n\t\tspin_lock_irqsave(&p->sighand->siglock, flags);\n\t\tp->sighand->action[sig - 1].sa.sa_handler = SIG_DFL;\n\t\tspin_unlock_irqrestore(&p->sighand->siglock, flags);\n\t}\n\tforce_sig(SIGSEGV, p);\n}"
  },
  {
    "function_name": "force_sig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1508-1511",
    "snippet": "void force_sig(int sig, struct task_struct *p)\n{\n\tforce_sig_info(sig, SEND_SIG_PRIV, p);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "force_sig_info",
          "args": [
            "sig",
            "SEND_SIG_PRIV",
            "p"
          ],
          "line": 1510
        },
        "resolved": true,
        "details": {
          "function_name": "force_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1230-1258",
          "snippet": "int\nforce_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *t)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint\nforce_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *t)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid force_sig(int sig, struct task_struct *p)\n{\n\tforce_sig_info(sig, SEND_SIG_PRIV, p);\n}"
  },
  {
    "function_name": "send_sig",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1501-1505",
    "snippet": "int\nsend_sig(int sig, struct task_struct *p, int priv)\n{\n\treturn send_sig_info(sig, __si_special(priv), p);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_sig_info",
          "args": [
            "sig",
            "__si_special(priv)",
            "p"
          ],
          "line": 1504
        },
        "resolved": true,
        "details": {
          "function_name": "send_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1485-1495",
          "snippet": "int send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, PIDTYPE_PID);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, PIDTYPE_PID);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__si_special",
          "args": [
            "priv"
          ],
          "line": 1504
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint\nsend_sig(int sig, struct task_struct *p, int priv)\n{\n\treturn send_sig_info(sig, __si_special(priv), p);\n}"
  },
  {
    "function_name": "send_sig_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1485-1495",
    "snippet": "int send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, PIDTYPE_PID);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_send_sig_info",
          "args": [
            "sig",
            "info",
            "p",
            "PIDTYPE_PID"
          ],
          "line": 1494
        },
        "resolved": true,
        "details": {
          "function_name": "do_send_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1205-1217",
          "snippet": "int do_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p,\n\t\t\tenum pid_type type)\n{\n\tunsigned long flags;\n\tint ret = -ESRCH;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tret = send_signal(sig, info, p, type);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint do_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p,\n\t\t\tenum pid_type type)\n{\n\tunsigned long flags;\n\tint ret = -ESRCH;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tret = send_signal(sig, info, p, type);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_signal",
          "args": [
            "sig"
          ],
          "line": 1491
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\t/*\n\t * Make sure legacy kernel users don't send in bad values\n\t * (normal paths check this in check_kill_permission).\n\t */\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\treturn do_send_sig_info(sig, info, p, PIDTYPE_PID);\n}"
  },
  {
    "function_name": "kill_something_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1441-1479",
    "snippet": "static int kill_something_info(int sig, struct kernel_siginfo *info, pid_t pid)\n{\n\tint ret;\n\n\tif (pid > 0) {\n\t\trcu_read_lock();\n\t\tret = kill_pid_info(sig, info, find_vpid(pid));\n\t\trcu_read_unlock();\n\t\treturn ret;\n\t}\n\n\t/* -INT_MIN is undefined.  Exclude this case to avoid a UBSAN warning */\n\tif (pid == INT_MIN)\n\t\treturn -ESRCH;\n\n\tread_lock(&tasklist_lock);\n\tif (pid != -1) {\n\t\tret = __kill_pgrp_info(sig, info,\n\t\t\t\tpid ? find_vpid(-pid) : task_pgrp(current));\n\t} else {\n\t\tint retval = 0, count = 0;\n\t\tstruct task_struct * p;\n\n\t\tfor_each_process(p) {\n\t\t\tif (task_pid_vnr(p) > 1 &&\n\t\t\t\t\t!same_thread_group(p, current)) {\n\t\t\t\tint err = group_send_sig_info(sig, info, p,\n\t\t\t\t\t\t\t      PIDTYPE_MAX);\n\t\t\t\t++count;\n\t\t\t\tif (err != -EPERM)\n\t\t\t\t\tretval = err;\n\t\t\t}\n\t\t}\n\t\tret = count ? retval : -ESRCH;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "read_unlock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1476
        },
        "resolved": true,
        "details": {
          "function_name": "tasks_perf_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcuperf.c",
          "lines": "287-289",
          "snippet": "static void tasks_perf_read_unlock(int idx)\n{\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/vmalloc.h>",
            "#include <linux/torture.h>",
            "#include <asm/byteorder.h>",
            "#include <linux/slab.h>",
            "#include <linux/srcu.h>",
            "#include <linux/stat.h>",
            "#include <linux/delay.h>",
            "#include <linux/cpu.h>",
            "#include <linux/freezer.h>",
            "#include <linux/reboot.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/completion.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/rcupdate.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/err.h>",
            "#include <linux/kthread.h>",
            "#include <linux/module.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/vmalloc.h>\n#include <linux/torture.h>\n#include <asm/byteorder.h>\n#include <linux/slab.h>\n#include <linux/srcu.h>\n#include <linux/stat.h>\n#include <linux/delay.h>\n#include <linux/cpu.h>\n#include <linux/freezer.h>\n#include <linux/reboot.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/moduleparam.h>\n#include <linux/completion.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <uapi/linux/sched/types.h>\n#include <linux/sched.h>\n#include <linux/interrupt.h>\n#include <linux/rcupdate.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/err.h>\n#include <linux/kthread.h>\n#include <linux/module.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nstatic void tasks_perf_read_unlock(int idx)\n{\n}"
        }
      },
      {
        "call_info": {
          "callee": "group_send_sig_info",
          "args": [
            "sig",
            "info",
            "p",
            "PIDTYPE_MAX"
          ],
          "line": 1467
        },
        "resolved": true,
        "details": {
          "function_name": "group_send_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1319-1332",
          "snippet": "int group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\tstruct task_struct *p, enum pid_type type)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, type);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\tstruct task_struct *p, enum pid_type type)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, type);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "p",
            "current"
          ],
          "line": 1466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_pid_vnr",
          "args": [
            "p"
          ],
          "line": 1465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__kill_pgrp_info",
          "args": [
            "sig",
            "info",
            "pid ? find_vpid(-pid) : task_pgrp(current)"
          ],
          "line": 1458
        },
        "resolved": true,
        "details": {
          "function_name": "__kill_pgrp_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1339-1352",
          "snippet": "int __kill_pgrp_info(int sig, struct kernel_siginfo *info, struct pid *pgrp)\n{\n\tstruct task_struct *p = NULL;\n\tint retval, success;\n\n\tsuccess = 0;\n\tretval = -ESRCH;\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tint err = group_send_sig_info(sig, info, p, PIDTYPE_PGID);\n\t\tsuccess |= !err;\n\t\tretval = err;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\treturn success ? 0 : retval;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint __kill_pgrp_info(int sig, struct kernel_siginfo *info, struct pid *pgrp)\n{\n\tstruct task_struct *p = NULL;\n\tint retval, success;\n\n\tsuccess = 0;\n\tretval = -ESRCH;\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tint err = group_send_sig_info(sig, info, p, PIDTYPE_PGID);\n\t\tsuccess |= !err;\n\t\tretval = err;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\treturn success ? 0 : retval;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pgrp",
          "args": [
            "current"
          ],
          "line": 1459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "find_vpid",
          "args": [
            "-pid"
          ],
          "line": 1459
        },
        "resolved": true,
        "details": {
          "function_name": "find_vpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "262-265",
          "snippet": "struct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "read_lock",
          "args": [
            "&tasklist_lock"
          ],
          "line": 1456
        },
        "resolved": true,
        "details": {
          "function_name": "usermodehelper_read_lock_wait",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/umh.c",
          "lines": "258-282",
          "snippet": "long usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}",
          "includes": [
            "#include <trace/events/module.h>",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/shmem_fs.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/async.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/rwsem.h>",
            "#include <linux/suspend.h>",
            "#include <linux/notifier.h>",
            "#include <linux/resource.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/mount.h>",
            "#include <linux/security.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/cred.h>",
            "#include <linux/completion.h>",
            "#include <linux/slab.h>",
            "#include <linux/kmod.h>",
            "#include <linux/unistd.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched.h>",
            "#include <linux/module.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DECLARE_RWSEM(umhelper_sem);",
            "static enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;",
            "static DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/module.h>\n#include <linux/pipe_fs_i.h>\n#include <linux/shmem_fs.h>\n#include <linux/uaccess.h>\n#include <linux/async.h>\n#include <linux/ptrace.h>\n#include <linux/rwsem.h>\n#include <linux/suspend.h>\n#include <linux/notifier.h>\n#include <linux/resource.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/mount.h>\n#include <linux/security.h>\n#include <linux/workqueue.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/cred.h>\n#include <linux/completion.h>\n#include <linux/slab.h>\n#include <linux/kmod.h>\n#include <linux/unistd.h>\n#include <linux/syscalls.h>\n#include <linux/binfmts.h>\n#include <linux/sched/task.h>\n#include <linux/sched.h>\n#include <linux/module.h>\n\nstatic DECLARE_RWSEM(umhelper_sem);\nstatic enum umh_disable_depth usermodehelper_disabled = UMH_DISABLED;\nstatic DECLARE_WAIT_QUEUE_HEAD(usermodehelper_disabled_waitq);\n\nlong usermodehelper_read_lock_wait(long timeout)\n{\n\tDEFINE_WAIT(wait);\n\n\tif (timeout < 0)\n\t\treturn -EINVAL;\n\n\tdown_read(&umhelper_sem);\n\tfor (;;) {\n\t\tprepare_to_wait(&usermodehelper_disabled_waitq, &wait,\n\t\t\t\tTASK_UNINTERRUPTIBLE);\n\t\tif (!usermodehelper_disabled)\n\t\t\tbreak;\n\n\t\tup_read(&umhelper_sem);\n\n\t\ttimeout = schedule_timeout(timeout);\n\t\tif (!timeout)\n\t\t\tbreak;\n\n\t\tdown_read(&umhelper_sem);\n\t}\n\tfinish_wait(&usermodehelper_disabled_waitq, &wait);\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1448
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_pid_info",
          "args": [
            "sig",
            "info",
            "find_vpid(pid)"
          ],
          "line": 1447
        },
        "resolved": true,
        "details": {
          "function_name": "kill_pid_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1354-1374",
          "snippet": "int kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\terror = group_send_sig_info(sig, info, p, PIDTYPE_TGID);\n\t\trcu_read_unlock();\n\t\tif (likely(!p || error != -ESRCH))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * The task was unhashed in between, try again.  If it\n\t\t * is dead, pid_task() will return NULL, if we race with\n\t\t * de_thread() it will find the new leader.\n\t\t */\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\terror = group_send_sig_info(sig, info, p, PIDTYPE_TGID);\n\t\trcu_read_unlock();\n\t\tif (likely(!p || error != -ESRCH))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * The task was unhashed in between, try again.  If it\n\t\t * is dead, pid_task() will return NULL, if we race with\n\t\t * de_thread() it will find the new leader.\n\t\t */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1446
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int kill_something_info(int sig, struct kernel_siginfo *info, pid_t pid)\n{\n\tint ret;\n\n\tif (pid > 0) {\n\t\trcu_read_lock();\n\t\tret = kill_pid_info(sig, info, find_vpid(pid));\n\t\trcu_read_unlock();\n\t\treturn ret;\n\t}\n\n\t/* -INT_MIN is undefined.  Exclude this case to avoid a UBSAN warning */\n\tif (pid == INT_MIN)\n\t\treturn -ESRCH;\n\n\tread_lock(&tasklist_lock);\n\tif (pid != -1) {\n\t\tret = __kill_pgrp_info(sig, info,\n\t\t\t\tpid ? find_vpid(-pid) : task_pgrp(current));\n\t} else {\n\t\tint retval = 0, count = 0;\n\t\tstruct task_struct * p;\n\n\t\tfor_each_process(p) {\n\t\t\tif (task_pid_vnr(p) > 1 &&\n\t\t\t\t\t!same_thread_group(p, current)) {\n\t\t\t\tint err = group_send_sig_info(sig, info, p,\n\t\t\t\t\t\t\t      PIDTYPE_MAX);\n\t\t\t\t++count;\n\t\t\t\tif (err != -EPERM)\n\t\t\t\t\tretval = err;\n\t\t\t}\n\t\t}\n\t\tret = count ? retval : -ESRCH;\n\t}\n\tread_unlock(&tasklist_lock);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kill_pid_info_as_cred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1397-1431",
    "snippet": "int kill_pid_info_as_cred(int sig, struct kernel_siginfo *info, struct pid *pid,\n\t\t\t const struct cred *cred)\n{\n\tint ret = -EINVAL;\n\tstruct task_struct *p;\n\tunsigned long flags;\n\n\tif (!valid_signal(sig))\n\t\treturn ret;\n\n\trcu_read_lock();\n\tp = pid_task(pid, PIDTYPE_PID);\n\tif (!p) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\tif (si_fromuser(info) && !kill_as_cred_perm(cred, p)) {\n\t\tret = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\tret = security_task_kill(p, info, sig, cred);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (sig) {\n\t\tif (lock_task_sighand(p, &flags)) {\n\t\t\tret = __send_signal(sig, info, p, PIDTYPE_TGID, 0);\n\t\t\tunlock_task_sighand(p, &flags);\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\nout_unlock:\n\trcu_read_unlock();\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1429
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 1424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__send_signal",
          "args": [
            "sig",
            "info",
            "p",
            "PIDTYPE_TGID",
            "0"
          ],
          "line": 1423
        },
        "resolved": true,
        "details": {
          "function_name": "__send_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1033-1151",
          "snippet": "static int __send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type, int from_ancestor_ns)\n{\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint override_rlimit;\n\tint ret = 0, result;\n\n\tassert_spin_locked(&t->sighand->siglock);\n\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t,\n\t\t\tfrom_ancestor_ns || (info == SEND_SIG_PRIV)))\n\t\tgoto ret;\n\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\t/*\n\t * Short-circuit ignored signals and support queuing\n\t * exactly one non-rt signal, so that we can get more\n\t * detailed information about the cause of the signal.\n\t */\n\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\tif (legacy_queue(pending, sig))\n\t\tgoto ret;\n\n\tresult = TRACE_SIGNAL_DELIVERED;\n\t/*\n\t * Skip useless siginfo allocation for SIGKILL SIGSTOP,\n\t * and kernel threads.\n\t */\n\tif (sig_kernel_only(sig) || (t->flags & PF_KTHREAD))\n\t\tgoto out_set;\n\n\t/*\n\t * Real-time signals must be queued if sent by sigqueue, or\n\t * some other real-time mechanism.  It is implementation\n\t * defined whether kill() does so.  We attempt to do so, on\n\t * the principle of least surprise, but since kill is not\n\t * allowed to fail with EAGAIN when low on memory we just\n\t * make sure at least one signal gets delivered and don't\n\t * pass on the info struct.\n\t */\n\tif (sig < SIGRTMIN)\n\t\toverride_rlimit = (is_si_special(info) || info->si_code >= 0);\n\telse\n\t\toverride_rlimit = 0;\n\n\tq = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit);\n\tif (q) {\n\t\tlist_add_tail(&q->list, &pending->list);\n\t\tswitch ((unsigned long) info) {\n\t\tcase (unsigned long) SEND_SIG_NOINFO:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_USER;\n\t\t\tq->info.si_pid = task_tgid_nr_ns(current,\n\t\t\t\t\t\t\ttask_active_pid_ns(t));\n\t\t\tq->info.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\t\t\tbreak;\n\t\tcase (unsigned long) SEND_SIG_PRIV:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_KERNEL;\n\t\t\tq->info.si_pid = 0;\n\t\t\tq->info.si_uid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcopy_siginfo(&q->info, info);\n\t\t\tif (from_ancestor_ns)\n\t\t\t\tq->info.si_pid = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tuserns_fixup_signal_uid(&q->info, t);\n\n\t} else if (!is_si_special(info)) {\n\t\tif (sig >= SIGRTMIN && info->si_code != SI_USER) {\n\t\t\t/*\n\t\t\t * Queue overflow, abort.  We may abort if the\n\t\t\t * signal was rt and sent by user using something\n\t\t\t * other than kill().\n\t\t\t */\n\t\t\tresult = TRACE_SIGNAL_OVERFLOW_FAIL;\n\t\t\tret = -EAGAIN;\n\t\t\tgoto ret;\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is a silent loss of information.  We still\n\t\t\t * send the signal, but the *info bits are lost.\n\t\t\t */\n\t\t\tresult = TRACE_SIGNAL_LOSE_INFO;\n\t\t}\n\t}\n\nout_set:\n\tsignalfd_notify(t, sig);\n\tsigaddset(&pending->signal, sig);\n\n\t/* Let multiprocess signals appear after on-going forks */\n\tif (type > PIDTYPE_TGID) {\n\t\tstruct multiprocess_signals *delayed;\n\t\thlist_for_each_entry(delayed, &t->signal->multiprocess, node) {\n\t\t\tsigset_t *signal = &delayed->signal;\n\t\t\t/* Can't queue both a stop and a continue signal */\n\t\t\tif (sig == SIGCONT)\n\t\t\t\tsigdelsetmask(signal, SIG_KERNEL_STOP_MASK);\n\t\t\telse if (sig_kernel_stop(sig))\n\t\t\t\tsigdelset(signal, SIGCONT);\n\t\t\tsigaddset(signal, sig);\n\t\t}\n\t}\n\n\tcomplete_signal(sig, t, type);\nret:\n\ttrace_signal_generate(sig, info, t, type != PIDTYPE_PID, result);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int __send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type, int from_ancestor_ns)\n{\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint override_rlimit;\n\tint ret = 0, result;\n\n\tassert_spin_locked(&t->sighand->siglock);\n\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t,\n\t\t\tfrom_ancestor_ns || (info == SEND_SIG_PRIV)))\n\t\tgoto ret;\n\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\t/*\n\t * Short-circuit ignored signals and support queuing\n\t * exactly one non-rt signal, so that we can get more\n\t * detailed information about the cause of the signal.\n\t */\n\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\tif (legacy_queue(pending, sig))\n\t\tgoto ret;\n\n\tresult = TRACE_SIGNAL_DELIVERED;\n\t/*\n\t * Skip useless siginfo allocation for SIGKILL SIGSTOP,\n\t * and kernel threads.\n\t */\n\tif (sig_kernel_only(sig) || (t->flags & PF_KTHREAD))\n\t\tgoto out_set;\n\n\t/*\n\t * Real-time signals must be queued if sent by sigqueue, or\n\t * some other real-time mechanism.  It is implementation\n\t * defined whether kill() does so.  We attempt to do so, on\n\t * the principle of least surprise, but since kill is not\n\t * allowed to fail with EAGAIN when low on memory we just\n\t * make sure at least one signal gets delivered and don't\n\t * pass on the info struct.\n\t */\n\tif (sig < SIGRTMIN)\n\t\toverride_rlimit = (is_si_special(info) || info->si_code >= 0);\n\telse\n\t\toverride_rlimit = 0;\n\n\tq = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit);\n\tif (q) {\n\t\tlist_add_tail(&q->list, &pending->list);\n\t\tswitch ((unsigned long) info) {\n\t\tcase (unsigned long) SEND_SIG_NOINFO:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_USER;\n\t\t\tq->info.si_pid = task_tgid_nr_ns(current,\n\t\t\t\t\t\t\ttask_active_pid_ns(t));\n\t\t\tq->info.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\t\t\tbreak;\n\t\tcase (unsigned long) SEND_SIG_PRIV:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_KERNEL;\n\t\t\tq->info.si_pid = 0;\n\t\t\tq->info.si_uid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcopy_siginfo(&q->info, info);\n\t\t\tif (from_ancestor_ns)\n\t\t\t\tq->info.si_pid = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tuserns_fixup_signal_uid(&q->info, t);\n\n\t} else if (!is_si_special(info)) {\n\t\tif (sig >= SIGRTMIN && info->si_code != SI_USER) {\n\t\t\t/*\n\t\t\t * Queue overflow, abort.  We may abort if the\n\t\t\t * signal was rt and sent by user using something\n\t\t\t * other than kill().\n\t\t\t */\n\t\t\tresult = TRACE_SIGNAL_OVERFLOW_FAIL;\n\t\t\tret = -EAGAIN;\n\t\t\tgoto ret;\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is a silent loss of information.  We still\n\t\t\t * send the signal, but the *info bits are lost.\n\t\t\t */\n\t\t\tresult = TRACE_SIGNAL_LOSE_INFO;\n\t\t}\n\t}\n\nout_set:\n\tsignalfd_notify(t, sig);\n\tsigaddset(&pending->signal, sig);\n\n\t/* Let multiprocess signals appear after on-going forks */\n\tif (type > PIDTYPE_TGID) {\n\t\tstruct multiprocess_signals *delayed;\n\t\thlist_for_each_entry(delayed, &t->signal->multiprocess, node) {\n\t\t\tsigset_t *signal = &delayed->signal;\n\t\t\t/* Can't queue both a stop and a continue signal */\n\t\t\tif (sig == SIGCONT)\n\t\t\t\tsigdelsetmask(signal, SIG_KERNEL_STOP_MASK);\n\t\t\telse if (sig_kernel_stop(sig))\n\t\t\t\tsigdelset(signal, SIGCONT);\n\t\t\tsigaddset(signal, sig);\n\t\t}\n\t}\n\n\tcomplete_signal(sig, t, type);\nret:\n\ttrace_signal_generate(sig, info, t, type != PIDTYPE_PID, result);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 1422
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1284-1314",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      },
      {
        "call_info": {
          "callee": "security_task_kill",
          "args": [
            "p",
            "info",
            "sig",
            "cred"
          ],
          "line": 1417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_as_cred_perm",
          "args": [
            "cred",
            "p"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "kill_as_cred_perm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1385-1394",
          "snippet": "static inline bool kill_as_cred_perm(const struct cred *cred,\n\t\t\t\t     struct task_struct *target)\n{\n\tconst struct cred *pcred = __task_cred(target);\n\n\treturn uid_eq(cred->euid, pcred->suid) ||\n\t       uid_eq(cred->euid, pcred->uid) ||\n\t       uid_eq(cred->uid, pcred->suid) ||\n\t       uid_eq(cred->uid, pcred->uid);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool kill_as_cred_perm(const struct cred *cred,\n\t\t\t\t     struct task_struct *target)\n{\n\tconst struct cred *pcred = __task_cred(target);\n\n\treturn uid_eq(cred->euid, pcred->suid) ||\n\t       uid_eq(cred->euid, pcred->uid) ||\n\t       uid_eq(cred->uid, pcred->suid) ||\n\t       uid_eq(cred->uid, pcred->uid);\n}"
        }
      },
      {
        "call_info": {
          "callee": "si_fromuser",
          "args": [
            "info"
          ],
          "line": 1413
        },
        "resolved": true,
        "details": {
          "function_name": "si_fromuser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "745-749",
          "snippet": "static inline bool si_fromuser(const struct kernel_siginfo *info)\n{\n\treturn info == SEND_SIG_NOINFO ||\n\t\t(!is_si_special(info) && SI_FROMUSER(info));\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic inline bool si_fromuser(const struct kernel_siginfo *info)\n{\n\treturn info == SEND_SIG_NOINFO ||\n\t\t(!is_si_special(info) && SI_FROMUSER(info));\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "pid",
            "PIDTYPE_PID"
          ],
          "line": 1408
        },
        "resolved": true,
        "details": {
          "function_name": "get_pid_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "376-385",
          "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1407
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_signal",
          "args": [
            "sig"
          ],
          "line": 1404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint kill_pid_info_as_cred(int sig, struct kernel_siginfo *info, struct pid *pid,\n\t\t\t const struct cred *cred)\n{\n\tint ret = -EINVAL;\n\tstruct task_struct *p;\n\tunsigned long flags;\n\n\tif (!valid_signal(sig))\n\t\treturn ret;\n\n\trcu_read_lock();\n\tp = pid_task(pid, PIDTYPE_PID);\n\tif (!p) {\n\t\tret = -ESRCH;\n\t\tgoto out_unlock;\n\t}\n\tif (si_fromuser(info) && !kill_as_cred_perm(cred, p)) {\n\t\tret = -EPERM;\n\t\tgoto out_unlock;\n\t}\n\tret = security_task_kill(p, info, sig, cred);\n\tif (ret)\n\t\tgoto out_unlock;\n\n\tif (sig) {\n\t\tif (lock_task_sighand(p, &flags)) {\n\t\t\tret = __send_signal(sig, info, p, PIDTYPE_TGID, 0);\n\t\t\tunlock_task_sighand(p, &flags);\n\t\t} else\n\t\t\tret = -ESRCH;\n\t}\nout_unlock:\n\trcu_read_unlock();\n\treturn ret;\n}"
  },
  {
    "function_name": "kill_as_cred_perm",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1385-1394",
    "snippet": "static inline bool kill_as_cred_perm(const struct cred *cred,\n\t\t\t\t     struct task_struct *target)\n{\n\tconst struct cred *pcred = __task_cred(target);\n\n\treturn uid_eq(cred->euid, pcred->suid) ||\n\t       uid_eq(cred->euid, pcred->uid) ||\n\t       uid_eq(cred->uid, pcred->suid) ||\n\t       uid_eq(cred->uid, pcred->uid);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cred->uid",
            "pcred->uid"
          ],
          "line": 1393
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cred->uid",
            "pcred->suid"
          ],
          "line": 1392
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cred->euid",
            "pcred->uid"
          ],
          "line": 1391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cred->euid",
            "pcred->suid"
          ],
          "line": 1390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "target"
          ],
          "line": 1388
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool kill_as_cred_perm(const struct cred *cred,\n\t\t\t\t     struct task_struct *target)\n{\n\tconst struct cred *pcred = __task_cred(target);\n\n\treturn uid_eq(cred->euid, pcred->suid) ||\n\t       uid_eq(cred->euid, pcred->uid) ||\n\t       uid_eq(cred->uid, pcred->suid) ||\n\t       uid_eq(cred->uid, pcred->uid);\n}"
  },
  {
    "function_name": "kill_proc_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1376-1383",
    "snippet": "static int kill_proc_info(int sig, struct kernel_siginfo *info, pid_t pid)\n{\n\tint error;\n\trcu_read_lock();\n\terror = kill_pid_info(sig, info, find_vpid(pid));\n\trcu_read_unlock();\n\treturn error;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1381
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "kill_pid_info",
          "args": [
            "sig",
            "info",
            "find_vpid(pid)"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "kill_pid_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1354-1374",
          "snippet": "int kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\terror = group_send_sig_info(sig, info, p, PIDTYPE_TGID);\n\t\trcu_read_unlock();\n\t\tif (likely(!p || error != -ESRCH))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * The task was unhashed in between, try again.  If it\n\t\t * is dead, pid_task() will return NULL, if we race with\n\t\t * de_thread() it will find the new leader.\n\t\t */\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\terror = group_send_sig_info(sig, info, p, PIDTYPE_TGID);\n\t\trcu_read_unlock();\n\t\tif (likely(!p || error != -ESRCH))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * The task was unhashed in between, try again.  If it\n\t\t * is dead, pid_task() will return NULL, if we race with\n\t\t * de_thread() it will find the new leader.\n\t\t */\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "find_vpid",
          "args": [
            "pid"
          ],
          "line": 1380
        },
        "resolved": true,
        "details": {
          "function_name": "find_vpid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "262-265",
          "snippet": "struct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid *find_vpid(int nr)\n{\n\treturn find_pid_ns(nr, task_active_pid_ns(current));\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1379
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int kill_proc_info(int sig, struct kernel_siginfo *info, pid_t pid)\n{\n\tint error;\n\trcu_read_lock();\n\terror = kill_pid_info(sig, info, find_vpid(pid));\n\trcu_read_unlock();\n\treturn error;\n}"
  },
  {
    "function_name": "kill_pid_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1354-1374",
    "snippet": "int kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\terror = group_send_sig_info(sig, info, p, PIDTYPE_TGID);\n\t\trcu_read_unlock();\n\t\tif (likely(!p || error != -ESRCH))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * The task was unhashed in between, try again.  If it\n\t\t * is dead, pid_task() will return NULL, if we race with\n\t\t * de_thread() it will find the new leader.\n\t\t */\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!p || error != -ESRCH"
          ],
          "line": 1365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1364
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "group_send_sig_info",
          "args": [
            "sig",
            "info",
            "p",
            "PIDTYPE_TGID"
          ],
          "line": 1363
        },
        "resolved": true,
        "details": {
          "function_name": "group_send_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1319-1332",
          "snippet": "int group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\tstruct task_struct *p, enum pid_type type)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, type);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\tstruct task_struct *p, enum pid_type type)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, type);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pid_task",
          "args": [
            "pid",
            "PIDTYPE_PID"
          ],
          "line": 1361
        },
        "resolved": true,
        "details": {
          "function_name": "get_pid_task",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "376-385",
          "snippet": "struct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct task_struct *get_pid_task(struct pid *pid, enum pid_type type)\n{\n\tstruct task_struct *result;\n\trcu_read_lock();\n\tresult = pid_task(pid, type);\n\tif (result)\n\t\tget_task_struct(result);\n\trcu_read_unlock();\n\treturn result;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1360
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint kill_pid_info(int sig, struct kernel_siginfo *info, struct pid *pid)\n{\n\tint error = -ESRCH;\n\tstruct task_struct *p;\n\n\tfor (;;) {\n\t\trcu_read_lock();\n\t\tp = pid_task(pid, PIDTYPE_PID);\n\t\tif (p)\n\t\t\terror = group_send_sig_info(sig, info, p, PIDTYPE_TGID);\n\t\trcu_read_unlock();\n\t\tif (likely(!p || error != -ESRCH))\n\t\t\treturn error;\n\n\t\t/*\n\t\t * The task was unhashed in between, try again.  If it\n\t\t * is dead, pid_task() will return NULL, if we race with\n\t\t * de_thread() it will find the new leader.\n\t\t */\n\t}\n}"
  },
  {
    "function_name": "__kill_pgrp_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1339-1352",
    "snippet": "int __kill_pgrp_info(int sig, struct kernel_siginfo *info, struct pid *pgrp)\n{\n\tstruct task_struct *p = NULL;\n\tint retval, success;\n\n\tsuccess = 0;\n\tretval = -ESRCH;\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tint err = group_send_sig_info(sig, info, p, PIDTYPE_PGID);\n\t\tsuccess |= !err;\n\t\tretval = err;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\treturn success ? 0 : retval;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "while_each_pid_task",
          "args": [
            "pgrp",
            "PIDTYPE_PGID",
            "p"
          ],
          "line": 1350
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "group_send_sig_info",
          "args": [
            "sig",
            "info",
            "p",
            "PIDTYPE_PGID"
          ],
          "line": 1347
        },
        "resolved": true,
        "details": {
          "function_name": "group_send_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1319-1332",
          "snippet": "int group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\tstruct task_struct *p, enum pid_type type)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, type);\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\tstruct task_struct *p, enum pid_type type)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, type);\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "do_each_pid_task",
          "args": [
            "pgrp",
            "PIDTYPE_PGID",
            "p"
          ],
          "line": 1346
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint __kill_pgrp_info(int sig, struct kernel_siginfo *info, struct pid *pgrp)\n{\n\tstruct task_struct *p = NULL;\n\tint retval, success;\n\n\tsuccess = 0;\n\tretval = -ESRCH;\n\tdo_each_pid_task(pgrp, PIDTYPE_PGID, p) {\n\t\tint err = group_send_sig_info(sig, info, p, PIDTYPE_PGID);\n\t\tsuccess |= !err;\n\t\tretval = err;\n\t} while_each_pid_task(pgrp, PIDTYPE_PGID, p);\n\treturn success ? 0 : retval;\n}"
  },
  {
    "function_name": "group_send_sig_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1319-1332",
    "snippet": "int group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\tstruct task_struct *p, enum pid_type type)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, type);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "do_send_sig_info",
          "args": [
            "sig",
            "info",
            "p",
            "type"
          ],
          "line": 1329
        },
        "resolved": true,
        "details": {
          "function_name": "do_send_sig_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1205-1217",
          "snippet": "int do_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p,\n\t\t\tenum pid_type type)\n{\n\tunsigned long flags;\n\tint ret = -ESRCH;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tret = send_signal(sig, info, p, type);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint do_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p,\n\t\t\tenum pid_type type)\n{\n\tunsigned long flags;\n\tint ret = -ESRCH;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tret = send_signal(sig, info, p, type);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1326
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "check_kill_permission",
          "args": [
            "sig",
            "info",
            "p"
          ],
          "line": 1325
        },
        "resolved": true,
        "details": {
          "function_name": "check_kill_permission",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "770-803",
          "snippet": "static int check_kill_permission(int sig, struct kernel_siginfo *info,\n\t\t\t\t struct task_struct *t)\n{\n\tstruct pid *sid;\n\tint error;\n\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\tif (!si_fromuser(info))\n\t\treturn 0;\n\n\terror = audit_signal_info(sig, t); /* Let audit system see the signal */\n\tif (error)\n\t\treturn error;\n\n\tif (!same_thread_group(current, t) &&\n\t    !kill_ok_by_cred(t)) {\n\t\tswitch (sig) {\n\t\tcase SIGCONT:\n\t\t\tsid = task_session(t);\n\t\t\t/*\n\t\t\t * We don't return the error if sid == NULL. The\n\t\t\t * task was unhashed, the caller must notice this.\n\t\t\t */\n\t\t\tif (!sid || sid == task_session(current))\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn security_task_kill(t, info, sig, NULL);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int check_kill_permission(int sig, struct kernel_siginfo *info,\n\t\t\t\t struct task_struct *t)\n{\n\tstruct pid *sid;\n\tint error;\n\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\tif (!si_fromuser(info))\n\t\treturn 0;\n\n\terror = audit_signal_info(sig, t); /* Let audit system see the signal */\n\tif (error)\n\t\treturn error;\n\n\tif (!same_thread_group(current, t) &&\n\t    !kill_ok_by_cred(t)) {\n\t\tswitch (sig) {\n\t\tcase SIGCONT:\n\t\t\tsid = task_session(t);\n\t\t\t/*\n\t\t\t * We don't return the error if sid == NULL. The\n\t\t\t * task was unhashed, the caller must notice this.\n\t\t\t */\n\t\t\tif (!sid || sid == task_session(current))\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn security_task_kill(t, info, sig, NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1324
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint group_send_sig_info(int sig, struct kernel_siginfo *info,\n\t\t\tstruct task_struct *p, enum pid_type type)\n{\n\tint ret;\n\n\trcu_read_lock();\n\tret = check_kill_permission(sig, info, p);\n\trcu_read_unlock();\n\n\tif (!ret && sig)\n\t\tret = do_send_sig_info(sig, info, p, type);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__lock_task_sighand",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1284-1314",
    "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1311
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&sighand->siglock",
            "*flags"
          ],
          "line": 1309
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "sighand == tsk->sighand"
          ],
          "line": 1307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&sighand->siglock",
            "*flags"
          ],
          "line": 1306
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sighand == NULL"
          ],
          "line": 1292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_dereference",
          "args": [
            "tsk->sighand"
          ],
          "line": 1291
        },
        "resolved": true,
        "details": {
          "function_name": "task_rcu_dereference",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/exit.c",
          "lines": "234-291",
          "snippet": "struct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}",
          "includes": [
            "#include <asm/mmu_context.h>",
            "#include <asm/pgtable.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/rcuwait.h>",
            "#include <linux/random.h>",
            "#include <linux/kcov.h>",
            "#include <linux/shm.h>",
            "#include <linux/writeback.h>",
            "#include <linux/oom.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <trace/events/sched.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/init_task.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/task_io_accounting_ops.h>",
            "#include <linux/blkdev.h>",
            "#include <linux/resource.h>",
            "#include <linux/audit.h> /* for audit_free() */",
            "#include <linux/pipe_fs_i.h>",
            "#include <linux/futex.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/signal.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/delayacct.h>",
            "#include <linux/taskstats_kern.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/kthread.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/mount.h>",
            "#include <linux/profile.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/freezer.h>",
            "#include <linux/fdtable.h>",
            "#include <linux/file.h>",
            "#include <linux/tsacct_kern.h>",
            "#include <linux/acct.h>",
            "#include <linux/cpu.h>",
            "#include <linux/key.h>",
            "#include <linux/iocontext.h>",
            "#include <linux/tty.h>",
            "#include <linux/personality.h>",
            "#include <linux/completion.h>",
            "#include <linux/capability.h>",
            "#include <linux/module.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/stat.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/autogroup.h>",
            "#include <linux/slab.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/mmu_context.h>\n#include <asm/pgtable.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/rcuwait.h>\n#include <linux/random.h>\n#include <linux/kcov.h>\n#include <linux/shm.h>\n#include <linux/writeback.h>\n#include <linux/oom.h>\n#include <linux/hw_breakpoint.h>\n#include <trace/events/sched.h>\n#include <linux/perf_event.h>\n#include <linux/init_task.h>\n#include <linux/fs_struct.h>\n#include <linux/tracehook.h>\n#include <linux/task_io_accounting_ops.h>\n#include <linux/blkdev.h>\n#include <linux/resource.h>\n#include <linux/audit.h> /* for audit_free() */\n#include <linux/pipe_fs_i.h>\n#include <linux/futex.h>\n#include <linux/mutex.h>\n#include <linux/cn_proc.h>\n#include <linux/posix-timers.h>\n#include <linux/signal.h>\n#include <linux/syscalls.h>\n#include <linux/cgroup.h>\n#include <linux/delayacct.h>\n#include <linux/taskstats_kern.h>\n#include <linux/mempolicy.h>\n#include <linux/kthread.h>\n#include <linux/proc_fs.h>\n#include <linux/mount.h>\n#include <linux/profile.h>\n#include <linux/ptrace.h>\n#include <linux/pid_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/binfmts.h>\n#include <linux/freezer.h>\n#include <linux/fdtable.h>\n#include <linux/file.h>\n#include <linux/tsacct_kern.h>\n#include <linux/acct.h>\n#include <linux/cpu.h>\n#include <linux/key.h>\n#include <linux/iocontext.h>\n#include <linux/tty.h>\n#include <linux/personality.h>\n#include <linux/completion.h>\n#include <linux/capability.h>\n#include <linux/module.h>\n#include <linux/interrupt.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/stat.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/autogroup.h>\n#include <linux/slab.h>\n#include <linux/mm.h>\n\nstruct task_struct *task_rcu_dereference(struct task_struct **ptask)\n{\n\tstruct sighand_struct *sighand;\n\tstruct task_struct *task;\n\n\t/*\n\t * We need to verify that release_task() was not called and thus\n\t * delayed_put_task_struct() can't run and drop the last reference\n\t * before rcu_read_unlock(). We check task->sighand != NULL,\n\t * but we can read the already freed and reused memory.\n\t */\nretry:\n\ttask = rcu_dereference(*ptask);\n\tif (!task)\n\t\treturn NULL;\n\n\tprobe_kernel_address(&task->sighand, sighand);\n\n\t/*\n\t * Pairs with atomic_dec_and_test() in put_task_struct(). If this task\n\t * was already freed we can not miss the preceding update of this\n\t * pointer.\n\t */\n\tsmp_rmb();\n\tif (unlikely(task != READ_ONCE(*ptask)))\n\t\tgoto retry;\n\n\t/*\n\t * We've re-checked that \"task == *ptask\", now we have two different\n\t * cases:\n\t *\n\t * 1. This is actually the same task/task_struct. In this case\n\t *    sighand != NULL tells us it is still alive.\n\t *\n\t * 2. This is another task which got the same memory for task_struct.\n\t *    We can't know this of course, and we can not trust\n\t *    sighand != NULL.\n\t *\n\t *    In this case we actually return a random value, but this is\n\t *    correct.\n\t *\n\t *    If we return NULL - we can pretend that we actually noticed that\n\t *    *ptask was updated when the previous task has exited. Or pretend\n\t *    that probe_slab_address(&sighand) reads NULL.\n\t *\n\t *    If we return the new task (because sighand is not NULL for any\n\t *    reason) - this is fine too. This (new) task can't go away before\n\t *    another gp pass.\n\t *\n\t *    And note: We could even eliminate the false positive if re-read\n\t *    task->sighand once again to avoid the falsely NULL. But this case\n\t *    is very unlikely so we don't care.\n\t */\n\tif (!sighand)\n\t\treturn NULL;\n\n\treturn task;\n}"
        }
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1289
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
  },
  {
    "function_name": "zap_other_threads",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1263-1282",
    "snippet": "int zap_other_threads(struct task_struct *p)\n{\n\tstruct task_struct *t = p;\n\tint count = 0;\n\n\tp->signal->group_stop_count = 0;\n\n\twhile_each_thread(p, t) {\n\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\tcount++;\n\n\t\t/* Don't bother with already dead threads */\n\t\tif (t->exit_state)\n\t\t\tcontinue;\n\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\tsignal_wake_up(t, 1);\n\t}\n\n\treturn count;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_wake_up",
          "args": [
            "t",
            "1"
          ],
          "line": 1278
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "702-714",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&t->pending.signal",
            "SIGKILL"
          ],
          "line": 1277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_clear_jobctl_pending",
          "args": [
            "t",
            "JOBCTL_PENDING_MASK"
          ],
          "line": 1271
        },
        "resolved": true,
        "details": {
          "function_name": "task_clear_jobctl_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "327-338",
          "snippet": "void task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_each_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 1270
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint zap_other_threads(struct task_struct *p)\n{\n\tstruct task_struct *t = p;\n\tint count = 0;\n\n\tp->signal->group_stop_count = 0;\n\n\twhile_each_thread(p, t) {\n\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\tcount++;\n\n\t\t/* Don't bother with already dead threads */\n\t\tif (t->exit_state)\n\t\t\tcontinue;\n\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\tsignal_wake_up(t, 1);\n\t}\n\n\treturn count;\n}"
  },
  {
    "function_name": "force_sig_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1230-1258",
    "snippet": "int\nforce_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *t)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&t->sighand->siglock",
            "flags"
          ],
          "line": 1255
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "send_signal",
          "args": [
            "sig",
            "info",
            "t",
            "PIDTYPE_PID"
          ],
          "line": 1254
        },
        "resolved": true,
        "details": {
          "function_name": "send_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1153-1164",
          "snippet": "static int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\tint from_ancestor_ns = 0;\n\n#ifdef CONFIG_PID_NS\n\tfrom_ancestor_ns = si_fromuser(info) &&\n\t\t\t   !task_pid_nr_ns(current, task_active_pid_ns(t));\n#endif\n\n\treturn __send_signal(sig, info, t, type, from_ancestor_ns);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\tint from_ancestor_ns = 0;\n\n#ifdef CONFIG_PID_NS\n\tfrom_ancestor_ns = si_fromuser(info) &&\n\t\t\t   !task_pid_nr_ns(current, task_active_pid_ns(t));\n#endif\n\n\treturn __send_signal(sig, info, t, type, from_ancestor_ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recalc_sigpending_and_wake",
          "args": [
            "t"
          ],
          "line": 1245
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_sigpending_and_wake",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "166-170",
          "snippet": "void recalc_sigpending_and_wake(struct task_struct *t)\n{\n\tif (recalc_sigpending_tsk(t))\n\t\tsignal_wake_up(t, 0);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid recalc_sigpending_and_wake(struct task_struct *t)\n{\n\tif (recalc_sigpending_tsk(t))\n\t\tsignal_wake_up(t, 0);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&t->blocked",
            "sig"
          ],
          "line": 1244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigismember",
          "args": [
            "&t->blocked",
            "sig"
          ],
          "line": 1240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&t->sighand->siglock",
            "flags"
          ],
          "line": 1237
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint\nforce_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *t)\n{\n\tunsigned long int flags;\n\tint ret, blocked, ignored;\n\tstruct k_sigaction *action;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\taction = &t->sighand->action[sig-1];\n\tignored = action->sa.sa_handler == SIG_IGN;\n\tblocked = sigismember(&t->blocked, sig);\n\tif (blocked || ignored) {\n\t\taction->sa.sa_handler = SIG_DFL;\n\t\tif (blocked) {\n\t\t\tsigdelset(&t->blocked, sig);\n\t\t\trecalc_sigpending_and_wake(t);\n\t\t}\n\t}\n\t/*\n\t * Don't clear SIGNAL_UNKILLABLE for traced tasks, users won't expect\n\t * debugging to leave init killable.\n\t */\n\tif (action->sa.sa_handler == SIG_DFL && !t->ptrace)\n\t\tt->signal->flags &= ~SIGNAL_UNKILLABLE;\n\tret = send_signal(sig, info, t, PIDTYPE_PID);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n\n\treturn ret;\n}"
  },
  {
    "function_name": "do_send_sig_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1205-1217",
    "snippet": "int do_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p,\n\t\t\tenum pid_type type)\n{\n\tunsigned long flags;\n\tint ret = -ESRCH;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tret = send_signal(sig, info, p, type);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 1213
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "send_signal",
          "args": [
            "sig",
            "info",
            "p",
            "type"
          ],
          "line": 1212
        },
        "resolved": true,
        "details": {
          "function_name": "send_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1153-1164",
          "snippet": "static int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\tint from_ancestor_ns = 0;\n\n#ifdef CONFIG_PID_NS\n\tfrom_ancestor_ns = si_fromuser(info) &&\n\t\t\t   !task_pid_nr_ns(current, task_active_pid_ns(t));\n#endif\n\n\treturn __send_signal(sig, info, t, type, from_ancestor_ns);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\tint from_ancestor_ns = 0;\n\n#ifdef CONFIG_PID_NS\n\tfrom_ancestor_ns = si_fromuser(info) &&\n\t\t\t   !task_pid_nr_ns(current, task_active_pid_ns(t));\n#endif\n\n\treturn __send_signal(sig, info, t, type, from_ancestor_ns);\n}"
        }
      },
      {
        "call_info": {
          "callee": "lock_task_sighand",
          "args": [
            "p",
            "&flags"
          ],
          "line": 1211
        },
        "resolved": true,
        "details": {
          "function_name": "__lock_task_sighand",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1284-1314",
          "snippet": "struct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstruct sighand_struct *__lock_task_sighand(struct task_struct *tsk,\n\t\t\t\t\t   unsigned long *flags)\n{\n\tstruct sighand_struct *sighand;\n\n\trcu_read_lock();\n\tfor (;;) {\n\t\tsighand = rcu_dereference(tsk->sighand);\n\t\tif (unlikely(sighand == NULL))\n\t\t\tbreak;\n\n\t\t/*\n\t\t * This sighand can be already freed and even reused, but\n\t\t * we rely on SLAB_TYPESAFE_BY_RCU and sighand_ctor() which\n\t\t * initializes ->siglock: this slab can't go away, it has\n\t\t * the same object type, ->siglock can't be reinitialized.\n\t\t *\n\t\t * We need to ensure that tsk->sighand is still the same\n\t\t * after we take the lock, we can race with de_thread() or\n\t\t * __exit_signal(). In the latter case the next iteration\n\t\t * must see ->sighand == NULL.\n\t\t */\n\t\tspin_lock_irqsave(&sighand->siglock, *flags);\n\t\tif (likely(sighand == tsk->sighand))\n\t\t\tbreak;\n\t\tspin_unlock_irqrestore(&sighand->siglock, *flags);\n\t}\n\trcu_read_unlock();\n\n\treturn sighand;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint do_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p,\n\t\t\tenum pid_type type)\n{\n\tunsigned long flags;\n\tint ret = -ESRCH;\n\n\tif (lock_task_sighand(p, &flags)) {\n\t\tret = send_signal(sig, info, p, type);\n\t\tunlock_task_sighand(p, &flags);\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "__group_send_sig_info",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1199-1203",
    "snippet": "int\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "send_signal",
          "args": [
            "sig",
            "info",
            "p",
            "PIDTYPE_TGID"
          ],
          "line": 1202
        },
        "resolved": true,
        "details": {
          "function_name": "send_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1153-1164",
          "snippet": "static int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\tint from_ancestor_ns = 0;\n\n#ifdef CONFIG_PID_NS\n\tfrom_ancestor_ns = si_fromuser(info) &&\n\t\t\t   !task_pid_nr_ns(current, task_active_pid_ns(t));\n#endif\n\n\treturn __send_signal(sig, info, t, type, from_ancestor_ns);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\tint from_ancestor_ns = 0;\n\n#ifdef CONFIG_PID_NS\n\tfrom_ancestor_ns = si_fromuser(info) &&\n\t\t\t   !task_pid_nr_ns(current, task_active_pid_ns(t));\n#endif\n\n\treturn __send_signal(sig, info, t, type, from_ancestor_ns);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint\n__group_send_sig_info(int sig, struct kernel_siginfo *info, struct task_struct *p)\n{\n\treturn send_signal(sig, info, p, PIDTYPE_TGID);\n}"
  },
  {
    "function_name": "setup_print_fatal_signals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1190-1195",
    "snippet": "static int __init setup_print_fatal_signals(char *str)\n{\n\tget_option (&str, &print_fatal_signals);\n\n\treturn 1;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int print_fatal_signals"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "get_option",
          "args": [
            "&str",
            "&print_fatal_signals"
          ],
          "line": 1192
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint print_fatal_signals;\n\nstatic int __init setup_print_fatal_signals(char *str)\n{\n\tget_option (&str, &print_fatal_signals);\n\n\treturn 1;\n}"
  },
  {
    "function_name": "print_fatal_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1166-1188",
    "snippet": "static void print_fatal_signal(int signr)\n{\n\tstruct pt_regs *regs = signal_pt_regs();\n\tpr_info(\"potentially unexpected fatal signal %d.\\n\", signr);\n\n#if defined(__i386__) && !defined(__arch_um__)\n\tpr_info(\"code at %08lx: \", regs->ip);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tunsigned char insn;\n\n\t\t\tif (get_user(insn, (unsigned char *)(regs->ip + i)))\n\t\t\t\tbreak;\n\t\t\tpr_cont(\"%02x \", insn);\n\t\t}\n\t}\n\tpr_cont(\"\\n\");\n#endif\n\tpreempt_disable();\n\tshow_regs(regs);\n\tpreempt_enable();\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "preempt_enable",
          "args": [],
          "line": 1187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "show_regs",
          "args": [
            "regs"
          ],
          "line": 1186
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "preempt_disable",
          "args": [],
          "line": 1185
        },
        "resolved": true,
        "details": {
          "function_name": "schedule_preempt_disabled",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "3571-3576",
          "snippet": "void __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void __sched",
            "static void __sched"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic void __sched;\nstatic void __sched;\n\nvoid __sched schedule_preempt_disabled(void)\n{\n\tsched_preempt_enable_no_resched();\n\tschedule();\n\tpreempt_disable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"\\n\""
          ],
          "line": 1183
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_pool_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4431-4437",
          "snippet": "static void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);\n\nstatic void pr_cont_pool_info(struct worker_pool *pool)\n{\n\tpr_cont(\" cpus=%*pbl\", nr_cpumask_bits, pool->attrs->cpumask);\n\tif (pool->node != NUMA_NO_NODE)\n\t\tpr_cont(\" node=%d\", pool->node);\n\tpr_cont(\" flags=0x%x nice=%d\", pool->flags, pool->attrs->nice);\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_cont",
          "args": [
            "\"%02x \"",
            "insn"
          ],
          "line": 1180
        },
        "resolved": true,
        "details": {
          "function_name": "pr_cont_work",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/workqueue.c",
          "lines": "4439-4451",
          "snippet": "static void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}",
          "includes": [
            "#include <trace/events/workqueue.h>",
            "#include \"workqueue_internal.h\"",
            "#include <linux/nmi.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/nodemask.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/jhash.h>",
            "#include <linux/idr.h>",
            "#include <linux/lockdep.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/freezer.h>",
            "#include <linux/mempolicy.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/kthread.h>",
            "#include <linux/notifier.h>",
            "#include <linux/cpu.h>",
            "#include <linux/slab.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/completion.h>",
            "#include <linux/signal.h>",
            "#include <linux/init.h>",
            "#include <linux/sched.h>",
            "#include <linux/kernel.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <trace/events/workqueue.h>\n#include \"workqueue_internal.h\"\n#include <linux/nmi.h>\n#include <linux/sched/isolation.h>\n#include <linux/uaccess.h>\n#include <linux/moduleparam.h>\n#include <linux/nodemask.h>\n#include <linux/rculist.h>\n#include <linux/hashtable.h>\n#include <linux/jhash.h>\n#include <linux/idr.h>\n#include <linux/lockdep.h>\n#include <linux/debug_locks.h>\n#include <linux/freezer.h>\n#include <linux/mempolicy.h>\n#include <linux/hardirq.h>\n#include <linux/kthread.h>\n#include <linux/notifier.h>\n#include <linux/cpu.h>\n#include <linux/slab.h>\n#include <linux/workqueue.h>\n#include <linux/completion.h>\n#include <linux/signal.h>\n#include <linux/init.h>\n#include <linux/sched.h>\n#include <linux/kernel.h>\n#include <linux/export.h>\n\nstatic void pr_cont_work(bool comma, struct work_struct *work)\n{\n\tif (work->func == wq_barrier_func) {\n\t\tstruct wq_barrier *barr;\n\n\t\tbarr = container_of(work, struct wq_barrier, work);\n\n\t\tpr_cont(\"%s BAR(%d)\", comma ? \",\" : \"\",\n\t\t\ttask_pid_nr(barr->task));\n\t} else {\n\t\tpr_cont(\"%s %pf\", comma ? \",\" : \"\", work->func);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "get_user",
          "args": [
            "insn",
            "(unsigned char *)(regs->ip + i)"
          ],
          "line": 1178
        },
        "resolved": true,
        "details": {
          "function_name": "bpf_obj_get_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/bpf/inode.c",
          "lines": "482-516",
          "snippet": "int bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/bpf_trace.h>",
            "#include <linux/bpf.h>",
            "#include <linux/filter.h>",
            "#include <linux/parser.h>",
            "#include <linux/kdev_t.h>",
            "#include <linux/fs.h>",
            "#include <linux/namei.h>",
            "#include <linux/mount.h>",
            "#include <linux/major.h>",
            "#include <linux/magic.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/bpf_trace.h>\n#include <linux/bpf.h>\n#include <linux/filter.h>\n#include <linux/parser.h>\n#include <linux/kdev_t.h>\n#include <linux/fs.h>\n#include <linux/namei.h>\n#include <linux/mount.h>\n#include <linux/major.h>\n#include <linux/magic.h>\n#include <linux/init.h>\n\nint bpf_obj_get_user(const char __user *pathname, int flags)\n{\n\tenum bpf_type type = BPF_TYPE_UNSPEC;\n\tstruct filename *pname;\n\tint ret = -ENOENT;\n\tint f_flags;\n\tvoid *raw;\n\n\tf_flags = bpf_get_file_flag(flags);\n\tif (f_flags < 0)\n\t\treturn f_flags;\n\n\tpname = getname(pathname);\n\tif (IS_ERR(pname))\n\t\treturn PTR_ERR(pname);\n\n\traw = bpf_obj_do_get(pname, &type, f_flags);\n\tif (IS_ERR(raw)) {\n\t\tret = PTR_ERR(raw);\n\t\tgoto out;\n\t}\n\n\tif (type == BPF_TYPE_PROG)\n\t\tret = bpf_prog_new_fd(raw);\n\telse if (type == BPF_TYPE_MAP)\n\t\tret = bpf_map_new_fd(raw, f_flags);\n\telse\n\t\tgoto out;\n\n\tif (ret < 0)\n\t\tbpf_any_put(raw, type);\nout:\n\tputname(pname);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"code at %08lx: \"",
            "regs->ip"
          ],
          "line": 1172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"potentially unexpected fatal signal %d.\\n\"",
            "signr"
          ],
          "line": 1169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signal_pt_regs",
          "args": [],
          "line": 1168
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void print_fatal_signal(int signr)\n{\n\tstruct pt_regs *regs = signal_pt_regs();\n\tpr_info(\"potentially unexpected fatal signal %d.\\n\", signr);\n\n#if defined(__i386__) && !defined(__arch_um__)\n\tpr_info(\"code at %08lx: \", regs->ip);\n\t{\n\t\tint i;\n\t\tfor (i = 0; i < 16; i++) {\n\t\t\tunsigned char insn;\n\n\t\t\tif (get_user(insn, (unsigned char *)(regs->ip + i)))\n\t\t\t\tbreak;\n\t\t\tpr_cont(\"%02x \", insn);\n\t\t}\n\t}\n\tpr_cont(\"\\n\");\n#endif\n\tpreempt_disable();\n\tshow_regs(regs);\n\tpreempt_enable();\n}"
  },
  {
    "function_name": "send_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1153-1164",
    "snippet": "static int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\tint from_ancestor_ns = 0;\n\n#ifdef CONFIG_PID_NS\n\tfrom_ancestor_ns = si_fromuser(info) &&\n\t\t\t   !task_pid_nr_ns(current, task_active_pid_ns(t));\n#endif\n\n\treturn __send_signal(sig, info, t, type, from_ancestor_ns);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__send_signal",
          "args": [
            "sig",
            "info",
            "t",
            "type",
            "from_ancestor_ns"
          ],
          "line": 1163
        },
        "resolved": true,
        "details": {
          "function_name": "__send_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1033-1151",
          "snippet": "static int __send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type, int from_ancestor_ns)\n{\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint override_rlimit;\n\tint ret = 0, result;\n\n\tassert_spin_locked(&t->sighand->siglock);\n\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t,\n\t\t\tfrom_ancestor_ns || (info == SEND_SIG_PRIV)))\n\t\tgoto ret;\n\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\t/*\n\t * Short-circuit ignored signals and support queuing\n\t * exactly one non-rt signal, so that we can get more\n\t * detailed information about the cause of the signal.\n\t */\n\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\tif (legacy_queue(pending, sig))\n\t\tgoto ret;\n\n\tresult = TRACE_SIGNAL_DELIVERED;\n\t/*\n\t * Skip useless siginfo allocation for SIGKILL SIGSTOP,\n\t * and kernel threads.\n\t */\n\tif (sig_kernel_only(sig) || (t->flags & PF_KTHREAD))\n\t\tgoto out_set;\n\n\t/*\n\t * Real-time signals must be queued if sent by sigqueue, or\n\t * some other real-time mechanism.  It is implementation\n\t * defined whether kill() does so.  We attempt to do so, on\n\t * the principle of least surprise, but since kill is not\n\t * allowed to fail with EAGAIN when low on memory we just\n\t * make sure at least one signal gets delivered and don't\n\t * pass on the info struct.\n\t */\n\tif (sig < SIGRTMIN)\n\t\toverride_rlimit = (is_si_special(info) || info->si_code >= 0);\n\telse\n\t\toverride_rlimit = 0;\n\n\tq = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit);\n\tif (q) {\n\t\tlist_add_tail(&q->list, &pending->list);\n\t\tswitch ((unsigned long) info) {\n\t\tcase (unsigned long) SEND_SIG_NOINFO:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_USER;\n\t\t\tq->info.si_pid = task_tgid_nr_ns(current,\n\t\t\t\t\t\t\ttask_active_pid_ns(t));\n\t\t\tq->info.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\t\t\tbreak;\n\t\tcase (unsigned long) SEND_SIG_PRIV:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_KERNEL;\n\t\t\tq->info.si_pid = 0;\n\t\t\tq->info.si_uid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcopy_siginfo(&q->info, info);\n\t\t\tif (from_ancestor_ns)\n\t\t\t\tq->info.si_pid = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tuserns_fixup_signal_uid(&q->info, t);\n\n\t} else if (!is_si_special(info)) {\n\t\tif (sig >= SIGRTMIN && info->si_code != SI_USER) {\n\t\t\t/*\n\t\t\t * Queue overflow, abort.  We may abort if the\n\t\t\t * signal was rt and sent by user using something\n\t\t\t * other than kill().\n\t\t\t */\n\t\t\tresult = TRACE_SIGNAL_OVERFLOW_FAIL;\n\t\t\tret = -EAGAIN;\n\t\t\tgoto ret;\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is a silent loss of information.  We still\n\t\t\t * send the signal, but the *info bits are lost.\n\t\t\t */\n\t\t\tresult = TRACE_SIGNAL_LOSE_INFO;\n\t\t}\n\t}\n\nout_set:\n\tsignalfd_notify(t, sig);\n\tsigaddset(&pending->signal, sig);\n\n\t/* Let multiprocess signals appear after on-going forks */\n\tif (type > PIDTYPE_TGID) {\n\t\tstruct multiprocess_signals *delayed;\n\t\thlist_for_each_entry(delayed, &t->signal->multiprocess, node) {\n\t\t\tsigset_t *signal = &delayed->signal;\n\t\t\t/* Can't queue both a stop and a continue signal */\n\t\t\tif (sig == SIGCONT)\n\t\t\t\tsigdelsetmask(signal, SIG_KERNEL_STOP_MASK);\n\t\t\telse if (sig_kernel_stop(sig))\n\t\t\t\tsigdelset(signal, SIGCONT);\n\t\t\tsigaddset(signal, sig);\n\t\t}\n\t}\n\n\tcomplete_signal(sig, t, type);\nret:\n\ttrace_signal_generate(sig, info, t, type != PIDTYPE_PID, result);\n\treturn ret;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int __send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type, int from_ancestor_ns)\n{\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint override_rlimit;\n\tint ret = 0, result;\n\n\tassert_spin_locked(&t->sighand->siglock);\n\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t,\n\t\t\tfrom_ancestor_ns || (info == SEND_SIG_PRIV)))\n\t\tgoto ret;\n\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\t/*\n\t * Short-circuit ignored signals and support queuing\n\t * exactly one non-rt signal, so that we can get more\n\t * detailed information about the cause of the signal.\n\t */\n\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\tif (legacy_queue(pending, sig))\n\t\tgoto ret;\n\n\tresult = TRACE_SIGNAL_DELIVERED;\n\t/*\n\t * Skip useless siginfo allocation for SIGKILL SIGSTOP,\n\t * and kernel threads.\n\t */\n\tif (sig_kernel_only(sig) || (t->flags & PF_KTHREAD))\n\t\tgoto out_set;\n\n\t/*\n\t * Real-time signals must be queued if sent by sigqueue, or\n\t * some other real-time mechanism.  It is implementation\n\t * defined whether kill() does so.  We attempt to do so, on\n\t * the principle of least surprise, but since kill is not\n\t * allowed to fail with EAGAIN when low on memory we just\n\t * make sure at least one signal gets delivered and don't\n\t * pass on the info struct.\n\t */\n\tif (sig < SIGRTMIN)\n\t\toverride_rlimit = (is_si_special(info) || info->si_code >= 0);\n\telse\n\t\toverride_rlimit = 0;\n\n\tq = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit);\n\tif (q) {\n\t\tlist_add_tail(&q->list, &pending->list);\n\t\tswitch ((unsigned long) info) {\n\t\tcase (unsigned long) SEND_SIG_NOINFO:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_USER;\n\t\t\tq->info.si_pid = task_tgid_nr_ns(current,\n\t\t\t\t\t\t\ttask_active_pid_ns(t));\n\t\t\tq->info.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\t\t\tbreak;\n\t\tcase (unsigned long) SEND_SIG_PRIV:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_KERNEL;\n\t\t\tq->info.si_pid = 0;\n\t\t\tq->info.si_uid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcopy_siginfo(&q->info, info);\n\t\t\tif (from_ancestor_ns)\n\t\t\t\tq->info.si_pid = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tuserns_fixup_signal_uid(&q->info, t);\n\n\t} else if (!is_si_special(info)) {\n\t\tif (sig >= SIGRTMIN && info->si_code != SI_USER) {\n\t\t\t/*\n\t\t\t * Queue overflow, abort.  We may abort if the\n\t\t\t * signal was rt and sent by user using something\n\t\t\t * other than kill().\n\t\t\t */\n\t\t\tresult = TRACE_SIGNAL_OVERFLOW_FAIL;\n\t\t\tret = -EAGAIN;\n\t\t\tgoto ret;\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is a silent loss of information.  We still\n\t\t\t * send the signal, but the *info bits are lost.\n\t\t\t */\n\t\t\tresult = TRACE_SIGNAL_LOSE_INFO;\n\t\t}\n\t}\n\nout_set:\n\tsignalfd_notify(t, sig);\n\tsigaddset(&pending->signal, sig);\n\n\t/* Let multiprocess signals appear after on-going forks */\n\tif (type > PIDTYPE_TGID) {\n\t\tstruct multiprocess_signals *delayed;\n\t\thlist_for_each_entry(delayed, &t->signal->multiprocess, node) {\n\t\t\tsigset_t *signal = &delayed->signal;\n\t\t\t/* Can't queue both a stop and a continue signal */\n\t\t\tif (sig == SIGCONT)\n\t\t\t\tsigdelsetmask(signal, SIG_KERNEL_STOP_MASK);\n\t\t\telse if (sig_kernel_stop(sig))\n\t\t\t\tsigdelset(signal, SIGCONT);\n\t\t\tsigaddset(signal, sig);\n\t\t}\n\t}\n\n\tcomplete_signal(sig, t, type);\nret:\n\ttrace_signal_generate(sig, info, t, type != PIDTYPE_PID, result);\n\treturn ret;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_pid_nr_ns",
          "args": [
            "current",
            "task_active_pid_ns(t)"
          ],
          "line": 1160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "t"
          ],
          "line": 1160
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "436-439",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "si_fromuser",
          "args": [
            "info"
          ],
          "line": 1159
        },
        "resolved": true,
        "details": {
          "function_name": "si_fromuser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "745-749",
          "snippet": "static inline bool si_fromuser(const struct kernel_siginfo *info)\n{\n\treturn info == SEND_SIG_NOINFO ||\n\t\t(!is_si_special(info) && SI_FROMUSER(info));\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic inline bool si_fromuser(const struct kernel_siginfo *info)\n{\n\treturn info == SEND_SIG_NOINFO ||\n\t\t(!is_si_special(info) && SI_FROMUSER(info));\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type)\n{\n\tint from_ancestor_ns = 0;\n\n#ifdef CONFIG_PID_NS\n\tfrom_ancestor_ns = si_fromuser(info) &&\n\t\t\t   !task_pid_nr_ns(current, task_active_pid_ns(t));\n#endif\n\n\treturn __send_signal(sig, info, t, type, from_ancestor_ns);\n}"
  },
  {
    "function_name": "__send_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1033-1151",
    "snippet": "static int __send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type, int from_ancestor_ns)\n{\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint override_rlimit;\n\tint ret = 0, result;\n\n\tassert_spin_locked(&t->sighand->siglock);\n\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t,\n\t\t\tfrom_ancestor_ns || (info == SEND_SIG_PRIV)))\n\t\tgoto ret;\n\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\t/*\n\t * Short-circuit ignored signals and support queuing\n\t * exactly one non-rt signal, so that we can get more\n\t * detailed information about the cause of the signal.\n\t */\n\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\tif (legacy_queue(pending, sig))\n\t\tgoto ret;\n\n\tresult = TRACE_SIGNAL_DELIVERED;\n\t/*\n\t * Skip useless siginfo allocation for SIGKILL SIGSTOP,\n\t * and kernel threads.\n\t */\n\tif (sig_kernel_only(sig) || (t->flags & PF_KTHREAD))\n\t\tgoto out_set;\n\n\t/*\n\t * Real-time signals must be queued if sent by sigqueue, or\n\t * some other real-time mechanism.  It is implementation\n\t * defined whether kill() does so.  We attempt to do so, on\n\t * the principle of least surprise, but since kill is not\n\t * allowed to fail with EAGAIN when low on memory we just\n\t * make sure at least one signal gets delivered and don't\n\t * pass on the info struct.\n\t */\n\tif (sig < SIGRTMIN)\n\t\toverride_rlimit = (is_si_special(info) || info->si_code >= 0);\n\telse\n\t\toverride_rlimit = 0;\n\n\tq = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit);\n\tif (q) {\n\t\tlist_add_tail(&q->list, &pending->list);\n\t\tswitch ((unsigned long) info) {\n\t\tcase (unsigned long) SEND_SIG_NOINFO:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_USER;\n\t\t\tq->info.si_pid = task_tgid_nr_ns(current,\n\t\t\t\t\t\t\ttask_active_pid_ns(t));\n\t\t\tq->info.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\t\t\tbreak;\n\t\tcase (unsigned long) SEND_SIG_PRIV:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_KERNEL;\n\t\t\tq->info.si_pid = 0;\n\t\t\tq->info.si_uid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcopy_siginfo(&q->info, info);\n\t\t\tif (from_ancestor_ns)\n\t\t\t\tq->info.si_pid = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tuserns_fixup_signal_uid(&q->info, t);\n\n\t} else if (!is_si_special(info)) {\n\t\tif (sig >= SIGRTMIN && info->si_code != SI_USER) {\n\t\t\t/*\n\t\t\t * Queue overflow, abort.  We may abort if the\n\t\t\t * signal was rt and sent by user using something\n\t\t\t * other than kill().\n\t\t\t */\n\t\t\tresult = TRACE_SIGNAL_OVERFLOW_FAIL;\n\t\t\tret = -EAGAIN;\n\t\t\tgoto ret;\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is a silent loss of information.  We still\n\t\t\t * send the signal, but the *info bits are lost.\n\t\t\t */\n\t\t\tresult = TRACE_SIGNAL_LOSE_INFO;\n\t\t}\n\t}\n\nout_set:\n\tsignalfd_notify(t, sig);\n\tsigaddset(&pending->signal, sig);\n\n\t/* Let multiprocess signals appear after on-going forks */\n\tif (type > PIDTYPE_TGID) {\n\t\tstruct multiprocess_signals *delayed;\n\t\thlist_for_each_entry(delayed, &t->signal->multiprocess, node) {\n\t\t\tsigset_t *signal = &delayed->signal;\n\t\t\t/* Can't queue both a stop and a continue signal */\n\t\t\tif (sig == SIGCONT)\n\t\t\t\tsigdelsetmask(signal, SIG_KERNEL_STOP_MASK);\n\t\t\telse if (sig_kernel_stop(sig))\n\t\t\t\tsigdelset(signal, SIGCONT);\n\t\t\tsigaddset(signal, sig);\n\t\t}\n\t}\n\n\tcomplete_signal(sig, t, type);\nret:\n\ttrace_signal_generate(sig, info, t, type != PIDTYPE_PID, result);\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "trace_signal_generate",
          "args": [
            "sig",
            "info",
            "t",
            "type != PIDTYPE_PID",
            "result"
          ],
          "line": 1149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "complete_signal",
          "args": [
            "sig",
            "t",
            "type"
          ],
          "line": 1147
        },
        "resolved": true,
        "details": {
          "function_name": "complete_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "931-1005",
          "snippet": "static void complete_signal(int sig, struct task_struct *p, enum pid_type type)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\n\t/*\n\t * Now find a thread we can wake up to take the signal off the queue.\n\t *\n\t * If the main thread wants the signal, it gets first crack.\n\t * Probably the least surprising to the average bear.\n\t */\n\tif (wants_signal(sig, p))\n\t\tt = p;\n\telse if ((type == PIDTYPE_PID) || thread_group_empty(p))\n\t\t/*\n\t\t * There is just one thread and it does not need to be woken.\n\t\t * It will dequeue unblocked signals before it runs again.\n\t\t */\n\t\treturn;\n\telse {\n\t\t/*\n\t\t * Otherwise try to find a suitable thread.\n\t\t */\n\t\tt = signal->curr_target;\n\t\twhile (!wants_signal(sig, t)) {\n\t\t\tt = next_thread(t);\n\t\t\tif (t == signal->curr_target)\n\t\t\t\t/*\n\t\t\t\t * No thread needs to be woken.\n\t\t\t\t * Any eligible threads will see\n\t\t\t\t * the signal in the queue soon.\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t}\n\t\tsignal->curr_target = t;\n\t}\n\n\t/*\n\t * Found a killable thread.  If the signal will be fatal,\n\t * then start taking the whole group down immediately.\n\t */\n\tif (sig_fatal(p, sig) &&\n\t    !(signal->flags & SIGNAL_GROUP_EXIT) &&\n\t    !sigismember(&t->real_blocked, sig) &&\n\t    (sig == SIGKILL || !p->ptrace)) {\n\t\t/*\n\t\t * This signal will be fatal to the whole group.\n\t\t */\n\t\tif (!sig_kernel_coredump(sig)) {\n\t\t\t/*\n\t\t\t * Start a group exit and wake everybody up.\n\t\t\t * This way we don't have other threads\n\t\t\t * running and doing things after a slower\n\t\t\t * thread has the fatal signal pending.\n\t\t\t */\n\t\t\tsignal->flags = SIGNAL_GROUP_EXIT;\n\t\t\tsignal->group_exit_code = sig;\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tt = p;\n\t\t\tdo {\n\t\t\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\t\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\t\t\tsignal_wake_up(t, 1);\n\t\t\t} while_each_thread(p, t);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * The signal is already in the shared-pending queue.\n\t * Tell the chosen thread to wake up and dequeue it.\n\t */\n\tsignal_wake_up(t, sig == SIGKILL);\n\treturn;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void complete_signal(int sig, struct task_struct *p, enum pid_type type)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\n\t/*\n\t * Now find a thread we can wake up to take the signal off the queue.\n\t *\n\t * If the main thread wants the signal, it gets first crack.\n\t * Probably the least surprising to the average bear.\n\t */\n\tif (wants_signal(sig, p))\n\t\tt = p;\n\telse if ((type == PIDTYPE_PID) || thread_group_empty(p))\n\t\t/*\n\t\t * There is just one thread and it does not need to be woken.\n\t\t * It will dequeue unblocked signals before it runs again.\n\t\t */\n\t\treturn;\n\telse {\n\t\t/*\n\t\t * Otherwise try to find a suitable thread.\n\t\t */\n\t\tt = signal->curr_target;\n\t\twhile (!wants_signal(sig, t)) {\n\t\t\tt = next_thread(t);\n\t\t\tif (t == signal->curr_target)\n\t\t\t\t/*\n\t\t\t\t * No thread needs to be woken.\n\t\t\t\t * Any eligible threads will see\n\t\t\t\t * the signal in the queue soon.\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t}\n\t\tsignal->curr_target = t;\n\t}\n\n\t/*\n\t * Found a killable thread.  If the signal will be fatal,\n\t * then start taking the whole group down immediately.\n\t */\n\tif (sig_fatal(p, sig) &&\n\t    !(signal->flags & SIGNAL_GROUP_EXIT) &&\n\t    !sigismember(&t->real_blocked, sig) &&\n\t    (sig == SIGKILL || !p->ptrace)) {\n\t\t/*\n\t\t * This signal will be fatal to the whole group.\n\t\t */\n\t\tif (!sig_kernel_coredump(sig)) {\n\t\t\t/*\n\t\t\t * Start a group exit and wake everybody up.\n\t\t\t * This way we don't have other threads\n\t\t\t * running and doing things after a slower\n\t\t\t * thread has the fatal signal pending.\n\t\t\t */\n\t\t\tsignal->flags = SIGNAL_GROUP_EXIT;\n\t\t\tsignal->group_exit_code = sig;\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tt = p;\n\t\t\tdo {\n\t\t\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\t\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\t\t\tsignal_wake_up(t, 1);\n\t\t\t} while_each_thread(p, t);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * The signal is already in the shared-pending queue.\n\t * Tell the chosen thread to wake up and dequeue it.\n\t */\n\tsignal_wake_up(t, sig == SIGKILL);\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "signal",
            "sig"
          ],
          "line": 1143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "signal",
            "SIGCONT"
          ],
          "line": 1142
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sig_kernel_stop",
          "args": [
            "sig"
          ],
          "line": 1141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelsetmask",
          "args": [
            "signal",
            "SIG_KERNEL_STOP_MASK"
          ],
          "line": 1140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hlist_for_each_entry",
          "args": [
            "delayed",
            "&t->signal->multiprocess",
            "node"
          ],
          "line": 1136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&pending->signal",
            "sig"
          ],
          "line": 1131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "signalfd_notify",
          "args": [
            "t",
            "sig"
          ],
          "line": 1130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_si_special",
          "args": [
            "info"
          ],
          "line": 1110
        },
        "resolved": true,
        "details": {
          "function_name": "is_si_special",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "740-743",
          "snippet": "static inline int is_si_special(const struct kernel_siginfo *info)\n{\n\treturn info <= SEND_SIG_PRIV;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic inline int is_si_special(const struct kernel_siginfo *info)\n{\n\treturn info <= SEND_SIG_PRIV;\n}"
        }
      },
      {
        "call_info": {
          "callee": "userns_fixup_signal_uid",
          "args": [
            "&q->info",
            "t"
          ],
          "line": 1108
        },
        "resolved": true,
        "details": {
          "function_name": "userns_fixup_signal_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1027-1030",
          "snippet": "static inline void userns_fixup_signal_uid(struct kernel_siginfo *info, struct task_struct *t)\n{\n\treturn;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic inline void userns_fixup_signal_uid(struct kernel_siginfo *info, struct task_struct *t)\n{\n\treturn;\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_siginfo",
          "args": [
            "&q->info",
            "info"
          ],
          "line": 1102
        },
        "resolved": true,
        "details": {
          "function_name": "copy_siginfo_from_user32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "3149-3158",
          "snippet": "int copy_siginfo_from_user32(struct kernel_siginfo *to,\n\t\t\t     const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn post_copy_siginfo_from_user32(to, &from);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint copy_siginfo_from_user32(struct kernel_siginfo *to,\n\t\t\t     const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn post_copy_siginfo_from_user32(to, &from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&q->info"
          ],
          "line": 1094
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "current_user_ns()",
            "current_uid()"
          ],
          "line": 1091
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_uid",
          "args": [],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1091
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_tgid_nr_ns",
          "args": [
            "current",
            "task_active_pid_ns(t)"
          ],
          "line": 1089
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_active_pid_ns",
          "args": [
            "t"
          ],
          "line": 1090
        },
        "resolved": true,
        "details": {
          "function_name": "task_active_pid_ns",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/pid.c",
          "lines": "436-439",
          "snippet": "struct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}",
          "includes": [
            "#include <linux/idr.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/proc_fs.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/init_task.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/hash.h>",
            "#include <linux/memblock.h>",
            "#include <linux/rculist.h>",
            "#include <linux/init.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/idr.h>\n#include <linux/sched/task.h>\n#include <linux/proc_fs.h>\n#include <linux/proc_ns.h>\n#include <linux/syscalls.h>\n#include <linux/init_task.h>\n#include <linux/pid_namespace.h>\n#include <linux/hash.h>\n#include <linux/memblock.h>\n#include <linux/rculist.h>\n#include <linux/init.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n\nstruct pid_namespace *task_active_pid_ns(struct task_struct *tsk)\n{\n\treturn ns_of_pid(task_pid(tsk));\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "&q->info"
          ],
          "line": 1085
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_add_tail",
          "args": [
            "&q->list",
            "&pending->list"
          ],
          "line": 1082
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sigqueue_alloc",
          "args": [
            "sig",
            "t",
            "GFP_ATOMIC",
            "override_rlimit"
          ],
          "line": 1080
        },
        "resolved": true,
        "details": {
          "function_name": "__sigqueue_alloc",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "401-434",
          "snippet": "static struct sigqueue *\n__sigqueue_alloc(int sig, struct task_struct *t, gfp_t flags, int override_rlimit)\n{\n\tstruct sigqueue *q = NULL;\n\tstruct user_struct *user;\n\n\t/*\n\t * Protect access to @t credentials. This can go away when all\n\t * callers hold rcu read lock.\n\t */\n\trcu_read_lock();\n\tuser = get_uid(__task_cred(t)->user);\n\tatomic_inc(&user->sigpending);\n\trcu_read_unlock();\n\n\tif (override_rlimit ||\n\t    atomic_read(&user->sigpending) <=\n\t\t\ttask_rlimit(t, RLIMIT_SIGPENDING)) {\n\t\tq = kmem_cache_alloc(sigqueue_cachep, flags);\n\t} else {\n\t\tprint_dropped_signal(sig);\n\t}\n\n\tif (unlikely(q == NULL)) {\n\t\tatomic_dec(&user->sigpending);\n\t\tfree_uid(user);\n\t} else {\n\t\tINIT_LIST_HEAD(&q->list);\n\t\tq->flags = 0;\n\t\tq->user = user;\n\t}\n\n\treturn q;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sigqueue_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nstatic struct sigqueue *\n__sigqueue_alloc(int sig, struct task_struct *t, gfp_t flags, int override_rlimit)\n{\n\tstruct sigqueue *q = NULL;\n\tstruct user_struct *user;\n\n\t/*\n\t * Protect access to @t credentials. This can go away when all\n\t * callers hold rcu read lock.\n\t */\n\trcu_read_lock();\n\tuser = get_uid(__task_cred(t)->user);\n\tatomic_inc(&user->sigpending);\n\trcu_read_unlock();\n\n\tif (override_rlimit ||\n\t    atomic_read(&user->sigpending) <=\n\t\t\ttask_rlimit(t, RLIMIT_SIGPENDING)) {\n\t\tq = kmem_cache_alloc(sigqueue_cachep, flags);\n\t} else {\n\t\tprint_dropped_signal(sig);\n\t}\n\n\tif (unlikely(q == NULL)) {\n\t\tatomic_dec(&user->sigpending);\n\t\tfree_uid(user);\n\t} else {\n\t\tINIT_LIST_HEAD(&q->list);\n\t\tq->flags = 0;\n\t\tq->user = user;\n\t}\n\n\treturn q;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sig_kernel_only",
          "args": [
            "sig"
          ],
          "line": 1063
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "legacy_queue",
          "args": [
            "pending",
            "sig"
          ],
          "line": 1055
        },
        "resolved": true,
        "details": {
          "function_name": "legacy_queue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "1007-1010",
          "snippet": "static inline bool legacy_queue(struct sigpending *signals, int sig)\n{\n\treturn (sig < SIGRTMIN) && sigismember(&signals->signal, sig);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool legacy_queue(struct sigpending *signals, int sig)\n{\n\treturn (sig < SIGRTMIN) && sigismember(&signals->signal, sig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "prepare_signal",
          "args": [
            "sig",
            "t",
            "from_ancestor_ns || (info == SEND_SIG_PRIV)"
          ],
          "line": 1044
        },
        "resolved": true,
        "details": {
          "function_name": "prepare_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "841-904",
          "snippet": "static bool prepare_signal(int sig, struct task_struct *p, bool force)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\tsigset_t flush;\n\n\tif (signal->flags & (SIGNAL_GROUP_EXIT | SIGNAL_GROUP_COREDUMP)) {\n\t\tif (!(signal->flags & SIGNAL_GROUP_EXIT))\n\t\t\treturn sig == SIGKILL;\n\t\t/*\n\t\t * The process is in the middle of dying, nothing to do.\n\t\t */\n\t} else if (sig_kernel_stop(sig)) {\n\t\t/*\n\t\t * This is a stop signal.  Remove SIGCONT from all queues.\n\t\t */\n\t\tsiginitset(&flush, sigmask(SIGCONT));\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t)\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t} else if (sig == SIGCONT) {\n\t\tunsigned int why;\n\t\t/*\n\t\t * Remove all stop signals from all queues, wake all threads.\n\t\t */\n\t\tsiginitset(&flush, SIG_KERNEL_STOP_MASK);\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t) {\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t\t\ttask_clear_jobctl_pending(t, JOBCTL_STOP_PENDING);\n\t\t\tif (likely(!(t->ptrace & PT_SEIZED)))\n\t\t\t\twake_up_state(t, __TASK_STOPPED);\n\t\t\telse\n\t\t\t\tptrace_trap_notify(t);\n\t\t}\n\n\t\t/*\n\t\t * Notify the parent with CLD_CONTINUED if we were stopped.\n\t\t *\n\t\t * If we were in the middle of a group stop, we pretend it\n\t\t * was already finished, and then continued. Since SIGCHLD\n\t\t * doesn't queue we report only CLD_STOPPED, as if the next\n\t\t * CLD_CONTINUED was dropped.\n\t\t */\n\t\twhy = 0;\n\t\tif (signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\twhy |= SIGNAL_CLD_CONTINUED;\n\t\telse if (signal->group_stop_count)\n\t\t\twhy |= SIGNAL_CLD_STOPPED;\n\n\t\tif (why) {\n\t\t\t/*\n\t\t\t * The first thread which returns from do_signal_stop()\n\t\t\t * will take ->siglock, notice SIGNAL_CLD_MASK, and\n\t\t\t * notify its parent. See get_signal().\n\t\t\t */\n\t\t\tsignal_set_stop_flags(signal, why | SIGNAL_STOP_CONTINUED);\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tsignal->group_exit_code = 0;\n\t\t}\n\t}\n\n\treturn !sig_ignored(p, sig, force);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool prepare_signal(int sig, struct task_struct *p, bool force)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\tsigset_t flush;\n\n\tif (signal->flags & (SIGNAL_GROUP_EXIT | SIGNAL_GROUP_COREDUMP)) {\n\t\tif (!(signal->flags & SIGNAL_GROUP_EXIT))\n\t\t\treturn sig == SIGKILL;\n\t\t/*\n\t\t * The process is in the middle of dying, nothing to do.\n\t\t */\n\t} else if (sig_kernel_stop(sig)) {\n\t\t/*\n\t\t * This is a stop signal.  Remove SIGCONT from all queues.\n\t\t */\n\t\tsiginitset(&flush, sigmask(SIGCONT));\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t)\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t} else if (sig == SIGCONT) {\n\t\tunsigned int why;\n\t\t/*\n\t\t * Remove all stop signals from all queues, wake all threads.\n\t\t */\n\t\tsiginitset(&flush, SIG_KERNEL_STOP_MASK);\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t) {\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t\t\ttask_clear_jobctl_pending(t, JOBCTL_STOP_PENDING);\n\t\t\tif (likely(!(t->ptrace & PT_SEIZED)))\n\t\t\t\twake_up_state(t, __TASK_STOPPED);\n\t\t\telse\n\t\t\t\tptrace_trap_notify(t);\n\t\t}\n\n\t\t/*\n\t\t * Notify the parent with CLD_CONTINUED if we were stopped.\n\t\t *\n\t\t * If we were in the middle of a group stop, we pretend it\n\t\t * was already finished, and then continued. Since SIGCHLD\n\t\t * doesn't queue we report only CLD_STOPPED, as if the next\n\t\t * CLD_CONTINUED was dropped.\n\t\t */\n\t\twhy = 0;\n\t\tif (signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\twhy |= SIGNAL_CLD_CONTINUED;\n\t\telse if (signal->group_stop_count)\n\t\t\twhy |= SIGNAL_CLD_STOPPED;\n\n\t\tif (why) {\n\t\t\t/*\n\t\t\t * The first thread which returns from do_signal_stop()\n\t\t\t * will take ->siglock, notice SIGNAL_CLD_MASK, and\n\t\t\t * notify its parent. See get_signal().\n\t\t\t */\n\t\t\tsignal_set_stop_flags(signal, why | SIGNAL_STOP_CONTINUED);\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tsignal->group_exit_code = 0;\n\t\t}\n\t}\n\n\treturn !sig_ignored(p, sig, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&t->sighand->siglock"
          ],
          "line": 1041
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int __send_signal(int sig, struct kernel_siginfo *info, struct task_struct *t,\n\t\t\tenum pid_type type, int from_ancestor_ns)\n{\n\tstruct sigpending *pending;\n\tstruct sigqueue *q;\n\tint override_rlimit;\n\tint ret = 0, result;\n\n\tassert_spin_locked(&t->sighand->siglock);\n\n\tresult = TRACE_SIGNAL_IGNORED;\n\tif (!prepare_signal(sig, t,\n\t\t\tfrom_ancestor_ns || (info == SEND_SIG_PRIV)))\n\t\tgoto ret;\n\n\tpending = (type != PIDTYPE_PID) ? &t->signal->shared_pending : &t->pending;\n\t/*\n\t * Short-circuit ignored signals and support queuing\n\t * exactly one non-rt signal, so that we can get more\n\t * detailed information about the cause of the signal.\n\t */\n\tresult = TRACE_SIGNAL_ALREADY_PENDING;\n\tif (legacy_queue(pending, sig))\n\t\tgoto ret;\n\n\tresult = TRACE_SIGNAL_DELIVERED;\n\t/*\n\t * Skip useless siginfo allocation for SIGKILL SIGSTOP,\n\t * and kernel threads.\n\t */\n\tif (sig_kernel_only(sig) || (t->flags & PF_KTHREAD))\n\t\tgoto out_set;\n\n\t/*\n\t * Real-time signals must be queued if sent by sigqueue, or\n\t * some other real-time mechanism.  It is implementation\n\t * defined whether kill() does so.  We attempt to do so, on\n\t * the principle of least surprise, but since kill is not\n\t * allowed to fail with EAGAIN when low on memory we just\n\t * make sure at least one signal gets delivered and don't\n\t * pass on the info struct.\n\t */\n\tif (sig < SIGRTMIN)\n\t\toverride_rlimit = (is_si_special(info) || info->si_code >= 0);\n\telse\n\t\toverride_rlimit = 0;\n\n\tq = __sigqueue_alloc(sig, t, GFP_ATOMIC, override_rlimit);\n\tif (q) {\n\t\tlist_add_tail(&q->list, &pending->list);\n\t\tswitch ((unsigned long) info) {\n\t\tcase (unsigned long) SEND_SIG_NOINFO:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_USER;\n\t\t\tq->info.si_pid = task_tgid_nr_ns(current,\n\t\t\t\t\t\t\ttask_active_pid_ns(t));\n\t\t\tq->info.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\t\t\tbreak;\n\t\tcase (unsigned long) SEND_SIG_PRIV:\n\t\t\tclear_siginfo(&q->info);\n\t\t\tq->info.si_signo = sig;\n\t\t\tq->info.si_errno = 0;\n\t\t\tq->info.si_code = SI_KERNEL;\n\t\t\tq->info.si_pid = 0;\n\t\t\tq->info.si_uid = 0;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tcopy_siginfo(&q->info, info);\n\t\t\tif (from_ancestor_ns)\n\t\t\t\tq->info.si_pid = 0;\n\t\t\tbreak;\n\t\t}\n\n\t\tuserns_fixup_signal_uid(&q->info, t);\n\n\t} else if (!is_si_special(info)) {\n\t\tif (sig >= SIGRTMIN && info->si_code != SI_USER) {\n\t\t\t/*\n\t\t\t * Queue overflow, abort.  We may abort if the\n\t\t\t * signal was rt and sent by user using something\n\t\t\t * other than kill().\n\t\t\t */\n\t\t\tresult = TRACE_SIGNAL_OVERFLOW_FAIL;\n\t\t\tret = -EAGAIN;\n\t\t\tgoto ret;\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is a silent loss of information.  We still\n\t\t\t * send the signal, but the *info bits are lost.\n\t\t\t */\n\t\t\tresult = TRACE_SIGNAL_LOSE_INFO;\n\t\t}\n\t}\n\nout_set:\n\tsignalfd_notify(t, sig);\n\tsigaddset(&pending->signal, sig);\n\n\t/* Let multiprocess signals appear after on-going forks */\n\tif (type > PIDTYPE_TGID) {\n\t\tstruct multiprocess_signals *delayed;\n\t\thlist_for_each_entry(delayed, &t->signal->multiprocess, node) {\n\t\t\tsigset_t *signal = &delayed->signal;\n\t\t\t/* Can't queue both a stop and a continue signal */\n\t\t\tif (sig == SIGCONT)\n\t\t\t\tsigdelsetmask(signal, SIG_KERNEL_STOP_MASK);\n\t\t\telse if (sig_kernel_stop(sig))\n\t\t\t\tsigdelset(signal, SIGCONT);\n\t\t\tsigaddset(signal, sig);\n\t\t}\n\t}\n\n\tcomplete_signal(sig, t, type);\nret:\n\ttrace_signal_generate(sig, info, t, type != PIDTYPE_PID, result);\n\treturn ret;\n}"
  },
  {
    "function_name": "userns_fixup_signal_uid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1027-1030",
    "snippet": "static inline void userns_fixup_signal_uid(struct kernel_siginfo *info, struct task_struct *t)\n{\n\treturn;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic inline void userns_fixup_signal_uid(struct kernel_siginfo *info, struct task_struct *t)\n{\n\treturn;\n}"
  },
  {
    "function_name": "userns_fixup_signal_uid",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1013-1025",
    "snippet": "static inline void userns_fixup_signal_uid(struct kernel_siginfo *info, struct task_struct *t)\n{\n\tif (current_user_ns() == task_cred_xxx(t, user_ns))\n\t\treturn;\n\n\tif (SI_FROMKERNEL(info))\n\t\treturn;\n\n\trcu_read_lock();\n\tinfo->si_uid = from_kuid_munged(task_cred_xxx(t, user_ns),\n\t\t\t\t\tmake_kuid(current_user_ns(), info->si_uid));\n\trcu_read_unlock();\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 1024
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "from_kuid_munged",
          "args": [
            "task_cred_xxx(t, user_ns)",
            "make_kuid(current_user_ns(), info->si_uid)"
          ],
          "line": 1022
        },
        "resolved": true,
        "details": {
          "function_name": "from_kuid_munged",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "436-444",
          "snippet": "uid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nuid_t from_kuid_munged(struct user_namespace *targ, kuid_t kuid)\n{\n\tuid_t uid;\n\tuid = from_kuid(targ, kuid);\n\n\tif (uid == (uid_t) -1)\n\t\tuid = overflowuid;\n\treturn uid;\n}"
        }
      },
      {
        "call_info": {
          "callee": "make_kuid",
          "args": [
            "current_user_ns()",
            "info->si_uid"
          ],
          "line": 1023
        },
        "resolved": true,
        "details": {
          "function_name": "make_kuid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user_namespace.c",
          "lines": "392-396",
          "snippet": "kuid_t make_kuid(struct user_namespace *ns, uid_t uid)\n{\n\t/* Map the uid to a global kernel uid */\n\treturn KUIDT_INIT(map_id_down(&ns->uid_map, uid));\n}",
          "includes": [
            "#include <linux/sort.h>",
            "#include <linux/bsearch.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/projid.h>",
            "#include <linux/ctype.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/fs.h>",
            "#include <linux/seq_file.h>",
            "#include <keys/user-type.h>",
            "#include <linux/key-type.h>",
            "#include <linux/keyctl.h>",
            "#include <linux/securebits.h>",
            "#include <linux/cred.h>",
            "#include <linux/highuid.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/slab.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/export.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/sort.h>\n#include <linux/bsearch.h>\n#include <linux/fs_struct.h>\n#include <linux/projid.h>\n#include <linux/ctype.h>\n#include <linux/uaccess.h>\n#include <linux/fs.h>\n#include <linux/seq_file.h>\n#include <keys/user-type.h>\n#include <linux/key-type.h>\n#include <linux/keyctl.h>\n#include <linux/securebits.h>\n#include <linux/cred.h>\n#include <linux/highuid.h>\n#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/sched/signal.h>\n#include <linux/slab.h>\n#include <linux/nsproxy.h>\n#include <linux/export.h>\n\nkuid_t make_kuid(struct user_namespace *ns, uid_t uid)\n{\n\t/* Map the uid to a global kernel uid */\n\treturn KUIDT_INIT(map_id_down(&ns->uid_map, uid));\n}"
        }
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1023
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cred_xxx",
          "args": [
            "t",
            "user_ns"
          ],
          "line": 1022
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 1021
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      },
      {
        "call_info": {
          "callee": "SI_FROMKERNEL",
          "args": [
            "info"
          ],
          "line": 1018
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_cred_xxx",
          "args": [
            "t",
            "user_ns"
          ],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_user_ns",
          "args": [],
          "line": 1015
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic inline void userns_fixup_signal_uid(struct kernel_siginfo *info, struct task_struct *t)\n{\n\tif (current_user_ns() == task_cred_xxx(t, user_ns))\n\t\treturn;\n\n\tif (SI_FROMKERNEL(info))\n\t\treturn;\n\n\trcu_read_lock();\n\tinfo->si_uid = from_kuid_munged(task_cred_xxx(t, user_ns),\n\t\t\t\t\tmake_kuid(current_user_ns(), info->si_uid));\n\trcu_read_unlock();\n}"
  },
  {
    "function_name": "legacy_queue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "1007-1010",
    "snippet": "static inline bool legacy_queue(struct sigpending *signals, int sig)\n{\n\treturn (sig < SIGRTMIN) && sigismember(&signals->signal, sig);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigismember",
          "args": [
            "&signals->signal",
            "sig"
          ],
          "line": 1009
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool legacy_queue(struct sigpending *signals, int sig)\n{\n\treturn (sig < SIGRTMIN) && sigismember(&signals->signal, sig);\n}"
  },
  {
    "function_name": "complete_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "931-1005",
    "snippet": "static void complete_signal(int sig, struct task_struct *p, enum pid_type type)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\n\t/*\n\t * Now find a thread we can wake up to take the signal off the queue.\n\t *\n\t * If the main thread wants the signal, it gets first crack.\n\t * Probably the least surprising to the average bear.\n\t */\n\tif (wants_signal(sig, p))\n\t\tt = p;\n\telse if ((type == PIDTYPE_PID) || thread_group_empty(p))\n\t\t/*\n\t\t * There is just one thread and it does not need to be woken.\n\t\t * It will dequeue unblocked signals before it runs again.\n\t\t */\n\t\treturn;\n\telse {\n\t\t/*\n\t\t * Otherwise try to find a suitable thread.\n\t\t */\n\t\tt = signal->curr_target;\n\t\twhile (!wants_signal(sig, t)) {\n\t\t\tt = next_thread(t);\n\t\t\tif (t == signal->curr_target)\n\t\t\t\t/*\n\t\t\t\t * No thread needs to be woken.\n\t\t\t\t * Any eligible threads will see\n\t\t\t\t * the signal in the queue soon.\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t}\n\t\tsignal->curr_target = t;\n\t}\n\n\t/*\n\t * Found a killable thread.  If the signal will be fatal,\n\t * then start taking the whole group down immediately.\n\t */\n\tif (sig_fatal(p, sig) &&\n\t    !(signal->flags & SIGNAL_GROUP_EXIT) &&\n\t    !sigismember(&t->real_blocked, sig) &&\n\t    (sig == SIGKILL || !p->ptrace)) {\n\t\t/*\n\t\t * This signal will be fatal to the whole group.\n\t\t */\n\t\tif (!sig_kernel_coredump(sig)) {\n\t\t\t/*\n\t\t\t * Start a group exit and wake everybody up.\n\t\t\t * This way we don't have other threads\n\t\t\t * running and doing things after a slower\n\t\t\t * thread has the fatal signal pending.\n\t\t\t */\n\t\t\tsignal->flags = SIGNAL_GROUP_EXIT;\n\t\t\tsignal->group_exit_code = sig;\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tt = p;\n\t\t\tdo {\n\t\t\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\t\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\t\t\tsignal_wake_up(t, 1);\n\t\t\t} while_each_thread(p, t);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * The signal is already in the shared-pending queue.\n\t * Tell the chosen thread to wake up and dequeue it.\n\t */\n\tsignal_wake_up(t, sig == SIGKILL);\n\treturn;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_wake_up",
          "args": [
            "t",
            "sig == SIGKILL"
          ],
          "line": 1003
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "702-714",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "while_each_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 994
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&t->pending.signal",
            "SIGKILL"
          ],
          "line": 992
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_clear_jobctl_pending",
          "args": [
            "t",
            "JOBCTL_PENDING_MASK"
          ],
          "line": 991
        },
        "resolved": true,
        "details": {
          "function_name": "task_clear_jobctl_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "327-338",
          "snippet": "void task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sig_kernel_coredump",
          "args": [
            "sig"
          ],
          "line": 979
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigismember",
          "args": [
            "&t->real_blocked",
            "sig"
          ],
          "line": 974
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sig_fatal",
          "args": [
            "p",
            "sig"
          ],
          "line": 972
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_thread",
          "args": [
            "t"
          ],
          "line": 956
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wants_signal",
          "args": [
            "sig",
            "t"
          ],
          "line": 955
        },
        "resolved": true,
        "details": {
          "function_name": "wants_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "914-929",
          "snippet": "static inline bool wants_signal(int sig, struct task_struct *p)\n{\n\tif (sigismember(&p->blocked, sig))\n\t\treturn false;\n\n\tif (p->flags & PF_EXITING)\n\t\treturn false;\n\n\tif (sig == SIGKILL)\n\t\treturn true;\n\n\tif (task_is_stopped_or_traced(p))\n\t\treturn false;\n\n\treturn task_curr(p) || !signal_pending(p);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool wants_signal(int sig, struct task_struct *p)\n{\n\tif (sigismember(&p->blocked, sig))\n\t\treturn false;\n\n\tif (p->flags & PF_EXITING)\n\t\treturn false;\n\n\tif (sig == SIGKILL)\n\t\treturn true;\n\n\tif (task_is_stopped_or_traced(p))\n\t\treturn false;\n\n\treturn task_curr(p) || !signal_pending(p);\n}"
        }
      },
      {
        "call_info": {
          "callee": "thread_group_empty",
          "args": [
            "p"
          ],
          "line": 944
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void complete_signal(int sig, struct task_struct *p, enum pid_type type)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\n\t/*\n\t * Now find a thread we can wake up to take the signal off the queue.\n\t *\n\t * If the main thread wants the signal, it gets first crack.\n\t * Probably the least surprising to the average bear.\n\t */\n\tif (wants_signal(sig, p))\n\t\tt = p;\n\telse if ((type == PIDTYPE_PID) || thread_group_empty(p))\n\t\t/*\n\t\t * There is just one thread and it does not need to be woken.\n\t\t * It will dequeue unblocked signals before it runs again.\n\t\t */\n\t\treturn;\n\telse {\n\t\t/*\n\t\t * Otherwise try to find a suitable thread.\n\t\t */\n\t\tt = signal->curr_target;\n\t\twhile (!wants_signal(sig, t)) {\n\t\t\tt = next_thread(t);\n\t\t\tif (t == signal->curr_target)\n\t\t\t\t/*\n\t\t\t\t * No thread needs to be woken.\n\t\t\t\t * Any eligible threads will see\n\t\t\t\t * the signal in the queue soon.\n\t\t\t\t */\n\t\t\t\treturn;\n\t\t}\n\t\tsignal->curr_target = t;\n\t}\n\n\t/*\n\t * Found a killable thread.  If the signal will be fatal,\n\t * then start taking the whole group down immediately.\n\t */\n\tif (sig_fatal(p, sig) &&\n\t    !(signal->flags & SIGNAL_GROUP_EXIT) &&\n\t    !sigismember(&t->real_blocked, sig) &&\n\t    (sig == SIGKILL || !p->ptrace)) {\n\t\t/*\n\t\t * This signal will be fatal to the whole group.\n\t\t */\n\t\tif (!sig_kernel_coredump(sig)) {\n\t\t\t/*\n\t\t\t * Start a group exit and wake everybody up.\n\t\t\t * This way we don't have other threads\n\t\t\t * running and doing things after a slower\n\t\t\t * thread has the fatal signal pending.\n\t\t\t */\n\t\t\tsignal->flags = SIGNAL_GROUP_EXIT;\n\t\t\tsignal->group_exit_code = sig;\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tt = p;\n\t\t\tdo {\n\t\t\t\ttask_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);\n\t\t\t\tsigaddset(&t->pending.signal, SIGKILL);\n\t\t\t\tsignal_wake_up(t, 1);\n\t\t\t} while_each_thread(p, t);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/*\n\t * The signal is already in the shared-pending queue.\n\t * Tell the chosen thread to wake up and dequeue it.\n\t */\n\tsignal_wake_up(t, sig == SIGKILL);\n\treturn;\n}"
  },
  {
    "function_name": "wants_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "914-929",
    "snippet": "static inline bool wants_signal(int sig, struct task_struct *p)\n{\n\tif (sigismember(&p->blocked, sig))\n\t\treturn false;\n\n\tif (p->flags & PF_EXITING)\n\t\treturn false;\n\n\tif (sig == SIGKILL)\n\t\treturn true;\n\n\tif (task_is_stopped_or_traced(p))\n\t\treturn false;\n\n\treturn task_curr(p) || !signal_pending(p);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_pending",
          "args": [
            "p"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_curr",
          "args": [
            "p"
          ],
          "line": 928
        },
        "resolved": true,
        "details": {
          "function_name": "task_curr",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "816-819",
          "snippet": "inline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\ninline int task_curr(const struct task_struct *p)\n{\n\treturn cpu_curr(task_cpu(p)) == p;\n}"
        }
      },
      {
        "call_info": {
          "callee": "task_is_stopped_or_traced",
          "args": [
            "p"
          ],
          "line": 925
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigismember",
          "args": [
            "&p->blocked",
            "sig"
          ],
          "line": 916
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool wants_signal(int sig, struct task_struct *p)\n{\n\tif (sigismember(&p->blocked, sig))\n\t\treturn false;\n\n\tif (p->flags & PF_EXITING)\n\t\treturn false;\n\n\tif (sig == SIGKILL)\n\t\treturn true;\n\n\tif (task_is_stopped_or_traced(p))\n\t\treturn false;\n\n\treturn task_curr(p) || !signal_pending(p);\n}"
  },
  {
    "function_name": "prepare_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "841-904",
    "snippet": "static bool prepare_signal(int sig, struct task_struct *p, bool force)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\tsigset_t flush;\n\n\tif (signal->flags & (SIGNAL_GROUP_EXIT | SIGNAL_GROUP_COREDUMP)) {\n\t\tif (!(signal->flags & SIGNAL_GROUP_EXIT))\n\t\t\treturn sig == SIGKILL;\n\t\t/*\n\t\t * The process is in the middle of dying, nothing to do.\n\t\t */\n\t} else if (sig_kernel_stop(sig)) {\n\t\t/*\n\t\t * This is a stop signal.  Remove SIGCONT from all queues.\n\t\t */\n\t\tsiginitset(&flush, sigmask(SIGCONT));\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t)\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t} else if (sig == SIGCONT) {\n\t\tunsigned int why;\n\t\t/*\n\t\t * Remove all stop signals from all queues, wake all threads.\n\t\t */\n\t\tsiginitset(&flush, SIG_KERNEL_STOP_MASK);\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t) {\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t\t\ttask_clear_jobctl_pending(t, JOBCTL_STOP_PENDING);\n\t\t\tif (likely(!(t->ptrace & PT_SEIZED)))\n\t\t\t\twake_up_state(t, __TASK_STOPPED);\n\t\t\telse\n\t\t\t\tptrace_trap_notify(t);\n\t\t}\n\n\t\t/*\n\t\t * Notify the parent with CLD_CONTINUED if we were stopped.\n\t\t *\n\t\t * If we were in the middle of a group stop, we pretend it\n\t\t * was already finished, and then continued. Since SIGCHLD\n\t\t * doesn't queue we report only CLD_STOPPED, as if the next\n\t\t * CLD_CONTINUED was dropped.\n\t\t */\n\t\twhy = 0;\n\t\tif (signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\twhy |= SIGNAL_CLD_CONTINUED;\n\t\telse if (signal->group_stop_count)\n\t\t\twhy |= SIGNAL_CLD_STOPPED;\n\n\t\tif (why) {\n\t\t\t/*\n\t\t\t * The first thread which returns from do_signal_stop()\n\t\t\t * will take ->siglock, notice SIGNAL_CLD_MASK, and\n\t\t\t * notify its parent. See get_signal().\n\t\t\t */\n\t\t\tsignal_set_stop_flags(signal, why | SIGNAL_STOP_CONTINUED);\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tsignal->group_exit_code = 0;\n\t\t}\n\t}\n\n\treturn !sig_ignored(p, sig, force);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sig_ignored",
          "args": [
            "p",
            "sig",
            "force"
          ],
          "line": 903
        },
        "resolved": true,
        "details": {
          "function_name": "sig_ignored",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "92-111",
          "snippet": "static bool sig_ignored(struct task_struct *t, int sig, bool force)\n{\n\t/*\n\t * Blocked signals are never ignored, since the\n\t * signal handler may change by the time it is\n\t * unblocked.\n\t */\n\tif (sigismember(&t->blocked, sig) || sigismember(&t->real_blocked, sig))\n\t\treturn false;\n\n\t/*\n\t * Tracers may want to know about even ignored signal unless it\n\t * is SIGKILL which can't be reported anyway but can be ignored\n\t * by SIGNAL_UNKILLABLE task.\n\t */\n\tif (t->ptrace && sig != SIGKILL)\n\t\treturn false;\n\n\treturn sig_task_ignored(t, sig, force);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool sig_ignored(struct task_struct *t, int sig, bool force)\n{\n\t/*\n\t * Blocked signals are never ignored, since the\n\t * signal handler may change by the time it is\n\t * unblocked.\n\t */\n\tif (sigismember(&t->blocked, sig) || sigismember(&t->real_blocked, sig))\n\t\treturn false;\n\n\t/*\n\t * Tracers may want to know about even ignored signal unless it\n\t * is SIGKILL which can't be reported anyway but can be ignored\n\t * by SIGNAL_UNKILLABLE task.\n\t */\n\tif (t->ptrace && sig != SIGKILL)\n\t\treturn false;\n\n\treturn sig_task_ignored(t, sig, force);\n}"
        }
      },
      {
        "call_info": {
          "callee": "signal_set_stop_flags",
          "args": [
            "signal",
            "why | SIGNAL_STOP_CONTINUED"
          ],
          "line": 897
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ptrace_trap_notify",
          "args": [
            "t"
          ],
          "line": 874
        },
        "resolved": true,
        "details": {
          "function_name": "ptrace_trap_notify",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "822-829",
          "snippet": "static void ptrace_trap_notify(struct task_struct *t)\n{\n\tWARN_ON_ONCE(!(t->ptrace & PT_SEIZED));\n\tassert_spin_locked(&t->sighand->siglock);\n\n\ttask_set_jobctl_pending(t, JOBCTL_TRAP_NOTIFY);\n\tptrace_signal_wake_up(t, t->jobctl & JOBCTL_LISTENING);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void ptrace_trap_notify(struct task_struct *t)\n{\n\tWARN_ON_ONCE(!(t->ptrace & PT_SEIZED));\n\tassert_spin_locked(&t->sighand->siglock);\n\n\ttask_set_jobctl_pending(t, JOBCTL_TRAP_NOTIFY);\n\tptrace_signal_wake_up(t, t->jobctl & JOBCTL_LISTENING);\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_state",
          "args": [
            "t",
            "__TASK_STOPPED"
          ],
          "line": 872
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "702-714",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "!(t->ptrace & PT_SEIZED)"
          ],
          "line": 871
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_clear_jobctl_pending",
          "args": [
            "t",
            "JOBCTL_STOP_PENDING"
          ],
          "line": 870
        },
        "resolved": true,
        "details": {
          "function_name": "task_clear_jobctl_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "327-338",
          "snippet": "void task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_sigqueue_mask",
          "args": [
            "&flush",
            "&t->pending"
          ],
          "line": 869
        },
        "resolved": true,
        "details": {
          "function_name": "flush_sigqueue_mask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "722-738",
          "snippet": "static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn;\n\n\tsigandnsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn;\n\n\tsigandnsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "siginitset",
          "args": [
            "&flush",
            "SIG_KERNEL_STOP_MASK"
          ],
          "line": 866
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "for_each_thread",
          "args": [
            "p",
            "t"
          ],
          "line": 859
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "siginitset",
          "args": [
            "&flush",
            "sigmask(SIGCONT)"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigmask",
          "args": [
            "SIGCONT"
          ],
          "line": 857
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sig_kernel_stop",
          "args": [
            "sig"
          ],
          "line": 853
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool prepare_signal(int sig, struct task_struct *p, bool force)\n{\n\tstruct signal_struct *signal = p->signal;\n\tstruct task_struct *t;\n\tsigset_t flush;\n\n\tif (signal->flags & (SIGNAL_GROUP_EXIT | SIGNAL_GROUP_COREDUMP)) {\n\t\tif (!(signal->flags & SIGNAL_GROUP_EXIT))\n\t\t\treturn sig == SIGKILL;\n\t\t/*\n\t\t * The process is in the middle of dying, nothing to do.\n\t\t */\n\t} else if (sig_kernel_stop(sig)) {\n\t\t/*\n\t\t * This is a stop signal.  Remove SIGCONT from all queues.\n\t\t */\n\t\tsiginitset(&flush, sigmask(SIGCONT));\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t)\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t} else if (sig == SIGCONT) {\n\t\tunsigned int why;\n\t\t/*\n\t\t * Remove all stop signals from all queues, wake all threads.\n\t\t */\n\t\tsiginitset(&flush, SIG_KERNEL_STOP_MASK);\n\t\tflush_sigqueue_mask(&flush, &signal->shared_pending);\n\t\tfor_each_thread(p, t) {\n\t\t\tflush_sigqueue_mask(&flush, &t->pending);\n\t\t\ttask_clear_jobctl_pending(t, JOBCTL_STOP_PENDING);\n\t\t\tif (likely(!(t->ptrace & PT_SEIZED)))\n\t\t\t\twake_up_state(t, __TASK_STOPPED);\n\t\t\telse\n\t\t\t\tptrace_trap_notify(t);\n\t\t}\n\n\t\t/*\n\t\t * Notify the parent with CLD_CONTINUED if we were stopped.\n\t\t *\n\t\t * If we were in the middle of a group stop, we pretend it\n\t\t * was already finished, and then continued. Since SIGCHLD\n\t\t * doesn't queue we report only CLD_STOPPED, as if the next\n\t\t * CLD_CONTINUED was dropped.\n\t\t */\n\t\twhy = 0;\n\t\tif (signal->flags & SIGNAL_STOP_STOPPED)\n\t\t\twhy |= SIGNAL_CLD_CONTINUED;\n\t\telse if (signal->group_stop_count)\n\t\t\twhy |= SIGNAL_CLD_STOPPED;\n\n\t\tif (why) {\n\t\t\t/*\n\t\t\t * The first thread which returns from do_signal_stop()\n\t\t\t * will take ->siglock, notice SIGNAL_CLD_MASK, and\n\t\t\t * notify its parent. See get_signal().\n\t\t\t */\n\t\t\tsignal_set_stop_flags(signal, why | SIGNAL_STOP_CONTINUED);\n\t\t\tsignal->group_stop_count = 0;\n\t\t\tsignal->group_exit_code = 0;\n\t\t}\n\t}\n\n\treturn !sig_ignored(p, sig, force);\n}"
  },
  {
    "function_name": "ptrace_trap_notify",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "822-829",
    "snippet": "static void ptrace_trap_notify(struct task_struct *t)\n{\n\tWARN_ON_ONCE(!(t->ptrace & PT_SEIZED));\n\tassert_spin_locked(&t->sighand->siglock);\n\n\ttask_set_jobctl_pending(t, JOBCTL_TRAP_NOTIFY);\n\tptrace_signal_wake_up(t, t->jobctl & JOBCTL_LISTENING);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ptrace_signal_wake_up",
          "args": [
            "t",
            "t->jobctl & JOBCTL_LISTENING"
          ],
          "line": 828
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_set_jobctl_pending",
          "args": [
            "t",
            "JOBCTL_TRAP_NOTIFY"
          ],
          "line": 827
        },
        "resolved": true,
        "details": {
          "function_name": "task_set_jobctl_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "275-289",
          "snippet": "bool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\n\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n\t\treturn false;\n\n\tif (mask & JOBCTL_STOP_SIGMASK)\n\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\n\ttask->jobctl |= mask;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nbool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\n\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n\t\treturn false;\n\n\tif (mask & JOBCTL_STOP_SIGMASK)\n\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\n\ttask->jobctl |= mask;\n\treturn true;\n}"
        }
      },
      {
        "call_info": {
          "callee": "assert_spin_locked",
          "args": [
            "&t->sighand->siglock"
          ],
          "line": 825
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(t->ptrace & PT_SEIZED)"
          ],
          "line": 824
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void ptrace_trap_notify(struct task_struct *t)\n{\n\tWARN_ON_ONCE(!(t->ptrace & PT_SEIZED));\n\tassert_spin_locked(&t->sighand->siglock);\n\n\ttask_set_jobctl_pending(t, JOBCTL_TRAP_NOTIFY);\n\tptrace_signal_wake_up(t, t->jobctl & JOBCTL_LISTENING);\n}"
  },
  {
    "function_name": "check_kill_permission",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "770-803",
    "snippet": "static int check_kill_permission(int sig, struct kernel_siginfo *info,\n\t\t\t\t struct task_struct *t)\n{\n\tstruct pid *sid;\n\tint error;\n\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\tif (!si_fromuser(info))\n\t\treturn 0;\n\n\terror = audit_signal_info(sig, t); /* Let audit system see the signal */\n\tif (error)\n\t\treturn error;\n\n\tif (!same_thread_group(current, t) &&\n\t    !kill_ok_by_cred(t)) {\n\t\tswitch (sig) {\n\t\tcase SIGCONT:\n\t\t\tsid = task_session(t);\n\t\t\t/*\n\t\t\t * We don't return the error if sid == NULL. The\n\t\t\t * task was unhashed, the caller must notice this.\n\t\t\t */\n\t\t\tif (!sid || sid == task_session(current))\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn security_task_kill(t, info, sig, NULL);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "security_task_kill",
          "args": [
            "t",
            "info",
            "sig",
            "NULL"
          ],
          "line": 802
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_session",
          "args": [
            "current"
          ],
          "line": 795
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_session",
          "args": [
            "t"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kill_ok_by_cred",
          "args": [
            "t"
          ],
          "line": 787
        },
        "resolved": true,
        "details": {
          "function_name": "kill_ok_by_cred",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "754-764",
          "snippet": "static bool kill_ok_by_cred(struct task_struct *t)\n{\n\tconst struct cred *cred = current_cred();\n\tconst struct cred *tcred = __task_cred(t);\n\n\treturn uid_eq(cred->euid, tcred->suid) ||\n\t       uid_eq(cred->euid, tcred->uid) ||\n\t       uid_eq(cred->uid, tcred->suid) ||\n\t       uid_eq(cred->uid, tcred->uid) ||\n\t       ns_capable(tcred->user_ns, CAP_KILL);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool kill_ok_by_cred(struct task_struct *t)\n{\n\tconst struct cred *cred = current_cred();\n\tconst struct cred *tcred = __task_cred(t);\n\n\treturn uid_eq(cred->euid, tcred->suid) ||\n\t       uid_eq(cred->euid, tcred->uid) ||\n\t       uid_eq(cred->uid, tcred->suid) ||\n\t       uid_eq(cred->uid, tcred->uid) ||\n\t       ns_capable(tcred->user_ns, CAP_KILL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "same_thread_group",
          "args": [
            "current",
            "t"
          ],
          "line": 786
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "audit_signal_info",
          "args": [
            "sig",
            "t"
          ],
          "line": 782
        },
        "resolved": true,
        "details": {
          "function_name": "audit_signal_info",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/auditsc.c",
          "lines": "2286-2340",
          "snippet": "int audit_signal_info(int sig, struct task_struct *t)\n{\n\tstruct audit_aux_data_pids *axp;\n\tstruct audit_context *ctx = audit_context();\n\tkuid_t uid = current_uid(), auid, t_uid = task_uid(t);\n\n\tif (auditd_test_task(t) &&\n\t    (sig == SIGTERM || sig == SIGHUP ||\n\t     sig == SIGUSR1 || sig == SIGUSR2)) {\n\t\taudit_sig_pid = task_tgid_nr(current);\n\t\tauid = audit_get_loginuid(current);\n\t\tif (uid_valid(auid))\n\t\t\taudit_sig_uid = auid;\n\t\telse\n\t\t\taudit_sig_uid = uid;\n\t\tsecurity_task_getsecid(current, &audit_sig_sid);\n\t}\n\n\tif (!audit_signals || audit_dummy_context())\n\t\treturn 0;\n\n\t/* optimize the common case by putting first signal recipient directly\n\t * in audit_context */\n\tif (!ctx->target_pid) {\n\t\tctx->target_pid = task_tgid_nr(t);\n\t\tctx->target_auid = audit_get_loginuid(t);\n\t\tctx->target_uid = t_uid;\n\t\tctx->target_sessionid = audit_get_sessionid(t);\n\t\tsecurity_task_getsecid(t, &ctx->target_sid);\n\t\tmemcpy(ctx->target_comm, t->comm, TASK_COMM_LEN);\n\t\treturn 0;\n\t}\n\n\taxp = (void *)ctx->aux_pids;\n\tif (!axp || axp->pid_count == AUDIT_AUX_PIDS) {\n\t\taxp = kzalloc(sizeof(*axp), GFP_ATOMIC);\n\t\tif (!axp)\n\t\t\treturn -ENOMEM;\n\n\t\taxp->d.type = AUDIT_OBJ_PID;\n\t\taxp->d.next = ctx->aux_pids;\n\t\tctx->aux_pids = (void *)axp;\n\t}\n\tBUG_ON(axp->pid_count >= AUDIT_AUX_PIDS);\n\n\taxp->target_pid[axp->pid_count] = task_tgid_nr(t);\n\taxp->target_auid[axp->pid_count] = audit_get_loginuid(t);\n\taxp->target_uid[axp->pid_count] = t_uid;\n\taxp->target_sessionid[axp->pid_count] = audit_get_sessionid(t);\n\tsecurity_task_getsecid(t, &axp->target_sid[axp->pid_count]);\n\tmemcpy(axp->target_comm[axp->pid_count], t->comm, TASK_COMM_LEN);\n\taxp->pid_count++;\n\n\treturn 0;\n}",
          "includes": [
            "#include \"audit.h\"",
            "#include <uapi/linux/limits.h>",
            "#include <linux/fsnotify_backend.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/string.h>",
            "#include <linux/ctype.h>",
            "#include <linux/compat.h>",
            "#include <linux/fs_struct.h>",
            "#include <linux/capability.h>",
            "#include <asm/syscall.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/highmem.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/list.h>",
            "#include <linux/security.h>",
            "#include <asm/unistd.h>",
            "#include <linux/compiler.h>",
            "#include <linux/netlink.h>",
            "#include <linux/time.h>",
            "#include <linux/personality.h>",
            "#include <linux/audit.h>",
            "#include <linux/mqueue.h>",
            "#include <linux/socket.h>",
            "#include <linux/mount.h>",
            "#include <linux/slab.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/namei.h>",
            "#include <linux/fs.h>",
            "#include <linux/atomic.h>",
            "#include <asm/types.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [
            "#define AUDIT_AUX_PIDS\t16"
          ],
          "globals_used": [
            "int audit_signals;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"audit.h\"\n#include <uapi/linux/limits.h>\n#include <linux/fsnotify_backend.h>\n#include <linux/uaccess.h>\n#include <linux/string.h>\n#include <linux/ctype.h>\n#include <linux/compat.h>\n#include <linux/fs_struct.h>\n#include <linux/capability.h>\n#include <asm/syscall.h>\n#include <linux/syscalls.h>\n#include <linux/highmem.h>\n#include <linux/binfmts.h>\n#include <linux/list.h>\n#include <linux/security.h>\n#include <asm/unistd.h>\n#include <linux/compiler.h>\n#include <linux/netlink.h>\n#include <linux/time.h>\n#include <linux/personality.h>\n#include <linux/audit.h>\n#include <linux/mqueue.h>\n#include <linux/socket.h>\n#include <linux/mount.h>\n#include <linux/slab.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/namei.h>\n#include <linux/fs.h>\n#include <linux/atomic.h>\n#include <asm/types.h>\n#include <linux/init.h>\n\n#define AUDIT_AUX_PIDS\t16\n\nint audit_signals;\n\nint audit_signal_info(int sig, struct task_struct *t)\n{\n\tstruct audit_aux_data_pids *axp;\n\tstruct audit_context *ctx = audit_context();\n\tkuid_t uid = current_uid(), auid, t_uid = task_uid(t);\n\n\tif (auditd_test_task(t) &&\n\t    (sig == SIGTERM || sig == SIGHUP ||\n\t     sig == SIGUSR1 || sig == SIGUSR2)) {\n\t\taudit_sig_pid = task_tgid_nr(current);\n\t\tauid = audit_get_loginuid(current);\n\t\tif (uid_valid(auid))\n\t\t\taudit_sig_uid = auid;\n\t\telse\n\t\t\taudit_sig_uid = uid;\n\t\tsecurity_task_getsecid(current, &audit_sig_sid);\n\t}\n\n\tif (!audit_signals || audit_dummy_context())\n\t\treturn 0;\n\n\t/* optimize the common case by putting first signal recipient directly\n\t * in audit_context */\n\tif (!ctx->target_pid) {\n\t\tctx->target_pid = task_tgid_nr(t);\n\t\tctx->target_auid = audit_get_loginuid(t);\n\t\tctx->target_uid = t_uid;\n\t\tctx->target_sessionid = audit_get_sessionid(t);\n\t\tsecurity_task_getsecid(t, &ctx->target_sid);\n\t\tmemcpy(ctx->target_comm, t->comm, TASK_COMM_LEN);\n\t\treturn 0;\n\t}\n\n\taxp = (void *)ctx->aux_pids;\n\tif (!axp || axp->pid_count == AUDIT_AUX_PIDS) {\n\t\taxp = kzalloc(sizeof(*axp), GFP_ATOMIC);\n\t\tif (!axp)\n\t\t\treturn -ENOMEM;\n\n\t\taxp->d.type = AUDIT_OBJ_PID;\n\t\taxp->d.next = ctx->aux_pids;\n\t\tctx->aux_pids = (void *)axp;\n\t}\n\tBUG_ON(axp->pid_count >= AUDIT_AUX_PIDS);\n\n\taxp->target_pid[axp->pid_count] = task_tgid_nr(t);\n\taxp->target_auid[axp->pid_count] = audit_get_loginuid(t);\n\taxp->target_uid[axp->pid_count] = t_uid;\n\taxp->target_sessionid[axp->pid_count] = audit_get_sessionid(t);\n\tsecurity_task_getsecid(t, &axp->target_sid[axp->pid_count]);\n\tmemcpy(axp->target_comm[axp->pid_count], t->comm, TASK_COMM_LEN);\n\taxp->pid_count++;\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "si_fromuser",
          "args": [
            "info"
          ],
          "line": 779
        },
        "resolved": true,
        "details": {
          "function_name": "si_fromuser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "745-749",
          "snippet": "static inline bool si_fromuser(const struct kernel_siginfo *info)\n{\n\treturn info == SEND_SIG_NOINFO ||\n\t\t(!is_si_special(info) && SI_FROMUSER(info));\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic inline bool si_fromuser(const struct kernel_siginfo *info)\n{\n\treturn info == SEND_SIG_NOINFO ||\n\t\t(!is_si_special(info) && SI_FROMUSER(info));\n}"
        }
      },
      {
        "call_info": {
          "callee": "valid_signal",
          "args": [
            "sig"
          ],
          "line": 776
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int check_kill_permission(int sig, struct kernel_siginfo *info,\n\t\t\t\t struct task_struct *t)\n{\n\tstruct pid *sid;\n\tint error;\n\n\tif (!valid_signal(sig))\n\t\treturn -EINVAL;\n\n\tif (!si_fromuser(info))\n\t\treturn 0;\n\n\terror = audit_signal_info(sig, t); /* Let audit system see the signal */\n\tif (error)\n\t\treturn error;\n\n\tif (!same_thread_group(current, t) &&\n\t    !kill_ok_by_cred(t)) {\n\t\tswitch (sig) {\n\t\tcase SIGCONT:\n\t\t\tsid = task_session(t);\n\t\t\t/*\n\t\t\t * We don't return the error if sid == NULL. The\n\t\t\t * task was unhashed, the caller must notice this.\n\t\t\t */\n\t\t\tif (!sid || sid == task_session(current))\n\t\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EPERM;\n\t\t}\n\t}\n\n\treturn security_task_kill(t, info, sig, NULL);\n}"
  },
  {
    "function_name": "kill_ok_by_cred",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "754-764",
    "snippet": "static bool kill_ok_by_cred(struct task_struct *t)\n{\n\tconst struct cred *cred = current_cred();\n\tconst struct cred *tcred = __task_cred(t);\n\n\treturn uid_eq(cred->euid, tcred->suid) ||\n\t       uid_eq(cred->euid, tcred->uid) ||\n\t       uid_eq(cred->uid, tcred->suid) ||\n\t       uid_eq(cred->uid, tcred->uid) ||\n\t       ns_capable(tcred->user_ns, CAP_KILL);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ns_capable",
          "args": [
            "tcred->user_ns",
            "CAP_KILL"
          ],
          "line": 763
        },
        "resolved": true,
        "details": {
          "function_name": "ns_capable_noaudit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/capability.c",
          "lines": "413-416",
          "snippet": "bool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}",
          "includes": [
            "#include <linux/uaccess.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/export.h>",
            "#include <linux/mm.h>",
            "#include <linux/capability.h>",
            "#include <linux/audit.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/uaccess.h>\n#include <linux/user_namespace.h>\n#include <linux/pid_namespace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/export.h>\n#include <linux/mm.h>\n#include <linux/capability.h>\n#include <linux/audit.h>\n\nbool ns_capable_noaudit(struct user_namespace *ns, int cap)\n{\n\treturn ns_capable_common(ns, cap, false);\n}"
        }
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cred->uid",
            "tcred->uid"
          ],
          "line": 762
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cred->uid",
            "tcred->suid"
          ],
          "line": 761
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cred->euid",
            "tcred->uid"
          ],
          "line": 760
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "uid_eq",
          "args": [
            "cred->euid",
            "tcred->suid"
          ],
          "line": 759
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "t"
          ],
          "line": 757
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "current_cred",
          "args": [],
          "line": 756
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool kill_ok_by_cred(struct task_struct *t)\n{\n\tconst struct cred *cred = current_cred();\n\tconst struct cred *tcred = __task_cred(t);\n\n\treturn uid_eq(cred->euid, tcred->suid) ||\n\t       uid_eq(cred->euid, tcred->uid) ||\n\t       uid_eq(cred->uid, tcred->suid) ||\n\t       uid_eq(cred->uid, tcred->uid) ||\n\t       ns_capable(tcred->user_ns, CAP_KILL);\n}"
  },
  {
    "function_name": "si_fromuser",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "745-749",
    "snippet": "static inline bool si_fromuser(const struct kernel_siginfo *info)\n{\n\treturn info == SEND_SIG_NOINFO ||\n\t\t(!is_si_special(info) && SI_FROMUSER(info));\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "SI_FROMUSER",
          "args": [
            "info"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_si_special",
          "args": [
            "info"
          ],
          "line": 748
        },
        "resolved": true,
        "details": {
          "function_name": "is_si_special",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "740-743",
          "snippet": "static inline int is_si_special(const struct kernel_siginfo *info)\n{\n\treturn info <= SEND_SIG_PRIV;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic inline int is_si_special(const struct kernel_siginfo *info)\n{\n\treturn info <= SEND_SIG_PRIV;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic inline bool si_fromuser(const struct kernel_siginfo *info)\n{\n\treturn info == SEND_SIG_NOINFO ||\n\t\t(!is_si_special(info) && SI_FROMUSER(info));\n}"
  },
  {
    "function_name": "is_si_special",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "740-743",
    "snippet": "static inline int is_si_special(const struct kernel_siginfo *info)\n{\n\treturn info <= SEND_SIG_PRIV;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic inline int is_si_special(const struct kernel_siginfo *info)\n{\n\treturn info <= SEND_SIG_PRIV;\n}"
  },
  {
    "function_name": "flush_sigqueue_mask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "722-738",
    "snippet": "static void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn;\n\n\tsigandnsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sigqueue_free",
          "args": [
            "q"
          ],
          "line": 735
        },
        "resolved": true,
        "details": {
          "function_name": "__sigqueue_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "436-443",
          "snippet": "static void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tatomic_dec(&q->user->sigpending);\n\tfree_uid(q->user);\n\tkmem_cache_free(sigqueue_cachep, q);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sigqueue_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nstatic void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tatomic_dec(&q->user->sigpending);\n\tfree_uid(q->user);\n\tkmem_cache_free(sigqueue_cachep, q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&q->list"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigismember",
          "args": [
            "mask",
            "q->info.si_signo"
          ],
          "line": 733
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "q",
            "n",
            "&s->list",
            "list"
          ],
          "line": 732
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigandnsets",
          "args": [
            "&s->signal",
            "&s->signal",
            "mask"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigisemptyset",
          "args": [
            "&m"
          ],
          "line": 728
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigandsets",
          "args": [
            "&m",
            "mask",
            "&s->signal"
          ],
          "line": 727
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic void flush_sigqueue_mask(sigset_t *mask, struct sigpending *s)\n{\n\tstruct sigqueue *q, *n;\n\tsigset_t m;\n\n\tsigandsets(&m, mask, &s->signal);\n\tif (sigisemptyset(&m))\n\t\treturn;\n\n\tsigandnsets(&s->signal, &s->signal, mask);\n\tlist_for_each_entry_safe(q, n, &s->list, list) {\n\t\tif (sigismember(mask, q->info.si_signo)) {\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "signal_wake_up_state",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "702-714",
    "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "kick_process",
          "args": [
            "t"
          ],
          "line": 713
        },
        "resolved": true,
        "details": {
          "function_name": "kick_process",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/core.c",
          "lines": "1424-1433",
          "snippet": "void kick_process(struct task_struct *p)\n{\n\tint cpu;\n\n\tpreempt_disable();\n\tcpu = task_cpu(p);\n\tif ((cpu != smp_processor_id()) && task_curr(p))\n\t\tsmp_send_reschedule(cpu);\n\tpreempt_enable();\n}",
          "includes": [
            "#include \"features.h\"",
            "#include <trace/events/sched.h>",
            "#include \"pelt.h\"",
            "#include \"../smpboot.h\"",
            "#include \"../workqueue_internal.h\"",
            "#include <asm/tlb.h>",
            "#include <asm/switch_to.h>",
            "#include <linux/kcov.h>",
            "#include <linux/nospec.h>",
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static __always_inline struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"features.h\"\n#include <trace/events/sched.h>\n#include \"pelt.h\"\n#include \"../smpboot.h\"\n#include \"../workqueue_internal.h\"\n#include <asm/tlb.h>\n#include <asm/switch_to.h>\n#include <linux/kcov.h>\n#include <linux/nospec.h>\n#include \"sched.h\"\n\nstatic __always_inline struct;\n\nvoid kick_process(struct task_struct *p)\n{\n\tint cpu;\n\n\tpreempt_disable();\n\tcpu = task_cpu(p);\n\tif ((cpu != smp_processor_id()) && task_curr(p))\n\t\tsmp_send_reschedule(cpu);\n\tpreempt_enable();\n}"
        }
      },
      {
        "call_info": {
          "callee": "wake_up_state",
          "args": [
            "t",
            "state | TASK_INTERRUPTIBLE"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "702-714",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "t",
            "TIF_SIGPENDING"
          ],
          "line": 704
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
  },
  {
    "function_name": "dequeue_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "613-688",
    "snippet": "int dequeue_signal(struct task_struct *tsk, sigset_t *mask, kernel_siginfo_t *info)\n{\n\tbool resched_timer = false;\n\tint signr;\n\n\t/* We only dequeue private signals from ourselves, we don't let\n\t * signalfd steal them\n\t */\n\tsignr = __dequeue_signal(&tsk->pending, mask, info, &resched_timer);\n\tif (!signr) {\n\t\tsignr = __dequeue_signal(&tsk->signal->shared_pending,\n\t\t\t\t\t mask, info, &resched_timer);\n#ifdef CONFIG_POSIX_TIMERS\n\t\t/*\n\t\t * itimer signal ?\n\t\t *\n\t\t * itimers are process shared and we restart periodic\n\t\t * itimers in the signal delivery path to prevent DoS\n\t\t * attacks in the high resolution timer case. This is\n\t\t * compliant with the old way of self-restarting\n\t\t * itimers, as the SIGALRM is a legacy signal and only\n\t\t * queued once. Changing the restart behaviour to\n\t\t * restart the timer in the signal dequeue path is\n\t\t * reducing the timer noise on heavy loaded !highres\n\t\t * systems too.\n\t\t */\n\t\tif (unlikely(signr == SIGALRM)) {\n\t\t\tstruct hrtimer *tmr = &tsk->signal->real_timer;\n\n\t\t\tif (!hrtimer_is_queued(tmr) &&\n\t\t\t    tsk->signal->it_real_incr != 0) {\n\t\t\t\thrtimer_forward(tmr, tmr->base->get_time(),\n\t\t\t\t\t\ttsk->signal->it_real_incr);\n\t\t\t\thrtimer_restart(tmr);\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\trecalc_sigpending();\n\tif (!signr)\n\t\treturn 0;\n\n\tif (unlikely(sig_kernel_stop(signr))) {\n\t\t/*\n\t\t * Set a marker that we have dequeued a stop signal.  Our\n\t\t * caller might release the siglock and then the pending\n\t\t * stop signal it is about to process is no longer in the\n\t\t * pending bitmasks, but must still be cleared by a SIGCONT\n\t\t * (and overruled by a SIGKILL).  So those cases clear this\n\t\t * shared flag after we've set it.  Note that this flag may\n\t\t * remain set after the signal we return is ignored or\n\t\t * handled.  That doesn't matter because its only purpose\n\t\t * is to alert stop-signal processing code when another\n\t\t * processor has come along and cleared the flag.\n\t\t */\n\t\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;\n\t}\n#ifdef CONFIG_POSIX_TIMERS\n\tif (resched_timer) {\n\t\t/*\n\t\t * Release the siglock to ensure proper locking order\n\t\t * of timer locks outside of siglocks.  Note, we leave\n\t\t * irqs disabled here, since the posix-timers code is\n\t\t * about to disable them again anyway.\n\t\t */\n\t\tspin_unlock(&tsk->sighand->siglock);\n\t\tposixtimer_rearm(info);\n\t\tspin_lock(&tsk->sighand->siglock);\n\n\t\t/* Don't expose the si_sys_private value to userspace */\n\t\tinfo->si_sys_private = 0;\n\t}\n#endif\n\treturn signr;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_lock",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 681
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_bh",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "166-169",
          "snippet": "void __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_bh(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_bh(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "posixtimer_rearm",
          "args": [
            "info"
          ],
          "line": 680
        },
        "resolved": true,
        "details": {
          "function_name": "posixtimer_rearm",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/posix-timers.c",
          "lines": "311-332",
          "snippet": "void posixtimer_rearm(struct kernel_siginfo *info)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\n\ttimr = lock_timer(info->si_tid, &flags);\n\tif (!timr)\n\t\treturn;\n\n\tif (timr->it_requeue_pending == info->si_sys_private) {\n\t\ttimr->kclock->timer_rearm(timr);\n\n\t\ttimr->it_active = 1;\n\t\ttimr->it_overrun_last = timr->it_overrun;\n\t\ttimr->it_overrun = -1LL;\n\t\t++timr->it_requeue_pending;\n\n\t\tinfo->si_overrun = timer_overrun_to_int(timr, info->si_overrun);\n\t}\n\n\tunlock_timer(timr, flags);\n}",
          "includes": [
            "#include \"posix-timers.h\"",
            "#include \"timekeeping.h\"",
            "#include <linux/nospec.h>",
            "#include <linux/compat.h>",
            "#include <linux/hashtable.h>",
            "#include <linux/export.h>",
            "#include <linux/workqueue.h>",
            "#include <linux/wait.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/posix-clock.h>",
            "#include <linux/hash.h>",
            "#include <linux/compiler.h>",
            "#include <linux/init.h>",
            "#include <linux/list.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/mutex.h>",
            "#include <linux/time.h>",
            "#include <linux/slab.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/mm.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"posix-timers.h\"\n#include \"timekeeping.h\"\n#include <linux/nospec.h>\n#include <linux/compat.h>\n#include <linux/hashtable.h>\n#include <linux/export.h>\n#include <linux/workqueue.h>\n#include <linux/wait.h>\n#include <linux/syscalls.h>\n#include <linux/posix-timers.h>\n#include <linux/posix-clock.h>\n#include <linux/hash.h>\n#include <linux/compiler.h>\n#include <linux/init.h>\n#include <linux/list.h>\n#include <linux/uaccess.h>\n#include <linux/sched/task.h>\n#include <linux/mutex.h>\n#include <linux/time.h>\n#include <linux/slab.h>\n#include <linux/interrupt.h>\n#include <linux/mm.h>\n\nstatic struct k_itimer *__lock_timer(timer_t timer_id, unsigned long *flags);\n\nvoid posixtimer_rearm(struct kernel_siginfo *info)\n{\n\tstruct k_itimer *timr;\n\tunsigned long flags;\n\n\ttimr = lock_timer(info->si_tid, &flags);\n\tif (!timr)\n\t\treturn;\n\n\tif (timr->it_requeue_pending == info->si_sys_private) {\n\t\ttimr->kclock->timer_rearm(timr);\n\n\t\ttimr->it_active = 1;\n\t\ttimr->it_overrun_last = timr->it_overrun;\n\t\ttimr->it_overrun = -1LL;\n\t\t++timr->it_requeue_pending;\n\n\t\tinfo->si_overrun = timer_overrun_to_int(timr, info->si_overrun);\n\t}\n\n\tunlock_timer(timr, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_unlock",
          "args": [
            "&tsk->sighand->siglock"
          ],
          "line": 679
        },
        "resolved": true,
        "details": {
          "function_name": "__pv_queued_spin_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/qspinlock_paravirt.h",
          "lines": "546-560",
          "snippet": "__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}",
          "includes": [
            "#include <asm/qspinlock_paravirt.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/memblock.h>",
            "#include <linux/hash.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <asm/qspinlock_paravirt.h>\n#include <linux/debug_locks.h>\n#include <linux/memblock.h>\n#include <linux/hash.h>\n\n__visible void __pv_queued_spin_unlock(struct qspinlock *lock)\n{\n\tu8 locked;\n\n\t/*\n\t * We must not unlock if SLOW, because in that case we must first\n\t * unhash. Otherwise it would be possible to have multiple @lock\n\t * entries, which would be BAD.\n\t */\n\tlocked = cmpxchg_release(&lock->locked, _Q_LOCKED_VAL, 0);\n\tif (likely(locked == _Q_LOCKED_VAL))\n\t\treturn;\n\n\t__pv_queued_spin_unlock_slowpath(lock, locked);\n}"
        }
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "sig_kernel_stop(signr)"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sig_kernel_stop",
          "args": [
            "signr"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "recalc_sigpending",
          "args": [],
          "line": 652
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_sigpending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "172-178",
          "snippet": "void recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current) &&\n\t    !klp_patch_pending(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current) &&\n\t    !klp_patch_pending(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_restart",
          "args": [
            "tmr"
          ],
          "line": 646
        },
        "resolved": true,
        "details": {
          "function_name": "perf_mux_hrtimer_restart",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/events/core.c",
          "lines": "1109-1128",
          "snippet": "static int perf_mux_hrtimer_restart(struct perf_cpu_context *cpuctx)\n{\n\tstruct hrtimer *timer = &cpuctx->hrtimer;\n\tstruct pmu *pmu = cpuctx->ctx.pmu;\n\tunsigned long flags;\n\n\t/* not for SW PMU */\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\treturn 0;\n\n\traw_spin_lock_irqsave(&cpuctx->hrtimer_lock, flags);\n\tif (!cpuctx->hrtimer_active) {\n\t\tcpuctx->hrtimer_active = 1;\n\t\thrtimer_forward_now(timer, cpuctx->hrtimer_interval);\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED);\n\t}\n\traw_spin_unlock_irqrestore(&cpuctx->hrtimer_lock, flags);\n\n\treturn 0;\n}",
          "includes": [
            "#include <asm/irq_regs.h>",
            "#include \"internal.h\"",
            "#include <linux/mount.h>",
            "#include <linux/proc_ns.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/sched/clock.h>",
            "#include <linux/parser.h>",
            "#include <linux/namei.h>",
            "#include <linux/filter.h>",
            "#include <linux/bpf.h>",
            "#include <linux/compat.h>",
            "#include <linux/mman.h>",
            "#include <linux/module.h>",
            "#include <linux/mm_types.h>",
            "#include <linux/hw_breakpoint.h>",
            "#include <linux/trace_events.h>",
            "#include <linux/perf_event.h>",
            "#include <linux/cgroup.h>",
            "#include <linux/kernel_stat.h>",
            "#include <linux/anon_inodes.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/rculist.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/vmalloc.h>",
            "#include <linux/export.h>",
            "#include <linux/device.h>",
            "#include <linux/vmstat.h>",
            "#include <linux/reboot.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/percpu.h>",
            "#include <linux/dcache.h>",
            "#include <linux/sysfs.h>",
            "#include <linux/tick.h>",
            "#include <linux/hash.h>",
            "#include <linux/slab.h>",
            "#include <linux/poll.h>",
            "#include <linux/file.h>",
            "#include <linux/idr.h>",
            "#include <linux/smp.h>",
            "#include <linux/cpu.h>",
            "#include <linux/mm.h>",
            "#include <linux/fs.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static bool perf_rotate_context(struct perf_cpu_context *cpuctx);",
            "static void update_context_time(struct perf_event_context *ctx);",
            "static __must_check struct"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <asm/irq_regs.h>\n#include \"internal.h\"\n#include <linux/mount.h>\n#include <linux/proc_ns.h>\n#include <linux/sched/mm.h>\n#include <linux/sched/clock.h>\n#include <linux/parser.h>\n#include <linux/namei.h>\n#include <linux/filter.h>\n#include <linux/bpf.h>\n#include <linux/compat.h>\n#include <linux/mman.h>\n#include <linux/module.h>\n#include <linux/mm_types.h>\n#include <linux/hw_breakpoint.h>\n#include <linux/trace_events.h>\n#include <linux/perf_event.h>\n#include <linux/cgroup.h>\n#include <linux/kernel_stat.h>\n#include <linux/anon_inodes.h>\n#include <linux/syscalls.h>\n#include <linux/uaccess.h>\n#include <linux/rculist.h>\n#include <linux/hardirq.h>\n#include <linux/vmalloc.h>\n#include <linux/export.h>\n#include <linux/device.h>\n#include <linux/vmstat.h>\n#include <linux/reboot.h>\n#include <linux/ptrace.h>\n#include <linux/percpu.h>\n#include <linux/dcache.h>\n#include <linux/sysfs.h>\n#include <linux/tick.h>\n#include <linux/hash.h>\n#include <linux/slab.h>\n#include <linux/poll.h>\n#include <linux/file.h>\n#include <linux/idr.h>\n#include <linux/smp.h>\n#include <linux/cpu.h>\n#include <linux/mm.h>\n#include <linux/fs.h>\n\nstatic bool perf_rotate_context(struct perf_cpu_context *cpuctx);\nstatic void update_context_time(struct perf_event_context *ctx);\nstatic __must_check struct;\n\nstatic int perf_mux_hrtimer_restart(struct perf_cpu_context *cpuctx)\n{\n\tstruct hrtimer *timer = &cpuctx->hrtimer;\n\tstruct pmu *pmu = cpuctx->ctx.pmu;\n\tunsigned long flags;\n\n\t/* not for SW PMU */\n\tif (pmu->task_ctx_nr == perf_sw_context)\n\t\treturn 0;\n\n\traw_spin_lock_irqsave(&cpuctx->hrtimer_lock, flags);\n\tif (!cpuctx->hrtimer_active) {\n\t\tcpuctx->hrtimer_active = 1;\n\t\thrtimer_forward_now(timer, cpuctx->hrtimer_interval);\n\t\thrtimer_start_expires(timer, HRTIMER_MODE_ABS_PINNED);\n\t}\n\traw_spin_unlock_irqrestore(&cpuctx->hrtimer_lock, flags);\n\n\treturn 0;\n}"
        }
      },
      {
        "call_info": {
          "callee": "hrtimer_forward",
          "args": [
            "tmr",
            "tmr->base->get_time()",
            "tsk->signal->it_real_incr"
          ],
          "line": 644
        },
        "resolved": true,
        "details": {
          "function_name": "hrtimer_forward",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/time/hrtimer.c",
          "lines": "907-939",
          "snippet": "u64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}",
          "includes": [
            "#include \"tick-internal.h\"",
            "#include <trace/events/timer.h>",
            "#include <linux/uaccess.h>",
            "#include <linux/compat.h>",
            "#include <linux/freezer.h>",
            "#include <linux/timer.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/nohz.h>",
            "#include <linux/sched/deadline.h>",
            "#include <linux/sched/rt.h>",
            "#include <linux/sched/sysctl.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/debugobjects.h>",
            "#include <linux/err.h>",
            "#include <linux/seq_file.h>",
            "#include <linux/tick.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/notifier.h>",
            "#include <linux/hrtimer.h>",
            "#include <linux/percpu.h>",
            "#include <linux/export.h>",
            "#include <linux/cpu.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"tick-internal.h\"\n#include <trace/events/timer.h>\n#include <linux/uaccess.h>\n#include <linux/compat.h>\n#include <linux/freezer.h>\n#include <linux/timer.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/nohz.h>\n#include <linux/sched/deadline.h>\n#include <linux/sched/rt.h>\n#include <linux/sched/sysctl.h>\n#include <linux/sched/signal.h>\n#include <linux/debugobjects.h>\n#include <linux/err.h>\n#include <linux/seq_file.h>\n#include <linux/tick.h>\n#include <linux/interrupt.h>\n#include <linux/syscalls.h>\n#include <linux/notifier.h>\n#include <linux/hrtimer.h>\n#include <linux/percpu.h>\n#include <linux/export.h>\n#include <linux/cpu.h>\n\nu64 hrtimer_forward(struct hrtimer *timer, ktime_t now, ktime_t interval)\n{\n\tu64 orun = 1;\n\tktime_t delta;\n\n\tdelta = ktime_sub(now, hrtimer_get_expires(timer));\n\n\tif (delta < 0)\n\t\treturn 0;\n\n\tif (WARN_ON(timer->state & HRTIMER_STATE_ENQUEUED))\n\t\treturn 0;\n\n\tif (interval < hrtimer_resolution)\n\t\tinterval = hrtimer_resolution;\n\n\tif (unlikely(delta >= interval)) {\n\t\ts64 incr = ktime_to_ns(interval);\n\n\t\torun = ktime_divns(delta, incr);\n\t\thrtimer_add_expires_ns(timer, incr * orun);\n\t\tif (hrtimer_get_expires_tv64(timer) > now)\n\t\t\treturn orun;\n\t\t/*\n\t\t * This (and the ktime_add() below) is the\n\t\t * correction for exact:\n\t\t */\n\t\torun++;\n\t}\n\thrtimer_add_expires(timer, interval);\n\n\treturn orun;\n}"
        }
      },
      {
        "call_info": {
          "callee": "tmr->base->get_time",
          "args": [],
          "line": 644
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hrtimer_is_queued",
          "args": [
            "tmr"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "signr == SIGALRM"
          ],
          "line": 639
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__dequeue_signal",
          "args": [
            "&tsk->signal->shared_pending",
            "mask",
            "info",
            "&resched_timer"
          ],
          "line": 623
        },
        "resolved": true,
        "details": {
          "function_name": "__dequeue_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "597-605",
          "snippet": "static int __dequeue_signal(struct sigpending *pending, sigset_t *mask,\n\t\t\tkernel_siginfo_t *info, bool *resched_timer)\n{\n\tint sig = next_signal(pending, mask);\n\n\tif (sig)\n\t\tcollect_signal(sig, pending, info, resched_timer);\n\treturn sig;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int __dequeue_signal(struct sigpending *pending, sigset_t *mask,\n\t\t\tkernel_siginfo_t *info, bool *resched_timer)\n{\n\tint sig = next_signal(pending, mask);\n\n\tif (sig)\n\t\tcollect_signal(sig, pending, info, resched_timer);\n\treturn sig;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nint dequeue_signal(struct task_struct *tsk, sigset_t *mask, kernel_siginfo_t *info)\n{\n\tbool resched_timer = false;\n\tint signr;\n\n\t/* We only dequeue private signals from ourselves, we don't let\n\t * signalfd steal them\n\t */\n\tsignr = __dequeue_signal(&tsk->pending, mask, info, &resched_timer);\n\tif (!signr) {\n\t\tsignr = __dequeue_signal(&tsk->signal->shared_pending,\n\t\t\t\t\t mask, info, &resched_timer);\n#ifdef CONFIG_POSIX_TIMERS\n\t\t/*\n\t\t * itimer signal ?\n\t\t *\n\t\t * itimers are process shared and we restart periodic\n\t\t * itimers in the signal delivery path to prevent DoS\n\t\t * attacks in the high resolution timer case. This is\n\t\t * compliant with the old way of self-restarting\n\t\t * itimers, as the SIGALRM is a legacy signal and only\n\t\t * queued once. Changing the restart behaviour to\n\t\t * restart the timer in the signal dequeue path is\n\t\t * reducing the timer noise on heavy loaded !highres\n\t\t * systems too.\n\t\t */\n\t\tif (unlikely(signr == SIGALRM)) {\n\t\t\tstruct hrtimer *tmr = &tsk->signal->real_timer;\n\n\t\t\tif (!hrtimer_is_queued(tmr) &&\n\t\t\t    tsk->signal->it_real_incr != 0) {\n\t\t\t\thrtimer_forward(tmr, tmr->base->get_time(),\n\t\t\t\t\t\ttsk->signal->it_real_incr);\n\t\t\t\thrtimer_restart(tmr);\n\t\t\t}\n\t\t}\n#endif\n\t}\n\n\trecalc_sigpending();\n\tif (!signr)\n\t\treturn 0;\n\n\tif (unlikely(sig_kernel_stop(signr))) {\n\t\t/*\n\t\t * Set a marker that we have dequeued a stop signal.  Our\n\t\t * caller might release the siglock and then the pending\n\t\t * stop signal it is about to process is no longer in the\n\t\t * pending bitmasks, but must still be cleared by a SIGCONT\n\t\t * (and overruled by a SIGKILL).  So those cases clear this\n\t\t * shared flag after we've set it.  Note that this flag may\n\t\t * remain set after the signal we return is ignored or\n\t\t * handled.  That doesn't matter because its only purpose\n\t\t * is to alert stop-signal processing code when another\n\t\t * processor has come along and cleared the flag.\n\t\t */\n\t\tcurrent->jobctl |= JOBCTL_STOP_DEQUEUED;\n\t}\n#ifdef CONFIG_POSIX_TIMERS\n\tif (resched_timer) {\n\t\t/*\n\t\t * Release the siglock to ensure proper locking order\n\t\t * of timer locks outside of siglocks.  Note, we leave\n\t\t * irqs disabled here, since the posix-timers code is\n\t\t * about to disable them again anyway.\n\t\t */\n\t\tspin_unlock(&tsk->sighand->siglock);\n\t\tposixtimer_rearm(info);\n\t\tspin_lock(&tsk->sighand->siglock);\n\n\t\t/* Don't expose the si_sys_private value to userspace */\n\t\tinfo->si_sys_private = 0;\n\t}\n#endif\n\treturn signr;\n}"
  },
  {
    "function_name": "__dequeue_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "597-605",
    "snippet": "static int __dequeue_signal(struct sigpending *pending, sigset_t *mask,\n\t\t\tkernel_siginfo_t *info, bool *resched_timer)\n{\n\tint sig = next_signal(pending, mask);\n\n\tif (sig)\n\t\tcollect_signal(sig, pending, info, resched_timer);\n\treturn sig;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "collect_signal",
          "args": [
            "sig",
            "pending",
            "info",
            "resched_timer"
          ],
          "line": 603
        },
        "resolved": true,
        "details": {
          "function_name": "collect_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "552-595",
          "snippet": "static void collect_signal(int sig, struct sigpending *list, kernel_siginfo_t *info,\n\t\t\t   bool *resched_timer)\n{\n\tstruct sigqueue *q, *first = NULL;\n\n\t/*\n\t * Collect the siginfo appropriate to this signal.  Check if\n\t * there is another siginfo for the same signal.\n\t*/\n\tlist_for_each_entry(q, &list->list, list) {\n\t\tif (q->info.si_signo == sig) {\n\t\t\tif (first)\n\t\t\t\tgoto still_pending;\n\t\t\tfirst = q;\n\t\t}\n\t}\n\n\tsigdelset(&list->signal, sig);\n\n\tif (first) {\nstill_pending:\n\t\tlist_del_init(&first->list);\n\t\tcopy_siginfo(info, &first->info);\n\n\t\t*resched_timer =\n\t\t\t(first->flags & SIGQUEUE_PREALLOC) &&\n\t\t\t(info->si_code == SI_TIMER) &&\n\t\t\t(info->si_sys_private);\n\n\t\t__sigqueue_free(first);\n\t} else {\n\t\t/*\n\t\t * Ok, it wasn't in the queue.  This must be\n\t\t * a fast-pathed signal or we must have been\n\t\t * out of queue space.  So zero out the info.\n\t\t */\n\t\tclear_siginfo(info);\n\t\tinfo->si_signo = sig;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\tinfo->si_pid = 0;\n\t\tinfo->si_uid = 0;\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic void collect_signal(int sig, struct sigpending *list, kernel_siginfo_t *info,\n\t\t\t   bool *resched_timer)\n{\n\tstruct sigqueue *q, *first = NULL;\n\n\t/*\n\t * Collect the siginfo appropriate to this signal.  Check if\n\t * there is another siginfo for the same signal.\n\t*/\n\tlist_for_each_entry(q, &list->list, list) {\n\t\tif (q->info.si_signo == sig) {\n\t\t\tif (first)\n\t\t\t\tgoto still_pending;\n\t\t\tfirst = q;\n\t\t}\n\t}\n\n\tsigdelset(&list->signal, sig);\n\n\tif (first) {\nstill_pending:\n\t\tlist_del_init(&first->list);\n\t\tcopy_siginfo(info, &first->info);\n\n\t\t*resched_timer =\n\t\t\t(first->flags & SIGQUEUE_PREALLOC) &&\n\t\t\t(info->si_code == SI_TIMER) &&\n\t\t\t(info->si_sys_private);\n\n\t\t__sigqueue_free(first);\n\t} else {\n\t\t/*\n\t\t * Ok, it wasn't in the queue.  This must be\n\t\t * a fast-pathed signal or we must have been\n\t\t * out of queue space.  So zero out the info.\n\t\t */\n\t\tclear_siginfo(info);\n\t\tinfo->si_signo = sig;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\tinfo->si_pid = 0;\n\t\tinfo->si_uid = 0;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "next_signal",
          "args": [
            "pending",
            "mask"
          ],
          "line": 600
        },
        "resolved": true,
        "details": {
          "function_name": "next_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "198-242",
          "snippet": "int next_signal(struct sigpending *pending, sigset_t *mask)\n{\n\tunsigned long i, *s, *m, x;\n\tint sig = 0;\n\n\ts = pending->signal.sig;\n\tm = mask->sig;\n\n\t/*\n\t * Handle the first word specially: it contains the\n\t * synchronous signals that need to be dequeued first.\n\t */\n\tx = *s &~ *m;\n\tif (x) {\n\t\tif (x & SYNCHRONOUS_MASK)\n\t\t\tx &= SYNCHRONOUS_MASK;\n\t\tsig = ffz(~x) + 1;\n\t\treturn sig;\n\t}\n\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tfor (i = 1; i < _NSIG_WORDS; ++i) {\n\t\t\tx = *++s &~ *++m;\n\t\t\tif (!x)\n\t\t\t\tcontinue;\n\t\t\tsig = ffz(~x) + i*_NSIG_BPW + 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\tx = s[1] &~ m[1];\n\t\tif (!x)\n\t\t\tbreak;\n\t\tsig = ffz(~x) + _NSIG_BPW + 1;\n\t\tbreak;\n\n\tcase 1:\n\t\t/* Nothing to do */\n\t\tbreak;\n\t}\n\n\treturn sig;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [
            "#define SYNCHRONOUS_MASK \\\n\t(sigmask(SIGSEGV) | sigmask(SIGBUS) | sigmask(SIGILL) | \\\n\t sigmask(SIGTRAP) | sigmask(SIGFPE) | sigmask(SIGSYS))"
          ],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\n#define SYNCHRONOUS_MASK \\\n\t(sigmask(SIGSEGV) | sigmask(SIGBUS) | sigmask(SIGILL) | \\\n\t sigmask(SIGTRAP) | sigmask(SIGFPE) | sigmask(SIGSYS))\n\nint next_signal(struct sigpending *pending, sigset_t *mask)\n{\n\tunsigned long i, *s, *m, x;\n\tint sig = 0;\n\n\ts = pending->signal.sig;\n\tm = mask->sig;\n\n\t/*\n\t * Handle the first word specially: it contains the\n\t * synchronous signals that need to be dequeued first.\n\t */\n\tx = *s &~ *m;\n\tif (x) {\n\t\tif (x & SYNCHRONOUS_MASK)\n\t\t\tx &= SYNCHRONOUS_MASK;\n\t\tsig = ffz(~x) + 1;\n\t\treturn sig;\n\t}\n\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tfor (i = 1; i < _NSIG_WORDS; ++i) {\n\t\t\tx = *++s &~ *++m;\n\t\t\tif (!x)\n\t\t\t\tcontinue;\n\t\t\tsig = ffz(~x) + i*_NSIG_BPW + 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\tx = s[1] &~ m[1];\n\t\tif (!x)\n\t\t\tbreak;\n\t\tsig = ffz(~x) + _NSIG_BPW + 1;\n\t\tbreak;\n\n\tcase 1:\n\t\t/* Nothing to do */\n\t\tbreak;\n\t}\n\n\treturn sig;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic int __dequeue_signal(struct sigpending *pending, sigset_t *mask,\n\t\t\tkernel_siginfo_t *info, bool *resched_timer)\n{\n\tint sig = next_signal(pending, mask);\n\n\tif (sig)\n\t\tcollect_signal(sig, pending, info, resched_timer);\n\treturn sig;\n}"
  },
  {
    "function_name": "collect_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "552-595",
    "snippet": "static void collect_signal(int sig, struct sigpending *list, kernel_siginfo_t *info,\n\t\t\t   bool *resched_timer)\n{\n\tstruct sigqueue *q, *first = NULL;\n\n\t/*\n\t * Collect the siginfo appropriate to this signal.  Check if\n\t * there is another siginfo for the same signal.\n\t*/\n\tlist_for_each_entry(q, &list->list, list) {\n\t\tif (q->info.si_signo == sig) {\n\t\t\tif (first)\n\t\t\t\tgoto still_pending;\n\t\t\tfirst = q;\n\t\t}\n\t}\n\n\tsigdelset(&list->signal, sig);\n\n\tif (first) {\nstill_pending:\n\t\tlist_del_init(&first->list);\n\t\tcopy_siginfo(info, &first->info);\n\n\t\t*resched_timer =\n\t\t\t(first->flags & SIGQUEUE_PREALLOC) &&\n\t\t\t(info->si_code == SI_TIMER) &&\n\t\t\t(info->si_sys_private);\n\n\t\t__sigqueue_free(first);\n\t} else {\n\t\t/*\n\t\t * Ok, it wasn't in the queue.  This must be\n\t\t * a fast-pathed signal or we must have been\n\t\t * out of queue space.  So zero out the info.\n\t\t */\n\t\tclear_siginfo(info);\n\t\tinfo->si_signo = sig;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\tinfo->si_pid = 0;\n\t\tinfo->si_uid = 0;\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_siginfo",
          "args": [
            "info"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sigqueue_free",
          "args": [
            "first"
          ],
          "line": 581
        },
        "resolved": true,
        "details": {
          "function_name": "__sigqueue_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "436-443",
          "snippet": "static void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tatomic_dec(&q->user->sigpending);\n\tfree_uid(q->user);\n\tkmem_cache_free(sigqueue_cachep, q);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sigqueue_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nstatic void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tatomic_dec(&q->user->sigpending);\n\tfree_uid(q->user);\n\tkmem_cache_free(sigqueue_cachep, q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "copy_siginfo",
          "args": [
            "info",
            "&first->info"
          ],
          "line": 574
        },
        "resolved": true,
        "details": {
          "function_name": "copy_siginfo_from_user32",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "3149-3158",
          "snippet": "int copy_siginfo_from_user32(struct kernel_siginfo *to,\n\t\t\t     const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn post_copy_siginfo_from_user32(to, &from);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint copy_siginfo_from_user32(struct kernel_siginfo *to,\n\t\t\t     const struct compat_siginfo __user *ufrom)\n{\n\tstruct compat_siginfo from;\n\n\tif (copy_from_user(&from, ufrom, sizeof(struct compat_siginfo)))\n\t\treturn -EFAULT;\n\n\treturn post_copy_siginfo_from_user32(to, &from);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&first->list"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&list->signal",
            "sig"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry",
          "args": [
            "q",
            "&list->list",
            "list"
          ],
          "line": 561
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic void collect_signal(int sig, struct sigpending *list, kernel_siginfo_t *info,\n\t\t\t   bool *resched_timer)\n{\n\tstruct sigqueue *q, *first = NULL;\n\n\t/*\n\t * Collect the siginfo appropriate to this signal.  Check if\n\t * there is another siginfo for the same signal.\n\t*/\n\tlist_for_each_entry(q, &list->list, list) {\n\t\tif (q->info.si_signo == sig) {\n\t\t\tif (first)\n\t\t\t\tgoto still_pending;\n\t\t\tfirst = q;\n\t\t}\n\t}\n\n\tsigdelset(&list->signal, sig);\n\n\tif (first) {\nstill_pending:\n\t\tlist_del_init(&first->list);\n\t\tcopy_siginfo(info, &first->info);\n\n\t\t*resched_timer =\n\t\t\t(first->flags & SIGQUEUE_PREALLOC) &&\n\t\t\t(info->si_code == SI_TIMER) &&\n\t\t\t(info->si_sys_private);\n\n\t\t__sigqueue_free(first);\n\t} else {\n\t\t/*\n\t\t * Ok, it wasn't in the queue.  This must be\n\t\t * a fast-pathed signal or we must have been\n\t\t * out of queue space.  So zero out the info.\n\t\t */\n\t\tclear_siginfo(info);\n\t\tinfo->si_signo = sig;\n\t\tinfo->si_errno = 0;\n\t\tinfo->si_code = SI_USER;\n\t\tinfo->si_pid = 0;\n\t\tinfo->si_uid = 0;\n\t}\n}"
  },
  {
    "function_name": "unhandled_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "539-550",
    "snippet": "bool unhandled_signal(struct task_struct *tsk, int sig)\n{\n\tvoid __user *handler = tsk->sighand->action[sig-1].sa.sa_handler;\n\tif (is_global_init(tsk))\n\t\treturn true;\n\n\tif (handler != SIG_IGN && handler != SIG_DFL)\n\t\treturn false;\n\n\t/* if ptraced, let the tracer determine */\n\treturn !tsk->ptrace;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "is_global_init",
          "args": [
            "tsk"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nbool unhandled_signal(struct task_struct *tsk, int sig)\n{\n\tvoid __user *handler = tsk->sighand->action[sig-1].sa.sa_handler;\n\tif (is_global_init(tsk))\n\t\treturn true;\n\n\tif (handler != SIG_IGN && handler != SIG_DFL)\n\t\treturn false;\n\n\t/* if ptraced, let the tracer determine */\n\treturn !tsk->ptrace;\n}"
  },
  {
    "function_name": "flush_signal_handlers",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "522-537",
    "snippet": "void\nflush_signal_handlers(struct task_struct *t, int force_default)\n{\n\tint i;\n\tstruct k_sigaction *ka = &t->sighand->action[0];\n\tfor (i = _NSIG ; i != 0 ; i--) {\n\t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n\t\t\tka->sa.sa_handler = SIG_DFL;\n\t\tka->sa.sa_flags = 0;\n#ifdef __ARCH_HAS_SA_RESTORER\n\t\tka->sa.sa_restorer = NULL;\n#endif\n\t\tsigemptyset(&ka->sa.sa_mask);\n\t\tka++;\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&ka->sa.sa_mask"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid\nflush_signal_handlers(struct task_struct *t, int force_default)\n{\n\tint i;\n\tstruct k_sigaction *ka = &t->sighand->action[0];\n\tfor (i = _NSIG ; i != 0 ; i--) {\n\t\tif (force_default || ka->sa.sa_handler != SIG_IGN)\n\t\t\tka->sa.sa_handler = SIG_DFL;\n\t\tka->sa.sa_flags = 0;\n#ifdef __ARCH_HAS_SA_RESTORER\n\t\tka->sa.sa_restorer = NULL;\n#endif\n\t\tsigemptyset(&ka->sa.sa_mask);\n\t\tka++;\n\t}\n}"
  },
  {
    "function_name": "ignore_signals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "508-516",
    "snippet": "void ignore_signals(struct task_struct *t)\n{\n\tint i;\n\n\tfor (i = 0; i < _NSIG; ++i)\n\t\tt->sighand->action[i].sa.sa_handler = SIG_IGN;\n\n\tflush_signals(t);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "flush_signals",
          "args": [
            "t"
          ],
          "line": 515
        },
        "resolved": true,
        "details": {
          "function_name": "flush_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "460-469",
          "snippet": "void flush_signals(struct task_struct *t)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\tclear_tsk_thread_flag(t, TIF_SIGPENDING);\n\tflush_sigqueue(&t->pending);\n\tflush_sigqueue(&t->signal->shared_pending);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid flush_signals(struct task_struct *t)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\tclear_tsk_thread_flag(t, TIF_SIGPENDING);\n\tflush_sigqueue(&t->pending);\n\tflush_sigqueue(&t->signal->shared_pending);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid ignore_signals(struct task_struct *t)\n{\n\tint i;\n\n\tfor (i = 0; i < _NSIG; ++i)\n\t\tt->sighand->action[i].sa.sa_handler = SIG_IGN;\n\n\tflush_signals(t);\n}"
  },
  {
    "function_name": "flush_itimer_signals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "496-505",
    "snippet": "void flush_itimer_signals(void)\n{\n\tstruct task_struct *tsk = current;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tsk->sighand->siglock, flags);\n\t__flush_itimer_signals(&tsk->pending);\n\t__flush_itimer_signals(&tsk->signal->shared_pending);\n\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&tsk->sighand->siglock",
            "flags"
          ],
          "line": 504
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "__flush_itimer_signals",
          "args": [
            "&tsk->signal->shared_pending"
          ],
          "line": 503
        },
        "resolved": true,
        "details": {
          "function_name": "__flush_itimer_signals",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "473-494",
          "snippet": "static void __flush_itimer_signals(struct sigpending *pending)\n{\n\tsigset_t signal, retain;\n\tstruct sigqueue *q, *n;\n\n\tsignal = pending->signal;\n\tsigemptyset(&retain);\n\n\tlist_for_each_entry_safe(q, n, &pending->list, list) {\n\t\tint sig = q->info.si_signo;\n\n\t\tif (likely(q->info.si_code != SI_TIMER)) {\n\t\t\tsigaddset(&retain, sig);\n\t\t} else {\n\t\t\tsigdelset(&signal, sig);\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n\n\tsigorsets(&pending->signal, &signal, &retain);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic void __flush_itimer_signals(struct sigpending *pending)\n{\n\tsigset_t signal, retain;\n\tstruct sigqueue *q, *n;\n\n\tsignal = pending->signal;\n\tsigemptyset(&retain);\n\n\tlist_for_each_entry_safe(q, n, &pending->list, list) {\n\t\tint sig = q->info.si_signo;\n\n\t\tif (likely(q->info.si_code != SI_TIMER)) {\n\t\t\tsigaddset(&retain, sig);\n\t\t} else {\n\t\t\tsigdelset(&signal, sig);\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n\n\tsigorsets(&pending->signal, &signal, &retain);\n}"
        }
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&tsk->sighand->siglock",
            "flags"
          ],
          "line": 501
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid flush_itimer_signals(void)\n{\n\tstruct task_struct *tsk = current;\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&tsk->sighand->siglock, flags);\n\t__flush_itimer_signals(&tsk->pending);\n\t__flush_itimer_signals(&tsk->signal->shared_pending);\n\tspin_unlock_irqrestore(&tsk->sighand->siglock, flags);\n}"
  },
  {
    "function_name": "__flush_itimer_signals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "473-494",
    "snippet": "static void __flush_itimer_signals(struct sigpending *pending)\n{\n\tsigset_t signal, retain;\n\tstruct sigqueue *q, *n;\n\n\tsignal = pending->signal;\n\tsigemptyset(&retain);\n\n\tlist_for_each_entry_safe(q, n, &pending->list, list) {\n\t\tint sig = q->info.si_signo;\n\n\t\tif (likely(q->info.si_code != SI_TIMER)) {\n\t\t\tsigaddset(&retain, sig);\n\t\t} else {\n\t\t\tsigdelset(&signal, sig);\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n\n\tsigorsets(&pending->signal, &signal, &retain);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "sigorsets",
          "args": [
            "&pending->signal",
            "&signal",
            "&retain"
          ],
          "line": 493
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__sigqueue_free",
          "args": [
            "q"
          ],
          "line": 489
        },
        "resolved": true,
        "details": {
          "function_name": "__sigqueue_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "436-443",
          "snippet": "static void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tatomic_dec(&q->user->sigpending);\n\tfree_uid(q->user);\n\tkmem_cache_free(sigqueue_cachep, q);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sigqueue_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nstatic void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tatomic_dec(&q->user->sigpending);\n\tfree_uid(q->user);\n\tkmem_cache_free(sigqueue_cachep, q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&q->list"
          ],
          "line": 488
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigdelset",
          "args": [
            "&signal",
            "sig"
          ],
          "line": 487
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigaddset",
          "args": [
            "&retain",
            "sig"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "likely",
          "args": [
            "q->info.si_code != SI_TIMER"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_for_each_entry_safe",
          "args": [
            "q",
            "n",
            "&pending->list",
            "list"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&retain"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nstatic void __flush_itimer_signals(struct sigpending *pending)\n{\n\tsigset_t signal, retain;\n\tstruct sigqueue *q, *n;\n\n\tsignal = pending->signal;\n\tsigemptyset(&retain);\n\n\tlist_for_each_entry_safe(q, n, &pending->list, list) {\n\t\tint sig = q->info.si_signo;\n\n\t\tif (likely(q->info.si_code != SI_TIMER)) {\n\t\t\tsigaddset(&retain, sig);\n\t\t} else {\n\t\t\tsigdelset(&signal, sig);\n\t\t\tlist_del_init(&q->list);\n\t\t\t__sigqueue_free(q);\n\t\t}\n\t}\n\n\tsigorsets(&pending->signal, &signal, &retain);\n}"
  },
  {
    "function_name": "flush_signals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "460-469",
    "snippet": "void flush_signals(struct task_struct *t)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\tclear_tsk_thread_flag(t, TIF_SIGPENDING);\n\tflush_sigqueue(&t->pending);\n\tflush_sigqueue(&t->signal->shared_pending);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irqrestore",
          "args": [
            "&t->sighand->siglock",
            "flags"
          ],
          "line": 468
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irqrestore",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "182-185",
          "snippet": "void __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irqrestore(raw_spinlock_t *lock, unsigned long flags)\n{\n\t__raw_spin_unlock_irqrestore(lock, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "flush_sigqueue",
          "args": [
            "&t->signal->shared_pending"
          ],
          "line": 467
        },
        "resolved": true,
        "details": {
          "function_name": "flush_sigqueue",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "445-455",
          "snippet": "void flush_sigqueue(struct sigpending *queue)\n{\n\tstruct sigqueue *q;\n\n\tsigemptyset(&queue->signal);\n\twhile (!list_empty(&queue->list)) {\n\t\tq = list_entry(queue->list.next, struct sigqueue , list);\n\t\tlist_del_init(&q->list);\n\t\t__sigqueue_free(q);\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid flush_sigqueue(struct sigpending *queue)\n{\n\tstruct sigqueue *q;\n\n\tsigemptyset(&queue->signal);\n\twhile (!list_empty(&queue->list)) {\n\t\tq = list_entry(queue->list.next, struct sigqueue , list);\n\t\tlist_del_init(&q->list);\n\t\t__sigqueue_free(q);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "clear_tsk_thread_flag",
          "args": [
            "t",
            "TIF_SIGPENDING"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irqsave",
          "args": [
            "&t->sighand->siglock",
            "flags"
          ],
          "line": 464
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irqsave_nested",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "359-370",
          "snippet": "unsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nunsigned long __lockfunc _raw_spin_lock_irqsave_nested(raw_spinlock_t *lock,\n\t\t\t\t\t\t   int subclass)\n{\n\tunsigned long flags;\n\n\tlocal_irq_save(flags);\n\tpreempt_disable();\n\tspin_acquire(&lock->dep_map, subclass, 0, _RET_IP_);\n\tLOCK_CONTENDED_FLAGS(lock, do_raw_spin_trylock, do_raw_spin_lock,\n\t\t\t\tdo_raw_spin_lock_flags, &flags);\n\treturn flags;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid flush_signals(struct task_struct *t)\n{\n\tunsigned long flags;\n\n\tspin_lock_irqsave(&t->sighand->siglock, flags);\n\tclear_tsk_thread_flag(t, TIF_SIGPENDING);\n\tflush_sigqueue(&t->pending);\n\tflush_sigqueue(&t->signal->shared_pending);\n\tspin_unlock_irqrestore(&t->sighand->siglock, flags);\n}"
  },
  {
    "function_name": "flush_sigqueue",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "445-455",
    "snippet": "void flush_sigqueue(struct sigpending *queue)\n{\n\tstruct sigqueue *q;\n\n\tsigemptyset(&queue->signal);\n\twhile (!list_empty(&queue->list)) {\n\t\tq = list_entry(queue->list.next, struct sigqueue , list);\n\t\tlist_del_init(&q->list);\n\t\t__sigqueue_free(q);\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "__sigqueue_free",
          "args": [
            "q"
          ],
          "line": 453
        },
        "resolved": true,
        "details": {
          "function_name": "__sigqueue_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "436-443",
          "snippet": "static void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tatomic_dec(&q->user->sigpending);\n\tfree_uid(q->user);\n\tkmem_cache_free(sigqueue_cachep, q);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static struct kmem_cache *sigqueue_cachep;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nstatic void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tatomic_dec(&q->user->sigpending);\n\tfree_uid(q->user);\n\tkmem_cache_free(sigqueue_cachep, q);\n}"
        }
      },
      {
        "call_info": {
          "callee": "list_del_init",
          "args": [
            "&q->list"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_entry",
          "args": [
            "queue->list.next",
            "structsigqueue",
            "list"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "list_empty",
          "args": [
            "&queue->list"
          ],
          "line": 450
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_segcblist_empty",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/rcu_segcblist.h",
          "lines": "50-53",
          "snippet": "static inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}",
          "includes": [
            "#include <linux/rcu_segcblist.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "void rcu_segcblist_init(struct rcu_segcblist *rsclp);",
            "void rcu_segcblist_disable(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);",
            "bool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);",
            "struct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/rcu_segcblist.h>\n\nvoid rcu_segcblist_init(struct rcu_segcblist *rsclp);\nvoid rcu_segcblist_disable(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_ready_cbs(struct rcu_segcblist *rsclp);\nbool rcu_segcblist_pend_cbs(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_cb(struct rcu_segcblist *rsclp);\nstruct rcu_head *rcu_segcblist_first_pend_cb(struct rcu_segcblist *rsclp);\n\nstatic inline bool rcu_segcblist_empty(struct rcu_segcblist *rsclp)\n{\n\treturn !rsclp->head;\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigemptyset",
          "args": [
            "&queue->signal"
          ],
          "line": 449
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid flush_sigqueue(struct sigpending *queue)\n{\n\tstruct sigqueue *q;\n\n\tsigemptyset(&queue->signal);\n\twhile (!list_empty(&queue->list)) {\n\t\tq = list_entry(queue->list.next, struct sigqueue , list);\n\t\tlist_del_init(&q->list);\n\t\t__sigqueue_free(q);\n\t}\n}"
  },
  {
    "function_name": "__sigqueue_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "436-443",
    "snippet": "static void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tatomic_dec(&q->user->sigpending);\n\tfree_uid(q->user);\n\tkmem_cache_free(sigqueue_cachep, q);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *sigqueue_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kmem_cache_free",
          "args": [
            "sigqueue_cachep",
            "q"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_uid",
          "args": [
            "q->user"
          ],
          "line": 441
        },
        "resolved": true,
        "details": {
          "function_name": "free_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user.c",
          "lines": "165-174",
          "snippet": "void free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/key.h>",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uidhash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/sched/user.h>\n#include <linux/key.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(uidhash_lock);\n\nvoid free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&q->user->sigpending"
          ],
          "line": 440
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nstatic void __sigqueue_free(struct sigqueue *q)\n{\n\tif (q->flags & SIGQUEUE_PREALLOC)\n\t\treturn;\n\tatomic_dec(&q->user->sigpending);\n\tfree_uid(q->user);\n\tkmem_cache_free(sigqueue_cachep, q);\n}"
  },
  {
    "function_name": "__sigqueue_alloc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "401-434",
    "snippet": "static struct sigqueue *\n__sigqueue_alloc(int sig, struct task_struct *t, gfp_t flags, int override_rlimit)\n{\n\tstruct sigqueue *q = NULL;\n\tstruct user_struct *user;\n\n\t/*\n\t * Protect access to @t credentials. This can go away when all\n\t * callers hold rcu read lock.\n\t */\n\trcu_read_lock();\n\tuser = get_uid(__task_cred(t)->user);\n\tatomic_inc(&user->sigpending);\n\trcu_read_unlock();\n\n\tif (override_rlimit ||\n\t    atomic_read(&user->sigpending) <=\n\t\t\ttask_rlimit(t, RLIMIT_SIGPENDING)) {\n\t\tq = kmem_cache_alloc(sigqueue_cachep, flags);\n\t} else {\n\t\tprint_dropped_signal(sig);\n\t}\n\n\tif (unlikely(q == NULL)) {\n\t\tatomic_dec(&user->sigpending);\n\t\tfree_uid(user);\n\t} else {\n\t\tINIT_LIST_HEAD(&q->list);\n\t\tq->flags = 0;\n\t\tq->user = user;\n\t}\n\n\treturn q;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "static struct kmem_cache *sigqueue_cachep;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "INIT_LIST_HEAD",
          "args": [
            "&q->list"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free_uid",
          "args": [
            "user"
          ],
          "line": 426
        },
        "resolved": true,
        "details": {
          "function_name": "free_uid",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/user.c",
          "lines": "165-174",
          "snippet": "void free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}",
          "includes": [
            "#include <linux/proc_ns.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/export.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/key.h>",
            "#include <linux/bitops.h>",
            "#include <linux/slab.h>",
            "#include <linux/sched.h>",
            "#include <linux/init.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "static DEFINE_SPINLOCK(uidhash_lock);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/proc_ns.h>\n#include <linux/user_namespace.h>\n#include <linux/export.h>\n#include <linux/interrupt.h>\n#include <linux/sched/user.h>\n#include <linux/key.h>\n#include <linux/bitops.h>\n#include <linux/slab.h>\n#include <linux/sched.h>\n#include <linux/init.h>\n\nstatic DEFINE_SPINLOCK(uidhash_lock);\n\nvoid free_uid(struct user_struct *up)\n{\n\tunsigned long flags;\n\n\tif (!up)\n\t\treturn;\n\n\tif (refcount_dec_and_lock_irqsave(&up->__count, &uidhash_lock, &flags))\n\t\tfree_user(up, flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_dec",
          "args": [
            "&user->sigpending"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "q == NULL"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "print_dropped_signal",
          "args": [
            "sig"
          ],
          "line": 421
        },
        "resolved": true,
        "details": {
          "function_name": "print_dropped_signal",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "244-256",
          "snippet": "static inline void print_dropped_signal(int sig)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\n\tif (!print_fatal_signals)\n\t\treturn;\n\n\tif (!__ratelimit(&ratelimit_state))\n\t\treturn;\n\n\tpr_info(\"%s/%d: reached RLIMIT_SIGPENDING, dropped signal %d\\n\",\n\t\t\t\tcurrent->comm, current->pid, sig);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "int print_fatal_signals"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint print_fatal_signals;\n\nstatic inline void print_dropped_signal(int sig)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\n\tif (!print_fatal_signals)\n\t\treturn;\n\n\tif (!__ratelimit(&ratelimit_state))\n\t\treturn;\n\n\tpr_info(\"%s/%d: reached RLIMIT_SIGPENDING, dropped signal %d\\n\",\n\t\t\t\tcurrent->comm, current->pid, sig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "kmem_cache_alloc",
          "args": [
            "sigqueue_cachep",
            "flags"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_rlimit",
          "args": [
            "t",
            "RLIMIT_SIGPENDING"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atomic_read",
          "args": [
            "&user->sigpending"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_unlock",
          "args": [],
          "line": 414
        },
        "resolved": true,
        "details": {
          "function_name": "__rcu_read_unlock",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/tree_plugin.h",
          "lines": "419-441",
          "snippet": "void __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}",
          "includes": [
            "#include \"../locking/rtmutex_common.h\"",
            "#include \"../time/tick-internal.h\"",
            "#include <uapi/linux/sched/types.h>",
            "#include <linux/sched/isolation.h>",
            "#include <linux/smpboot.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/oom.h>",
            "#include <linux/gfp.h>",
            "#include <linux/delay.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"../locking/rtmutex_common.h\"\n#include \"../time/tick-internal.h\"\n#include <uapi/linux/sched/types.h>\n#include <linux/sched/isolation.h>\n#include <linux/smpboot.h>\n#include <linux/sched/debug.h>\n#include <linux/oom.h>\n#include <linux/gfp.h>\n#include <linux/delay.h>\n\nvoid __rcu_read_unlock(void)\n{\n\tstruct task_struct *t = current;\n\n\tif (t->rcu_read_lock_nesting != 1) {\n\t\t--t->rcu_read_lock_nesting;\n\t} else {\n\t\tbarrier();  /* critical section before exit code. */\n\t\tt->rcu_read_lock_nesting = INT_MIN;\n\t\tbarrier();  /* assign before ->rcu_read_unlock_special load */\n\t\tif (unlikely(READ_ONCE(t->rcu_read_unlock_special.s)))\n\t\t\trcu_read_unlock_special(t);\n\t\tbarrier();  /* ->rcu_read_unlock_special load before assign */\n\t\tt->rcu_read_lock_nesting = 0;\n\t}\n#ifdef CONFIG_PROVE_LOCKING\n\t{\n\t\tint rrln = READ_ONCE(t->rcu_read_lock_nesting);\n\n\t\tWARN_ON_ONCE(rrln < 0 && rrln > INT_MIN / 2);\n\t}\n#endif /* #ifdef CONFIG_PROVE_LOCKING */\n}"
        }
      },
      {
        "call_info": {
          "callee": "atomic_inc",
          "args": [
            "&user->sigpending"
          ],
          "line": 413
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_uid",
          "args": [
            "__task_cred(t)->user"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__task_cred",
          "args": [
            "t"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "rcu_read_lock",
          "args": [],
          "line": 411
        },
        "resolved": true,
        "details": {
          "function_name": "rcu_read_lock_bh_held",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/rcu/update.c",
          "lines": "300-309",
          "snippet": "int rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}",
          "includes": [
            "#include \"rcu.h\"",
            "#include <linux/sched/isolation.h>",
            "#include <linux/rcupdate_wait.h>",
            "#include <linux/tick.h>",
            "#include <linux/kthread.h>",
            "#include <linux/moduleparam.h>",
            "#include <linux/delay.h>",
            "#include <linux/hardirq.h>",
            "#include <linux/export.h>",
            "#include <linux/mutex.h>",
            "#include <linux/cpu.h>",
            "#include <linux/notifier.h>",
            "#include <linux/percpu.h>",
            "#include <linux/bitops.h>",
            "#include <linux/atomic.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/signal.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/smp.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/init.h>",
            "#include <linux/kernel.h>",
            "#include <linux/types.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"rcu.h\"\n#include <linux/sched/isolation.h>\n#include <linux/rcupdate_wait.h>\n#include <linux/tick.h>\n#include <linux/kthread.h>\n#include <linux/moduleparam.h>\n#include <linux/delay.h>\n#include <linux/hardirq.h>\n#include <linux/export.h>\n#include <linux/mutex.h>\n#include <linux/cpu.h>\n#include <linux/notifier.h>\n#include <linux/percpu.h>\n#include <linux/bitops.h>\n#include <linux/atomic.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/signal.h>\n#include <linux/interrupt.h>\n#include <linux/smp.h>\n#include <linux/spinlock.h>\n#include <linux/init.h>\n#include <linux/kernel.h>\n#include <linux/types.h>\n\nint rcu_read_lock_bh_held(void)\n{\n\tif (!debug_lockdep_rcu_enabled())\n\t\treturn 1;\n\tif (!rcu_is_watching())\n\t\treturn 0;\n\tif (!rcu_lockdep_current_cpu_online())\n\t\treturn 0;\n\treturn in_softirq() || irqs_disabled();\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic struct kmem_cache *sigqueue_cachep;\n\nstatic struct sigqueue *\n__sigqueue_alloc(int sig, struct task_struct *t, gfp_t flags, int override_rlimit)\n{\n\tstruct sigqueue *q = NULL;\n\tstruct user_struct *user;\n\n\t/*\n\t * Protect access to @t credentials. This can go away when all\n\t * callers hold rcu read lock.\n\t */\n\trcu_read_lock();\n\tuser = get_uid(__task_cred(t)->user);\n\tatomic_inc(&user->sigpending);\n\trcu_read_unlock();\n\n\tif (override_rlimit ||\n\t    atomic_read(&user->sigpending) <=\n\t\t\ttask_rlimit(t, RLIMIT_SIGPENDING)) {\n\t\tq = kmem_cache_alloc(sigqueue_cachep, flags);\n\t} else {\n\t\tprint_dropped_signal(sig);\n\t}\n\n\tif (unlikely(q == NULL)) {\n\t\tatomic_dec(&user->sigpending);\n\t\tfree_uid(user);\n\t} else {\n\t\tINIT_LIST_HEAD(&q->list);\n\t\tq->flags = 0;\n\t\tq->user = user;\n\t}\n\n\treturn q;\n}"
  },
  {
    "function_name": "task_join_group_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "382-394",
    "snippet": "void task_join_group_stop(struct task_struct *task)\n{\n\t/* Have the new thread join an on-going signal group stop */\n\tunsigned long jobctl = current->jobctl;\n\tif (jobctl & JOBCTL_STOP_PENDING) {\n\t\tstruct signal_struct *sig = current->signal;\n\t\tunsigned long signr = jobctl & JOBCTL_STOP_SIGMASK;\n\t\tunsigned long gstop = JOBCTL_STOP_PENDING | JOBCTL_STOP_CONSUME;\n\t\tif (task_set_jobctl_pending(task, signr | gstop)) {\n\t\t\tsig->group_stop_count++;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_set_jobctl_pending",
          "args": [
            "task",
            "signr | gstop"
          ],
          "line": 390
        },
        "resolved": true,
        "details": {
          "function_name": "task_set_jobctl_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "275-289",
          "snippet": "bool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\n\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n\t\treturn false;\n\n\tif (mask & JOBCTL_STOP_SIGMASK)\n\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\n\ttask->jobctl |= mask;\n\treturn true;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nbool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\n\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n\t\treturn false;\n\n\tif (mask & JOBCTL_STOP_SIGMASK)\n\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\n\ttask->jobctl |= mask;\n\treturn true;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid task_join_group_stop(struct task_struct *task)\n{\n\t/* Have the new thread join an on-going signal group stop */\n\tunsigned long jobctl = current->jobctl;\n\tif (jobctl & JOBCTL_STOP_PENDING) {\n\t\tstruct signal_struct *sig = current->signal;\n\t\tunsigned long signr = jobctl & JOBCTL_STOP_SIGMASK;\n\t\tunsigned long gstop = JOBCTL_STOP_PENDING | JOBCTL_STOP_CONSUME;\n\t\tif (task_set_jobctl_pending(task, signr | gstop)) {\n\t\t\tsig->group_stop_count++;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "task_participate_group_stop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "356-380",
    "snippet": "static bool task_participate_group_stop(struct task_struct *task)\n{\n\tstruct signal_struct *sig = task->signal;\n\tbool consume = task->jobctl & JOBCTL_STOP_CONSUME;\n\n\tWARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING));\n\n\ttask_clear_jobctl_pending(task, JOBCTL_STOP_PENDING);\n\n\tif (!consume)\n\t\treturn false;\n\n\tif (!WARN_ON_ONCE(sig->group_stop_count == 0))\n\t\tsig->group_stop_count--;\n\n\t/*\n\t * Tell the caller to notify completion iff we are entering into a\n\t * fresh group stop.  Read comment in do_signal_stop() for details.\n\t */\n\tif (!sig->group_stop_count && !(sig->flags & SIGNAL_STOP_STOPPED)) {\n\t\tsignal_set_stop_flags(sig, SIGNAL_STOP_STOPPED);\n\t\treturn true;\n\t}\n\treturn false;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_set_stop_flags",
          "args": [
            "sig",
            "SIGNAL_STOP_STOPPED"
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "sig->group_stop_count == 0"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "task_clear_jobctl_pending",
          "args": [
            "task",
            "JOBCTL_STOP_PENDING"
          ],
          "line": 363
        },
        "resolved": true,
        "details": {
          "function_name": "task_clear_jobctl_pending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "327-338",
          "snippet": "void task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}"
        }
      },
      {
        "call_info": {
          "callee": "WARN_ON_ONCE",
          "args": [
            "!(task->jobctl & JOBCTL_STOP_PENDING)"
          ],
          "line": 361
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool task_participate_group_stop(struct task_struct *task)\n{\n\tstruct signal_struct *sig = task->signal;\n\tbool consume = task->jobctl & JOBCTL_STOP_CONSUME;\n\n\tWARN_ON_ONCE(!(task->jobctl & JOBCTL_STOP_PENDING));\n\n\ttask_clear_jobctl_pending(task, JOBCTL_STOP_PENDING);\n\n\tif (!consume)\n\t\treturn false;\n\n\tif (!WARN_ON_ONCE(sig->group_stop_count == 0))\n\t\tsig->group_stop_count--;\n\n\t/*\n\t * Tell the caller to notify completion iff we are entering into a\n\t * fresh group stop.  Read comment in do_signal_stop() for details.\n\t */\n\tif (!sig->group_stop_count && !(sig->flags & SIGNAL_STOP_STOPPED)) {\n\t\tsignal_set_stop_flags(sig, SIGNAL_STOP_STOPPED);\n\t\treturn true;\n\t}\n\treturn false;\n}"
  },
  {
    "function_name": "task_clear_jobctl_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "327-338",
    "snippet": "void task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "task_clear_jobctl_trapping",
          "args": [
            "task"
          ],
          "line": 337
        },
        "resolved": true,
        "details": {
          "function_name": "task_clear_jobctl_trapping",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "303-310",
          "snippet": "void task_clear_jobctl_trapping(struct task_struct *task)\n{\n\tif (unlikely(task->jobctl & JOBCTL_TRAPPING)) {\n\t\ttask->jobctl &= ~JOBCTL_TRAPPING;\n\t\tsmp_mb();\t/* advised by wake_up_bit() */\n\t\twake_up_bit(&task->jobctl, JOBCTL_TRAPPING_BIT);\n\t}\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid task_clear_jobctl_trapping(struct task_struct *task)\n{\n\tif (unlikely(task->jobctl & JOBCTL_TRAPPING)) {\n\t\ttask->jobctl &= ~JOBCTL_TRAPPING;\n\t\tsmp_mb();\t/* advised by wake_up_bit() */\n\t\twake_up_bit(&task->jobctl, JOBCTL_TRAPPING_BIT);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mask & ~JOBCTL_PENDING_MASK"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid task_clear_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~JOBCTL_PENDING_MASK);\n\n\tif (mask & JOBCTL_STOP_PENDING)\n\t\tmask |= JOBCTL_STOP_CONSUME | JOBCTL_STOP_DEQUEUED;\n\n\ttask->jobctl &= ~mask;\n\n\tif (!(task->jobctl & JOBCTL_PENDING_MASK))\n\t\ttask_clear_jobctl_trapping(task);\n}"
  },
  {
    "function_name": "task_clear_jobctl_trapping",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "303-310",
    "snippet": "void task_clear_jobctl_trapping(struct task_struct *task)\n{\n\tif (unlikely(task->jobctl & JOBCTL_TRAPPING)) {\n\t\ttask->jobctl &= ~JOBCTL_TRAPPING;\n\t\tsmp_mb();\t/* advised by wake_up_bit() */\n\t\twake_up_bit(&task->jobctl, JOBCTL_TRAPPING_BIT);\n\t}\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "wake_up_bit",
          "args": [
            "&task->jobctl",
            "JOBCTL_TRAPPING_BIT"
          ],
          "line": 308
        },
        "resolved": true,
        "details": {
          "function_name": "wake_up_bit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/sched/wait_bit.c",
          "lines": "146-149",
          "snippet": "void wake_up_bit(void *word, int bit)\n{\n\t__wake_up_bit(bit_waitqueue(word, bit), word, bit);\n}",
          "includes": [
            "#include \"sched.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"sched.h\"\n\nvoid wake_up_bit(void *word, int bit)\n{\n\t__wake_up_bit(bit_waitqueue(word, bit), word, bit);\n}"
        }
      },
      {
        "call_info": {
          "callee": "smp_mb",
          "args": [],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "task->jobctl & JOBCTL_TRAPPING"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid task_clear_jobctl_trapping(struct task_struct *task)\n{\n\tif (unlikely(task->jobctl & JOBCTL_TRAPPING)) {\n\t\ttask->jobctl &= ~JOBCTL_TRAPPING;\n\t\tsmp_mb();\t/* advised by wake_up_bit() */\n\t\twake_up_bit(&task->jobctl, JOBCTL_TRAPPING_BIT);\n\t}\n}"
  },
  {
    "function_name": "task_set_jobctl_pending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "275-289",
    "snippet": "bool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\n\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n\t\treturn false;\n\n\tif (mask & JOBCTL_STOP_SIGMASK)\n\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\n\ttask->jobctl |= mask;\n\treturn true;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "fatal_signal_pending(task) || (task->flags & PF_EXITING)"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "fatal_signal_pending",
          "args": [
            "task"
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "(mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK)"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "BUG_ON",
          "args": [
            "mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING)"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nbool task_set_jobctl_pending(struct task_struct *task, unsigned long mask)\n{\n\tBUG_ON(mask & ~(JOBCTL_PENDING_MASK | JOBCTL_STOP_CONSUME |\n\t\t\tJOBCTL_STOP_SIGMASK | JOBCTL_TRAPPING));\n\tBUG_ON((mask & JOBCTL_TRAPPING) && !(mask & JOBCTL_PENDING_MASK));\n\n\tif (unlikely(fatal_signal_pending(task) || (task->flags & PF_EXITING)))\n\t\treturn false;\n\n\tif (mask & JOBCTL_STOP_SIGMASK)\n\t\ttask->jobctl &= ~JOBCTL_STOP_SIGMASK;\n\n\ttask->jobctl |= mask;\n\treturn true;\n}"
  },
  {
    "function_name": "print_dropped_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "244-256",
    "snippet": "static inline void print_dropped_signal(int sig)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\n\tif (!print_fatal_signals)\n\t\treturn;\n\n\tif (!__ratelimit(&ratelimit_state))\n\t\treturn;\n\n\tpr_info(\"%s/%d: reached RLIMIT_SIGPENDING, dropped signal %d\\n\",\n\t\t\t\tcurrent->comm, current->pid, sig);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int print_fatal_signals"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "pr_info",
          "args": [
            "\"%s/%d: reached RLIMIT_SIGPENDING, dropped signal %d\\n\"",
            "current->comm",
            "current->pid",
            "sig"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "__ratelimit",
          "args": [
            "&ratelimit_state"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint print_fatal_signals;\n\nstatic inline void print_dropped_signal(int sig)\n{\n\tstatic DEFINE_RATELIMIT_STATE(ratelimit_state, 5 * HZ, 10);\n\n\tif (!print_fatal_signals)\n\t\treturn;\n\n\tif (!__ratelimit(&ratelimit_state))\n\t\treturn;\n\n\tpr_info(\"%s/%d: reached RLIMIT_SIGPENDING, dropped signal %d\\n\",\n\t\t\t\tcurrent->comm, current->pid, sig);\n}"
  },
  {
    "function_name": "next_signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "198-242",
    "snippet": "int next_signal(struct sigpending *pending, sigset_t *mask)\n{\n\tunsigned long i, *s, *m, x;\n\tint sig = 0;\n\n\ts = pending->signal.sig;\n\tm = mask->sig;\n\n\t/*\n\t * Handle the first word specially: it contains the\n\t * synchronous signals that need to be dequeued first.\n\t */\n\tx = *s &~ *m;\n\tif (x) {\n\t\tif (x & SYNCHRONOUS_MASK)\n\t\t\tx &= SYNCHRONOUS_MASK;\n\t\tsig = ffz(~x) + 1;\n\t\treturn sig;\n\t}\n\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tfor (i = 1; i < _NSIG_WORDS; ++i) {\n\t\t\tx = *++s &~ *++m;\n\t\t\tif (!x)\n\t\t\t\tcontinue;\n\t\t\tsig = ffz(~x) + i*_NSIG_BPW + 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\tx = s[1] &~ m[1];\n\t\tif (!x)\n\t\t\tbreak;\n\t\tsig = ffz(~x) + _NSIG_BPW + 1;\n\t\tbreak;\n\n\tcase 1:\n\t\t/* Nothing to do */\n\t\tbreak;\n\t}\n\n\treturn sig;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [
      "#define SYNCHRONOUS_MASK \\\n\t(sigmask(SIGSEGV) | sigmask(SIGBUS) | sigmask(SIGILL) | \\\n\t sigmask(SIGTRAP) | sigmask(SIGFPE) | sigmask(SIGSYS))"
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "ffz",
          "args": [
            "~x"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffz",
          "args": [
            "~x"
          ],
          "line": 224
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ffz",
          "args": [
            "~x"
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\n#define SYNCHRONOUS_MASK \\\n\t(sigmask(SIGSEGV) | sigmask(SIGBUS) | sigmask(SIGILL) | \\\n\t sigmask(SIGTRAP) | sigmask(SIGFPE) | sigmask(SIGSYS))\n\nint next_signal(struct sigpending *pending, sigset_t *mask)\n{\n\tunsigned long i, *s, *m, x;\n\tint sig = 0;\n\n\ts = pending->signal.sig;\n\tm = mask->sig;\n\n\t/*\n\t * Handle the first word specially: it contains the\n\t * synchronous signals that need to be dequeued first.\n\t */\n\tx = *s &~ *m;\n\tif (x) {\n\t\tif (x & SYNCHRONOUS_MASK)\n\t\t\tx &= SYNCHRONOUS_MASK;\n\t\tsig = ffz(~x) + 1;\n\t\treturn sig;\n\t}\n\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tfor (i = 1; i < _NSIG_WORDS; ++i) {\n\t\t\tx = *++s &~ *++m;\n\t\t\tif (!x)\n\t\t\t\tcontinue;\n\t\t\tsig = ffz(~x) + i*_NSIG_BPW + 1;\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\n\tcase 2:\n\t\tx = s[1] &~ m[1];\n\t\tif (!x)\n\t\t\tbreak;\n\t\tsig = ffz(~x) + _NSIG_BPW + 1;\n\t\tbreak;\n\n\tcase 1:\n\t\t/* Nothing to do */\n\t\tbreak;\n\t}\n\n\treturn sig;\n}"
  },
  {
    "function_name": "calculate_sigpending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "181-190",
    "snippet": "void calculate_sigpending(void)\n{\n\t/* Have any signals or users of TIF_SIGPENDING been delayed\n\t * until after fork?\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tset_tsk_thread_flag(current, TIF_SIGPENDING);\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "spin_unlock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 189
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_unlock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "190-193",
          "snippet": "void __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_unlock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_unlock_irq(lock);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recalc_sigpending",
          "args": [],
          "line": 188
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_sigpending",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "172-178",
          "snippet": "void recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current) &&\n\t    !klp_patch_pending(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current) &&\n\t    !klp_patch_pending(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}"
        }
      },
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "current",
            "TIF_SIGPENDING"
          ],
          "line": 187
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "spin_lock_irq",
          "args": [
            "&current->sighand->siglock"
          ],
          "line": 186
        },
        "resolved": true,
        "details": {
          "function_name": "_raw_spin_lock_irq",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/locking/spinlock.c",
          "lines": "158-161",
          "snippet": "void __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}",
          "includes": [
            "#include <linux/export.h>",
            "#include <linux/debug_locks.h>",
            "#include <linux/interrupt.h>",
            "#include <linux/spinlock.h>",
            "#include <linux/preempt.h>",
            "#include <linux/linkage.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/export.h>\n#include <linux/debug_locks.h>\n#include <linux/interrupt.h>\n#include <linux/spinlock.h>\n#include <linux/preempt.h>\n#include <linux/linkage.h>\n\nvoid __lockfunc _raw_spin_lock_irq(raw_spinlock_t *lock)\n{\n\t__raw_spin_lock_irq(lock);\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid calculate_sigpending(void)\n{\n\t/* Have any signals or users of TIF_SIGPENDING been delayed\n\t * until after fork?\n\t */\n\tspin_lock_irq(&current->sighand->siglock);\n\tset_tsk_thread_flag(current, TIF_SIGPENDING);\n\trecalc_sigpending();\n\tspin_unlock_irq(&current->sighand->siglock);\n}"
  },
  {
    "function_name": "recalc_sigpending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "172-178",
    "snippet": "void recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current) &&\n\t    !klp_patch_pending(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "clear_thread_flag",
          "args": [
            "TIF_SIGPENDING"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "klp_patch_pending",
          "args": [
            "current"
          ],
          "line": 175
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "freezing",
          "args": [
            "current"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "freezing_slow_path",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/freezer.c",
          "lines": "42-57",
          "snippet": "bool freezing_slow_path(struct task_struct *p)\n{\n\tif (p->flags & (PF_NOFREEZE | PF_SUSPEND_TASK))\n\t\treturn false;\n\n\tif (test_tsk_thread_flag(p, TIF_MEMDIE))\n\t\treturn false;\n\n\tif (pm_nosig_freezing || cgroup_freezing(p))\n\t\treturn true;\n\n\tif (pm_freezing && !(p->flags & PF_KTHREAD))\n\t\treturn true;\n\n\treturn false;\n}",
          "includes": [
            "#include <linux/kthread.h>",
            "#include <linux/freezer.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/export.h>",
            "#include <linux/suspend.h>",
            "#include <linux/interrupt.h>"
          ],
          "macros_used": [],
          "globals_used": [
            "bool pm_freezing;",
            "bool pm_nosig_freezing;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kthread.h>\n#include <linux/freezer.h>\n#include <linux/syscalls.h>\n#include <linux/export.h>\n#include <linux/suspend.h>\n#include <linux/interrupt.h>\n\nbool pm_freezing;\nbool pm_nosig_freezing;\n\nbool freezing_slow_path(struct task_struct *p)\n{\n\tif (p->flags & (PF_NOFREEZE | PF_SUSPEND_TASK))\n\t\treturn false;\n\n\tif (test_tsk_thread_flag(p, TIF_MEMDIE))\n\t\treturn false;\n\n\tif (pm_nosig_freezing || cgroup_freezing(p))\n\t\treturn true;\n\n\tif (pm_freezing && !(p->flags & PF_KTHREAD))\n\t\treturn true;\n\n\treturn false;\n}"
        }
      },
      {
        "call_info": {
          "callee": "recalc_sigpending_tsk",
          "args": [
            "current"
          ],
          "line": 174
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_sigpending_tsk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "145-160",
          "snippet": "static bool recalc_sigpending_tsk(struct task_struct *t)\n{\n\tif ((t->jobctl & JOBCTL_PENDING_MASK) ||\n\t    PENDING(&t->pending, &t->blocked) ||\n\t    PENDING(&t->signal->shared_pending, &t->blocked)) {\n\t\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\treturn true;\n\t}\n\n\t/*\n\t * We must never clear the flag in another thread, or in current\n\t * when it's possible the current syscall is returning -ERESTART*.\n\t * So we don't clear it here, and only callers who know they should do.\n\t */\n\treturn false;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool recalc_sigpending_tsk(struct task_struct *t)\n{\n\tif ((t->jobctl & JOBCTL_PENDING_MASK) ||\n\t    PENDING(&t->pending, &t->blocked) ||\n\t    PENDING(&t->signal->shared_pending, &t->blocked)) {\n\t\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\treturn true;\n\t}\n\n\t/*\n\t * We must never clear the flag in another thread, or in current\n\t * when it's possible the current syscall is returning -ERESTART*.\n\t * So we don't clear it here, and only callers who know they should do.\n\t */\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid recalc_sigpending(void)\n{\n\tif (!recalc_sigpending_tsk(current) && !freezing(current) &&\n\t    !klp_patch_pending(current))\n\t\tclear_thread_flag(TIF_SIGPENDING);\n\n}"
  },
  {
    "function_name": "recalc_sigpending_and_wake",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "166-170",
    "snippet": "void recalc_sigpending_and_wake(struct task_struct *t)\n{\n\tif (recalc_sigpending_tsk(t))\n\t\tsignal_wake_up(t, 0);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "signal_wake_up",
          "args": [
            "t",
            "0"
          ],
          "line": 169
        },
        "resolved": true,
        "details": {
          "function_name": "signal_wake_up_state",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "702-714",
          "snippet": "void signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid signal_wake_up_state(struct task_struct *t, unsigned int state)\n{\n\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t/*\n\t * TASK_WAKEKILL also means wake it up in the stopped/traced/killable\n\t * case. We don't check t->state here because there is a race with it\n\t * executing another processor and just now entering stopped state.\n\t * By using wake_up_state, we ensure the process will wake up and\n\t * handle its death signal.\n\t */\n\tif (!wake_up_state(t, state | TASK_INTERRUPTIBLE))\n\t\tkick_process(t);\n}"
        }
      },
      {
        "call_info": {
          "callee": "recalc_sigpending_tsk",
          "args": [
            "t"
          ],
          "line": 168
        },
        "resolved": true,
        "details": {
          "function_name": "recalc_sigpending_tsk",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "145-160",
          "snippet": "static bool recalc_sigpending_tsk(struct task_struct *t)\n{\n\tif ((t->jobctl & JOBCTL_PENDING_MASK) ||\n\t    PENDING(&t->pending, &t->blocked) ||\n\t    PENDING(&t->signal->shared_pending, &t->blocked)) {\n\t\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\treturn true;\n\t}\n\n\t/*\n\t * We must never clear the flag in another thread, or in current\n\t * when it's possible the current syscall is returning -ERESTART*.\n\t * So we don't clear it here, and only callers who know they should do.\n\t */\n\treturn false;\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool recalc_sigpending_tsk(struct task_struct *t)\n{\n\tif ((t->jobctl & JOBCTL_PENDING_MASK) ||\n\t    PENDING(&t->pending, &t->blocked) ||\n\t    PENDING(&t->signal->shared_pending, &t->blocked)) {\n\t\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\treturn true;\n\t}\n\n\t/*\n\t * We must never clear the flag in another thread, or in current\n\t * when it's possible the current syscall is returning -ERESTART*.\n\t * So we don't clear it here, and only callers who know they should do.\n\t */\n\treturn false;\n}"
        }
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nvoid recalc_sigpending_and_wake(struct task_struct *t)\n{\n\tif (recalc_sigpending_tsk(t))\n\t\tsignal_wake_up(t, 0);\n}"
  },
  {
    "function_name": "recalc_sigpending_tsk",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "145-160",
    "snippet": "static bool recalc_sigpending_tsk(struct task_struct *t)\n{\n\tif ((t->jobctl & JOBCTL_PENDING_MASK) ||\n\t    PENDING(&t->pending, &t->blocked) ||\n\t    PENDING(&t->signal->shared_pending, &t->blocked)) {\n\t\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\treturn true;\n\t}\n\n\t/*\n\t * We must never clear the flag in another thread, or in current\n\t * when it's possible the current syscall is returning -ERESTART*.\n\t * So we don't clear it here, and only callers who know they should do.\n\t */\n\treturn false;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_tsk_thread_flag",
          "args": [
            "t",
            "TIF_SIGPENDING"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PENDING",
          "args": [
            "&t->signal->shared_pending",
            "&t->blocked"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "PENDING",
          "args": [
            "&t->pending",
            "&t->blocked"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool recalc_sigpending_tsk(struct task_struct *t)\n{\n\tif ((t->jobctl & JOBCTL_PENDING_MASK) ||\n\t    PENDING(&t->pending, &t->blocked) ||\n\t    PENDING(&t->signal->shared_pending, &t->blocked)) {\n\t\tset_tsk_thread_flag(t, TIF_SIGPENDING);\n\t\treturn true;\n\t}\n\n\t/*\n\t * We must never clear the flag in another thread, or in current\n\t * when it's possible the current syscall is returning -ERESTART*.\n\t * So we don't clear it here, and only callers who know they should do.\n\t */\n\treturn false;\n}"
  },
  {
    "function_name": "has_pending_signals",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "117-141",
    "snippet": "static inline bool has_pending_signals(sigset_t *signal, sigset_t *blocked)\n{\n\tunsigned long ready;\n\tlong i;\n\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tfor (i = _NSIG_WORDS, ready = 0; --i >= 0 ;)\n\t\t\tready |= signal->sig[i] &~ blocked->sig[i];\n\t\tbreak;\n\n\tcase 4: ready  = signal->sig[3] &~ blocked->sig[3];\n\t\tready |= signal->sig[2] &~ blocked->sig[2];\n\t\tready |= signal->sig[1] &~ blocked->sig[1];\n\t\tready |= signal->sig[0] &~ blocked->sig[0];\n\t\tbreak;\n\n\tcase 2: ready  = signal->sig[1] &~ blocked->sig[1];\n\t\tready |= signal->sig[0] &~ blocked->sig[0];\n\t\tbreak;\n\n\tcase 1: ready  = signal->sig[0] &~ blocked->sig[0];\n\t}\n\treturn ready !=\t0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool has_pending_signals(sigset_t *signal, sigset_t *blocked)\n{\n\tunsigned long ready;\n\tlong i;\n\n\tswitch (_NSIG_WORDS) {\n\tdefault:\n\t\tfor (i = _NSIG_WORDS, ready = 0; --i >= 0 ;)\n\t\t\tready |= signal->sig[i] &~ blocked->sig[i];\n\t\tbreak;\n\n\tcase 4: ready  = signal->sig[3] &~ blocked->sig[3];\n\t\tready |= signal->sig[2] &~ blocked->sig[2];\n\t\tready |= signal->sig[1] &~ blocked->sig[1];\n\t\tready |= signal->sig[0] &~ blocked->sig[0];\n\t\tbreak;\n\n\tcase 2: ready  = signal->sig[1] &~ blocked->sig[1];\n\t\tready |= signal->sig[0] &~ blocked->sig[0];\n\t\tbreak;\n\n\tcase 1: ready  = signal->sig[0] &~ blocked->sig[0];\n\t}\n\treturn ready !=\t0;\n}"
  },
  {
    "function_name": "sig_ignored",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "92-111",
    "snippet": "static bool sig_ignored(struct task_struct *t, int sig, bool force)\n{\n\t/*\n\t * Blocked signals are never ignored, since the\n\t * signal handler may change by the time it is\n\t * unblocked.\n\t */\n\tif (sigismember(&t->blocked, sig) || sigismember(&t->real_blocked, sig))\n\t\treturn false;\n\n\t/*\n\t * Tracers may want to know about even ignored signal unless it\n\t * is SIGKILL which can't be reported anyway but can be ignored\n\t * by SIGNAL_UNKILLABLE task.\n\t */\n\tif (t->ptrace && sig != SIGKILL)\n\t\treturn false;\n\n\treturn sig_task_ignored(t, sig, force);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sig_task_ignored",
          "args": [
            "t",
            "sig",
            "force"
          ],
          "line": 110
        },
        "resolved": true,
        "details": {
          "function_name": "sig_task_ignored",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "75-90",
          "snippet": "static bool sig_task_ignored(struct task_struct *t, int sig, bool force)\n{\n\tvoid __user *handler;\n\n\thandler = sig_handler(t, sig);\n\n\t/* SIGKILL and SIGSTOP may not be sent to the global init */\n\tif (unlikely(is_global_init(t) && sig_kernel_only(sig)))\n\t\treturn true;\n\n\tif (unlikely(t->signal->flags & SIGNAL_UNKILLABLE) &&\n\t    handler == SIG_DFL && !(force && sig_kernel_only(sig)))\n\t\treturn true;\n\n\treturn sig_handler_ignored(handler, sig);\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool sig_task_ignored(struct task_struct *t, int sig, bool force)\n{\n\tvoid __user *handler;\n\n\thandler = sig_handler(t, sig);\n\n\t/* SIGKILL and SIGSTOP may not be sent to the global init */\n\tif (unlikely(is_global_init(t) && sig_kernel_only(sig)))\n\t\treturn true;\n\n\tif (unlikely(t->signal->flags & SIGNAL_UNKILLABLE) &&\n\t    handler == SIG_DFL && !(force && sig_kernel_only(sig)))\n\t\treturn true;\n\n\treturn sig_handler_ignored(handler, sig);\n}"
        }
      },
      {
        "call_info": {
          "callee": "sigismember",
          "args": [
            "&t->real_blocked",
            "sig"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sigismember",
          "args": [
            "&t->blocked",
            "sig"
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool sig_ignored(struct task_struct *t, int sig, bool force)\n{\n\t/*\n\t * Blocked signals are never ignored, since the\n\t * signal handler may change by the time it is\n\t * unblocked.\n\t */\n\tif (sigismember(&t->blocked, sig) || sigismember(&t->real_blocked, sig))\n\t\treturn false;\n\n\t/*\n\t * Tracers may want to know about even ignored signal unless it\n\t * is SIGKILL which can't be reported anyway but can be ignored\n\t * by SIGNAL_UNKILLABLE task.\n\t */\n\tif (t->ptrace && sig != SIGKILL)\n\t\treturn false;\n\n\treturn sig_task_ignored(t, sig, force);\n}"
  },
  {
    "function_name": "sig_task_ignored",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "75-90",
    "snippet": "static bool sig_task_ignored(struct task_struct *t, int sig, bool force)\n{\n\tvoid __user *handler;\n\n\thandler = sig_handler(t, sig);\n\n\t/* SIGKILL and SIGSTOP may not be sent to the global init */\n\tif (unlikely(is_global_init(t) && sig_kernel_only(sig)))\n\t\treturn true;\n\n\tif (unlikely(t->signal->flags & SIGNAL_UNKILLABLE) &&\n\t    handler == SIG_DFL && !(force && sig_kernel_only(sig)))\n\t\treturn true;\n\n\treturn sig_handler_ignored(handler, sig);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sig_handler_ignored",
          "args": [
            "handler",
            "sig"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "sig_handler_ignored",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
          "lines": "68-73",
          "snippet": "static inline bool sig_handler_ignored(void __user *handler, int sig)\n{\n\t/* Is it explicitly or implicitly ignored? */\n\treturn handler == SIG_IGN ||\n\t       (handler == SIG_DFL && sig_kernel_ignore(sig));\n}",
          "includes": [
            "#include <linux/kdb.h>",
            "#include \"audit.h\"\t/* audit_signal_info() */",
            "#include <asm/cacheflush.h>",
            "#include <asm/siginfo.h>",
            "#include <asm/unistd.h>",
            "#include <linux/uaccess.h>",
            "#include <asm/param.h>",
            "#include <trace/events/signal.h>",
            "#include <linux/livepatch.h>",
            "#include <linux/posix-timers.h>",
            "#include <linux/compiler.h>",
            "#include <linux/cn_proc.h>",
            "#include <linux/compat.h>",
            "#include <linux/uprobes.h>",
            "#include <linux/user_namespace.h>",
            "#include <linux/nsproxy.h>",
            "#include <linux/pid_namespace.h>",
            "#include <linux/freezer.h>",
            "#include <linux/capability.h>",
            "#include <linux/tracehook.h>",
            "#include <linux/ratelimit.h>",
            "#include <linux/signalfd.h>",
            "#include <linux/signal.h>",
            "#include <linux/ptrace.h>",
            "#include <linux/syscalls.h>",
            "#include <linux/security.h>",
            "#include <linux/coredump.h>",
            "#include <linux/binfmts.h>",
            "#include <linux/tty.h>",
            "#include <linux/fs.h>",
            "#include <linux/sched/cputime.h>",
            "#include <linux/sched/task_stack.h>",
            "#include <linux/sched/task.h>",
            "#include <linux/sched/debug.h>",
            "#include <linux/sched/user.h>",
            "#include <linux/sched/mm.h>",
            "#include <linux/init.h>",
            "#include <linux/export.h>",
            "#include <linux/slab.h>"
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool sig_handler_ignored(void __user *handler, int sig)\n{\n\t/* Is it explicitly or implicitly ignored? */\n\treturn handler == SIG_IGN ||\n\t       (handler == SIG_DFL && sig_kernel_ignore(sig));\n}"
        }
      },
      {
        "call_info": {
          "callee": "sig_kernel_only",
          "args": [
            "sig"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "t->signal->flags & SIGNAL_UNKILLABLE"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "unlikely",
          "args": [
            "is_global_init(t) && sig_kernel_only(sig)"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sig_kernel_only",
          "args": [
            "sig"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_global_init",
          "args": [
            "t"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic bool sig_task_ignored(struct task_struct *t, int sig, bool force)\n{\n\tvoid __user *handler;\n\n\thandler = sig_handler(t, sig);\n\n\t/* SIGKILL and SIGSTOP may not be sent to the global init */\n\tif (unlikely(is_global_init(t) && sig_kernel_only(sig)))\n\t\treturn true;\n\n\tif (unlikely(t->signal->flags & SIGNAL_UNKILLABLE) &&\n\t    handler == SIG_DFL && !(force && sig_kernel_only(sig)))\n\t\treturn true;\n\n\treturn sig_handler_ignored(handler, sig);\n}"
  },
  {
    "function_name": "sig_handler_ignored",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "68-73",
    "snippet": "static inline bool sig_handler_ignored(void __user *handler, int sig)\n{\n\t/* Is it explicitly or implicitly ignored? */\n\treturn handler == SIG_IGN ||\n\t       (handler == SIG_DFL && sig_kernel_ignore(sig));\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "sig_kernel_ignore",
          "args": [
            "sig"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic inline bool sig_handler_ignored(void __user *handler, int sig)\n{\n\t/* Is it explicitly or implicitly ignored? */\n\treturn handler == SIG_IGN ||\n\t       (handler == SIG_DFL && sig_kernel_ignore(sig));\n}"
  },
  {
    "function_name": "sig_handler",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "63-66",
    "snippet": "static void __user *sig_handler(struct task_struct *t, int sig)\n{\n\treturn t->sighand->action[sig - 1].sa.sa_handler;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nstatic void __user *sig_handler(struct task_struct *t, int sig)\n{\n\treturn t->sighand->action[sig - 1].sa.sa_handler;\n}"
  },
  {
    "function_name": "restart_syscall",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2650-2654",
    "snippet": "SYSCALL_DEFINE0(restart_syscall)\n{\n\tstruct restart_block *restart = &current->restart_block;\n\treturn restart->fn(restart);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE0(restart_syscall)\n{\n\tstruct restart_block *restart = &current->restart_block;\n\treturn restart->fn(restart);\n}"
  },
  {
    "function_name": "rt_sigprocmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2745-2773",
    "snippet": "SYSCALL_DEFINE4(rt_sigprocmask, int, how, sigset_t __user *, nset,\n\t\tsigset_t __user *, oset, size_t, sigsetsize)\n{\n\tsigset_t old_set, new_set;\n\tint error;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\told_set = current->blocked;\n\n\tif (nset) {\n\t\tif (copy_from_user(&new_set, nset, sizeof(sigset_t)))\n\t\t\treturn -EFAULT;\n\t\tsigdelsetmask(&new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\n\t\terror = sigprocmask(how, &new_set, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (oset) {\n\t\tif (copy_to_user(oset, &old_set, sizeof(sigset_t)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(rt_sigprocmask, int, how, sigset_t __user *, nset,\n\t\tsigset_t __user *, oset, size_t, sigsetsize)\n{\n\tsigset_t old_set, new_set;\n\tint error;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\told_set = current->blocked;\n\n\tif (nset) {\n\t\tif (copy_from_user(&new_set, nset, sizeof(sigset_t)))\n\t\t\treturn -EFAULT;\n\t\tsigdelsetmask(&new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\n\t\terror = sigprocmask(how, &new_set, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\n\tif (oset) {\n\t\tif (copy_to_user(oset, &old_set, sizeof(sigset_t)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rt_sigprocmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2776-2797",
    "snippet": "SYSCALL_DEFINE4(rt_sigprocmask, int, how, compat_sigset_t __user *, nset,\n\t\tcompat_sigset_t __user *, oset, compat_size_t, sigsetsize)\n{\n\tsigset_t old_set = current->blocked;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (nset) {\n\t\tsigset_t new_set;\n\t\tint error;\n\t\tif (get_compat_sigset(&new_set, nset))\n\t\t\treturn -EFAULT;\n\t\tsigdelsetmask(&new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\n\t\terror = sigprocmask(how, &new_set, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn oset ? put_compat_sigset(oset, &old_set, sizeof(*oset)) : 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(rt_sigprocmask, int, how, compat_sigset_t __user *, nset,\n\t\tcompat_sigset_t __user *, oset, compat_size_t, sigsetsize)\n{\n\tsigset_t old_set = current->blocked;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (nset) {\n\t\tsigset_t new_set;\n\t\tint error;\n\t\tif (get_compat_sigset(&new_set, nset))\n\t\t\treturn -EFAULT;\n\t\tsigdelsetmask(&new_set, sigmask(SIGKILL)|sigmask(SIGSTOP));\n\n\t\terror = sigprocmask(how, &new_set, NULL);\n\t\tif (error)\n\t\t\treturn error;\n\t}\n\treturn oset ? put_compat_sigset(oset, &old_set, sizeof(*oset)) : 0;\n}"
  },
  {
    "function_name": "rt_sigpending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2817-2830",
    "snippet": "SYSCALL_DEFINE2(rt_sigpending, sigset_t __user *, uset, size_t, sigsetsize)\n{\n\tsigset_t set;\n\n\tif (sigsetsize > sizeof(*uset))\n\t\treturn -EINVAL;\n\n\tdo_sigpending(&set);\n\n\tif (copy_to_user(uset, &set, sigsetsize))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE2(rt_sigpending, sigset_t __user *, uset, size_t, sigsetsize)\n{\n\tsigset_t set;\n\n\tif (sigsetsize > sizeof(*uset))\n\t\treturn -EINVAL;\n\n\tdo_sigpending(&set);\n\n\tif (copy_to_user(uset, &set, sigsetsize))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rt_sigpending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "2833-2844",
    "snippet": "SYSCALL_DEFINE2(rt_sigpending, compat_sigset_t __user *, uset,\n\t\tcompat_size_t, sigsetsize)\n{\n\tsigset_t set;\n\n\tif (sigsetsize > sizeof(*uset))\n\t\treturn -EINVAL;\n\n\tdo_sigpending(&set);\n\n\treturn put_compat_sigset(uset, &set, sigsetsize);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE2(rt_sigpending, compat_sigset_t __user *, uset,\n\t\tcompat_size_t, sigsetsize)\n{\n\tsigset_t set;\n\n\tif (sigsetsize > sizeof(*uset))\n\t\treturn -EINVAL;\n\n\tdo_sigpending(&set);\n\n\treturn put_compat_sigset(uset, &set, sigsetsize);\n}"
  },
  {
    "function_name": "rt_sigtimedwait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3225-3255",
    "snippet": "SYSCALL_DEFINE4(rt_sigtimedwait, const sigset_t __user *, uthese,\n\t\tsiginfo_t __user *, uinfo,\n\t\tconst struct __kernel_timespec __user *, uts,\n\t\tsize_t, sigsetsize)\n{\n\tsigset_t these;\n\tstruct timespec64 ts;\n\tkernel_siginfo_t info;\n\tint ret;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&these, uthese, sizeof(these)))\n\t\treturn -EFAULT;\n\n\tif (uts) {\n\t\tif (get_timespec64(&ts, uts))\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = do_sigtimedwait(&these, &info, uts ? &ts : NULL);\n\n\tif (ret > 0 && uinfo) {\n\t\tif (copy_siginfo_to_user(uinfo, &info))\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nSYSCALL_DEFINE4(rt_sigtimedwait, const sigset_t __user *, uthese,\n\t\tsiginfo_t __user *, uinfo,\n\t\tconst struct __kernel_timespec __user *, uts,\n\t\tsize_t, sigsetsize)\n{\n\tsigset_t these;\n\tstruct timespec64 ts;\n\tkernel_siginfo_t info;\n\tint ret;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&these, uthese, sizeof(these)))\n\t\treturn -EFAULT;\n\n\tif (uts) {\n\t\tif (get_timespec64(&ts, uts))\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = do_sigtimedwait(&these, &info, uts ? &ts : NULL);\n\n\tif (ret > 0 && uinfo) {\n\t\tif (copy_siginfo_to_user(uinfo, &info))\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "rt_sigtimedwait",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3258-3286",
    "snippet": "SYSCALL_DEFINE4(rt_sigtimedwait, compat_sigset_t __user *, uthese,\n\t\tstruct compat_siginfo __user *, uinfo,\n\t\tstruct old_timespec32 __user *, uts, compat_size_t, sigsetsize)\n{\n\tsigset_t s;\n\tstruct timespec64 t;\n\tkernel_siginfo_t info;\n\tlong ret;\n\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (get_compat_sigset(&s, uthese))\n\t\treturn -EFAULT;\n\n\tif (uts) {\n\t\tif (get_old_timespec32(&t, uts))\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = do_sigtimedwait(&s, &info, uts ? &t : NULL);\n\n\tif (ret > 0 && uinfo) {\n\t\tif (copy_siginfo_to_user32(uinfo, &info))\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nSYSCALL_DEFINE4(rt_sigtimedwait, compat_sigset_t __user *, uthese,\n\t\tstruct compat_siginfo __user *, uinfo,\n\t\tstruct old_timespec32 __user *, uts, compat_size_t, sigsetsize)\n{\n\tsigset_t s;\n\tstruct timespec64 t;\n\tkernel_siginfo_t info;\n\tlong ret;\n\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (get_compat_sigset(&s, uthese))\n\t\treturn -EFAULT;\n\n\tif (uts) {\n\t\tif (get_old_timespec32(&t, uts))\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = do_sigtimedwait(&s, &info, uts ? &t : NULL);\n\n\tif (ret > 0 && uinfo) {\n\t\tif (copy_siginfo_to_user32(uinfo, &info))\n\t\t\tret = -EFAULT;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "kill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3294-3306",
    "snippet": "SYSCALL_DEFINE2(kill, pid_t, pid, int, sig)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_USER;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\treturn kill_something_info(sig, &info, pid);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nSYSCALL_DEFINE2(kill, pid_t, pid, int, sig)\n{\n\tstruct kernel_siginfo info;\n\n\tclear_siginfo(&info);\n\tinfo.si_signo = sig;\n\tinfo.si_errno = 0;\n\tinfo.si_code = SI_USER;\n\tinfo.si_pid = task_tgid_vnr(current);\n\tinfo.si_uid = from_kuid_munged(current_user_ns(), current_uid());\n\n\treturn kill_something_info(sig, &info, pid);\n}"
  },
  {
    "function_name": "tgkill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3362-3369",
    "snippet": "SYSCALL_DEFINE3(tgkill, pid_t, tgid, pid_t, pid, int, sig)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\n\treturn do_tkill(tgid, pid, sig);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE3(tgkill, pid_t, tgid, pid_t, pid, int, sig)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0 || tgid <= 0)\n\t\treturn -EINVAL;\n\n\treturn do_tkill(tgid, pid, sig);\n}"
  },
  {
    "function_name": "tkill",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3378-3385",
    "snippet": "SYSCALL_DEFINE2(tkill, pid_t, pid, int, sig)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0)\n\t\treturn -EINVAL;\n\n\treturn do_tkill(0, pid, sig);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE2(tkill, pid_t, pid, int, sig)\n{\n\t/* This is only valid for single tasks */\n\tif (pid <= 0)\n\t\treturn -EINVAL;\n\n\treturn do_tkill(0, pid, sig);\n}"
  },
  {
    "function_name": "rt_sigqueueinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3406-3414",
    "snippet": "SYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tkernel_siginfo_t info;\n\tint ret = __copy_siginfo_from_user(sig, &info, uinfo);\n\tif (unlikely(ret))\n\t\treturn ret;\n\treturn do_rt_sigqueueinfo(pid, sig, &info);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nSYSCALL_DEFINE3(rt_sigqueueinfo, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tkernel_siginfo_t info;\n\tint ret = __copy_siginfo_from_user(sig, &info, uinfo);\n\tif (unlikely(ret))\n\t\treturn ret;\n\treturn do_rt_sigqueueinfo(pid, sig, &info);\n}"
  },
  {
    "function_name": "rt_sigqueueinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3417-3427",
    "snippet": "SYSCALL_DEFINE3(rt_sigqueueinfo,\n\t\t\tcompat_pid_t, pid,\n\t\t\tint, sig,\n\t\t\tstruct compat_siginfo __user *, uinfo)\n{\n\tkernel_siginfo_t info;\n\tint ret = __copy_siginfo_from_user32(sig, &info, uinfo);\n\tif (unlikely(ret))\n\t\treturn ret;\n\treturn do_rt_sigqueueinfo(pid, sig, &info);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nSYSCALL_DEFINE3(rt_sigqueueinfo,\n\t\t\tcompat_pid_t, pid,\n\t\t\tint, sig,\n\t\t\tstruct compat_siginfo __user *, uinfo)\n{\n\tkernel_siginfo_t info;\n\tint ret = __copy_siginfo_from_user32(sig, &info, uinfo);\n\tif (unlikely(ret))\n\t\treturn ret;\n\treturn do_rt_sigqueueinfo(pid, sig, &info);\n}"
  },
  {
    "function_name": "rt_tgsigqueueinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3446-3454",
    "snippet": "SYSCALL_DEFINE4(rt_tgsigqueueinfo, pid_t, tgid, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tkernel_siginfo_t info;\n\tint ret = __copy_siginfo_from_user(sig, &info, uinfo);\n\tif (unlikely(ret))\n\t\treturn ret;\n\treturn do_rt_tgsigqueueinfo(tgid, pid, sig, &info);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nSYSCALL_DEFINE4(rt_tgsigqueueinfo, pid_t, tgid, pid_t, pid, int, sig,\n\t\tsiginfo_t __user *, uinfo)\n{\n\tkernel_siginfo_t info;\n\tint ret = __copy_siginfo_from_user(sig, &info, uinfo);\n\tif (unlikely(ret))\n\t\treturn ret;\n\treturn do_rt_tgsigqueueinfo(tgid, pid, sig, &info);\n}"
  },
  {
    "function_name": "rt_tgsigqueueinfo",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3457-3468",
    "snippet": "SYSCALL_DEFINE4(rt_tgsigqueueinfo,\n\t\t\tcompat_pid_t, tgid,\n\t\t\tcompat_pid_t, pid,\n\t\t\tint, sig,\n\t\t\tstruct compat_siginfo __user *, uinfo)\n{\n\tkernel_siginfo_t info;\n\tint ret = __copy_siginfo_from_user32(sig, &info, uinfo);\n\tif (unlikely(ret))\n\t\treturn ret;\n\treturn do_rt_tgsigqueueinfo(tgid, pid, sig, &info);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [
      "int force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;"
    ],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nint force_sig_fault(int sig, int code, void __user *addr\n\t___ARCH_SI_TRAPNO(int trapno)\n\t___ARCH_SI_IA64(int imm, unsigned int flags, unsigned long isr)\n\t, struct task_struct *t)\n{\n\tstruct kernel_siginfo info;\n\nSYSCALL_DEFINE4(rt_tgsigqueueinfo,\n\t\t\tcompat_pid_t, tgid,\n\t\t\tcompat_pid_t, pid,\n\t\t\tint, sig,\n\t\t\tstruct compat_siginfo __user *, uinfo)\n{\n\tkernel_siginfo_t info;\n\tint ret = __copy_siginfo_from_user32(sig, &info, uinfo);\n\tif (unlikely(ret))\n\t\treturn ret;\n\treturn do_rt_tgsigqueueinfo(tgid, pid, sig, &info);\n}"
  },
  {
    "function_name": "sigaltstack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3585-3597",
    "snippet": "SYSCALL_DEFINE2(sigaltstack,const stack_t __user *,uss, stack_t __user *,uoss)\n{\n\tstack_t new, old;\n\tint err;\n\tif (uss && copy_from_user(&new, uss, sizeof(stack_t)))\n\t\treturn -EFAULT;\n\terr = do_sigaltstack(uss ? &new : NULL, uoss ? &old : NULL,\n\t\t\t      current_user_stack_pointer(),\n\t\t\t      MINSIGSTKSZ);\n\tif (!err && uoss && copy_to_user(uoss, &old, sizeof(stack_t)))\n\t\terr = -EFAULT;\n\treturn err;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE2(sigaltstack,const stack_t __user *,uss, stack_t __user *,uoss)\n{\n\tstack_t new, old;\n\tint err;\n\tif (uss && copy_from_user(&new, uss, sizeof(stack_t)))\n\t\treturn -EFAULT;\n\terr = do_sigaltstack(uss ? &new : NULL, uoss ? &old : NULL,\n\t\t\t      current_user_stack_pointer(),\n\t\t\t      MINSIGSTKSZ);\n\tif (!err && uoss && copy_to_user(uoss, &old, sizeof(stack_t)))\n\t\terr = -EFAULT;\n\treturn err;\n}"
  },
  {
    "function_name": "sigaltstack",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3653-3658",
    "snippet": "SYSCALL_DEFINE2(sigaltstack,\n\t\t\tconst compat_stack_t __user *, uss_ptr,\n\t\t\tcompat_stack_t __user *, uoss_ptr)\n{\n\treturn do_compat_sigaltstack(uss_ptr, uoss_ptr);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE2(sigaltstack,\n\t\t\tconst compat_stack_t __user *, uss_ptr,\n\t\t\tcompat_stack_t __user *, uoss_ptr)\n{\n\treturn do_compat_sigaltstack(uss_ptr, uoss_ptr);\n}"
  },
  {
    "function_name": "sigpending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3689-3702",
    "snippet": "SYSCALL_DEFINE1(sigpending, old_sigset_t __user *, uset)\n{\n\tsigset_t set;\n\n\tif (sizeof(old_sigset_t) > sizeof(*uset))\n\t\treturn -EINVAL;\n\n\tdo_sigpending(&set);\n\n\tif (copy_to_user(uset, &set, sizeof(old_sigset_t)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE1(sigpending, old_sigset_t __user *, uset)\n{\n\tsigset_t set;\n\n\tif (sizeof(old_sigset_t) > sizeof(*uset))\n\t\treturn -EINVAL;\n\n\tdo_sigpending(&set);\n\n\tif (copy_to_user(uset, &set, sizeof(old_sigset_t)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "sigpending",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3705-3712",
    "snippet": "SYSCALL_DEFINE1(sigpending, compat_old_sigset_t __user *, set32)\n{\n\tsigset_t set;\n\n\tdo_sigpending(&set);\n\n\treturn put_user(set.sig[0], set32);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE1(sigpending, compat_old_sigset_t __user *, set32)\n{\n\tsigset_t set;\n\n\tdo_sigpending(&set);\n\n\treturn put_user(set.sig[0], set32);\n}"
  },
  {
    "function_name": "sigprocmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3728-3765",
    "snippet": "SYSCALL_DEFINE3(sigprocmask, int, how, old_sigset_t __user *, nset,\n\t\told_sigset_t __user *, oset)\n{\n\told_sigset_t old_set, new_set;\n\tsigset_t new_blocked;\n\n\told_set = current->blocked.sig[0];\n\n\tif (nset) {\n\t\tif (copy_from_user(&new_set, nset, sizeof(*nset)))\n\t\t\treturn -EFAULT;\n\n\t\tnew_blocked = current->blocked;\n\n\t\tswitch (how) {\n\t\tcase SIG_BLOCK:\n\t\t\tsigaddsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_UNBLOCK:\n\t\t\tsigdelsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_SETMASK:\n\t\t\tnew_blocked.sig[0] = new_set;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tset_current_blocked(&new_blocked);\n\t}\n\n\tif (oset) {\n\t\tif (copy_to_user(oset, &old_set, sizeof(*oset)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE3(sigprocmask, int, how, old_sigset_t __user *, nset,\n\t\told_sigset_t __user *, oset)\n{\n\told_sigset_t old_set, new_set;\n\tsigset_t new_blocked;\n\n\told_set = current->blocked.sig[0];\n\n\tif (nset) {\n\t\tif (copy_from_user(&new_set, nset, sizeof(*nset)))\n\t\t\treturn -EFAULT;\n\n\t\tnew_blocked = current->blocked;\n\n\t\tswitch (how) {\n\t\tcase SIG_BLOCK:\n\t\t\tsigaddsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_UNBLOCK:\n\t\t\tsigdelsetmask(&new_blocked, new_set);\n\t\t\tbreak;\n\t\tcase SIG_SETMASK:\n\t\t\tnew_blocked.sig[0] = new_set;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\n\t\tset_current_blocked(&new_blocked);\n\t}\n\n\tif (oset) {\n\t\tif (copy_to_user(oset, &old_set, sizeof(*oset)))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rt_sigaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3776-3799",
    "snippet": "SYSCALL_DEFINE4(rt_sigaction, int, sig,\n\t\tconst struct sigaction __user *, act,\n\t\tstruct sigaction __user *, oact,\n\t\tsize_t, sigsetsize)\n{\n\tstruct k_sigaction new_sa, old_sa;\n\tint ret;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (act && copy_from_user(&new_sa.sa, act, sizeof(new_sa.sa)))\n\t\treturn -EFAULT;\n\n\tret = do_sigaction(sig, act ? &new_sa : NULL, oact ? &old_sa : NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (oact && copy_to_user(oact, &old_sa.sa, sizeof(old_sa.sa)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(rt_sigaction, int, sig,\n\t\tconst struct sigaction __user *, act,\n\t\tstruct sigaction __user *, oact,\n\t\tsize_t, sigsetsize)\n{\n\tstruct k_sigaction new_sa, old_sa;\n\tint ret;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (act && copy_from_user(&new_sa.sa, act, sizeof(new_sa.sa)))\n\t\treturn -EFAULT;\n\n\tret = do_sigaction(sig, act ? &new_sa : NULL, oact ? &old_sa : NULL);\n\tif (ret)\n\t\treturn ret;\n\n\tif (oact && copy_to_user(oact, &old_sa.sa, sizeof(old_sa.sa)))\n\t\treturn -EFAULT;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "rt_sigaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3801-3843",
    "snippet": "SYSCALL_DEFINE4(rt_sigaction, int, sig,\n\t\tconst struct compat_sigaction __user *, act,\n\t\tstruct compat_sigaction __user *, oact,\n\t\tcompat_size_t, sigsetsize)\n{\n\tstruct k_sigaction new_ka, old_ka;\n#ifdef __ARCH_HAS_SA_RESTORER\n\tcompat_uptr_t restorer;\n#endif\n\tint ret;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\treturn -EINVAL;\n\n\tif (act) {\n\t\tcompat_uptr_t handler;\n\t\tret = get_user(handler, &act->sa_handler);\n\t\tnew_ka.sa.sa_handler = compat_ptr(handler);\n#ifdef __ARCH_HAS_SA_RESTORER\n\t\tret |= get_user(restorer, &act->sa_restorer);\n\t\tnew_ka.sa.sa_restorer = compat_ptr(restorer);\n#endif\n\t\tret |= get_compat_sigset(&new_ka.sa.sa_mask, &act->sa_mask);\n\t\tret |= get_user(new_ka.sa.sa_flags, &act->sa_flags);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\n\tif (!ret && oact) {\n\t\tret = put_user(ptr_to_compat(old_ka.sa.sa_handler), \n\t\t\t       &oact->sa_handler);\n\t\tret |= put_compat_sigset(&oact->sa_mask, &old_ka.sa.sa_mask,\n\t\t\t\t\t sizeof(oact->sa_mask));\n\t\tret |= put_user(old_ka.sa.sa_flags, &oact->sa_flags);\n#ifdef __ARCH_HAS_SA_RESTORER\n\t\tret |= put_user(ptr_to_compat(old_ka.sa.sa_restorer),\n\t\t\t\t&oact->sa_restorer);\n#endif\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE4(rt_sigaction, int, sig,\n\t\tconst struct compat_sigaction __user *, act,\n\t\tstruct compat_sigaction __user *, oact,\n\t\tcompat_size_t, sigsetsize)\n{\n\tstruct k_sigaction new_ka, old_ka;\n#ifdef __ARCH_HAS_SA_RESTORER\n\tcompat_uptr_t restorer;\n#endif\n\tint ret;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(compat_sigset_t))\n\t\treturn -EINVAL;\n\n\tif (act) {\n\t\tcompat_uptr_t handler;\n\t\tret = get_user(handler, &act->sa_handler);\n\t\tnew_ka.sa.sa_handler = compat_ptr(handler);\n#ifdef __ARCH_HAS_SA_RESTORER\n\t\tret |= get_user(restorer, &act->sa_restorer);\n\t\tnew_ka.sa.sa_restorer = compat_ptr(restorer);\n#endif\n\t\tret |= get_compat_sigset(&new_ka.sa.sa_mask, &act->sa_mask);\n\t\tret |= get_user(new_ka.sa.sa_flags, &act->sa_flags);\n\t\tif (ret)\n\t\t\treturn -EFAULT;\n\t}\n\n\tret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\n\tif (!ret && oact) {\n\t\tret = put_user(ptr_to_compat(old_ka.sa.sa_handler), \n\t\t\t       &oact->sa_handler);\n\t\tret |= put_compat_sigset(&oact->sa_mask, &old_ka.sa.sa_mask,\n\t\t\t\t\t sizeof(oact->sa_mask));\n\t\tret |= put_user(old_ka.sa.sa_flags, &oact->sa_flags);\n#ifdef __ARCH_HAS_SA_RESTORER\n\t\tret |= put_user(ptr_to_compat(old_ka.sa.sa_restorer),\n\t\t\t\t&oact->sa_restorer);\n#endif\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "sigaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3848-3881",
    "snippet": "SYSCALL_DEFINE3(sigaction, int, sig,\n\t\tconst struct old_sigaction __user *, act,\n\t        struct old_sigaction __user *, oact)\n{\n\tstruct k_sigaction new_ka, old_ka;\n\tint ret;\n\n\tif (act) {\n\t\told_sigset_t mask;\n\t\tif (!access_ok(VERIFY_READ, act, sizeof(*act)) ||\n\t\t    __get_user(new_ka.sa.sa_handler, &act->sa_handler) ||\n\t\t    __get_user(new_ka.sa.sa_restorer, &act->sa_restorer) ||\n\t\t    __get_user(new_ka.sa.sa_flags, &act->sa_flags) ||\n\t\t    __get_user(mask, &act->sa_mask))\n\t\t\treturn -EFAULT;\n#ifdef __ARCH_HAS_KA_RESTORER\n\t\tnew_ka.ka_restorer = NULL;\n#endif\n\t\tsiginitset(&new_ka.sa.sa_mask, mask);\n\t}\n\n\tret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\n\n\tif (!ret && oact) {\n\t\tif (!access_ok(VERIFY_WRITE, oact, sizeof(*oact)) ||\n\t\t    __put_user(old_ka.sa.sa_handler, &oact->sa_handler) ||\n\t\t    __put_user(old_ka.sa.sa_restorer, &oact->sa_restorer) ||\n\t\t    __put_user(old_ka.sa.sa_flags, &oact->sa_flags) ||\n\t\t    __put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE3(sigaction, int, sig,\n\t\tconst struct old_sigaction __user *, act,\n\t        struct old_sigaction __user *, oact)\n{\n\tstruct k_sigaction new_ka, old_ka;\n\tint ret;\n\n\tif (act) {\n\t\told_sigset_t mask;\n\t\tif (!access_ok(VERIFY_READ, act, sizeof(*act)) ||\n\t\t    __get_user(new_ka.sa.sa_handler, &act->sa_handler) ||\n\t\t    __get_user(new_ka.sa.sa_restorer, &act->sa_restorer) ||\n\t\t    __get_user(new_ka.sa.sa_flags, &act->sa_flags) ||\n\t\t    __get_user(mask, &act->sa_mask))\n\t\t\treturn -EFAULT;\n#ifdef __ARCH_HAS_KA_RESTORER\n\t\tnew_ka.ka_restorer = NULL;\n#endif\n\t\tsiginitset(&new_ka.sa.sa_mask, mask);\n\t}\n\n\tret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\n\n\tif (!ret && oact) {\n\t\tif (!access_ok(VERIFY_WRITE, oact, sizeof(*oact)) ||\n\t\t    __put_user(old_ka.sa.sa_handler, &oact->sa_handler) ||\n\t\t    __put_user(old_ka.sa.sa_restorer, &oact->sa_restorer) ||\n\t\t    __put_user(old_ka.sa.sa_flags, &oact->sa_flags) ||\n\t\t    __put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask))\n\t\t\treturn -EFAULT;\n\t}\n\n\treturn ret;\n}"
  },
  {
    "function_name": "sigaction",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3884-3922",
    "snippet": "SYSCALL_DEFINE3(sigaction, int, sig,\n\t\tconst struct compat_old_sigaction __user *, act,\n\t        struct compat_old_sigaction __user *, oact)\n{\n\tstruct k_sigaction new_ka, old_ka;\n\tint ret;\n\tcompat_old_sigset_t mask;\n\tcompat_uptr_t handler, restorer;\n\n\tif (act) {\n\t\tif (!access_ok(VERIFY_READ, act, sizeof(*act)) ||\n\t\t    __get_user(handler, &act->sa_handler) ||\n\t\t    __get_user(restorer, &act->sa_restorer) ||\n\t\t    __get_user(new_ka.sa.sa_flags, &act->sa_flags) ||\n\t\t    __get_user(mask, &act->sa_mask))\n\t\t\treturn -EFAULT;\n\n#ifdef __ARCH_HAS_KA_RESTORER\n\t\tnew_ka.ka_restorer = NULL;\n#endif\n\t\tnew_ka.sa.sa_handler = compat_ptr(handler);\n\t\tnew_ka.sa.sa_restorer = compat_ptr(restorer);\n\t\tsiginitset(&new_ka.sa.sa_mask, mask);\n\t}\n\n\tret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\n\n\tif (!ret && oact) {\n\t\tif (!access_ok(VERIFY_WRITE, oact, sizeof(*oact)) ||\n\t\t    __put_user(ptr_to_compat(old_ka.sa.sa_handler),\n\t\t\t       &oact->sa_handler) ||\n\t\t    __put_user(ptr_to_compat(old_ka.sa.sa_restorer),\n\t\t\t       &oact->sa_restorer) ||\n\t\t    __put_user(old_ka.sa.sa_flags, &oact->sa_flags) ||\n\t\t    __put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask))\n\t\t\treturn -EFAULT;\n\t}\n\treturn ret;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE3(sigaction, int, sig,\n\t\tconst struct compat_old_sigaction __user *, act,\n\t        struct compat_old_sigaction __user *, oact)\n{\n\tstruct k_sigaction new_ka, old_ka;\n\tint ret;\n\tcompat_old_sigset_t mask;\n\tcompat_uptr_t handler, restorer;\n\n\tif (act) {\n\t\tif (!access_ok(VERIFY_READ, act, sizeof(*act)) ||\n\t\t    __get_user(handler, &act->sa_handler) ||\n\t\t    __get_user(restorer, &act->sa_restorer) ||\n\t\t    __get_user(new_ka.sa.sa_flags, &act->sa_flags) ||\n\t\t    __get_user(mask, &act->sa_mask))\n\t\t\treturn -EFAULT;\n\n#ifdef __ARCH_HAS_KA_RESTORER\n\t\tnew_ka.ka_restorer = NULL;\n#endif\n\t\tnew_ka.sa.sa_handler = compat_ptr(handler);\n\t\tnew_ka.sa.sa_restorer = compat_ptr(restorer);\n\t\tsiginitset(&new_ka.sa.sa_mask, mask);\n\t}\n\n\tret = do_sigaction(sig, act ? &new_ka : NULL, oact ? &old_ka : NULL);\n\n\tif (!ret && oact) {\n\t\tif (!access_ok(VERIFY_WRITE, oact, sizeof(*oact)) ||\n\t\t    __put_user(ptr_to_compat(old_ka.sa.sa_handler),\n\t\t\t       &oact->sa_handler) ||\n\t\t    __put_user(ptr_to_compat(old_ka.sa.sa_restorer),\n\t\t\t       &oact->sa_restorer) ||\n\t\t    __put_user(old_ka.sa.sa_flags, &oact->sa_flags) ||\n\t\t    __put_user(old_ka.sa.sa_mask.sig[0], &oact->sa_mask))\n\t\t\treturn -EFAULT;\n\t}\n\treturn ret;\n}"
  },
  {
    "function_name": "sgetmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3930-3934",
    "snippet": "SYSCALL_DEFINE0(sgetmask)\n{\n\t/* SMP safe */\n\treturn current->blocked.sig[0];\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE0(sgetmask)\n{\n\t/* SMP safe */\n\treturn current->blocked.sig[0];\n}"
  },
  {
    "function_name": "ssetmask",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3936-3945",
    "snippet": "SYSCALL_DEFINE1(ssetmask, int, newmask)\n{\n\tint old = current->blocked.sig[0];\n\tsigset_t newset;\n\n\tsiginitset(&newset, newmask);\n\tset_current_blocked(&newset);\n\n\treturn old;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE1(ssetmask, int, newmask)\n{\n\tint old = current->blocked.sig[0];\n\tsigset_t newset;\n\n\tsiginitset(&newset, newmask);\n\tset_current_blocked(&newset);\n\n\treturn old;\n}"
  },
  {
    "function_name": "signal",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3952-3964",
    "snippet": "SYSCALL_DEFINE2(signal, int, sig, __sighandler_t, handler)\n{\n\tstruct k_sigaction new_sa, old_sa;\n\tint ret;\n\n\tnew_sa.sa.sa_handler = handler;\n\tnew_sa.sa.sa_flags = SA_ONESHOT | SA_NOMASK;\n\tsigemptyset(&new_sa.sa.sa_mask);\n\n\tret = do_sigaction(sig, &new_sa, &old_sa);\n\n\treturn ret ? ret : (unsigned long)old_sa.sa.sa_handler;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE2(signal, int, sig, __sighandler_t, handler)\n{\n\tstruct k_sigaction new_sa, old_sa;\n\tint ret;\n\n\tnew_sa.sa.sa_handler = handler;\n\tnew_sa.sa.sa_flags = SA_ONESHOT | SA_NOMASK;\n\tsigemptyset(&new_sa.sa.sa_mask);\n\n\tret = do_sigaction(sig, &new_sa, &old_sa);\n\n\treturn ret ? ret : (unsigned long)old_sa.sa.sa_handler;\n}"
  },
  {
    "function_name": "pause",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3969-3976",
    "snippet": "SYSCALL_DEFINE0(pause)\n{\n\twhile (!signal_pending(current)) {\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule();\n\t}\n\treturn -ERESTARTNOHAND;\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE0(pause)\n{\n\twhile (!signal_pending(current)) {\n\t\t__set_current_state(TASK_INTERRUPTIBLE);\n\t\tschedule();\n\t}\n\treturn -ERESTARTNOHAND;\n}"
  },
  {
    "function_name": "rt_sigsuspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "3999-4010",
    "snippet": "SYSCALL_DEFINE2(rt_sigsuspend, sigset_t __user *, unewset, size_t, sigsetsize)\n{\n\tsigset_t newset;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&newset, unewset, sizeof(newset)))\n\t\treturn -EFAULT;\n\treturn sigsuspend(&newset);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE2(rt_sigsuspend, sigset_t __user *, unewset, size_t, sigsetsize)\n{\n\tsigset_t newset;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (copy_from_user(&newset, unewset, sizeof(newset)))\n\t\treturn -EFAULT;\n\treturn sigsuspend(&newset);\n}"
  },
  {
    "function_name": "rt_sigsuspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "4013-4024",
    "snippet": "SYSCALL_DEFINE2(rt_sigsuspend, compat_sigset_t __user *, unewset, compat_size_t, sigsetsize)\n{\n\tsigset_t newset;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (get_compat_sigset(&newset, unewset))\n\t\treturn -EFAULT;\n\treturn sigsuspend(&newset);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE2(rt_sigsuspend, compat_sigset_t __user *, unewset, compat_size_t, sigsetsize)\n{\n\tsigset_t newset;\n\n\t/* XXX: Don't preclude handling different sized sigset_t's.  */\n\tif (sigsetsize != sizeof(sigset_t))\n\t\treturn -EINVAL;\n\n\tif (get_compat_sigset(&newset, unewset))\n\t\treturn -EFAULT;\n\treturn sigsuspend(&newset);\n}"
  },
  {
    "function_name": "sigsuspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "4028-4033",
    "snippet": "SYSCALL_DEFINE1(sigsuspend, old_sigset_t, mask)\n{\n\tsigset_t blocked;\n\tsiginitset(&blocked, mask);\n\treturn sigsuspend(&blocked);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE1(sigsuspend, old_sigset_t, mask)\n{\n\tsigset_t blocked;\n\tsiginitset(&blocked, mask);\n\treturn sigsuspend(&blocked);\n}"
  },
  {
    "function_name": "sigsuspend",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2018-18955/repo/kernel/signal.c",
    "lines": "4036-4041",
    "snippet": "SYSCALL_DEFINE3(sigsuspend, int, unused1, int, unused2, old_sigset_t, mask)\n{\n\tsigset_t blocked;\n\tsiginitset(&blocked, mask);\n\treturn sigsuspend(&blocked);\n}",
    "includes": [
      "#include <linux/kdb.h>",
      "#include \"audit.h\"\t/* audit_signal_info() */",
      "#include <asm/cacheflush.h>",
      "#include <asm/siginfo.h>",
      "#include <asm/unistd.h>",
      "#include <linux/uaccess.h>",
      "#include <asm/param.h>",
      "#include <trace/events/signal.h>",
      "#include <linux/livepatch.h>",
      "#include <linux/posix-timers.h>",
      "#include <linux/compiler.h>",
      "#include <linux/cn_proc.h>",
      "#include <linux/compat.h>",
      "#include <linux/uprobes.h>",
      "#include <linux/user_namespace.h>",
      "#include <linux/nsproxy.h>",
      "#include <linux/pid_namespace.h>",
      "#include <linux/freezer.h>",
      "#include <linux/capability.h>",
      "#include <linux/tracehook.h>",
      "#include <linux/ratelimit.h>",
      "#include <linux/signalfd.h>",
      "#include <linux/signal.h>",
      "#include <linux/ptrace.h>",
      "#include <linux/syscalls.h>",
      "#include <linux/security.h>",
      "#include <linux/coredump.h>",
      "#include <linux/binfmts.h>",
      "#include <linux/tty.h>",
      "#include <linux/fs.h>",
      "#include <linux/sched/cputime.h>",
      "#include <linux/sched/task_stack.h>",
      "#include <linux/sched/task.h>",
      "#include <linux/sched/debug.h>",
      "#include <linux/sched/user.h>",
      "#include <linux/sched/mm.h>",
      "#include <linux/init.h>",
      "#include <linux/export.h>",
      "#include <linux/slab.h>"
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include <linux/kdb.h>\n#include \"audit.h\"\t/* audit_signal_info() */\n#include <asm/cacheflush.h>\n#include <asm/siginfo.h>\n#include <asm/unistd.h>\n#include <linux/uaccess.h>\n#include <asm/param.h>\n#include <trace/events/signal.h>\n#include <linux/livepatch.h>\n#include <linux/posix-timers.h>\n#include <linux/compiler.h>\n#include <linux/cn_proc.h>\n#include <linux/compat.h>\n#include <linux/uprobes.h>\n#include <linux/user_namespace.h>\n#include <linux/nsproxy.h>\n#include <linux/pid_namespace.h>\n#include <linux/freezer.h>\n#include <linux/capability.h>\n#include <linux/tracehook.h>\n#include <linux/ratelimit.h>\n#include <linux/signalfd.h>\n#include <linux/signal.h>\n#include <linux/ptrace.h>\n#include <linux/syscalls.h>\n#include <linux/security.h>\n#include <linux/coredump.h>\n#include <linux/binfmts.h>\n#include <linux/tty.h>\n#include <linux/fs.h>\n#include <linux/sched/cputime.h>\n#include <linux/sched/task_stack.h>\n#include <linux/sched/task.h>\n#include <linux/sched/debug.h>\n#include <linux/sched/user.h>\n#include <linux/sched/mm.h>\n#include <linux/init.h>\n#include <linux/export.h>\n#include <linux/slab.h>\n\nSYSCALL_DEFINE3(sigsuspend, int, unused1, int, unused2, old_sigset_t, mask)\n{\n\tsigset_t blocked;\n\tsiginitset(&blocked, mask);\n\treturn sigsuspend(&blocked);\n}"
  }
]