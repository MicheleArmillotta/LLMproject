[
  {
    "function_name": "cs_cmd_set_mlock",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/set_mlock.c",
    "lines": "37-310",
    "snippet": "static void cs_cmd_set_mlock(sourceinfo_t *si, int parc, char *parv[])\n{\n\tmychan_t *mc;\n\tchar modebuf[32], *end, c;\n\tint dir = MTYPE_NUL;\n\tint newlock_on = 0, newlock_off = 0, newlock_limit = 0, flag = 0;\n\tunsigned int mask, changed;\n\tbool mask_ext;\n\tchar newlock_key[KEYLEN];\n\tchar newlock_ext[ignore_mode_list_size][512];\n\tbool newlock_ext_off[ignore_mode_list_size];\n\tchar newext[512];\n\tchar ext_plus[ignore_mode_list_size + 1];\n\tchar ext_minus[ignore_mode_list_size + 1];\n\tsize_t i;\n\tchar *letters = strtok(parv[1], \" \");\n\tchar *arg;\n\tmetadata_t *md;\n\n\tif (!(mc = mychan_find(parv[0])))\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), parv[0]);\n\t\treturn;\n\t}\n\n\tif (!chanacs_source_has_flag(mc, si, CA_SET))\n\t{\n\t\tif (ircd->oper_only_modes == 0 ||\n\t\t\t\t!has_priv(si, PRIV_CHAN_CMODES) ||\n\t\t\t\t!has_priv(si, PRIV_CHAN_ADMIN))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this command.\"));\n\t\t\treturn;\n\t\t}\n\t\tmask = ~ircd->oper_only_modes;\n\t\tmask_ext = true;\n\t}\n\telse\n\t{\n\t\tmask = has_priv(si, PRIV_CHAN_CMODES) ? 0 : ircd->oper_only_modes;\n\t\tmask_ext = false;\n\n\t}\n\n\tfor (i = 0; i < ignore_mode_list_size; i++)\n\t{\n\t\tnewlock_ext[i][0] = '\\0';\n\t\tnewlock_ext_off[i] = false;\n\t}\n\tnewlock_key[0] = '\\0';\n\n\twhile (letters && *letters)\n\t{\n\t\tif (*letters != '+' && *letters != '-' && dir == MTYPE_NUL)\n\t\t{\n\t\t\tletters++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch ((c = *letters++))\n\t\t{\n\t\t  case '+':\n\t\t\t  dir = MTYPE_ADD;\n\t\t\t  break;\n\n\t\t  case '-':\n\t\t\t  dir = MTYPE_DEL;\n\t\t\t  break;\n\n\t\t  case 'k':\n\t\t\t  if (dir == MTYPE_ADD)\n\t\t\t  {\n\t\t\t\t  arg = strtok(NULL, \" \");\n\t\t\t\t  if (!arg)\n\t\t\t\t  {\n\t\t\t\t\t  command_fail(si, fault_badparams, _(\"You need to specify a value for mode +%c.\"), 'k');\n\t\t\t\t\t  return;\n\t\t\t\t  }\n\t\t\t\t  else if (strlen(arg) >= KEYLEN)\n\t\t\t\t  {\n\t\t\t\t\t  command_fail(si, fault_badparams, _(\"MLOCK key is too long (%d > %d).\"), (int)strlen(arg), KEYLEN - 1);\n\t\t\t\t\t  return;\n\t\t\t\t  }\n\t\t\t\t  else if (strchr(arg, ',') || arg[0] == ':')\n\t\t\t\t  {\n\t\t\t\t\t  command_fail(si, fault_badparams, _(\"MLOCK key contains invalid characters.\"));\n\t\t\t\t\t  return;\n\t\t\t\t  }\n\n\t\t\t\t  mowgli_strlcpy(newlock_key, arg, sizeof newlock_key);\n\t\t\t\t  newlock_off &= ~CMODE_KEY;\n\t\t\t  }\n\t\t\t  else\n\t\t\t  {\n\t\t\t\t  newlock_key[0] = '\\0';\n\t\t\t\t  newlock_off |= CMODE_KEY;\n\t\t\t  }\n\n\t\t\t  break;\n\n\t\t  case 'l':\n\t\t\t  if (dir == MTYPE_ADD)\n\t\t\t  {\n\t\t\t\t  arg = strtok(NULL, \" \");\n\t\t\t\t  if(!arg)\n\t\t\t\t  {\n\t\t\t\t\t  command_fail(si, fault_badparams, _(\"You need to specify a value for mode +%c.\"), 'l');\n\t\t\t\t\t  return;\n\t\t\t\t  }\n\n\t\t\t\t  if (atol(arg) <= 0)\n\t\t\t\t  {\n\t\t\t\t\t  command_fail(si, fault_badparams, _(\"You must specify a positive integer for limit.\"));\n\t\t\t\t\t  return;\n\t\t\t\t  }\n\n\t\t\t\t  newlock_limit = atol(arg);\n\t\t\t\t  newlock_off &= ~CMODE_LIMIT;\n\t\t\t  }\n\t\t\t  else\n\t\t\t  {\n\t\t\t\t  newlock_limit = 0;\n\t\t\t\t  newlock_off |= CMODE_LIMIT;\n\t\t\t  }\n\n\t\t\t  break;\n\n\t\t  default:\n\t\t\t  flag = mode_to_flag(c);\n\n\t\t\t  if (flag)\n\t\t\t  {\n\t\t\t\t  if (dir == MTYPE_ADD)\n\t\t\t\t\t  newlock_on |= flag, newlock_off &= ~flag;\n\t\t\t\t  else\n\t\t\t\t\t  newlock_off |= flag, newlock_on &= ~flag;\n\t\t\t\t  break;\n\t\t\t  }\n\n\t\t\t  for (i = 0; ignore_mode_list[i].mode != '\\0'; i++)\n\t\t\t  {\n\t\t\t\t  if (c == ignore_mode_list[i].mode)\n\t\t\t\t  {\n\t\t\t\t\t  if (dir == MTYPE_ADD)\n\t\t\t\t\t  {\n\t\t\t\t\t\t  arg = strtok(NULL, \" \");\n\t\t\t\t\t\t  if(!arg)\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t  command_fail(si, fault_badparams, _(\"You need to specify a value for mode +%c.\"), c);\n\t\t\t\t\t\t\t  return;\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t  if (strlen(arg) > 350)\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t  command_fail(si, fault_badparams, _(\"Invalid value \\2%s\\2 for mode +%c.\"), arg, c);\n\t\t\t\t\t\t\t  return;\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t  if ((mc->chan == NULL || mc->chan->extmodes[i] == NULL || strcmp(mc->chan->extmodes[i], arg)) && !ignore_mode_list[i].check(arg, mc->chan, mc, si->su, si->smu))\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t  command_fail(si, fault_badparams, _(\"Invalid value \\2%s\\2 for mode +%c.\"), arg, c);\n\t\t\t\t\t\t\t  return;\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t  mowgli_strlcpy(newlock_ext[i], arg, sizeof newlock_ext[i]);\n\t\t\t\t\t\t  newlock_ext_off[i] = false;\n\t\t\t\t\t  }\n\t\t\t\t\t  else\n\t\t\t\t\t  {\n\t\t\t\t\t\t  newlock_ext[i][0] = '\\0';\n\t\t\t\t\t\t  newlock_ext_off[i] = true;\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t  }\n\t\t}\n\t}\n\n\t/* note: the following does not treat +lk and extmodes correctly */\n\tchanged = ((newlock_on ^ mc->mlock_on) | (newlock_off ^ mc->mlock_off));\n\tchanged &= ~mask;\n\t/* if they're only allowed to alter oper only modes, require\n\t * them to actually change such modes -- jilles */\n\tif (!changed && mask_ext)\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You may only alter \\2+%s\\2 modes.\"), flags_to_string(~mask));\n\t\treturn;\n\t}\n\n\t/* save it to mychan */\n\t/* leave the modes in mask unchanged -- jilles */\n\tmc->mlock_on = (newlock_on & ~mask) | (mc->mlock_on & mask);\n\tmc->mlock_off = (newlock_off & ~mask) | (mc->mlock_off & mask);\n\tif (!(mask & CMODE_LIMIT))\n\t\tmc->mlock_limit = newlock_limit;\n\tif (!(mask & CMODE_KEY))\n\t{\n\t\tfree(mc->mlock_key);\n\t\tmc->mlock_key = *newlock_key != '\\0' ? sstrdup(newlock_key) : NULL;\n\t}\n\n\text_plus[0] = '\\0';\n\text_minus[0] = '\\0';\n\tif (mask_ext)\n\t{\n\t\tmd = metadata_find(mc, \"private:mlockext\");\n\t\tif (md != NULL)\n\t\t{\n\t\t\targ = md->value;\n\t\t\twhile (*arg != '\\0')\n\t\t\t{\n\t\t\t\tmodebuf[0] = *arg;\n\t\t\t\tmodebuf[1] = '\\0';\n\t\t\t\tmowgli_strlcat(arg[1] == ' ' || arg[1] == '\\0' ? ext_minus : ext_plus, modebuf, ignore_mode_list_size + 1);\n\t\t\t\targ++;\n\t\t\t\twhile (*arg != ' ' && *arg != '\\0')\n\t\t\t\t\targ++;\n\t\t\t\twhile (*arg == ' ')\n\t\t\t\t\targ++;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tnewext[0] = '\\0';\n\t\tfor (i = 0; i < ignore_mode_list_size; i++)\n\t\t{\n\t\t\tif (newlock_ext[i][0] != '\\0' || newlock_ext_off[i])\n\t\t\t{\n\t\t\t\tif (*newext != '\\0')\n\t\t\t\t{\n\t\t\t\t\tmodebuf[0] = ' ';\n\t\t\t\t\tmodebuf[1] = '\\0';\n\t\t\t\t\tmowgli_strlcat(newext, modebuf, sizeof newext);\n\t\t\t\t}\n\t\t\t\tmodebuf[0] = ignore_mode_list[i].mode;\n\t\t\t\tmodebuf[1] = '\\0';\n\t\t\t\tmowgli_strlcat(newext, modebuf, sizeof newext);\n\t\t\t\tmowgli_strlcat(newlock_ext_off[i] ? ext_minus : ext_plus,\n\t\t\t\t\t\tmodebuf, ignore_mode_list_size + 1);\n\t\t\t\tif (!newlock_ext_off[i])\n\t\t\t\t\tmowgli_strlcat(newext, newlock_ext[i], sizeof newext);\n\t\t\t}\n\t\t}\n\t\tif (newext[0] != '\\0')\n\t\t\tmetadata_add(mc, \"private:mlockext\", newext);\n\t\telse\n\t\t\tmetadata_delete(mc, \"private:mlockext\");\n\t}\n\n\tend = modebuf;\n\t*end = 0;\n\n\tif (mc->mlock_on || mc->mlock_key || mc->mlock_limit || *ext_plus)\n\t\tend += snprintf(end, sizeof(modebuf) - (end - modebuf), \"+%s%s%s%s\", flags_to_string(mc->mlock_on), mc->mlock_key ? \"k\" : \"\", mc->mlock_limit ? \"l\" : \"\", ext_plus);\n\n\tif (mc->mlock_off || *ext_minus)\n\t\tend += snprintf(end, sizeof(modebuf) - (end - modebuf), \"-%s%s%s%s\", flags_to_string(mc->mlock_off), mc->mlock_off & CMODE_KEY ? \"k\" : \"\", mc->mlock_off & CMODE_LIMIT ? \"l\" : \"\", ext_minus);\n\n\tif (*modebuf)\n\t{\n\t\tcommand_success_nodata(si, _(\"The MLOCK for \\2%s\\2 has been set to \\2%s\\2.\"), mc->name, modebuf);\n\t\tlogcommand(si, CMDLOG_SET, \"SET:MLOCK: \\2%s\\2 to \\2%s\\2\", mc->name, modebuf);\n\t}\n\telse\n\t{\n\t\tcommand_success_nodata(si, _(\"The MLOCK for \\2%s\\2 has been removed.\"), mc->name);\n\t\tlogcommand(si, CMDLOG_SET, \"SET:MLOCK:NONE: \\2%s\\2\", mc->name);\n\t}\n\tif (changed & ircd->oper_only_modes)\n\t\tlogcommand(si, CMDLOG_SET, _(\"SET:MLOCK: \\2%s\\2 to \\2%s\\2 by \\2%s\\2\"), mc->name, *modebuf != '\\0' ? modebuf : \"+\", get_oper_name(si));\n\n\tcheck_modes(mc, true);\n\tif (mc->chan != NULL)\n\t\tmlock_sts(mc->chan);\n\n\treturn;\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_cmd_set_mlock(sourceinfo_t *si, int parc, char *parv[]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mlock_sts",
          "args": [
            "mc->chan"
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_modes",
          "args": [
            "mc",
            "true"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_SET",
            "_(\"SET:MLOCK: \\2%s\\2 to \\2%s\\2 by \\2%s\\2\")",
            "mc->name",
            "*modebuf != '\\0' ? modebuf : \"+\"",
            "get_oper_name(si)"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_oper_name",
          "args": [
            "si"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"SET:MLOCK: \\2%s\\2 to \\2%s\\2 by \\2%s\\2\""
          ],
          "line": 303
        },
        "resolved": true,
        "details": {
          "function_name": "_moddeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/set_mlock.c",
          "lines": "32-35",
          "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tcommand_delete(&cs_set_mlock, *cs_set_cmdtree);\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "command_t cs_set_mlock = { \"MLOCK\", N_(\"Sets channel mode lock.\"), AC_NONE, 2, cs_cmd_set_mlock, { .path = \"cservice/set_mlock\" } };",
            "mowgli_patricia_t **cs_set_cmdtree;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\ncommand_t cs_set_mlock = { \"MLOCK\", N_(\"Sets channel mode lock.\"), AC_NONE, 2, cs_cmd_set_mlock, { .path = \"cservice/set_mlock\" } };\nmowgli_patricia_t **cs_set_cmdtree;\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tcommand_delete(&cs_set_mlock, *cs_set_cmdtree);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_SET",
            "\"SET:MLOCK:NONE: \\2%s\\2\"",
            "mc->name"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"The MLOCK for \\2%s\\2 has been removed.\")",
            "mc->name"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_SET",
            "\"SET:MLOCK: \\2%s\\2 to \\2%s\\2\"",
            "mc->name",
            "modebuf"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"The MLOCK for \\2%s\\2 has been set to \\2%s\\2.\")",
            "mc->name",
            "modebuf"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "end",
            "sizeof(modebuf) - (end - modebuf)",
            "\"-%s%s%s%s\"",
            "flags_to_string(mc->mlock_off)",
            "mc->mlock_off & CMODE_KEY ? \"k\" : \"\"",
            "mc->mlock_off & CMODE_LIMIT ? \"l\" : \"\"",
            "ext_minus"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flags_to_string",
          "args": [
            "mc->mlock_off"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "end",
            "sizeof(modebuf) - (end - modebuf)",
            "\"+%s%s%s%s\"",
            "flags_to_string(mc->mlock_on)",
            "mc->mlock_key ? \"k\" : \"\"",
            "mc->mlock_limit ? \"l\" : \"\"",
            "ext_plus"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flags_to_string",
          "args": [
            "mc->mlock_on"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_delete",
          "args": [
            "mc",
            "\"private:mlockext\""
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_add",
          "args": [
            "mc",
            "\"private:mlockext\"",
            "newext"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcat",
          "args": [
            "newext",
            "newlock_ext[i]",
            "sizeof newext"
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcat",
          "args": [
            "newlock_ext_off[i] ? ext_minus : ext_plus",
            "modebuf",
            "ignore_mode_list_size + 1"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcat",
          "args": [
            "newext",
            "modebuf",
            "sizeof newext"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcat",
          "args": [
            "newext",
            "modebuf",
            "sizeof newext"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcat",
          "args": [
            "arg[1] == ' ' || arg[1] == '\\0' ? ext_minus : ext_plus",
            "modebuf",
            "ignore_mode_list_size + 1"
          ],
          "line": 246
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:mlockext\""
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sstrdup",
          "args": [
            "newlock_key"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mc->mlock_key"
          ],
          "line": 230
        },
        "resolved": true,
        "details": {
          "function_name": "free_template_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/access.c",
          "lines": "358-371",
          "snippet": "static void free_template_list(mowgli_list_t *l)\n{\n\tmowgli_node_t *n, *tn;\n\n\treturn_if_fail(l != NULL);\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, l->head)\n\t{\n\t\ttemplate_t *t = n->data;\n\n\t\tmowgli_node_delete(&t->node, l);\n\t\tfree(t);\n\t}\n}",
          "includes": [
            "#include \"template.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void free_template_list(mowgli_list_t *l)\n{\n\tmowgli_node_t *n, *tn;\n\n\treturn_if_fail(l != NULL);\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, l->head)\n\t{\n\t\ttemplate_t *t = n->data;\n\n\t\tmowgli_node_delete(&t->node, l);\n\t\tfree(t);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You may only alter \\2+%s\\2 modes.\")",
            "flags_to_string(~mask)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flags_to_string",
          "args": [
            "~mask"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcpy",
          "args": [
            "newlock_ext[i]",
            "arg",
            "sizeof newlock_ext[i]"
          ],
          "line": 198
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_badparams",
            "_(\"Invalid value \\2%s\\2 for mode +%c.\")",
            "arg",
            "c"
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ignore_mode_list[i].check",
          "args": [
            "arg",
            "mc->chan",
            "mc",
            "si->su",
            "si->smu"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "mc->chan->extmodes[i]",
            "arg"
          ],
          "line": 193
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_badparams",
            "_(\"Invalid value \\2%s\\2 for mode +%c.\")",
            "arg",
            "c"
          ],
          "line": 190
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "arg"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_badparams",
            "_(\"You need to specify a value for mode +%c.\")",
            "c"
          ],
          "line": 185
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\" \""
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mode_to_flag",
          "args": [
            "c"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "arg"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_badparams",
            "_(\"You must specify a positive integer for limit.\")"
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "arg"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_badparams",
            "_(\"You need to specify a value for mode +%c.\")",
            "'l'"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\" \""
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcpy",
          "args": [
            "newlock_key",
            "arg",
            "sizeof newlock_key"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_badparams",
            "_(\"MLOCK key contains invalid characters.\")"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "arg",
            "','"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_badparams",
            "_(\"MLOCK key is too long (%d > %d).\")",
            "(int)strlen(arg)",
            "KEYLEN - 1"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "arg"
          ],
          "line": 117
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "arg"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_badparams",
            "_(\"You need to specify a value for mode +%c.\")",
            "'k'"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\" \""
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_priv",
          "args": [
            "si",
            "PRIV_CHAN_CMODES"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not authorized to perform this command.\")"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_priv",
          "args": [
            "si",
            "PRIV_CHAN_ADMIN"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_priv",
          "args": [
            "si",
            "PRIV_CHAN_CMODES"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_source_has_flag",
          "args": [
            "mc",
            "si",
            "CA_SET"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_target",
            "_(\"Channel \\2%s\\2 is not registered.\")",
            "parv[0]"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_find",
          "args": [
            "parv[0]"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "parv[1]",
            "\" \""
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic void cs_cmd_set_mlock(sourceinfo_t *si, int parc, char *parv[]);\n\nstatic void cs_cmd_set_mlock(sourceinfo_t *si, int parc, char *parv[])\n{\n\tmychan_t *mc;\n\tchar modebuf[32], *end, c;\n\tint dir = MTYPE_NUL;\n\tint newlock_on = 0, newlock_off = 0, newlock_limit = 0, flag = 0;\n\tunsigned int mask, changed;\n\tbool mask_ext;\n\tchar newlock_key[KEYLEN];\n\tchar newlock_ext[ignore_mode_list_size][512];\n\tbool newlock_ext_off[ignore_mode_list_size];\n\tchar newext[512];\n\tchar ext_plus[ignore_mode_list_size + 1];\n\tchar ext_minus[ignore_mode_list_size + 1];\n\tsize_t i;\n\tchar *letters = strtok(parv[1], \" \");\n\tchar *arg;\n\tmetadata_t *md;\n\n\tif (!(mc = mychan_find(parv[0])))\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), parv[0]);\n\t\treturn;\n\t}\n\n\tif (!chanacs_source_has_flag(mc, si, CA_SET))\n\t{\n\t\tif (ircd->oper_only_modes == 0 ||\n\t\t\t\t!has_priv(si, PRIV_CHAN_CMODES) ||\n\t\t\t\t!has_priv(si, PRIV_CHAN_ADMIN))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this command.\"));\n\t\t\treturn;\n\t\t}\n\t\tmask = ~ircd->oper_only_modes;\n\t\tmask_ext = true;\n\t}\n\telse\n\t{\n\t\tmask = has_priv(si, PRIV_CHAN_CMODES) ? 0 : ircd->oper_only_modes;\n\t\tmask_ext = false;\n\n\t}\n\n\tfor (i = 0; i < ignore_mode_list_size; i++)\n\t{\n\t\tnewlock_ext[i][0] = '\\0';\n\t\tnewlock_ext_off[i] = false;\n\t}\n\tnewlock_key[0] = '\\0';\n\n\twhile (letters && *letters)\n\t{\n\t\tif (*letters != '+' && *letters != '-' && dir == MTYPE_NUL)\n\t\t{\n\t\t\tletters++;\n\t\t\tcontinue;\n\t\t}\n\n\t\tswitch ((c = *letters++))\n\t\t{\n\t\t  case '+':\n\t\t\t  dir = MTYPE_ADD;\n\t\t\t  break;\n\n\t\t  case '-':\n\t\t\t  dir = MTYPE_DEL;\n\t\t\t  break;\n\n\t\t  case 'k':\n\t\t\t  if (dir == MTYPE_ADD)\n\t\t\t  {\n\t\t\t\t  arg = strtok(NULL, \" \");\n\t\t\t\t  if (!arg)\n\t\t\t\t  {\n\t\t\t\t\t  command_fail(si, fault_badparams, _(\"You need to specify a value for mode +%c.\"), 'k');\n\t\t\t\t\t  return;\n\t\t\t\t  }\n\t\t\t\t  else if (strlen(arg) >= KEYLEN)\n\t\t\t\t  {\n\t\t\t\t\t  command_fail(si, fault_badparams, _(\"MLOCK key is too long (%d > %d).\"), (int)strlen(arg), KEYLEN - 1);\n\t\t\t\t\t  return;\n\t\t\t\t  }\n\t\t\t\t  else if (strchr(arg, ',') || arg[0] == ':')\n\t\t\t\t  {\n\t\t\t\t\t  command_fail(si, fault_badparams, _(\"MLOCK key contains invalid characters.\"));\n\t\t\t\t\t  return;\n\t\t\t\t  }\n\n\t\t\t\t  mowgli_strlcpy(newlock_key, arg, sizeof newlock_key);\n\t\t\t\t  newlock_off &= ~CMODE_KEY;\n\t\t\t  }\n\t\t\t  else\n\t\t\t  {\n\t\t\t\t  newlock_key[0] = '\\0';\n\t\t\t\t  newlock_off |= CMODE_KEY;\n\t\t\t  }\n\n\t\t\t  break;\n\n\t\t  case 'l':\n\t\t\t  if (dir == MTYPE_ADD)\n\t\t\t  {\n\t\t\t\t  arg = strtok(NULL, \" \");\n\t\t\t\t  if(!arg)\n\t\t\t\t  {\n\t\t\t\t\t  command_fail(si, fault_badparams, _(\"You need to specify a value for mode +%c.\"), 'l');\n\t\t\t\t\t  return;\n\t\t\t\t  }\n\n\t\t\t\t  if (atol(arg) <= 0)\n\t\t\t\t  {\n\t\t\t\t\t  command_fail(si, fault_badparams, _(\"You must specify a positive integer for limit.\"));\n\t\t\t\t\t  return;\n\t\t\t\t  }\n\n\t\t\t\t  newlock_limit = atol(arg);\n\t\t\t\t  newlock_off &= ~CMODE_LIMIT;\n\t\t\t  }\n\t\t\t  else\n\t\t\t  {\n\t\t\t\t  newlock_limit = 0;\n\t\t\t\t  newlock_off |= CMODE_LIMIT;\n\t\t\t  }\n\n\t\t\t  break;\n\n\t\t  default:\n\t\t\t  flag = mode_to_flag(c);\n\n\t\t\t  if (flag)\n\t\t\t  {\n\t\t\t\t  if (dir == MTYPE_ADD)\n\t\t\t\t\t  newlock_on |= flag, newlock_off &= ~flag;\n\t\t\t\t  else\n\t\t\t\t\t  newlock_off |= flag, newlock_on &= ~flag;\n\t\t\t\t  break;\n\t\t\t  }\n\n\t\t\t  for (i = 0; ignore_mode_list[i].mode != '\\0'; i++)\n\t\t\t  {\n\t\t\t\t  if (c == ignore_mode_list[i].mode)\n\t\t\t\t  {\n\t\t\t\t\t  if (dir == MTYPE_ADD)\n\t\t\t\t\t  {\n\t\t\t\t\t\t  arg = strtok(NULL, \" \");\n\t\t\t\t\t\t  if(!arg)\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t  command_fail(si, fault_badparams, _(\"You need to specify a value for mode +%c.\"), c);\n\t\t\t\t\t\t\t  return;\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t  if (strlen(arg) > 350)\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t  command_fail(si, fault_badparams, _(\"Invalid value \\2%s\\2 for mode +%c.\"), arg, c);\n\t\t\t\t\t\t\t  return;\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t  if ((mc->chan == NULL || mc->chan->extmodes[i] == NULL || strcmp(mc->chan->extmodes[i], arg)) && !ignore_mode_list[i].check(arg, mc->chan, mc, si->su, si->smu))\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t  command_fail(si, fault_badparams, _(\"Invalid value \\2%s\\2 for mode +%c.\"), arg, c);\n\t\t\t\t\t\t\t  return;\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t  mowgli_strlcpy(newlock_ext[i], arg, sizeof newlock_ext[i]);\n\t\t\t\t\t\t  newlock_ext_off[i] = false;\n\t\t\t\t\t  }\n\t\t\t\t\t  else\n\t\t\t\t\t  {\n\t\t\t\t\t\t  newlock_ext[i][0] = '\\0';\n\t\t\t\t\t\t  newlock_ext_off[i] = true;\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t  }\n\t\t}\n\t}\n\n\t/* note: the following does not treat +lk and extmodes correctly */\n\tchanged = ((newlock_on ^ mc->mlock_on) | (newlock_off ^ mc->mlock_off));\n\tchanged &= ~mask;\n\t/* if they're only allowed to alter oper only modes, require\n\t * them to actually change such modes -- jilles */\n\tif (!changed && mask_ext)\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You may only alter \\2+%s\\2 modes.\"), flags_to_string(~mask));\n\t\treturn;\n\t}\n\n\t/* save it to mychan */\n\t/* leave the modes in mask unchanged -- jilles */\n\tmc->mlock_on = (newlock_on & ~mask) | (mc->mlock_on & mask);\n\tmc->mlock_off = (newlock_off & ~mask) | (mc->mlock_off & mask);\n\tif (!(mask & CMODE_LIMIT))\n\t\tmc->mlock_limit = newlock_limit;\n\tif (!(mask & CMODE_KEY))\n\t{\n\t\tfree(mc->mlock_key);\n\t\tmc->mlock_key = *newlock_key != '\\0' ? sstrdup(newlock_key) : NULL;\n\t}\n\n\text_plus[0] = '\\0';\n\text_minus[0] = '\\0';\n\tif (mask_ext)\n\t{\n\t\tmd = metadata_find(mc, \"private:mlockext\");\n\t\tif (md != NULL)\n\t\t{\n\t\t\targ = md->value;\n\t\t\twhile (*arg != '\\0')\n\t\t\t{\n\t\t\t\tmodebuf[0] = *arg;\n\t\t\t\tmodebuf[1] = '\\0';\n\t\t\t\tmowgli_strlcat(arg[1] == ' ' || arg[1] == '\\0' ? ext_minus : ext_plus, modebuf, ignore_mode_list_size + 1);\n\t\t\t\targ++;\n\t\t\t\twhile (*arg != ' ' && *arg != '\\0')\n\t\t\t\t\targ++;\n\t\t\t\twhile (*arg == ' ')\n\t\t\t\t\targ++;\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{\n\t\tnewext[0] = '\\0';\n\t\tfor (i = 0; i < ignore_mode_list_size; i++)\n\t\t{\n\t\t\tif (newlock_ext[i][0] != '\\0' || newlock_ext_off[i])\n\t\t\t{\n\t\t\t\tif (*newext != '\\0')\n\t\t\t\t{\n\t\t\t\t\tmodebuf[0] = ' ';\n\t\t\t\t\tmodebuf[1] = '\\0';\n\t\t\t\t\tmowgli_strlcat(newext, modebuf, sizeof newext);\n\t\t\t\t}\n\t\t\t\tmodebuf[0] = ignore_mode_list[i].mode;\n\t\t\t\tmodebuf[1] = '\\0';\n\t\t\t\tmowgli_strlcat(newext, modebuf, sizeof newext);\n\t\t\t\tmowgli_strlcat(newlock_ext_off[i] ? ext_minus : ext_plus,\n\t\t\t\t\t\tmodebuf, ignore_mode_list_size + 1);\n\t\t\t\tif (!newlock_ext_off[i])\n\t\t\t\t\tmowgli_strlcat(newext, newlock_ext[i], sizeof newext);\n\t\t\t}\n\t\t}\n\t\tif (newext[0] != '\\0')\n\t\t\tmetadata_add(mc, \"private:mlockext\", newext);\n\t\telse\n\t\t\tmetadata_delete(mc, \"private:mlockext\");\n\t}\n\n\tend = modebuf;\n\t*end = 0;\n\n\tif (mc->mlock_on || mc->mlock_key || mc->mlock_limit || *ext_plus)\n\t\tend += snprintf(end, sizeof(modebuf) - (end - modebuf), \"+%s%s%s%s\", flags_to_string(mc->mlock_on), mc->mlock_key ? \"k\" : \"\", mc->mlock_limit ? \"l\" : \"\", ext_plus);\n\n\tif (mc->mlock_off || *ext_minus)\n\t\tend += snprintf(end, sizeof(modebuf) - (end - modebuf), \"-%s%s%s%s\", flags_to_string(mc->mlock_off), mc->mlock_off & CMODE_KEY ? \"k\" : \"\", mc->mlock_off & CMODE_LIMIT ? \"l\" : \"\", ext_minus);\n\n\tif (*modebuf)\n\t{\n\t\tcommand_success_nodata(si, _(\"The MLOCK for \\2%s\\2 has been set to \\2%s\\2.\"), mc->name, modebuf);\n\t\tlogcommand(si, CMDLOG_SET, \"SET:MLOCK: \\2%s\\2 to \\2%s\\2\", mc->name, modebuf);\n\t}\n\telse\n\t{\n\t\tcommand_success_nodata(si, _(\"The MLOCK for \\2%s\\2 has been removed.\"), mc->name);\n\t\tlogcommand(si, CMDLOG_SET, \"SET:MLOCK:NONE: \\2%s\\2\", mc->name);\n\t}\n\tif (changed & ircd->oper_only_modes)\n\t\tlogcommand(si, CMDLOG_SET, _(\"SET:MLOCK: \\2%s\\2 to \\2%s\\2 by \\2%s\\2\"), mc->name, *modebuf != '\\0' ? modebuf : \"+\", get_oper_name(si));\n\n\tcheck_modes(mc, true);\n\tif (mc->chan != NULL)\n\t\tmlock_sts(mc->chan);\n\n\treturn;\n}"
  },
  {
    "function_name": "_moddeinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/set_mlock.c",
    "lines": "32-35",
    "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tcommand_delete(&cs_set_mlock, *cs_set_cmdtree);\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "command_t cs_set_mlock = { \"MLOCK\", N_(\"Sets channel mode lock.\"), AC_NONE, 2, cs_cmd_set_mlock, { .path = \"cservice/set_mlock\" } };",
      "mowgli_patricia_t **cs_set_cmdtree;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "command_delete",
          "args": [
            "&cs_set_mlock",
            "*cs_set_cmdtree"
          ],
          "line": 34
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\ncommand_t cs_set_mlock = { \"MLOCK\", N_(\"Sets channel mode lock.\"), AC_NONE, 2, cs_cmd_set_mlock, { .path = \"cservice/set_mlock\" } };\nmowgli_patricia_t **cs_set_cmdtree;\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tcommand_delete(&cs_set_mlock, *cs_set_cmdtree);\n}"
  },
  {
    "function_name": "_modinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/set_mlock.c",
    "lines": "25-30",
    "snippet": "void _modinit(module_t *m)\n{\n\tMODULE_TRY_REQUEST_SYMBOL(m, cs_set_cmdtree, \"chanserv/set_core\", \"cs_set_cmdtree\");\n\n\tcommand_add(&cs_set_mlock, *cs_set_cmdtree);\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "command_t cs_set_mlock = { \"MLOCK\", N_(\"Sets channel mode lock.\"), AC_NONE, 2, cs_cmd_set_mlock, { .path = \"cservice/set_mlock\" } };",
      "mowgli_patricia_t **cs_set_cmdtree;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "command_add",
          "args": [
            "&cs_set_mlock",
            "*cs_set_cmdtree"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MODULE_TRY_REQUEST_SYMBOL",
          "args": [
            "m",
            "cs_set_cmdtree",
            "\"chanserv/set_core\"",
            "\"cs_set_cmdtree\""
          ],
          "line": 27
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\ncommand_t cs_set_mlock = { \"MLOCK\", N_(\"Sets channel mode lock.\"), AC_NONE, 2, cs_cmd_set_mlock, { .path = \"cservice/set_mlock\" } };\nmowgli_patricia_t **cs_set_cmdtree;\n\nvoid _modinit(module_t *m)\n{\n\tMODULE_TRY_REQUEST_SYMBOL(m, cs_set_cmdtree, \"chanserv/set_core\", \"cs_set_cmdtree\");\n\n\tcommand_add(&cs_set_mlock, *cs_set_cmdtree);\n}"
  }
]