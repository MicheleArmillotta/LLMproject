[
  {
    "function_name": "cs_cmd_flags",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/flags.c",
    "lines": "154-488",
    "snippet": "static void cs_cmd_flags(sourceinfo_t *si, int parc, char *parv[])\n{\n\tchanacs_t *ca;\n\tmowgli_node_t *n;\n\tchar *channel = parv[0];\n\tchar *target = sstrdup(parv[1]);\n\tchar *flagstr = parv[2];\n\tconst char *str1;\n\tunsigned int addflags, removeflags, restrictflags;\n\thook_channel_acl_req_t req;\n\tmychan_t *mc;\n\n\tif (parc < 1)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"FLAGS\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: FLAGS <channel> [target] [flags]\"));\n\t\treturn;\n\t}\n\n\tmc = mychan_find(channel);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), channel);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\") && (target || !has_priv(si, PRIV_CHAN_AUSPEX)))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), channel);\n\t\treturn;\n\t}\n\n\tif (!target || (target && target[0] == '+' && flagstr == NULL))\n\t{\n\t\tunsigned int flags = (target != NULL) ? flags_to_bitmask(target, 0) : 0;\n\n\t\tdo_list(si, mc, flags);\n\t\treturn;\n\t}\n\n\t/*\n\t * following conditions are for compatibility with Anope just to avoid a whole clusterfuck\n\t * of confused users caused by their 'innovation.'  yeah, that's a word for it alright.\n\t *\n\t * anope 1.9's shiny new FLAGS command has:\n\t *\n\t * FLAGS #channel LIST\n\t * FLAGS #channel MODIFY user flagspec\n\t * FLAGS #channel CLEAR\n\t *\n\t * obviously they do not support the atheme syntax, because lets face it, they like to\n\t * 'innovate.'  this is, of course, hilarious for obvious reasons.  never mind that we\n\t * *invented* the FLAGS system for channel ACLs, so you would think they would find it\n\t * worthwhile to be compatible here.  i guess that would have been too obvious or something\n\t * about their whole 'stealing our design' thing that they have been doing in 1.9 since the\n\t * beginning...  or do i mean 'innovating?'\n\t *\n\t * anyway we rewrite the commands as appropriate in the two if blocks below so that they\n\t * are processed by the flags code as the user would intend.  obviously, we're not really\n\t * capable of handling the anope flag model (which makes honestly zero sense to me, and is\n\t * extremely complex which kind of misses the entire point of the flags UI design...) so if\n\t * some user tries passing anope flags, it will probably be hilarious.  the good news is\n\t * most of the anope flags tie up to atheme flags in some weird way anyway (probably because,\n\t * i don't know, they copied the entire design and then fucked it up?  yeah.  probably that.)\n\t *\n\t *   --nenolod\n\t */\n\telse if (!strcasecmp(target, \"LIST\") && myentity_find_ext(target) == NULL)\n\t{\n\t\tdo_list(si, mc, 0);\n\t\tfree(target);\n\n\t\treturn;\n\t}\n\telse if (!strcasecmp(target, \"CLEAR\") && myentity_find_ext(target) == NULL)\n\t{\n\t\tfree(target);\n\n\t\tif (!chanacs_source_has_flag(mc, si, CA_FOUNDER))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, \"You are not authorized to perform this operation.\");\n\t\t\treturn;\n\t\t}\n\n\t\tmowgli_node_t *tn;\n\n\t\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mc->chanacs.head)\n\t\t{\n\t\t\tca = n->data;\n\n\t\t\tif (ca->level & CA_FOUNDER)\n\t\t\t\tcontinue;\n\n\t\t\tobject_unref(ca);\n\t\t}\n\n\t\tlogcommand(si, CMDLOG_DO, \"CLEAR:FLAGS: \\2%s\\2\", mc->name);\n\t\tcommand_success_nodata(si, _(\"Cleared flags in \\2%s\\2.\"), mc->name);\n\t\treturn;\n\t}\n\telse if (!strcasecmp(target, \"MODIFY\") && myentity_find_ext(target) == NULL)\n\t{\n\t\tfree(target);\n\n\t\tif (parc < 3)\n\t\t{\n\t\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"FLAGS\");\n\t\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: FLAGS <#channel> MODIFY [target] <flags>\"));\n\t\t\treturn;\n\t\t}\n\n\t\tflagstr = strchr(parv[2], ' ');\n\t\tif (flagstr)\n\t\t\t*flagstr++ = '\\0';\n\n\t\ttarget = strdup(parv[2]);\n\t}\n\n\t{\n\t\tmyentity_t *mt;\n\n\t\tif (!si->smu)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not logged in.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!flagstr)\n\t\t{\n\t\t\tif (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to execute this command.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (validhostmask(target))\n\t\t\t\tca = chanacs_find_host_literal(mc, target, 0);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!(mt = myentity_find_ext(target)))\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not registered.\"), target);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfree(target);\n\t\t\t\ttarget = sstrdup(mt->name);\n\t\t\t\tca = chanacs_find_literal(mc, mt, 0);\n\t\t\t}\n\t\t\tif (ca != NULL)\n\t\t\t{\n\t\t\t\tstr1 = bitmask_to_flags2(ca->level, 0);\n\t\t\t\tcommand_success_string(si, str1, _(\"Flags for \\2%s\\2 in \\2%s\\2 are \\2%s\\2.\"),\n\t\t\t\t\t\ttarget, channel,\n\t\t\t\t\t\tstr1);\n\t\t\t}\n\t\t\telse\n\t\t\t\tcommand_success_string(si, \"\", _(\"No flags for \\2%s\\2 in \\2%s\\2.\"),\n\t\t\t\t\t\ttarget, channel);\n\t\t\tlogcommand(si, CMDLOG_GET, \"FLAGS: \\2%s\\2 on \\2%s\\2\", mc->name, target);\n\t\t\treturn;\n\t\t}\n\n\t\t/* founder may always set flags -- jilles */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER)\n\t\t\trestrictflags = ca_all;\n\t\telse\n\t\t{\n\t\t\tif (!(restrictflags & CA_FLAGS))\n\t\t\t{\n\t\t\t\t/* allow a user to remove their own access\n\t\t\t\t * even without +f */\n\t\t\t\tif (restrictflags & CA_AKICK ||\n\t\t\t\t\t\tsi->smu == NULL ||\n\t\t\t\t\t\tirccasecmp(target, entity(si->smu)->name) ||\n\t\t\t\t\t\tstrcmp(flagstr, \"-*\"))\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to execute this command.\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (irccasecmp(target, entity(si->smu)->name))\n\t\t\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\t\telse\n\t\t\t\trestrictflags |= allow_flags(mc, restrictflags);\n\t\t}\n\n\t\tif (*flagstr == '+' || *flagstr == '-' || *flagstr == '=')\n\t\t{\n\t\t\tflags_make_bitmasks(flagstr, &addflags, &removeflags);\n\t\t\tif (addflags == 0 && removeflags == 0)\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_badparams, _(\"No valid flags given, use /%s%s HELP FLAGS for a list\"), ircd->uses_rcommand ? \"\" : \"msg \", chansvs.me->disp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\taddflags = get_template_flags(mc, flagstr);\n\t\t\tif (addflags == 0)\n\t\t\t{\n\t\t\t\t/* Hack -- jilles */\n\t\t\t\tif (*target == '+' || *target == '-' || *target == '=')\n\t\t\t\t\tcommand_fail(si, fault_badparams, _(\"Usage: FLAGS %s [target] [flags]\"), mc->name);\n\t\t\t\telse\n\t\t\t\t\tcommand_fail(si, fault_badparams, _(\"Invalid template name given, use /%s%s TEMPLATE %s for a list\"), ircd->uses_rcommand ? \"\" : \"msg \", chansvs.me->disp, mc->name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tremoveflags = ca_all & ~addflags;\n\t\t}\n\n\t\tif (!validhostmask(target))\n\t\t{\n\t\t\tif (!(mt = myentity_find_ext(target)))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not registered.\"), target);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfree(target);\n\t\t\ttarget = sstrdup(mt->name);\n\n\t\t\tca = chanacs_open(mc, mt, NULL, true, entity(si->smu));\n\n\t\t\tif (ca->level & CA_FOUNDER && removeflags & CA_FLAGS && !(removeflags & CA_FOUNDER))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You may not remove a founder's +f access.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (ca->level & CA_FOUNDER && removeflags & CA_FOUNDER && mychan_num_founders(mc) == 1)\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You may not remove the last founder.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!(ca->level & CA_FOUNDER) && addflags & CA_FOUNDER)\n\t\t\t{\n\t\t\t\tif (mychan_num_founders(mc) >= chansvs.maxfounders)\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_noprivs, _(\"Only %d founders allowed per channel.\"), chansvs.maxfounders);\n\t\t\t\t\tchanacs_close(ca);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!myentity_can_register_channel(mt))\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_toomany, _(\"\\2%s\\2 has too many channels registered.\"), mt->name);\n\t\t\t\t\tchanacs_close(ca);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!myentity_allow_foundership(mt))\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_toomany, _(\"\\2%s\\2 cannot take foundership of a channel.\"), mt->name);\n\t\t\t\t\tchanacs_close(ca);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (addflags & CA_FOUNDER)\n\t\t\t\taddflags |= CA_FLAGS, removeflags &= ~CA_FLAGS;\n\n\t\t\t/* If NEVEROP is set, don't allow adding new entries\n\t\t\t * except sole +b. Adding flags if the current level\n\t\t\t * is +b counts as adding an entry.\n\t\t\t * -- jilles */\n\t\t\t/* XXX: not all entities are users */\n\t\t\tif (isuser(mt) && (MU_NEVEROP & user(mt)->flags && addflags != CA_AKICK && addflags != 0 && (ca->level == 0 || ca->level == CA_AKICK)))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 does not wish to be added to channel access lists (NEVEROP set).\"), mt->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (ca->level == 0 && chanacs_is_table_full(ca))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treq.ca = ca;\n\t\t\treq.oldlevel = ca->level;\n\n\t\t\tif (!chanacs_modify(ca, &addflags, &removeflags, restrictflags))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not allowed to set \\2%s\\2 on \\2%s\\2 in \\2%s\\2.\"), bitmask_to_flags2(addflags, removeflags), mt->name, mc->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treq.newlevel = ca->level;\n\n\t\t\thook_call_channel_acl_change(&req);\n\t\t\tchanacs_close(ca);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (addflags & CA_FOUNDER)\n\t\t\t{\n\t\t                command_fail(si, fault_badparams, _(\"You may not set founder status on a hostmask.\"));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tca = chanacs_open(mc, NULL, target, true, entity(si->smu));\n\t\t\tif (ca->level == 0 && chanacs_is_table_full(ca))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treq.ca = ca;\n\t\t\treq.oldlevel = ca->level;\n\n\t\t\tif (!chanacs_modify(ca, &addflags, &removeflags, restrictflags))\n\t\t\t{\n\t\t                command_fail(si, fault_noprivs, _(\"You are not allowed to set \\2%s\\2 on \\2%s\\2 in \\2%s\\2.\"), bitmask_to_flags2(addflags, removeflags), target, mc->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treq.newlevel = ca->level;\n\n\t\t\thook_call_channel_acl_change(&req);\n\t\t\tchanacs_close(ca);\n\t\t}\n\n\t\tif ((addflags | removeflags) == 0)\n\t\t{\n\t\t\tcommand_fail(si, fault_nochange, _(\"Channel access to \\2%s\\2 for \\2%s\\2 unchanged.\"), channel, target);\n\t\t\treturn;\n\t\t}\n\t\tflagstr = bitmask_to_flags2(addflags, removeflags);\n\t\tcommand_success_nodata(si, _(\"Flags \\2%s\\2 were set on \\2%s\\2 in \\2%s\\2.\"), flagstr, target, channel);\n\t\tlogcommand(si, CMDLOG_SET, \"FLAGS: \\2%s\\2 \\2%s\\2 \\2%s\\2\", mc->name, target, flagstr);\n\t\tverbose(mc, \"\\2%s\\2 set flags \\2%s\\2 on \\2%s\\2\", get_source_name(si), flagstr, target);\n\t}\n\n\tfree(target);\n}",
    "includes": [
      "#include \"template.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_cmd_flags(sourceinfo_t *si, int parc, char *parv[]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "free",
          "args": [
            "target"
          ],
          "line": 487
        },
        "resolved": true,
        "details": {
          "function_name": "free_template_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/access.c",
          "lines": "358-371",
          "snippet": "static void free_template_list(mowgli_list_t *l)\n{\n\tmowgli_node_t *n, *tn;\n\n\treturn_if_fail(l != NULL);\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, l->head)\n\t{\n\t\ttemplate_t *t = n->data;\n\n\t\tmowgli_node_delete(&t->node, l);\n\t\tfree(t);\n\t}\n}",
          "includes": [
            "#include \"template.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void free_template_list(mowgli_list_t *l)\n{\n\tmowgli_node_t *n, *tn;\n\n\treturn_if_fail(l != NULL);\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, l->head)\n\t{\n\t\ttemplate_t *t = n->data;\n\n\t\tmowgli_node_delete(&t->node, l);\n\t\tfree(t);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "mc",
            "\"\\2%s\\2 set flags \\2%s\\2 on \\2%s\\2\"",
            "get_source_name(si)",
            "flagstr",
            "target"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_source_name",
          "args": [
            "si"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_SET",
            "\"FLAGS: \\2%s\\2 \\2%s\\2 \\2%s\\2\"",
            "mc->name",
            "target",
            "flagstr"
          ],
          "line": 483
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"Flags \\2%s\\2 were set on \\2%s\\2 in \\2%s\\2.\")",
            "flagstr",
            "target",
            "channel"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Flags \\2%s\\2 were set on \\2%s\\2 in \\2%s\\2.\""
          ],
          "line": 482
        },
        "resolved": true,
        "details": {
          "function_name": "_moddeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/flags.c",
          "lines": "29-32",
          "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_flags);\n}",
          "includes": [
            "#include \"template.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "command_t cs_flags = { \"FLAGS\", N_(\"Manipulates specific permissions on a channel.\"),\n                        AC_NONE, 3, cs_cmd_flags, { .path = \"cservice/flags\" } };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"template.h\"\n#include \"atheme.h\"\n\ncommand_t cs_flags = { \"FLAGS\", N_(\"Manipulates specific permissions on a channel.\"),\n                        AC_NONE, 3, cs_cmd_flags, { .path = \"cservice/flags\" } };\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "bitmask_to_flags2",
          "args": [
            "addflags",
            "removeflags"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nochange",
            "_(\"Channel access to \\2%s\\2 for \\2%s\\2 unchanged.\")",
            "channel",
            "target"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_call_channel_acl_change",
          "args": [
            "&req"
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca"
          ],
          "line": 466
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not allowed to set \\2%s\\2 on \\2%s\\2 in \\2%s\\2.\")",
            "bitmask_to_flags2(addflags, removeflags)",
            "target",
            "mc->name"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmask_to_flags2",
          "args": [
            "addflags",
            "removeflags"
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_modify",
          "args": [
            "ca",
            "&addflags",
            "&removeflags",
            "restrictflags"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_toomany",
            "_(\"Channel %s access list is full.\")",
            "mc->name"
          ],
          "line": 455
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_is_table_full",
          "args": [
            "ca"
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_open",
          "args": [
            "mc",
            "NULL",
            "target",
            "true",
            "entity(si->smu)"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entity",
          "args": [
            "si->smu"
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_badparams",
            "_(\"You may not set founder status on a hostmask.\")"
          ],
          "line": 448
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca"
          ],
          "line": 442
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_call_channel_acl_change",
          "args": [
            "&req"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not allowed to set \\2%s\\2 on \\2%s\\2 in \\2%s\\2.\")",
            "bitmask_to_flags2(addflags, removeflags)",
            "mt->name",
            "mc->name"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmask_to_flags2",
          "args": [
            "addflags",
            "removeflags"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_modify",
          "args": [
            "ca",
            "&addflags",
            "&removeflags",
            "restrictflags"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_toomany",
            "_(\"Channel %s access list is full.\")",
            "mc->name"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_is_table_full",
          "args": [
            "ca"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca"
          ],
          "line": 418
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"\\2%s\\2 does not wish to be added to channel access lists (NEVEROP set).\")",
            "mt->name"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user",
          "args": [
            "mt"
          ],
          "line": 415
        },
        "resolved": true,
        "details": {
          "function_name": "sync_myuser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/sync.c",
          "lines": "266-276",
          "snippet": "static void sync_myuser(myuser_t *mu)\n{\n\tmowgli_node_t *iter;\n\n\treturn_if_fail(mu != NULL);\n\n\tMOWGLI_ITER_FOREACH(iter, mu->logins.head)\n\t{\n\t\tsync_user(iter->data);\n\t}\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic void sync_myuser(myuser_t *mu)\n{\n\tmowgli_node_t *iter;\n\n\treturn_if_fail(mu != NULL);\n\n\tMOWGLI_ITER_FOREACH(iter, mu->logins.head)\n\t{\n\t\tsync_user(iter->data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isuser",
          "args": [
            "mt"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_toomany",
            "_(\"\\2%s\\2 cannot take foundership of a channel.\")",
            "mt->name"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "myentity_allow_foundership",
          "args": [
            "mt"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_toomany",
            "_(\"\\2%s\\2 has too many channels registered.\")",
            "mt->name"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "myentity_can_register_channel",
          "args": [
            "mt"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca"
          ],
          "line": 391
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"Only %d founders allowed per channel.\")",
            "chansvs.maxfounders"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_num_founders",
          "args": [
            "mc"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You may not remove the last founder.\")"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_num_founders",
          "args": [
            "mc"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You may not remove a founder's +f access.\")"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_open",
          "args": [
            "mc",
            "mt",
            "NULL",
            "true",
            "entity(si->smu)"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entity",
          "args": [
            "si->smu"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sstrdup",
          "args": [
            "mt->name"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_target",
            "_(\"\\2%s\\2 is not registered.\")",
            "target"
          ],
          "line": 368
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "myentity_find_ext",
          "args": [
            "target"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validhostmask",
          "args": [
            "target"
          ],
          "line": 364
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_badparams",
            "_(\"Invalid template name given, use /%s%s TEMPLATE %s for a list\")",
            "ircd->uses_rcommand ? \"\" : \"msg \"",
            "chansvs.me->disp",
            "mc->name"
          ],
          "line": 358
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_badparams",
            "_(\"Usage: FLAGS %s [target] [flags]\")",
            "mc->name"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_template_flags",
          "args": [
            "mc",
            "flagstr"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_badparams",
            "_(\"No valid flags given, use /%s%s HELP FLAGS for a list\")",
            "ircd->uses_rcommand ? \"\" : \"msg \"",
            "chansvs.me->disp"
          ],
          "line": 345
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flags_make_bitmasks",
          "args": [
            "flagstr",
            "&addflags",
            "&removeflags"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_flags",
          "args": [
            "mc",
            "restrictflags"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_flags",
          "args": [
            "mc",
            "restrictflags"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irccasecmp",
          "args": [
            "target",
            "entity(si->smu)->name"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entity",
          "args": [
            "si->smu"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not authorized to execute this command.\")"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "flagstr",
            "\"-*\""
          ],
          "line": 328
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "irccasecmp",
          "args": [
            "target",
            "entity(si->smu)->name"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entity",
          "args": [
            "si->smu"
          ],
          "line": 327
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_source_flags",
          "args": [
            "mc",
            "si"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_GET",
            "\"FLAGS: \\2%s\\2 on \\2%s\\2\"",
            "mc->name",
            "target"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_string",
          "args": [
            "si",
            "\"\"",
            "_(\"No flags for \\2%s\\2 in \\2%s\\2.\")",
            "target",
            "channel"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_string",
          "args": [
            "si",
            "str1",
            "_(\"Flags for \\2%s\\2 in \\2%s\\2 are \\2%s\\2.\")",
            "target",
            "channel",
            "str1"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmask_to_flags2",
          "args": [
            "ca->level",
            "0"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_find_literal",
          "args": [
            "mc",
            "mt",
            "0"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sstrdup",
          "args": [
            "mt->name"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_target",
            "_(\"\\2%s\\2 is not registered.\")",
            "target"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "myentity_find_ext",
          "args": [
            "target"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_find_host_literal",
          "args": [
            "mc",
            "target",
            "0"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validhostmask",
          "args": [
            "target"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not authorized to execute this command.\")"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_source_has_flag",
          "args": [
            "mc",
            "si",
            "CA_ACLVIEW"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not logged in.\")"
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "parv[2]"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "parv[2]",
            "' '"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "_(\"Syntax: FLAGS <#channel> MODIFY [target] <flags>\")"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "STR_INSUFFICIENT_PARAMS",
            "\"FLAGS\""
          ],
          "line": 260
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "myentity_find_ext",
          "args": [
            "target"
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "target",
            "\"MODIFY\""
          ],
          "line": 254
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"Cleared flags in \\2%s\\2.\")",
            "mc->name"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_DO",
            "\"CLEAR:FLAGS: \\2%s\\2\"",
            "mc->name"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_unref",
          "args": [
            "ca"
          ],
          "line": 247
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_ITER_FOREACH_SAFE",
          "args": [
            "n",
            "tn",
            "mc->chanacs.head"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "\"You are not authorized to perform this operation.\""
          ],
          "line": 234
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_source_has_flag",
          "args": [
            "mc",
            "si",
            "CA_FOUNDER"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "myentity_find_ext",
          "args": [
            "target"
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "target",
            "\"CLEAR\""
          ],
          "line": 228
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "do_list",
          "args": [
            "si",
            "mc",
            "0"
          ],
          "line": 223
        },
        "resolved": true,
        "details": {
          "function_name": "do_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/flags.c",
          "lines": "97-151",
          "snippet": "static void do_list(sourceinfo_t *si, mychan_t *mc, unsigned int flags)\n{\n\tchanacs_t *ca;\n\tmowgli_node_t *n;\n\tbool operoverride = false;\n\tunsigned int i = 1;\n\n\tif (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t{\n\t\tif (has_priv(si, PRIV_CHAN_AUSPEX))\n\t\t\toperoverride = true;\n\t\telse\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcommand_success_nodata(si, _(\"Entry Nickname/Host          Flags\"));\n\tcommand_success_nodata(si, \"----- ---------------------- -----\");\n\n\tMOWGLI_ITER_FOREACH(n, mc->chanacs.head)\n\t{\n\t\tconst char *template, *mod_ago;\n\t\tstruct tm tm;\n\t\tchar mod_date[64];\n\n\t\tca = n->data;\n\n\t\tif (flags && !(ca->level & flags))\n\t\t\tcontinue;\n\n\t\ttemplate = get_template_name(mc, ca->level);\n\t\tmod_ago = ca->tmodified ? time_ago(ca->tmodified) : \"?\";\n\n\t\ttm = *localtime(&ca->tmodified);\n\t\tstrftime(mod_date, sizeof mod_date, TIME_FORMAT, &tm);\n\n\t\tif (template != NULL)\n\t\t\tcommand_success_nodata(si, _(\"%-5d %-22s %-20s (%s) (%s) [modified %s ago, on %s]\"),\n\t\t\t\ti, ca->entity ? ca->entity->name : ca->host, bitmask_to_flags(ca->level), template, mc->name, mod_ago, mod_date);\n\t\telse\n\t\t\tcommand_success_nodata(si, _(\"%-5d %-22s %-20s (%s) [modified %s ago, on %s]\"),\n\t\t\t\ti, ca->entity ? ca->entity->name : ca->host, bitmask_to_flags(ca->level), mc->name, mod_ago, mod_date);\n\t\ti++;\n\t}\n\n\tcommand_success_nodata(si, \"----- ---------------------- -----\");\n\tcommand_success_nodata(si, _(\"End of \\2%s\\2 FLAGS listing.\"), mc->name);\n\n\tif (operoverride)\n\t\tlogcommand(si, CMDLOG_ADMIN, \"FLAGS: \\2%s\\2 (oper override)\", mc->name);\n\telse\n\t\tlogcommand(si, CMDLOG_GET, \"FLAGS: \\2%s\\2\", mc->name);\n}",
          "includes": [
            "#include \"template.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void do_list(sourceinfo_t *si, mychan_t *mc, unsigned int flags)\n{\n\tchanacs_t *ca;\n\tmowgli_node_t *n;\n\tbool operoverride = false;\n\tunsigned int i = 1;\n\n\tif (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t{\n\t\tif (has_priv(si, PRIV_CHAN_AUSPEX))\n\t\t\toperoverride = true;\n\t\telse\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcommand_success_nodata(si, _(\"Entry Nickname/Host          Flags\"));\n\tcommand_success_nodata(si, \"----- ---------------------- -----\");\n\n\tMOWGLI_ITER_FOREACH(n, mc->chanacs.head)\n\t{\n\t\tconst char *template, *mod_ago;\n\t\tstruct tm tm;\n\t\tchar mod_date[64];\n\n\t\tca = n->data;\n\n\t\tif (flags && !(ca->level & flags))\n\t\t\tcontinue;\n\n\t\ttemplate = get_template_name(mc, ca->level);\n\t\tmod_ago = ca->tmodified ? time_ago(ca->tmodified) : \"?\";\n\n\t\ttm = *localtime(&ca->tmodified);\n\t\tstrftime(mod_date, sizeof mod_date, TIME_FORMAT, &tm);\n\n\t\tif (template != NULL)\n\t\t\tcommand_success_nodata(si, _(\"%-5d %-22s %-20s (%s) (%s) [modified %s ago, on %s]\"),\n\t\t\t\ti, ca->entity ? ca->entity->name : ca->host, bitmask_to_flags(ca->level), template, mc->name, mod_ago, mod_date);\n\t\telse\n\t\t\tcommand_success_nodata(si, _(\"%-5d %-22s %-20s (%s) [modified %s ago, on %s]\"),\n\t\t\t\ti, ca->entity ? ca->entity->name : ca->host, bitmask_to_flags(ca->level), mc->name, mod_ago, mod_date);\n\t\ti++;\n\t}\n\n\tcommand_success_nodata(si, \"----- ---------------------- -----\");\n\tcommand_success_nodata(si, _(\"End of \\2%s\\2 FLAGS listing.\"), mc->name);\n\n\tif (operoverride)\n\t\tlogcommand(si, CMDLOG_ADMIN, \"FLAGS: \\2%s\\2 (oper override)\", mc->name);\n\telse\n\t\tlogcommand(si, CMDLOG_GET, \"FLAGS: \\2%s\\2\", mc->name);\n}"
        }
      },
      {
        "call_info": {
          "callee": "myentity_find_ext",
          "args": [
            "target"
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "target",
            "\"LIST\""
          ],
          "line": 221
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flags_to_bitmask",
          "args": [
            "target",
            "0"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"\\2%s\\2 is closed.\")",
            "channel"
          ],
          "line": 182
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_priv",
          "args": [
            "si",
            "PRIV_CHAN_AUSPEX"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:close:closer\""
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_target",
            "_(\"Channel \\2%s\\2 is not registered.\")",
            "channel"
          ],
          "line": 176
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_find",
          "args": [
            "channel"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "_(\"Syntax: FLAGS <channel> [target] [flags]\")"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "STR_INSUFFICIENT_PARAMS",
            "\"FLAGS\""
          ],
          "line": 168
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sstrdup",
          "args": [
            "parv[1]"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void cs_cmd_flags(sourceinfo_t *si, int parc, char *parv[]);\n\nstatic void cs_cmd_flags(sourceinfo_t *si, int parc, char *parv[])\n{\n\tchanacs_t *ca;\n\tmowgli_node_t *n;\n\tchar *channel = parv[0];\n\tchar *target = sstrdup(parv[1]);\n\tchar *flagstr = parv[2];\n\tconst char *str1;\n\tunsigned int addflags, removeflags, restrictflags;\n\thook_channel_acl_req_t req;\n\tmychan_t *mc;\n\n\tif (parc < 1)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"FLAGS\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: FLAGS <channel> [target] [flags]\"));\n\t\treturn;\n\t}\n\n\tmc = mychan_find(channel);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), channel);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\") && (target || !has_priv(si, PRIV_CHAN_AUSPEX)))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), channel);\n\t\treturn;\n\t}\n\n\tif (!target || (target && target[0] == '+' && flagstr == NULL))\n\t{\n\t\tunsigned int flags = (target != NULL) ? flags_to_bitmask(target, 0) : 0;\n\n\t\tdo_list(si, mc, flags);\n\t\treturn;\n\t}\n\n\t/*\n\t * following conditions are for compatibility with Anope just to avoid a whole clusterfuck\n\t * of confused users caused by their 'innovation.'  yeah, that's a word for it alright.\n\t *\n\t * anope 1.9's shiny new FLAGS command has:\n\t *\n\t * FLAGS #channel LIST\n\t * FLAGS #channel MODIFY user flagspec\n\t * FLAGS #channel CLEAR\n\t *\n\t * obviously they do not support the atheme syntax, because lets face it, they like to\n\t * 'innovate.'  this is, of course, hilarious for obvious reasons.  never mind that we\n\t * *invented* the FLAGS system for channel ACLs, so you would think they would find it\n\t * worthwhile to be compatible here.  i guess that would have been too obvious or something\n\t * about their whole 'stealing our design' thing that they have been doing in 1.9 since the\n\t * beginning...  or do i mean 'innovating?'\n\t *\n\t * anyway we rewrite the commands as appropriate in the two if blocks below so that they\n\t * are processed by the flags code as the user would intend.  obviously, we're not really\n\t * capable of handling the anope flag model (which makes honestly zero sense to me, and is\n\t * extremely complex which kind of misses the entire point of the flags UI design...) so if\n\t * some user tries passing anope flags, it will probably be hilarious.  the good news is\n\t * most of the anope flags tie up to atheme flags in some weird way anyway (probably because,\n\t * i don't know, they copied the entire design and then fucked it up?  yeah.  probably that.)\n\t *\n\t *   --nenolod\n\t */\n\telse if (!strcasecmp(target, \"LIST\") && myentity_find_ext(target) == NULL)\n\t{\n\t\tdo_list(si, mc, 0);\n\t\tfree(target);\n\n\t\treturn;\n\t}\n\telse if (!strcasecmp(target, \"CLEAR\") && myentity_find_ext(target) == NULL)\n\t{\n\t\tfree(target);\n\n\t\tif (!chanacs_source_has_flag(mc, si, CA_FOUNDER))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, \"You are not authorized to perform this operation.\");\n\t\t\treturn;\n\t\t}\n\n\t\tmowgli_node_t *tn;\n\n\t\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mc->chanacs.head)\n\t\t{\n\t\t\tca = n->data;\n\n\t\t\tif (ca->level & CA_FOUNDER)\n\t\t\t\tcontinue;\n\n\t\t\tobject_unref(ca);\n\t\t}\n\n\t\tlogcommand(si, CMDLOG_DO, \"CLEAR:FLAGS: \\2%s\\2\", mc->name);\n\t\tcommand_success_nodata(si, _(\"Cleared flags in \\2%s\\2.\"), mc->name);\n\t\treturn;\n\t}\n\telse if (!strcasecmp(target, \"MODIFY\") && myentity_find_ext(target) == NULL)\n\t{\n\t\tfree(target);\n\n\t\tif (parc < 3)\n\t\t{\n\t\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"FLAGS\");\n\t\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: FLAGS <#channel> MODIFY [target] <flags>\"));\n\t\t\treturn;\n\t\t}\n\n\t\tflagstr = strchr(parv[2], ' ');\n\t\tif (flagstr)\n\t\t\t*flagstr++ = '\\0';\n\n\t\ttarget = strdup(parv[2]);\n\t}\n\n\t{\n\t\tmyentity_t *mt;\n\n\t\tif (!si->smu)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not logged in.\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (!flagstr)\n\t\t{\n\t\t\tif (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to execute this command.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (validhostmask(target))\n\t\t\t\tca = chanacs_find_host_literal(mc, target, 0);\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (!(mt = myentity_find_ext(target)))\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not registered.\"), target);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tfree(target);\n\t\t\t\ttarget = sstrdup(mt->name);\n\t\t\t\tca = chanacs_find_literal(mc, mt, 0);\n\t\t\t}\n\t\t\tif (ca != NULL)\n\t\t\t{\n\t\t\t\tstr1 = bitmask_to_flags2(ca->level, 0);\n\t\t\t\tcommand_success_string(si, str1, _(\"Flags for \\2%s\\2 in \\2%s\\2 are \\2%s\\2.\"),\n\t\t\t\t\t\ttarget, channel,\n\t\t\t\t\t\tstr1);\n\t\t\t}\n\t\t\telse\n\t\t\t\tcommand_success_string(si, \"\", _(\"No flags for \\2%s\\2 in \\2%s\\2.\"),\n\t\t\t\t\t\ttarget, channel);\n\t\t\tlogcommand(si, CMDLOG_GET, \"FLAGS: \\2%s\\2 on \\2%s\\2\", mc->name, target);\n\t\t\treturn;\n\t\t}\n\n\t\t/* founder may always set flags -- jilles */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER)\n\t\t\trestrictflags = ca_all;\n\t\telse\n\t\t{\n\t\t\tif (!(restrictflags & CA_FLAGS))\n\t\t\t{\n\t\t\t\t/* allow a user to remove their own access\n\t\t\t\t * even without +f */\n\t\t\t\tif (restrictflags & CA_AKICK ||\n\t\t\t\t\t\tsi->smu == NULL ||\n\t\t\t\t\t\tirccasecmp(target, entity(si->smu)->name) ||\n\t\t\t\t\t\tstrcmp(flagstr, \"-*\"))\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to execute this command.\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (irccasecmp(target, entity(si->smu)->name))\n\t\t\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\t\telse\n\t\t\t\trestrictflags |= allow_flags(mc, restrictflags);\n\t\t}\n\n\t\tif (*flagstr == '+' || *flagstr == '-' || *flagstr == '=')\n\t\t{\n\t\t\tflags_make_bitmasks(flagstr, &addflags, &removeflags);\n\t\t\tif (addflags == 0 && removeflags == 0)\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_badparams, _(\"No valid flags given, use /%s%s HELP FLAGS for a list\"), ircd->uses_rcommand ? \"\" : \"msg \", chansvs.me->disp);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\taddflags = get_template_flags(mc, flagstr);\n\t\t\tif (addflags == 0)\n\t\t\t{\n\t\t\t\t/* Hack -- jilles */\n\t\t\t\tif (*target == '+' || *target == '-' || *target == '=')\n\t\t\t\t\tcommand_fail(si, fault_badparams, _(\"Usage: FLAGS %s [target] [flags]\"), mc->name);\n\t\t\t\telse\n\t\t\t\t\tcommand_fail(si, fault_badparams, _(\"Invalid template name given, use /%s%s TEMPLATE %s for a list\"), ircd->uses_rcommand ? \"\" : \"msg \", chansvs.me->disp, mc->name);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tremoveflags = ca_all & ~addflags;\n\t\t}\n\n\t\tif (!validhostmask(target))\n\t\t{\n\t\t\tif (!(mt = myentity_find_ext(target)))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not registered.\"), target);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfree(target);\n\t\t\ttarget = sstrdup(mt->name);\n\n\t\t\tca = chanacs_open(mc, mt, NULL, true, entity(si->smu));\n\n\t\t\tif (ca->level & CA_FOUNDER && removeflags & CA_FLAGS && !(removeflags & CA_FOUNDER))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You may not remove a founder's +f access.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (ca->level & CA_FOUNDER && removeflags & CA_FOUNDER && mychan_num_founders(mc) == 1)\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You may not remove the last founder.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (!(ca->level & CA_FOUNDER) && addflags & CA_FOUNDER)\n\t\t\t{\n\t\t\t\tif (mychan_num_founders(mc) >= chansvs.maxfounders)\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_noprivs, _(\"Only %d founders allowed per channel.\"), chansvs.maxfounders);\n\t\t\t\t\tchanacs_close(ca);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!myentity_can_register_channel(mt))\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_toomany, _(\"\\2%s\\2 has too many channels registered.\"), mt->name);\n\t\t\t\t\tchanacs_close(ca);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (!myentity_allow_foundership(mt))\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_toomany, _(\"\\2%s\\2 cannot take foundership of a channel.\"), mt->name);\n\t\t\t\t\tchanacs_close(ca);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (addflags & CA_FOUNDER)\n\t\t\t\taddflags |= CA_FLAGS, removeflags &= ~CA_FLAGS;\n\n\t\t\t/* If NEVEROP is set, don't allow adding new entries\n\t\t\t * except sole +b. Adding flags if the current level\n\t\t\t * is +b counts as adding an entry.\n\t\t\t * -- jilles */\n\t\t\t/* XXX: not all entities are users */\n\t\t\tif (isuser(mt) && (MU_NEVEROP & user(mt)->flags && addflags != CA_AKICK && addflags != 0 && (ca->level == 0 || ca->level == CA_AKICK)))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 does not wish to be added to channel access lists (NEVEROP set).\"), mt->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (ca->level == 0 && chanacs_is_table_full(ca))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treq.ca = ca;\n\t\t\treq.oldlevel = ca->level;\n\n\t\t\tif (!chanacs_modify(ca, &addflags, &removeflags, restrictflags))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not allowed to set \\2%s\\2 on \\2%s\\2 in \\2%s\\2.\"), bitmask_to_flags2(addflags, removeflags), mt->name, mc->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treq.newlevel = ca->level;\n\n\t\t\thook_call_channel_acl_change(&req);\n\t\t\tchanacs_close(ca);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif (addflags & CA_FOUNDER)\n\t\t\t{\n\t\t                command_fail(si, fault_badparams, _(\"You may not set founder status on a hostmask.\"));\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tca = chanacs_open(mc, NULL, target, true, entity(si->smu));\n\t\t\tif (ca->level == 0 && chanacs_is_table_full(ca))\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treq.ca = ca;\n\t\t\treq.oldlevel = ca->level;\n\n\t\t\tif (!chanacs_modify(ca, &addflags, &removeflags, restrictflags))\n\t\t\t{\n\t\t                command_fail(si, fault_noprivs, _(\"You are not allowed to set \\2%s\\2 on \\2%s\\2 in \\2%s\\2.\"), bitmask_to_flags2(addflags, removeflags), target, mc->name);\n\t\t\t\tchanacs_close(ca);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\treq.newlevel = ca->level;\n\n\t\t\thook_call_channel_acl_change(&req);\n\t\t\tchanacs_close(ca);\n\t\t}\n\n\t\tif ((addflags | removeflags) == 0)\n\t\t{\n\t\t\tcommand_fail(si, fault_nochange, _(\"Channel access to \\2%s\\2 for \\2%s\\2 unchanged.\"), channel, target);\n\t\t\treturn;\n\t\t}\n\t\tflagstr = bitmask_to_flags2(addflags, removeflags);\n\t\tcommand_success_nodata(si, _(\"Flags \\2%s\\2 were set on \\2%s\\2 in \\2%s\\2.\"), flagstr, target, channel);\n\t\tlogcommand(si, CMDLOG_SET, \"FLAGS: \\2%s\\2 \\2%s\\2 \\2%s\\2\", mc->name, target, flagstr);\n\t\tverbose(mc, \"\\2%s\\2 set flags \\2%s\\2 on \\2%s\\2\", get_source_name(si), flagstr, target);\n\t}\n\n\tfree(target);\n}"
  },
  {
    "function_name": "do_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/flags.c",
    "lines": "97-151",
    "snippet": "static void do_list(sourceinfo_t *si, mychan_t *mc, unsigned int flags)\n{\n\tchanacs_t *ca;\n\tmowgli_node_t *n;\n\tbool operoverride = false;\n\tunsigned int i = 1;\n\n\tif (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t{\n\t\tif (has_priv(si, PRIV_CHAN_AUSPEX))\n\t\t\toperoverride = true;\n\t\telse\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcommand_success_nodata(si, _(\"Entry Nickname/Host          Flags\"));\n\tcommand_success_nodata(si, \"----- ---------------------- -----\");\n\n\tMOWGLI_ITER_FOREACH(n, mc->chanacs.head)\n\t{\n\t\tconst char *template, *mod_ago;\n\t\tstruct tm tm;\n\t\tchar mod_date[64];\n\n\t\tca = n->data;\n\n\t\tif (flags && !(ca->level & flags))\n\t\t\tcontinue;\n\n\t\ttemplate = get_template_name(mc, ca->level);\n\t\tmod_ago = ca->tmodified ? time_ago(ca->tmodified) : \"?\";\n\n\t\ttm = *localtime(&ca->tmodified);\n\t\tstrftime(mod_date, sizeof mod_date, TIME_FORMAT, &tm);\n\n\t\tif (template != NULL)\n\t\t\tcommand_success_nodata(si, _(\"%-5d %-22s %-20s (%s) (%s) [modified %s ago, on %s]\"),\n\t\t\t\ti, ca->entity ? ca->entity->name : ca->host, bitmask_to_flags(ca->level), template, mc->name, mod_ago, mod_date);\n\t\telse\n\t\t\tcommand_success_nodata(si, _(\"%-5d %-22s %-20s (%s) [modified %s ago, on %s]\"),\n\t\t\t\ti, ca->entity ? ca->entity->name : ca->host, bitmask_to_flags(ca->level), mc->name, mod_ago, mod_date);\n\t\ti++;\n\t}\n\n\tcommand_success_nodata(si, \"----- ---------------------- -----\");\n\tcommand_success_nodata(si, _(\"End of \\2%s\\2 FLAGS listing.\"), mc->name);\n\n\tif (operoverride)\n\t\tlogcommand(si, CMDLOG_ADMIN, \"FLAGS: \\2%s\\2 (oper override)\", mc->name);\n\telse\n\t\tlogcommand(si, CMDLOG_GET, \"FLAGS: \\2%s\\2\", mc->name);\n}",
    "includes": [
      "#include \"template.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_GET",
            "\"FLAGS: \\2%s\\2\"",
            "mc->name"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_ADMIN",
            "\"FLAGS: \\2%s\\2 (oper override)\"",
            "mc->name"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"End of \\2%s\\2 FLAGS listing.\")",
            "mc->name"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"End of \\2%s\\2 FLAGS listing.\""
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "_moddeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/flags.c",
          "lines": "29-32",
          "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_flags);\n}",
          "includes": [
            "#include \"template.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "command_t cs_flags = { \"FLAGS\", N_(\"Manipulates specific permissions on a channel.\"),\n                        AC_NONE, 3, cs_cmd_flags, { .path = \"cservice/flags\" } };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"template.h\"\n#include \"atheme.h\"\n\ncommand_t cs_flags = { \"FLAGS\", N_(\"Manipulates specific permissions on a channel.\"),\n                        AC_NONE, 3, cs_cmd_flags, { .path = \"cservice/flags\" } };\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_flags);\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "\"----- ---------------------- -----\""
          ],
          "line": 144
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"%-5d %-22s %-20s (%s) [modified %s ago, on %s]\")",
            "i",
            "ca->entity ? ca->entity->name : ca->host",
            "bitmask_to_flags(ca->level)",
            "mc->name",
            "mod_ago",
            "mod_date"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmask_to_flags",
          "args": [
            "ca->level"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"%-5d %-22s %-20s (%s) (%s) [modified %s ago, on %s]\")",
            "i",
            "ca->entity ? ca->entity->name : ca->host",
            "bitmask_to_flags(ca->level)",
            "template",
            "mc->name",
            "mod_ago",
            "mod_date"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmask_to_flags",
          "args": [
            "ca->level"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strftime",
          "args": [
            "mod_date",
            "sizeof mod_date",
            "TIME_FORMAT",
            "&tm"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "localtime",
          "args": [
            "&ca->tmodified"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_ago",
          "args": [
            "ca->tmodified"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_template_name",
          "args": [
            "mc",
            "ca->level"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "get_template_name",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/flags.c",
          "lines": "50-95",
          "snippet": "static const char *get_template_name(mychan_t *mc, unsigned int level)\n{\n\tmetadata_t *md;\n\tconst char *p, *q, *r;\n\tchar *s;\n\tchar ss[40];\n\tstatic char flagname[400];\n\ttemplate_iter_t iter;\n\n\tmd = metadata_find(mc, \"private:templates\");\n\tif (md != NULL)\n\t{\n\t\tp = md->value;\n\t\twhile (p != NULL)\n\t\t{\n\t\t\twhile (*p == ' ')\n\t\t\t\tp++;\n\t\t\tq = strchr(p, '=');\n\t\t\tif (q == NULL)\n\t\t\t\tbreak;\n\t\t\tr = strchr(q, ' ');\n\t\t\tif (r != NULL && r < q)\n\t\t\t\tbreak;\n\t\t\tmowgli_strlcpy(ss, q, sizeof ss);\n\t\t\tif (r != NULL && r - q < (int)(sizeof ss - 1))\n\t\t\t{\n\t\t\t\tss[r - q] = '\\0';\n\t\t\t}\n\t\t\tif (level == flags_to_bitmask(ss, 0))\n\t\t\t{\n\t\t\t\tmowgli_strlcpy(flagname, p, sizeof flagname);\n\t\t\t\ts = strchr(flagname, '=');\n\t\t\t\tif (s != NULL)\n\t\t\t\t\t*s = '\\0';\n\t\t\t\treturn flagname;\n\t\t\t}\n\t\t\tp = r;\n\t\t}\n\t}\n\n\titer.res = NULL;\n\titer.level = level;\n\tmowgli_patricia_foreach(global_template_dict, global_template_search, &iter);\n\n\treturn iter.res;\n}",
          "includes": [
            "#include \"template.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"template.h\"\n#include \"atheme.h\"\n\nstatic const char *get_template_name(mychan_t *mc, unsigned int level)\n{\n\tmetadata_t *md;\n\tconst char *p, *q, *r;\n\tchar *s;\n\tchar ss[40];\n\tstatic char flagname[400];\n\ttemplate_iter_t iter;\n\n\tmd = metadata_find(mc, \"private:templates\");\n\tif (md != NULL)\n\t{\n\t\tp = md->value;\n\t\twhile (p != NULL)\n\t\t{\n\t\t\twhile (*p == ' ')\n\t\t\t\tp++;\n\t\t\tq = strchr(p, '=');\n\t\t\tif (q == NULL)\n\t\t\t\tbreak;\n\t\t\tr = strchr(q, ' ');\n\t\t\tif (r != NULL && r < q)\n\t\t\t\tbreak;\n\t\t\tmowgli_strlcpy(ss, q, sizeof ss);\n\t\t\tif (r != NULL && r - q < (int)(sizeof ss - 1))\n\t\t\t{\n\t\t\t\tss[r - q] = '\\0';\n\t\t\t}\n\t\t\tif (level == flags_to_bitmask(ss, 0))\n\t\t\t{\n\t\t\t\tmowgli_strlcpy(flagname, p, sizeof flagname);\n\t\t\t\ts = strchr(flagname, '=');\n\t\t\t\tif (s != NULL)\n\t\t\t\t\t*s = '\\0';\n\t\t\t\treturn flagname;\n\t\t\t}\n\t\t\tp = r;\n\t\t}\n\t}\n\n\titer.res = NULL;\n\titer.level = level;\n\tmowgli_patricia_foreach(global_template_dict, global_template_search, &iter);\n\n\treturn iter.res;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MOWGLI_ITER_FOREACH",
          "args": [
            "n",
            "mc->chanacs.head"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "\"----- ---------------------- -----\""
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"Entry Nickname/Host          Flags\")"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not authorized to perform this operation.\")"
          ],
          "line": 110
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_priv",
          "args": [
            "si",
            "PRIV_CHAN_AUSPEX"
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_source_has_flag",
          "args": [
            "mc",
            "si",
            "CA_ACLVIEW"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void do_list(sourceinfo_t *si, mychan_t *mc, unsigned int flags)\n{\n\tchanacs_t *ca;\n\tmowgli_node_t *n;\n\tbool operoverride = false;\n\tunsigned int i = 1;\n\n\tif (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t{\n\t\tif (has_priv(si, PRIV_CHAN_AUSPEX))\n\t\t\toperoverride = true;\n\t\telse\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tcommand_success_nodata(si, _(\"Entry Nickname/Host          Flags\"));\n\tcommand_success_nodata(si, \"----- ---------------------- -----\");\n\n\tMOWGLI_ITER_FOREACH(n, mc->chanacs.head)\n\t{\n\t\tconst char *template, *mod_ago;\n\t\tstruct tm tm;\n\t\tchar mod_date[64];\n\n\t\tca = n->data;\n\n\t\tif (flags && !(ca->level & flags))\n\t\t\tcontinue;\n\n\t\ttemplate = get_template_name(mc, ca->level);\n\t\tmod_ago = ca->tmodified ? time_ago(ca->tmodified) : \"?\";\n\n\t\ttm = *localtime(&ca->tmodified);\n\t\tstrftime(mod_date, sizeof mod_date, TIME_FORMAT, &tm);\n\n\t\tif (template != NULL)\n\t\t\tcommand_success_nodata(si, _(\"%-5d %-22s %-20s (%s) (%s) [modified %s ago, on %s]\"),\n\t\t\t\ti, ca->entity ? ca->entity->name : ca->host, bitmask_to_flags(ca->level), template, mc->name, mod_ago, mod_date);\n\t\telse\n\t\t\tcommand_success_nodata(si, _(\"%-5d %-22s %-20s (%s) [modified %s ago, on %s]\"),\n\t\t\t\ti, ca->entity ? ca->entity->name : ca->host, bitmask_to_flags(ca->level), mc->name, mod_ago, mod_date);\n\t\ti++;\n\t}\n\n\tcommand_success_nodata(si, \"----- ---------------------- -----\");\n\tcommand_success_nodata(si, _(\"End of \\2%s\\2 FLAGS listing.\"), mc->name);\n\n\tif (operoverride)\n\t\tlogcommand(si, CMDLOG_ADMIN, \"FLAGS: \\2%s\\2 (oper override)\", mc->name);\n\telse\n\t\tlogcommand(si, CMDLOG_GET, \"FLAGS: \\2%s\\2\", mc->name);\n}"
  },
  {
    "function_name": "get_template_name",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/flags.c",
    "lines": "50-95",
    "snippet": "static const char *get_template_name(mychan_t *mc, unsigned int level)\n{\n\tmetadata_t *md;\n\tconst char *p, *q, *r;\n\tchar *s;\n\tchar ss[40];\n\tstatic char flagname[400];\n\ttemplate_iter_t iter;\n\n\tmd = metadata_find(mc, \"private:templates\");\n\tif (md != NULL)\n\t{\n\t\tp = md->value;\n\t\twhile (p != NULL)\n\t\t{\n\t\t\twhile (*p == ' ')\n\t\t\t\tp++;\n\t\t\tq = strchr(p, '=');\n\t\t\tif (q == NULL)\n\t\t\t\tbreak;\n\t\t\tr = strchr(q, ' ');\n\t\t\tif (r != NULL && r < q)\n\t\t\t\tbreak;\n\t\t\tmowgli_strlcpy(ss, q, sizeof ss);\n\t\t\tif (r != NULL && r - q < (int)(sizeof ss - 1))\n\t\t\t{\n\t\t\t\tss[r - q] = '\\0';\n\t\t\t}\n\t\t\tif (level == flags_to_bitmask(ss, 0))\n\t\t\t{\n\t\t\t\tmowgli_strlcpy(flagname, p, sizeof flagname);\n\t\t\t\ts = strchr(flagname, '=');\n\t\t\t\tif (s != NULL)\n\t\t\t\t\t*s = '\\0';\n\t\t\t\treturn flagname;\n\t\t\t}\n\t\t\tp = r;\n\t\t}\n\t}\n\n\titer.res = NULL;\n\titer.level = level;\n\tmowgli_patricia_foreach(global_template_dict, global_template_search, &iter);\n\n\treturn iter.res;\n}",
    "includes": [
      "#include \"template.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mowgli_patricia_foreach",
          "args": [
            "global_template_dict",
            "global_template_search",
            "&iter"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "flagname",
            "'='"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcpy",
          "args": [
            "flagname",
            "p",
            "sizeof flagname"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flags_to_bitmask",
          "args": [
            "ss",
            "0"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcpy",
          "args": [
            "ss",
            "q",
            "sizeof ss"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "q",
            "' '"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "p",
            "'='"
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:templates\""
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"template.h\"\n#include \"atheme.h\"\n\nstatic const char *get_template_name(mychan_t *mc, unsigned int level)\n{\n\tmetadata_t *md;\n\tconst char *p, *q, *r;\n\tchar *s;\n\tchar ss[40];\n\tstatic char flagname[400];\n\ttemplate_iter_t iter;\n\n\tmd = metadata_find(mc, \"private:templates\");\n\tif (md != NULL)\n\t{\n\t\tp = md->value;\n\t\twhile (p != NULL)\n\t\t{\n\t\t\twhile (*p == ' ')\n\t\t\t\tp++;\n\t\t\tq = strchr(p, '=');\n\t\t\tif (q == NULL)\n\t\t\t\tbreak;\n\t\t\tr = strchr(q, ' ');\n\t\t\tif (r != NULL && r < q)\n\t\t\t\tbreak;\n\t\t\tmowgli_strlcpy(ss, q, sizeof ss);\n\t\t\tif (r != NULL && r - q < (int)(sizeof ss - 1))\n\t\t\t{\n\t\t\t\tss[r - q] = '\\0';\n\t\t\t}\n\t\t\tif (level == flags_to_bitmask(ss, 0))\n\t\t\t{\n\t\t\t\tmowgli_strlcpy(flagname, p, sizeof flagname);\n\t\t\t\ts = strchr(flagname, '=');\n\t\t\t\tif (s != NULL)\n\t\t\t\t\t*s = '\\0';\n\t\t\t\treturn flagname;\n\t\t\t}\n\t\t\tp = r;\n\t\t}\n\t}\n\n\titer.res = NULL;\n\titer.level = level;\n\tmowgli_patricia_foreach(global_template_dict, global_template_search, &iter);\n\n\treturn iter.res;\n}"
  },
  {
    "function_name": "global_template_search",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/flags.c",
    "lines": "39-48",
    "snippet": "static int global_template_search(const char *key, void *data, void *privdata)\n{\n\ttemplate_iter_t *iter = privdata;\n\tdefault_template_t *def_t = data;\n\n\tif (def_t->flags == iter->level)\n\t\titer->res = key;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"template.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [],
    "contextual_snippet": "#include \"template.h\"\n#include \"atheme.h\"\n\nstatic int global_template_search(const char *key, void *data, void *privdata)\n{\n\ttemplate_iter_t *iter = privdata;\n\tdefault_template_t *def_t = data;\n\n\tif (def_t->flags == iter->level)\n\t\titer->res = key;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "_moddeinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/flags.c",
    "lines": "29-32",
    "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_flags);\n}",
    "includes": [
      "#include \"template.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "command_t cs_flags = { \"FLAGS\", N_(\"Manipulates specific permissions on a channel.\"),\n                        AC_NONE, 3, cs_cmd_flags, { .path = \"cservice/flags\" } };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "service_named_unbind_command",
          "args": [
            "\"chanserv\"",
            "&cs_flags"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"template.h\"\n#include \"atheme.h\"\n\ncommand_t cs_flags = { \"FLAGS\", N_(\"Manipulates specific permissions on a channel.\"),\n                        AC_NONE, 3, cs_cmd_flags, { .path = \"cservice/flags\" } };\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_flags);\n}"
  },
  {
    "function_name": "_modinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/flags.c",
    "lines": "24-27",
    "snippet": "void _modinit(module_t *m)\n{\n\tservice_named_bind_command(\"chanserv\", &cs_flags);\n}",
    "includes": [
      "#include \"template.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "command_t cs_flags = { \"FLAGS\", N_(\"Manipulates specific permissions on a channel.\"),\n                        AC_NONE, 3, cs_cmd_flags, { .path = \"cservice/flags\" } };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "service_named_bind_command",
          "args": [
            "\"chanserv\"",
            "&cs_flags"
          ],
          "line": 26
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"template.h\"\n#include \"atheme.h\"\n\ncommand_t cs_flags = { \"FLAGS\", N_(\"Manipulates specific permissions on a channel.\"),\n                        AC_NONE, 3, cs_cmd_flags, { .path = \"cservice/flags\" } };\n\nvoid _modinit(module_t *m)\n{\n\tservice_named_bind_command(\"chanserv\", &cs_flags);\n}"
  }
]