[
  {
    "function_name": "_moddeinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
    "lines": "543-556",
    "snippet": "void\n_moddeinit(module_unload_intent_t intent)\n{\n\tcommand_delete(&cs_set_antiflood, *cs_set_cmdtree);\n\n\thook_del_channel_message(on_channel_message);\n\thook_del_channel_drop(on_channel_drop);\n\n\tmowgli_patricia_destroy(mqueue_trie, mqueue_trie_destroy_cb, NULL);\n\tmowgli_timer_destroy(base_eventloop, mqueue_gc_timer);\n\tmowgli_timer_destroy(base_eventloop, antiflood_unenforce_timer);\n\n\tdel_conf_item(\"ANTIFLOOD_ENFORCE_METHOD\", &chansvs.me->conf_table);\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static mowgli_patricia_t *mqueue_trie = NULL;",
      "static mowgli_eventloop_timer_t *mqueue_gc_timer = NULL;",
      "static mowgli_eventloop_timer_t *antiflood_unenforce_timer = NULL;",
      "static command_t cs_set_antiflood = {\n\t\"ANTIFLOOD\", N_(\"Set anti-flood action\"), AC_NONE, 2,\n\tcs_set_cmd_antiflood, { .path = \"cservice/set_antiflood\" }\n};",
      "mowgli_patricia_t **cs_set_cmdtree;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "del_conf_item",
          "args": [
            "\"ANTIFLOOD_ENFORCE_METHOD\"",
            "&chansvs.me->conf_table"
          ],
          "line": 555
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_timer_destroy",
          "args": [
            "base_eventloop",
            "antiflood_unenforce_timer"
          ],
          "line": 553
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_timer_destroy",
          "args": [
            "base_eventloop",
            "mqueue_gc_timer"
          ],
          "line": 552
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_patricia_destroy",
          "args": [
            "mqueue_trie",
            "mqueue_trie_destroy_cb",
            "NULL"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_del_channel_drop",
          "args": [
            "on_channel_drop"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_del_channel_message",
          "args": [
            "on_channel_message"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_delete",
          "args": [
            "&cs_set_antiflood",
            "*cs_set_cmdtree"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic mowgli_patricia_t *mqueue_trie = NULL;\nstatic mowgli_eventloop_timer_t *mqueue_gc_timer = NULL;\nstatic mowgli_eventloop_timer_t *antiflood_unenforce_timer = NULL;\nstatic command_t cs_set_antiflood = {\n\t\"ANTIFLOOD\", N_(\"Set anti-flood action\"), AC_NONE, 2,\n\tcs_set_cmd_antiflood, { .path = \"cservice/set_antiflood\" }\n};\nmowgli_patricia_t **cs_set_cmdtree;\n\nvoid\n_moddeinit(module_unload_intent_t intent)\n{\n\tcommand_delete(&cs_set_antiflood, *cs_set_cmdtree);\n\n\thook_del_channel_message(on_channel_message);\n\thook_del_channel_drop(on_channel_drop);\n\n\tmowgli_patricia_destroy(mqueue_trie, mqueue_trie_destroy_cb, NULL);\n\tmowgli_timer_destroy(base_eventloop, mqueue_gc_timer);\n\tmowgli_timer_destroy(base_eventloop, antiflood_unenforce_timer);\n\n\tdel_conf_item(\"ANTIFLOOD_ENFORCE_METHOD\", &chansvs.me->conf_table);\n}"
  },
  {
    "function_name": "_modinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
    "lines": "510-541",
    "snippet": "void\n_modinit(module_t *m)\n{\n\tMODULE_TRY_REQUEST_SYMBOL(m, cs_set_cmdtree, \"chanserv/set_core\", \"cs_set_cmdtree\");\n\n\t/* attempt to pull in the place_quietmask() routine from chanserv/quiet,\n\t   we don't see it as a hardfail because we can run without QUIET support. */\n\tif (module_request(\"chanserv/quiet\"))\n\t{\n\t\tplace_quietmask = module_locate_symbol(\"chanserv/quiet\", \"place_quietmask\");\n\t\tif (place_quietmask == NULL)\n\t\t\tantiflood_enforce_method = ANTIFLOOD_ENFORCE_KICKBAN;\n\t}\n\n\thook_add_event(\"channel_message\");\n\thook_add_channel_message(on_channel_message);\n\n\thook_add_event(\"channel_drop\");\n\thook_add_channel_drop(on_channel_drop);\n\n\tmsg_heap = sharedheap_get(sizeof(msg_t));\n\n\tmqueue_heap = sharedheap_get(sizeof(mqueue_t));\n\tmqueue_trie = mowgli_patricia_create(irccasecanon);\n\tmqueue_gc_timer = mowgli_timer_add(base_eventloop, \"mqueue_gc\", mqueue_gc, NULL, 300);\n\n\tantiflood_unenforce_timer = mowgli_timer_add(base_eventloop, \"antiflood_unenforce\", antiflood_unenforce_timer_cb, NULL, 3600);\n\n\tcommand_add(&cs_set_antiflood, *cs_set_cmdtree);\n\n\tadd_conf_item(\"ANTIFLOOD_ENFORCE_METHOD\", &chansvs.me->conf_table, c_ci_antiflood_enforce_method);\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static antiflood_enforce_method_t antiflood_enforce_method = ANTIFLOOD_ENFORCE_QUIET;",
      "static mowgli_heap_t *msg_heap = NULL;",
      "static mowgli_patricia_t *mqueue_trie = NULL;",
      "static mowgli_heap_t *mqueue_heap = NULL;",
      "static mowgli_eventloop_timer_t *mqueue_gc_timer = NULL;",
      "static mowgli_eventloop_timer_t *antiflood_unenforce_timer = NULL;",
      "static command_t cs_set_antiflood = {\n\t\"ANTIFLOOD\", N_(\"Set anti-flood action\"), AC_NONE, 2,\n\tcs_set_cmd_antiflood, { .path = \"cservice/set_antiflood\" }\n};",
      "mowgli_patricia_t **cs_set_cmdtree;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_conf_item",
          "args": [
            "\"ANTIFLOOD_ENFORCE_METHOD\"",
            "&chansvs.me->conf_table",
            "c_ci_antiflood_enforce_method"
          ],
          "line": 540
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_add",
          "args": [
            "&cs_set_antiflood",
            "*cs_set_cmdtree"
          ],
          "line": 538
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_timer_add",
          "args": [
            "base_eventloop",
            "\"antiflood_unenforce\"",
            "antiflood_unenforce_timer_cb",
            "NULL",
            "3600"
          ],
          "line": 536
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_timer_add",
          "args": [
            "base_eventloop",
            "\"mqueue_gc\"",
            "mqueue_gc",
            "NULL",
            "300"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_patricia_create",
          "args": [
            "irccasecanon"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sharedheap_get",
          "args": [
            "sizeof(mqueue_t)"
          ],
          "line": 532
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sharedheap_get",
          "args": [
            "sizeof(msg_t)"
          ],
          "line": 530
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_channel_drop",
          "args": [
            "on_channel_drop"
          ],
          "line": 528
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_event",
          "args": [
            "\"channel_drop\""
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_channel_message",
          "args": [
            "on_channel_message"
          ],
          "line": 525
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_event",
          "args": [
            "\"channel_message\""
          ],
          "line": 524
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_locate_symbol",
          "args": [
            "\"chanserv/quiet\"",
            "\"place_quietmask\""
          ],
          "line": 519
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "module_request",
          "args": [
            "\"chanserv/quiet\""
          ],
          "line": 517
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MODULE_TRY_REQUEST_SYMBOL",
          "args": [
            "m",
            "cs_set_cmdtree",
            "\"chanserv/set_core\"",
            "\"cs_set_cmdtree\""
          ],
          "line": 513
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic antiflood_enforce_method_t antiflood_enforce_method = ANTIFLOOD_ENFORCE_QUIET;\nstatic mowgli_heap_t *msg_heap = NULL;\nstatic mowgli_patricia_t *mqueue_trie = NULL;\nstatic mowgli_heap_t *mqueue_heap = NULL;\nstatic mowgli_eventloop_timer_t *mqueue_gc_timer = NULL;\nstatic mowgli_eventloop_timer_t *antiflood_unenforce_timer = NULL;\nstatic command_t cs_set_antiflood = {\n\t\"ANTIFLOOD\", N_(\"Set anti-flood action\"), AC_NONE, 2,\n\tcs_set_cmd_antiflood, { .path = \"cservice/set_antiflood\" }\n};\nmowgli_patricia_t **cs_set_cmdtree;\n\nvoid\n_modinit(module_t *m)\n{\n\tMODULE_TRY_REQUEST_SYMBOL(m, cs_set_cmdtree, \"chanserv/set_core\", \"cs_set_cmdtree\");\n\n\t/* attempt to pull in the place_quietmask() routine from chanserv/quiet,\n\t   we don't see it as a hardfail because we can run without QUIET support. */\n\tif (module_request(\"chanserv/quiet\"))\n\t{\n\t\tplace_quietmask = module_locate_symbol(\"chanserv/quiet\", \"place_quietmask\");\n\t\tif (place_quietmask == NULL)\n\t\t\tantiflood_enforce_method = ANTIFLOOD_ENFORCE_KICKBAN;\n\t}\n\n\thook_add_event(\"channel_message\");\n\thook_add_channel_message(on_channel_message);\n\n\thook_add_event(\"channel_drop\");\n\thook_add_channel_drop(on_channel_drop);\n\n\tmsg_heap = sharedheap_get(sizeof(msg_t));\n\n\tmqueue_heap = sharedheap_get(sizeof(mqueue_t));\n\tmqueue_trie = mowgli_patricia_create(irccasecanon);\n\tmqueue_gc_timer = mowgli_timer_add(base_eventloop, \"mqueue_gc\", mqueue_gc, NULL, 300);\n\n\tantiflood_unenforce_timer = mowgli_timer_add(base_eventloop, \"antiflood_unenforce\", antiflood_unenforce_timer_cb, NULL, 3600);\n\n\tcommand_add(&cs_set_antiflood, *cs_set_cmdtree);\n\n\tadd_conf_item(\"ANTIFLOOD_ENFORCE_METHOD\", &chansvs.me->conf_table, c_ci_antiflood_enforce_method);\n}"
  },
  {
    "function_name": "c_ci_antiflood_enforce_method",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
    "lines": "491-508",
    "snippet": "static int\nc_ci_antiflood_enforce_method(mowgli_config_file_entry_t *ce)\n{\n\tif (ce->vardata == NULL)\n\t{\n\t\tconf_report_warning(ce, \"no parameter for configuration option\");\n\t\treturn 0;\n\t}\n\n\tif (!strcasecmp(ce->vardata, \"QUIET\"))\n\t\tantiflood_enforce_method = ANTIFLOOD_ENFORCE_QUIET;\n\telse if (!strcasecmp(ce->vardata, \"KICKBAN\"))\n\t\tantiflood_enforce_method = ANTIFLOOD_ENFORCE_KICKBAN;\n\telse if (!strcasecmp(ce->vardata, \"AKILL\") || !strcasecmp(ce->vardata, \"KLINE\"))\n\t\tantiflood_enforce_method = ANTIFLOOD_ENFORCE_KLINE;\n\n\treturn 0;\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static antiflood_enforce_method_t antiflood_enforce_method = ANTIFLOOD_ENFORCE_QUIET;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "ce->vardata",
            "\"KLINE\""
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "ce->vardata",
            "\"AKILL\""
          ],
          "line": 504
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "ce->vardata",
            "\"KICKBAN\""
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "ce->vardata",
            "\"QUIET\""
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conf_report_warning",
          "args": [
            "ce",
            "\"no parameter for configuration option\""
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic antiflood_enforce_method_t antiflood_enforce_method = ANTIFLOOD_ENFORCE_QUIET;\n\nstatic int\nc_ci_antiflood_enforce_method(mowgli_config_file_entry_t *ce)\n{\n\tif (ce->vardata == NULL)\n\t{\n\t\tconf_report_warning(ce, \"no parameter for configuration option\");\n\t\treturn 0;\n\t}\n\n\tif (!strcasecmp(ce->vardata, \"QUIET\"))\n\t\tantiflood_enforce_method = ANTIFLOOD_ENFORCE_QUIET;\n\telse if (!strcasecmp(ce->vardata, \"KICKBAN\"))\n\t\tantiflood_enforce_method = ANTIFLOOD_ENFORCE_KICKBAN;\n\telse if (!strcasecmp(ce->vardata, \"AKILL\") || !strcasecmp(ce->vardata, \"KLINE\"))\n\t\tantiflood_enforce_method = ANTIFLOOD_ENFORCE_KLINE;\n\n\treturn 0;\n}"
  },
  {
    "function_name": "cs_set_cmd_antiflood",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
    "lines": "399-482",
    "snippet": "static void\ncs_set_cmd_antiflood(sourceinfo_t *si, int parc, char *parv[])\n{\n\tmychan_t *mc;\n\n\tif (!(mc = mychan_find(parv[0])))\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), parv[0]);\n\t\treturn;\n\t}\n\n\t/* allow opers with PRIV_CHAN_ADMIN to override this setting since it has\n\t   oper-specific settings (i.e. AKILL action) */\n\tif (!chanacs_source_has_flag(mc, si, CA_SET) && !has_priv(si, PRIV_CHAN_ADMIN))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this command.\"));\n\t\treturn;\n\t}\n\n\tif (parv[1] == NULL)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"SET ANTIFLOOD\");\n\t\treturn;\n\t}\n\n\tif (!strcasecmp(parv[1], \"OFF\"))\n\t{\n\t\tmc->flags &= ~MC_ANTIFLOOD;\n\t\tmetadata_delete(mc, METADATA_KEY_ENFORCE_METHOD);\n\n\t\tlogcommand(si, CMDLOG_SET, \"ANTIFLOOD:NONE: \\2%s\\2\",  mc->name);\n\t\tcommand_success_nodata(si, _(\"Flood protection turned off for \\2%s\\2.\"), mc->name);\n\t\treturn;\n\t}\n\telse if (!strcasecmp(parv[1], \"ON\"))\n\t{\n\t\tif (MC_ANTIFLOOD & mc->flags)\n\t\t{\n\t\t\tcommand_fail(si, fault_nochange, _(\"The \\2%s\\2 flag is already set for channel \\2%s\\2.\"), \"ANTIFLOOD\", mc->name);\n\t\t\treturn;\n\t\t}\n\t\tmc->flags |= MC_ANTIFLOOD;\n\t\tmetadata_delete(mc, METADATA_KEY_ENFORCE_METHOD);\n\n\t\tlogcommand(si, CMDLOG_SET, \"ANTIFLOOD: %s (%s)\",  mc->name, \"DEFAULT\");\n\t\tcommand_success_nodata(si, _(\"Flood protection turned on for \\2%s\\2 with default settings.\"), mc->name);\n\t\treturn;\n\t}\n\telse if (!strcasecmp(parv[1], \"QUIET\"))\n\t{\n\t\tmc->flags |= MC_ANTIFLOOD;\n\t\tmetadata_add(mc, METADATA_KEY_ENFORCE_METHOD, \"QUIET\");\n\n\t\tlogcommand(si, CMDLOG_SET, \"ANTIFLOOD: %s (%s)\",  mc->name, \"QUIET\");\n\t\tcommand_success_nodata(si, _(\"Flood protection turned on for \\2%s\\2 with \\2%s\\2 action.\"), mc->name, \"QUIET\");\n\t\treturn;\n\t}\n\telse if (!strcasecmp(parv[1], \"KICKBAN\"))\n\t{\n\t\tmc->flags |= MC_ANTIFLOOD;\n\t\tmetadata_add(mc, METADATA_KEY_ENFORCE_METHOD, \"KICKBAN\");\n\n\t\tlogcommand(si, CMDLOG_SET, \"ANTIFLOOD: %s (%s)\",  mc->name, \"KICKBAN\");\n\t\tcommand_success_nodata(si, _(\"Flood protection turned on for \\2%s\\2 with \\2%s\\2 action.\"), mc->name, \"KICKBAN\");\n\t\treturn;\n\t}\n\telse if (!strcasecmp(parv[1], \"AKILL\") || !strcasecmp(parv[1], \"KLINE\"))\n\t{\n\t\tif (has_priv(si, PRIV_AKILL))\n\t\t{\n\t\t\tmc->flags |= MC_ANTIFLOOD;\n\t\t\tmetadata_add(mc, METADATA_KEY_ENFORCE_METHOD, \"AKILL\");\n\n\t\t\tlogcommand(si, CMDLOG_SET, \"ANTIFLOOD: %s (%s)\",  mc->name, \"AKILL\");\n\t\t\tcommand_success_nodata(si, _(\"Flood protection turned on for \\2%s\\2 with \\2%s\\2 action.\"), mc->name, \"AKILL\");\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this command.\"));\n\t\t\treturn;\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [
      "#define METADATA_KEY_ENFORCE_METHOD\t\"private:antiflood:enforce-method\""
    ],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not authorized to perform this command.\")"
          ],
          "line": 478
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"You are not authorized to perform this command.\""
          ],
          "line": 478
        },
        "resolved": true,
        "details": {
          "function_name": "_moddeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
          "lines": "543-556",
          "snippet": "void\n_moddeinit(module_unload_intent_t intent)\n{\n\tcommand_delete(&cs_set_antiflood, *cs_set_cmdtree);\n\n\thook_del_channel_message(on_channel_message);\n\thook_del_channel_drop(on_channel_drop);\n\n\tmowgli_patricia_destroy(mqueue_trie, mqueue_trie_destroy_cb, NULL);\n\tmowgli_timer_destroy(base_eventloop, mqueue_gc_timer);\n\tmowgli_timer_destroy(base_eventloop, antiflood_unenforce_timer);\n\n\tdel_conf_item(\"ANTIFLOOD_ENFORCE_METHOD\", &chansvs.me->conf_table);\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static mowgli_patricia_t *mqueue_trie = NULL;",
            "static mowgli_eventloop_timer_t *mqueue_gc_timer = NULL;",
            "static mowgli_eventloop_timer_t *antiflood_unenforce_timer = NULL;",
            "static command_t cs_set_antiflood = {\n\t\"ANTIFLOOD\", N_(\"Set anti-flood action\"), AC_NONE, 2,\n\tcs_set_cmd_antiflood, { .path = \"cservice/set_antiflood\" }\n};",
            "mowgli_patricia_t **cs_set_cmdtree;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic mowgli_patricia_t *mqueue_trie = NULL;\nstatic mowgli_eventloop_timer_t *mqueue_gc_timer = NULL;\nstatic mowgli_eventloop_timer_t *antiflood_unenforce_timer = NULL;\nstatic command_t cs_set_antiflood = {\n\t\"ANTIFLOOD\", N_(\"Set anti-flood action\"), AC_NONE, 2,\n\tcs_set_cmd_antiflood, { .path = \"cservice/set_antiflood\" }\n};\nmowgli_patricia_t **cs_set_cmdtree;\n\nvoid\n_moddeinit(module_unload_intent_t intent)\n{\n\tcommand_delete(&cs_set_antiflood, *cs_set_cmdtree);\n\n\thook_del_channel_message(on_channel_message);\n\thook_del_channel_drop(on_channel_drop);\n\n\tmowgli_patricia_destroy(mqueue_trie, mqueue_trie_destroy_cb, NULL);\n\tmowgli_timer_destroy(base_eventloop, mqueue_gc_timer);\n\tmowgli_timer_destroy(base_eventloop, antiflood_unenforce_timer);\n\n\tdel_conf_item(\"ANTIFLOOD_ENFORCE_METHOD\", &chansvs.me->conf_table);\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"Flood protection turned on for \\2%s\\2 with \\2%s\\2 action.\")",
            "mc->name",
            "\"AKILL\""
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_SET",
            "\"ANTIFLOOD: %s (%s)\"",
            "mc->name",
            "\"AKILL\""
          ],
          "line": 472
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_add",
          "args": [
            "mc",
            "METADATA_KEY_ENFORCE_METHOD",
            "\"AKILL\""
          ],
          "line": 470
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_priv",
          "args": [
            "si",
            "PRIV_AKILL"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "parv[1]",
            "\"KLINE\""
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "parv[1]",
            "\"AKILL\""
          ],
          "line": 465
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"Flood protection turned on for \\2%s\\2 with \\2%s\\2 action.\")",
            "mc->name",
            "\"KICKBAN\""
          ],
          "line": 462
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_SET",
            "\"ANTIFLOOD: %s (%s)\"",
            "mc->name",
            "\"KICKBAN\""
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_add",
          "args": [
            "mc",
            "METADATA_KEY_ENFORCE_METHOD",
            "\"KICKBAN\""
          ],
          "line": 459
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "parv[1]",
            "\"KICKBAN\""
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"Flood protection turned on for \\2%s\\2 with \\2%s\\2 action.\")",
            "mc->name",
            "\"QUIET\""
          ],
          "line": 453
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_SET",
            "\"ANTIFLOOD: %s (%s)\"",
            "mc->name",
            "\"QUIET\""
          ],
          "line": 452
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_add",
          "args": [
            "mc",
            "METADATA_KEY_ENFORCE_METHOD",
            "\"QUIET\""
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "parv[1]",
            "\"QUIET\""
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"Flood protection turned on for \\2%s\\2 with default settings.\")",
            "mc->name"
          ],
          "line": 444
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_SET",
            "\"ANTIFLOOD: %s (%s)\"",
            "mc->name",
            "\"DEFAULT\""
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_delete",
          "args": [
            "mc",
            "METADATA_KEY_ENFORCE_METHOD"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nochange",
            "_(\"The \\2%s\\2 flag is already set for channel \\2%s\\2.\")",
            "\"ANTIFLOOD\"",
            "mc->name"
          ],
          "line": 437
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "parv[1]",
            "\"ON\""
          ],
          "line": 433
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"Flood protection turned off for \\2%s\\2.\")",
            "mc->name"
          ],
          "line": 430
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_SET",
            "\"ANTIFLOOD:NONE: \\2%s\\2\"",
            "mc->name"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_delete",
          "args": [
            "mc",
            "METADATA_KEY_ENFORCE_METHOD"
          ],
          "line": 427
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "parv[1]",
            "\"OFF\""
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "STR_INSUFFICIENT_PARAMS",
            "\"SET ANTIFLOOD\""
          ],
          "line": 420
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not authorized to perform this command.\")"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_priv",
          "args": [
            "si",
            "PRIV_CHAN_ADMIN"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_source_has_flag",
          "args": [
            "mc",
            "si",
            "CA_SET"
          ],
          "line": 412
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_target",
            "_(\"Channel \\2%s\\2 is not registered.\")",
            "parv[0]"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_find",
          "args": [
            "parv[0]"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\n#define METADATA_KEY_ENFORCE_METHOD\t\"private:antiflood:enforce-method\"\n\nstatic void\ncs_set_cmd_antiflood(sourceinfo_t *si, int parc, char *parv[])\n{\n\tmychan_t *mc;\n\n\tif (!(mc = mychan_find(parv[0])))\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), parv[0]);\n\t\treturn;\n\t}\n\n\t/* allow opers with PRIV_CHAN_ADMIN to override this setting since it has\n\t   oper-specific settings (i.e. AKILL action) */\n\tif (!chanacs_source_has_flag(mc, si, CA_SET) && !has_priv(si, PRIV_CHAN_ADMIN))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this command.\"));\n\t\treturn;\n\t}\n\n\tif (parv[1] == NULL)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"SET ANTIFLOOD\");\n\t\treturn;\n\t}\n\n\tif (!strcasecmp(parv[1], \"OFF\"))\n\t{\n\t\tmc->flags &= ~MC_ANTIFLOOD;\n\t\tmetadata_delete(mc, METADATA_KEY_ENFORCE_METHOD);\n\n\t\tlogcommand(si, CMDLOG_SET, \"ANTIFLOOD:NONE: \\2%s\\2\",  mc->name);\n\t\tcommand_success_nodata(si, _(\"Flood protection turned off for \\2%s\\2.\"), mc->name);\n\t\treturn;\n\t}\n\telse if (!strcasecmp(parv[1], \"ON\"))\n\t{\n\t\tif (MC_ANTIFLOOD & mc->flags)\n\t\t{\n\t\t\tcommand_fail(si, fault_nochange, _(\"The \\2%s\\2 flag is already set for channel \\2%s\\2.\"), \"ANTIFLOOD\", mc->name);\n\t\t\treturn;\n\t\t}\n\t\tmc->flags |= MC_ANTIFLOOD;\n\t\tmetadata_delete(mc, METADATA_KEY_ENFORCE_METHOD);\n\n\t\tlogcommand(si, CMDLOG_SET, \"ANTIFLOOD: %s (%s)\",  mc->name, \"DEFAULT\");\n\t\tcommand_success_nodata(si, _(\"Flood protection turned on for \\2%s\\2 with default settings.\"), mc->name);\n\t\treturn;\n\t}\n\telse if (!strcasecmp(parv[1], \"QUIET\"))\n\t{\n\t\tmc->flags |= MC_ANTIFLOOD;\n\t\tmetadata_add(mc, METADATA_KEY_ENFORCE_METHOD, \"QUIET\");\n\n\t\tlogcommand(si, CMDLOG_SET, \"ANTIFLOOD: %s (%s)\",  mc->name, \"QUIET\");\n\t\tcommand_success_nodata(si, _(\"Flood protection turned on for \\2%s\\2 with \\2%s\\2 action.\"), mc->name, \"QUIET\");\n\t\treturn;\n\t}\n\telse if (!strcasecmp(parv[1], \"KICKBAN\"))\n\t{\n\t\tmc->flags |= MC_ANTIFLOOD;\n\t\tmetadata_add(mc, METADATA_KEY_ENFORCE_METHOD, \"KICKBAN\");\n\n\t\tlogcommand(si, CMDLOG_SET, \"ANTIFLOOD: %s (%s)\",  mc->name, \"KICKBAN\");\n\t\tcommand_success_nodata(si, _(\"Flood protection turned on for \\2%s\\2 with \\2%s\\2 action.\"), mc->name, \"KICKBAN\");\n\t\treturn;\n\t}\n\telse if (!strcasecmp(parv[1], \"AKILL\") || !strcasecmp(parv[1], \"KLINE\"))\n\t{\n\t\tif (has_priv(si, PRIV_AKILL))\n\t\t{\n\t\t\tmc->flags |= MC_ANTIFLOOD;\n\t\t\tmetadata_add(mc, METADATA_KEY_ENFORCE_METHOD, \"AKILL\");\n\n\t\t\tlogcommand(si, CMDLOG_SET, \"ANTIFLOOD: %s (%s)\",  mc->name, \"AKILL\");\n\t\t\tcommand_success_nodata(si, _(\"Flood protection turned on for \\2%s\\2 with \\2%s\\2 action.\"), mc->name, \"AKILL\");\n\t\t\treturn;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this command.\"));\n\t\t\treturn;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "on_channel_drop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
    "lines": "388-397",
    "snippet": "static void\non_channel_drop(mychan_t *mc)\n{\n\tmqueue_t *mq;\n\n\tmq = mqueue_get(mc);\n\treturn_if_fail(mq != NULL);\n\n\tmqueue_destroy(mq);\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mqueue_destroy",
          "args": [
            "mq"
          ],
          "line": 396
        },
        "resolved": true,
        "details": {
          "function_name": "mqueue_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
          "lines": "145-151",
          "snippet": "static void\nmqueue_destroy(mqueue_t *mq)\n{\n\tmowgli_patricia_delete(mqueue_trie, mq->name);\n\n\tmqueue_free(mq);\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static mowgli_patricia_t *mqueue_trie = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic mowgli_patricia_t *mqueue_trie = NULL;\n\nstatic void\nmqueue_destroy(mqueue_t *mq)\n{\n\tmowgli_patricia_delete(mqueue_trie, mq->name);\n\n\tmqueue_free(mq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "return_if_fail",
          "args": [
            "mq != NULL"
          ],
          "line": 394
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mqueue_get",
          "args": [
            "mc"
          ],
          "line": 393
        },
        "resolved": true,
        "details": {
          "function_name": "mqueue_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
          "lines": "133-143",
          "snippet": "static mqueue_t *\nmqueue_get(mychan_t *mc)\n{\n\tmqueue_t *mq;\n\n\tmq = mowgli_patricia_retrieve(mqueue_trie, mc->name);\n\tif (mq == NULL)\n\t\tmq = mqueue_create(mc->name);\n\n\treturn mq;\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static mowgli_patricia_t *mqueue_trie = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic mowgli_patricia_t *mqueue_trie = NULL;\n\nstatic mqueue_t *\nmqueue_get(mychan_t *mc)\n{\n\tmqueue_t *mq;\n\n\tmq = mowgli_patricia_retrieve(mqueue_trie, mc->name);\n\tif (mq == NULL)\n\t\tmq = mqueue_create(mc->name);\n\n\treturn mq;\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic void\non_channel_drop(mychan_t *mc)\n{\n\tmqueue_t *mq;\n\n\tmq = mqueue_get(mc);\n\treturn_if_fail(mq != NULL);\n\n\tmqueue_destroy(mq);\n}"
  },
  {
    "function_name": "on_channel_message",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
    "lines": "343-386",
    "snippet": "static void\non_channel_message(hook_cmessage_data_t *data)\n{\n\tchanuser_t *cu;\n\tmychan_t *mc;\n\tmqueue_t *mq;\n\tmsg_t *msg;\n\n\treturn_if_fail(data != NULL);\n\treturn_if_fail(data->msg != NULL);\n\treturn_if_fail(data->u != NULL);\n\treturn_if_fail(data->c != NULL);\n\n\tcu = chanuser_find(data->c, data->u);\n\tif (cu == NULL)\n\t\treturn;\n\n\tmc = mychan_from(data->c);\n\tif (mc == NULL)\n\t\treturn;\n\n\tmq = mqueue_get(mc);\n\treturn_if_fail(mq != NULL);\n\n\tmsg = msg_create(mq, data->u, data->msg);\n\n\t/* never enforce against any user who has special CSTATUS flags. */\n\tif (cu->modes)\n\t\treturn;\n\n\t/* do not enforce unless enforcement is specifically enabled */\n\tif (!(mc->flags & MC_ANTIFLOOD))\n\t\treturn;\n\n\tif (mqueue_should_enforce(mq) != MQ_ENFORCE_NONE)\n\t{\n\t\tantiflood_enforce_method_impl_t *enf = antiflood_enforce_method_impl_get(mc);\n\n\t\tif (enf == NULL || enf->enforce == NULL)\n\t\t\treturn;\n\n\t\tenf->enforce(data->u, data->c);\n\t}\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enf->enforce",
          "args": [
            "data->u",
            "data->c"
          ],
          "line": 384
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "antiflood_enforce_method_impl_get",
          "args": [
            "mc"
          ],
          "line": 379
        },
        "resolved": true,
        "details": {
          "function_name": "antiflood_enforce_method_impl_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
          "lines": "304-321",
          "snippet": "static inline antiflood_enforce_method_impl_t *\nantiflood_enforce_method_impl_get(mychan_t *mc)\n{\n\tmetadata_t *md;\n\n\tmd = metadata_find(mc, METADATA_KEY_ENFORCE_METHOD);\n\tif (md != NULL)\n\t{\n\t\tif (!strcasecmp(md->value, \"QUIET\"))\n\t\t\treturn &antiflood_enforce_methods[ANTIFLOOD_ENFORCE_QUIET];\n\t\telse if (!strcasecmp(md->value, \"KICKBAN\"))\n\t\t\treturn &antiflood_enforce_methods[ANTIFLOOD_ENFORCE_KICKBAN];\n\t\telse if (!strcasecmp(md->value, \"AKILL\"))\n\t\t\treturn &antiflood_enforce_methods[ANTIFLOOD_ENFORCE_KLINE];\n\t}\n\n\treturn &antiflood_enforce_methods[antiflood_enforce_method];\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [
            "#define METADATA_KEY_ENFORCE_METHOD\t\"private:antiflood:enforce-method\""
          ],
          "globals_used": [
            "static antiflood_enforce_method_t antiflood_enforce_method = ANTIFLOOD_ENFORCE_QUIET;",
            "static antiflood_enforce_method_impl_t antiflood_enforce_methods[ANTIFLOOD_ENFORCE_COUNT] = {\n\t[ANTIFLOOD_ENFORCE_QUIET]   = { &antiflood_enforce_quiet, &antiflood_unenforce_banlike },\n\t[ANTIFLOOD_ENFORCE_KICKBAN] = { &antiflood_enforce_kickban, &antiflood_unenforce_banlike },\n\t[ANTIFLOOD_ENFORCE_KLINE]   = { &antiflood_enforce_kline },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\n#define METADATA_KEY_ENFORCE_METHOD\t\"private:antiflood:enforce-method\"\n\nstatic antiflood_enforce_method_t antiflood_enforce_method = ANTIFLOOD_ENFORCE_QUIET;\nstatic antiflood_enforce_method_impl_t antiflood_enforce_methods[ANTIFLOOD_ENFORCE_COUNT] = {\n\t[ANTIFLOOD_ENFORCE_QUIET]   = { &antiflood_enforce_quiet, &antiflood_unenforce_banlike },\n\t[ANTIFLOOD_ENFORCE_KICKBAN] = { &antiflood_enforce_kickban, &antiflood_unenforce_banlike },\n\t[ANTIFLOOD_ENFORCE_KLINE]   = { &antiflood_enforce_kline },\n};\n\nstatic inline antiflood_enforce_method_impl_t *\nantiflood_enforce_method_impl_get(mychan_t *mc)\n{\n\tmetadata_t *md;\n\n\tmd = metadata_find(mc, METADATA_KEY_ENFORCE_METHOD);\n\tif (md != NULL)\n\t{\n\t\tif (!strcasecmp(md->value, \"QUIET\"))\n\t\t\treturn &antiflood_enforce_methods[ANTIFLOOD_ENFORCE_QUIET];\n\t\telse if (!strcasecmp(md->value, \"KICKBAN\"))\n\t\t\treturn &antiflood_enforce_methods[ANTIFLOOD_ENFORCE_KICKBAN];\n\t\telse if (!strcasecmp(md->value, \"AKILL\"))\n\t\t\treturn &antiflood_enforce_methods[ANTIFLOOD_ENFORCE_KLINE];\n\t}\n\n\treturn &antiflood_enforce_methods[antiflood_enforce_method];\n}"
        }
      },
      {
        "call_info": {
          "callee": "mqueue_should_enforce",
          "args": [
            "mq"
          ],
          "line": 377
        },
        "resolved": true,
        "details": {
          "function_name": "mqueue_should_enforce",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
          "lines": "174-222",
          "snippet": "static mqueue_enforce_strategy_t\nmqueue_should_enforce(mqueue_t *mq)\n{\n\tmsg_t *oldest, *newest;\n\ttime_t age_delta;\n\n\tif (MOWGLI_LIST_LENGTH(&mq->entries) < mq->max)\n\t\treturn MQ_ENFORCE_NONE;\n\n\toldest = mq->entries.head->data;\n\tnewest = mq->entries.tail->data;\n\n\tif (oldest == NULL || newest == NULL || oldest == newest)\n\t\treturn MQ_ENFORCE_NONE;\n\n\tage_delta = newest->time - oldest->time;\n\n\tif (age_delta <= antiflood_msg_time)\n\t{\n\t\tmowgli_node_t *n;\n\t\tsize_t msg_matches = 0, usr_matches = 0;\n\t\ttime_t usr_first_seen = 0;\n\n\t\tMOWGLI_ITER_FOREACH(n, mq->entries.head)\n\t\t{\n\t\t\tmsg_t *msg = n->data;\n\n\t\t\tif (!strcasecmp(msg->message, newest->message))\n\t\t\t\tmsg_matches++;\n\n\t\t\tif (msg->source == newest->source)\n\t\t\t{\n\t\t\t\tusr_matches++;\n\n\t\t\t\tif (!usr_first_seen)\n\t\t\t\t\tusr_first_seen = msg->time;\n\t\t\t}\n\t\t}\n\n\t\tif (msg_matches > (antiflood_msg_count / 2))\n\t\t\treturn MQ_ENFORCE_MSG;\n\n\t\tif (usr_matches > (antiflood_msg_count / 2) &&\n\t\t\t((newest->time - usr_first_seen) < antiflood_msg_time / 4))\n\t\t\treturn MQ_ENFORCE_LINE;\n\t}\n\n\treturn MQ_ENFORCE_NONE;\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int antiflood_msg_time = 60;",
            "static int antiflood_msg_count = 10;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic int antiflood_msg_time = 60;\nstatic int antiflood_msg_count = 10;\n\nstatic mqueue_enforce_strategy_t\nmqueue_should_enforce(mqueue_t *mq)\n{\n\tmsg_t *oldest, *newest;\n\ttime_t age_delta;\n\n\tif (MOWGLI_LIST_LENGTH(&mq->entries) < mq->max)\n\t\treturn MQ_ENFORCE_NONE;\n\n\toldest = mq->entries.head->data;\n\tnewest = mq->entries.tail->data;\n\n\tif (oldest == NULL || newest == NULL || oldest == newest)\n\t\treturn MQ_ENFORCE_NONE;\n\n\tage_delta = newest->time - oldest->time;\n\n\tif (age_delta <= antiflood_msg_time)\n\t{\n\t\tmowgli_node_t *n;\n\t\tsize_t msg_matches = 0, usr_matches = 0;\n\t\ttime_t usr_first_seen = 0;\n\n\t\tMOWGLI_ITER_FOREACH(n, mq->entries.head)\n\t\t{\n\t\t\tmsg_t *msg = n->data;\n\n\t\t\tif (!strcasecmp(msg->message, newest->message))\n\t\t\t\tmsg_matches++;\n\n\t\t\tif (msg->source == newest->source)\n\t\t\t{\n\t\t\t\tusr_matches++;\n\n\t\t\t\tif (!usr_first_seen)\n\t\t\t\t\tusr_first_seen = msg->time;\n\t\t\t}\n\t\t}\n\n\t\tif (msg_matches > (antiflood_msg_count / 2))\n\t\t\treturn MQ_ENFORCE_MSG;\n\n\t\tif (usr_matches > (antiflood_msg_count / 2) &&\n\t\t\t((newest->time - usr_first_seen) < antiflood_msg_time / 4))\n\t\t\treturn MQ_ENFORCE_LINE;\n\t}\n\n\treturn MQ_ENFORCE_NONE;\n}"
        }
      },
      {
        "call_info": {
          "callee": "msg_create",
          "args": [
            "mq",
            "data->u",
            "data->msg"
          ],
          "line": 367
        },
        "resolved": true,
        "details": {
          "function_name": "msg_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
          "lines": "76-96",
          "snippet": "static msg_t *\nmsg_create(mqueue_t *mq, user_t *u, const char *message)\n{\n\tmsg_t *msg;\n\n\tmsg = mowgli_heap_alloc(msg_heap);\n\tmsg->message = sstrdup(message);\n\tmsg->time = CURRTIME;\n\tmsg->source = u->uid != NULL ? strshare_ref(u->uid) : strshare_ref(u->nick);\n\n\tif (MOWGLI_LIST_LENGTH(&mq->entries) > mq->max)\n\t{\n\t\tmsg_t *head_msg = mq->entries.head->data;\n\t\tmsg_destroy(head_msg, mq);\n\t}\n\n\tmowgli_node_add(msg, &msg->node, &mq->entries);\n\tmq->last_used = CURRTIME;\n\n\treturn msg;\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static mowgli_heap_t *msg_heap = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic mowgli_heap_t *msg_heap = NULL;\n\nstatic msg_t *\nmsg_create(mqueue_t *mq, user_t *u, const char *message)\n{\n\tmsg_t *msg;\n\n\tmsg = mowgli_heap_alloc(msg_heap);\n\tmsg->message = sstrdup(message);\n\tmsg->time = CURRTIME;\n\tmsg->source = u->uid != NULL ? strshare_ref(u->uid) : strshare_ref(u->nick);\n\n\tif (MOWGLI_LIST_LENGTH(&mq->entries) > mq->max)\n\t{\n\t\tmsg_t *head_msg = mq->entries.head->data;\n\t\tmsg_destroy(head_msg, mq);\n\t}\n\n\tmowgli_node_add(msg, &msg->node, &mq->entries);\n\tmq->last_used = CURRTIME;\n\n\treturn msg;\n}"
        }
      },
      {
        "call_info": {
          "callee": "return_if_fail",
          "args": [
            "mq != NULL"
          ],
          "line": 365
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mqueue_get",
          "args": [
            "mc"
          ],
          "line": 364
        },
        "resolved": true,
        "details": {
          "function_name": "mqueue_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
          "lines": "133-143",
          "snippet": "static mqueue_t *\nmqueue_get(mychan_t *mc)\n{\n\tmqueue_t *mq;\n\n\tmq = mowgli_patricia_retrieve(mqueue_trie, mc->name);\n\tif (mq == NULL)\n\t\tmq = mqueue_create(mc->name);\n\n\treturn mq;\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static mowgli_patricia_t *mqueue_trie = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic mowgli_patricia_t *mqueue_trie = NULL;\n\nstatic mqueue_t *\nmqueue_get(mychan_t *mc)\n{\n\tmqueue_t *mq;\n\n\tmq = mowgli_patricia_retrieve(mqueue_trie, mc->name);\n\tif (mq == NULL)\n\t\tmq = mqueue_create(mc->name);\n\n\treturn mq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mychan_from",
          "args": [
            "data->c"
          ],
          "line": 360
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanuser_find",
          "args": [
            "data->c",
            "data->u"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "return_if_fail",
          "args": [
            "data->c != NULL"
          ],
          "line": 354
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "return_if_fail",
          "args": [
            "data->u != NULL"
          ],
          "line": 353
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "return_if_fail",
          "args": [
            "data->msg != NULL"
          ],
          "line": 352
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "return_if_fail",
          "args": [
            "data != NULL"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic void\non_channel_message(hook_cmessage_data_t *data)\n{\n\tchanuser_t *cu;\n\tmychan_t *mc;\n\tmqueue_t *mq;\n\tmsg_t *msg;\n\n\treturn_if_fail(data != NULL);\n\treturn_if_fail(data->msg != NULL);\n\treturn_if_fail(data->u != NULL);\n\treturn_if_fail(data->c != NULL);\n\n\tcu = chanuser_find(data->c, data->u);\n\tif (cu == NULL)\n\t\treturn;\n\n\tmc = mychan_from(data->c);\n\tif (mc == NULL)\n\t\treturn;\n\n\tmq = mqueue_get(mc);\n\treturn_if_fail(mq != NULL);\n\n\tmsg = msg_create(mq, data->u, data->msg);\n\n\t/* never enforce against any user who has special CSTATUS flags. */\n\tif (cu->modes)\n\t\treturn;\n\n\t/* do not enforce unless enforcement is specifically enabled */\n\tif (!(mc->flags & MC_ANTIFLOOD))\n\t\treturn;\n\n\tif (mqueue_should_enforce(mq) != MQ_ENFORCE_NONE)\n\t{\n\t\tantiflood_enforce_method_impl_t *enf = antiflood_enforce_method_impl_get(mc);\n\n\t\tif (enf == NULL || enf->enforce == NULL)\n\t\t\treturn;\n\n\t\tenf->enforce(data->u, data->c);\n\t}\n}"
  },
  {
    "function_name": "antiflood_unenforce_timer_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
    "lines": "323-339",
    "snippet": "static void\nantiflood_unenforce_timer_cb(void *unused)\n{\n\tmowgli_patricia_iteration_state_t state;\n\tmychan_t *mc;\n\n\tMOWGLI_PATRICIA_FOREACH(mc, &state, mclist)\n\t{\n\t\tantiflood_enforce_method_impl_t *enf = antiflood_enforce_method_impl_get(mc);\n\n\t\tif (mc->chan == NULL)\n\t\t\tcontinue;\n\n\t\tif (enf->unenforce != NULL)\n\t\t\tenf->unenforce(mc->chan);\n\t}\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "enf->unenforce",
          "args": [
            "mc->chan"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "antiflood_enforce_method_impl_get",
          "args": [
            "mc"
          ],
          "line": 331
        },
        "resolved": true,
        "details": {
          "function_name": "antiflood_enforce_method_impl_get",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
          "lines": "304-321",
          "snippet": "static inline antiflood_enforce_method_impl_t *\nantiflood_enforce_method_impl_get(mychan_t *mc)\n{\n\tmetadata_t *md;\n\n\tmd = metadata_find(mc, METADATA_KEY_ENFORCE_METHOD);\n\tif (md != NULL)\n\t{\n\t\tif (!strcasecmp(md->value, \"QUIET\"))\n\t\t\treturn &antiflood_enforce_methods[ANTIFLOOD_ENFORCE_QUIET];\n\t\telse if (!strcasecmp(md->value, \"KICKBAN\"))\n\t\t\treturn &antiflood_enforce_methods[ANTIFLOOD_ENFORCE_KICKBAN];\n\t\telse if (!strcasecmp(md->value, \"AKILL\"))\n\t\t\treturn &antiflood_enforce_methods[ANTIFLOOD_ENFORCE_KLINE];\n\t}\n\n\treturn &antiflood_enforce_methods[antiflood_enforce_method];\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [
            "#define METADATA_KEY_ENFORCE_METHOD\t\"private:antiflood:enforce-method\""
          ],
          "globals_used": [
            "static antiflood_enforce_method_t antiflood_enforce_method = ANTIFLOOD_ENFORCE_QUIET;",
            "static antiflood_enforce_method_impl_t antiflood_enforce_methods[ANTIFLOOD_ENFORCE_COUNT] = {\n\t[ANTIFLOOD_ENFORCE_QUIET]   = { &antiflood_enforce_quiet, &antiflood_unenforce_banlike },\n\t[ANTIFLOOD_ENFORCE_KICKBAN] = { &antiflood_enforce_kickban, &antiflood_unenforce_banlike },\n\t[ANTIFLOOD_ENFORCE_KLINE]   = { &antiflood_enforce_kline },\n};"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\n#define METADATA_KEY_ENFORCE_METHOD\t\"private:antiflood:enforce-method\"\n\nstatic antiflood_enforce_method_t antiflood_enforce_method = ANTIFLOOD_ENFORCE_QUIET;\nstatic antiflood_enforce_method_impl_t antiflood_enforce_methods[ANTIFLOOD_ENFORCE_COUNT] = {\n\t[ANTIFLOOD_ENFORCE_QUIET]   = { &antiflood_enforce_quiet, &antiflood_unenforce_banlike },\n\t[ANTIFLOOD_ENFORCE_KICKBAN] = { &antiflood_enforce_kickban, &antiflood_unenforce_banlike },\n\t[ANTIFLOOD_ENFORCE_KLINE]   = { &antiflood_enforce_kline },\n};\n\nstatic inline antiflood_enforce_method_impl_t *\nantiflood_enforce_method_impl_get(mychan_t *mc)\n{\n\tmetadata_t *md;\n\n\tmd = metadata_find(mc, METADATA_KEY_ENFORCE_METHOD);\n\tif (md != NULL)\n\t{\n\t\tif (!strcasecmp(md->value, \"QUIET\"))\n\t\t\treturn &antiflood_enforce_methods[ANTIFLOOD_ENFORCE_QUIET];\n\t\telse if (!strcasecmp(md->value, \"KICKBAN\"))\n\t\t\treturn &antiflood_enforce_methods[ANTIFLOOD_ENFORCE_KICKBAN];\n\t\telse if (!strcasecmp(md->value, \"AKILL\"))\n\t\t\treturn &antiflood_enforce_methods[ANTIFLOOD_ENFORCE_KLINE];\n\t}\n\n\treturn &antiflood_enforce_methods[antiflood_enforce_method];\n}"
        }
      },
      {
        "call_info": {
          "callee": "MOWGLI_PATRICIA_FOREACH",
          "args": [
            "mc",
            "&state",
            "mclist"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic void\nantiflood_unenforce_timer_cb(void *unused)\n{\n\tmowgli_patricia_iteration_state_t state;\n\tmychan_t *mc;\n\n\tMOWGLI_PATRICIA_FOREACH(mc, &state, mclist)\n\t{\n\t\tantiflood_enforce_method_impl_t *enf = antiflood_enforce_method_impl_get(mc);\n\n\t\tif (mc->chan == NULL)\n\t\t\tcontinue;\n\n\t\tif (enf->unenforce != NULL)\n\t\t\tenf->unenforce(mc->chan);\n\t}\n}"
  },
  {
    "function_name": "antiflood_enforce_method_impl_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
    "lines": "304-321",
    "snippet": "static inline antiflood_enforce_method_impl_t *\nantiflood_enforce_method_impl_get(mychan_t *mc)\n{\n\tmetadata_t *md;\n\n\tmd = metadata_find(mc, METADATA_KEY_ENFORCE_METHOD);\n\tif (md != NULL)\n\t{\n\t\tif (!strcasecmp(md->value, \"QUIET\"))\n\t\t\treturn &antiflood_enforce_methods[ANTIFLOOD_ENFORCE_QUIET];\n\t\telse if (!strcasecmp(md->value, \"KICKBAN\"))\n\t\t\treturn &antiflood_enforce_methods[ANTIFLOOD_ENFORCE_KICKBAN];\n\t\telse if (!strcasecmp(md->value, \"AKILL\"))\n\t\t\treturn &antiflood_enforce_methods[ANTIFLOOD_ENFORCE_KLINE];\n\t}\n\n\treturn &antiflood_enforce_methods[antiflood_enforce_method];\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [
      "#define METADATA_KEY_ENFORCE_METHOD\t\"private:antiflood:enforce-method\""
    ],
    "globals_used": [
      "static antiflood_enforce_method_t antiflood_enforce_method = ANTIFLOOD_ENFORCE_QUIET;",
      "static antiflood_enforce_method_impl_t antiflood_enforce_methods[ANTIFLOOD_ENFORCE_COUNT] = {\n\t[ANTIFLOOD_ENFORCE_QUIET]   = { &antiflood_enforce_quiet, &antiflood_unenforce_banlike },\n\t[ANTIFLOOD_ENFORCE_KICKBAN] = { &antiflood_enforce_kickban, &antiflood_unenforce_banlike },\n\t[ANTIFLOOD_ENFORCE_KLINE]   = { &antiflood_enforce_kline },\n};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "md->value",
            "\"AKILL\""
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "md->value",
            "\"KICKBAN\""
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "md->value",
            "\"QUIET\""
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "METADATA_KEY_ENFORCE_METHOD"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\n#define METADATA_KEY_ENFORCE_METHOD\t\"private:antiflood:enforce-method\"\n\nstatic antiflood_enforce_method_t antiflood_enforce_method = ANTIFLOOD_ENFORCE_QUIET;\nstatic antiflood_enforce_method_impl_t antiflood_enforce_methods[ANTIFLOOD_ENFORCE_COUNT] = {\n\t[ANTIFLOOD_ENFORCE_QUIET]   = { &antiflood_enforce_quiet, &antiflood_unenforce_banlike },\n\t[ANTIFLOOD_ENFORCE_KICKBAN] = { &antiflood_enforce_kickban, &antiflood_unenforce_banlike },\n\t[ANTIFLOOD_ENFORCE_KLINE]   = { &antiflood_enforce_kline },\n};\n\nstatic inline antiflood_enforce_method_impl_t *\nantiflood_enforce_method_impl_get(mychan_t *mc)\n{\n\tmetadata_t *md;\n\n\tmd = metadata_find(mc, METADATA_KEY_ENFORCE_METHOD);\n\tif (md != NULL)\n\t{\n\t\tif (!strcasecmp(md->value, \"QUIET\"))\n\t\t\treturn &antiflood_enforce_methods[ANTIFLOOD_ENFORCE_QUIET];\n\t\telse if (!strcasecmp(md->value, \"KICKBAN\"))\n\t\t\treturn &antiflood_enforce_methods[ANTIFLOOD_ENFORCE_KICKBAN];\n\t\telse if (!strcasecmp(md->value, \"AKILL\"))\n\t\t\treturn &antiflood_enforce_methods[ANTIFLOOD_ENFORCE_KLINE];\n\t}\n\n\treturn &antiflood_enforce_methods[antiflood_enforce_method];\n}"
  },
  {
    "function_name": "antiflood_enforce_kline",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
    "lines": "286-291",
    "snippet": "static void\nantiflood_enforce_kline(user_t *u, channel_t *c)\n{\n\tkline_add_user(u, \"Flooding\", 86400, chansvs.nick);\n\tslog(LG_INFO, \"ANTIFLOOD:ENFORCE:AKILL: \\2%s!%s@%s\\2 from \\2%s\\2\", u->nick, u->user, u->vhost, c->name);\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slog",
          "args": [
            "LG_INFO",
            "\"ANTIFLOOD:ENFORCE:AKILL: \\2%s!%s@%s\\2 from \\2%s\\2\"",
            "u->nick",
            "u->user",
            "u->vhost",
            "c->name"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kline_add_user",
          "args": [
            "u",
            "\"Flooding\"",
            "86400",
            "chansvs.nick"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic void\nantiflood_enforce_kline(user_t *u, channel_t *c)\n{\n\tkline_add_user(u, \"Flooding\", 86400, chansvs.nick);\n\tslog(LG_INFO, \"ANTIFLOOD:ENFORCE:AKILL: \\2%s!%s@%s\\2 from \\2%s\\2\", u->nick, u->user, u->vhost, c->name);\n}"
  },
  {
    "function_name": "antiflood_enforce_kickban",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
    "lines": "263-284",
    "snippet": "static void\nantiflood_enforce_kickban(user_t *u, channel_t *c)\n{\n\tchanban_t *cb;\n\n\tban(chansvs.me->me, c, u);\n\tremove_ban_exceptions(chansvs.me->me, c, u);\n\ttry_kick(chansvs.me->me, c, u, \"Flooding\");\n\n\t/* poison tail */\n\tif (c->bans.tail != NULL)\n\t{\n\t\tcb = c->bans.tail->data;\n\t\tcb->flags |= CBAN_ANTIFLOOD;\n\t}\n\telse if (c->bans.head != NULL)\n\t{\n\t\tcb = c->bans.head->data;\n\t\tcb->flags |= CBAN_ANTIFLOOD;\n\t}\n\tslog(LG_INFO, \"ANTIFLOOD:ENFORCE:KICKBAN: \\2%s!%s@%s\\2 from \\2%s\\2\", u->nick, u->user, u->vhost, c->name);\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "slog",
          "args": [
            "LG_INFO",
            "\"ANTIFLOOD:ENFORCE:KICKBAN: \\2%s!%s@%s\\2 from \\2%s\\2\"",
            "u->nick",
            "u->user",
            "u->vhost",
            "c->name"
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_kick",
          "args": [
            "chansvs.me->me",
            "c",
            "u",
            "\"Flooding\""
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_ban_exceptions",
          "args": [
            "chansvs.me->me",
            "c",
            "u"
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ban",
          "args": [
            "chansvs.me->me",
            "c",
            "u"
          ],
          "line": 268
        },
        "resolved": true,
        "details": {
          "function_name": "cs_cmd_unban",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/ban.c",
          "lines": "111-204",
          "snippet": "static void cs_cmd_unban(sourceinfo_t *si, int parc, char *parv[])\n{\n        const char *channel = parv[0];\n        const char *target = parv[1];\n        channel_t *c = channel_find(channel);\n\tmychan_t *mc = mychan_find(channel);\n\tuser_t *tu;\n\tchanban_t *cb;\n\n\tif (!channel)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"UNBAN\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: UNBAN <#channel> <nickname|hostmask>\"));\n\t\treturn;\n\t}\n\n\tif (!target)\n\t{\n\t\tif (si->su == NULL)\n\t\t{\n\t\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"UNBAN\");\n\t\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: UNBAN <#channel> <nickname|hostmask>\"));\n\t\t\treturn;\n\t\t}\n\t\ttarget = si->su->nick;\n\t}\n\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), channel);\n\t\treturn;\n\t}\n\n\tif (!c)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is currently empty.\"), channel);\n\t\treturn;\n\t}\n\n\tif (!chanacs_source_has_flag(mc, si, CA_REMOVE) &&\n\t\t\t(si->su == NULL ||\n\t\t\t !chanacs_source_has_flag(mc, si, CA_EXEMPT) ||\n\t\t\t irccasecmp(target, si->su->nick)))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\treturn;\n\t}\n\n\tif ((tu = user_find_named(target)))\n\t{\n\t\tmowgli_node_t *n, *tn;\n\t\tchar hostbuf2[BUFSIZE];\n\t\tint count = 0;\n\n\t\tsnprintf(hostbuf2, BUFSIZE, \"%s!%s@%s\", tu->nick, tu->user, tu->vhost);\n\t\tfor (n = next_matching_ban(c, tu, 'b', c->bans.head); n != NULL; n = next_matching_ban(c, tu, 'b', tn))\n\t\t{\n\t\t\ttn = n->next;\n\t\t\tcb = n->data;\n\n\t\t\tlogcommand(si, CMDLOG_DO, \"UNBAN: \\2%s\\2 on \\2%s\\2 (for user \\2%s\\2)\", cb->mask, mc->name, hostbuf2);\n\t\t\tmodestack_mode_param(chansvs.nick, c, MTYPE_DEL, cb->type, cb->mask);\n\t\t\tchanban_delete(cb);\n\t\t\tcount++;\n\t\t}\n\t\tif (count > 0)\n\t\t\tcommand_success_nodata(si, _(\"Unbanned \\2%s\\2 on \\2%s\\2 (%d ban%s removed).\"),\n\t\t\t\ttarget, channel, count, (count != 1 ? \"s\" : \"\"));\n\t\telse\n\t\t\tcommand_success_nodata(si, _(\"No bans found matching \\2%s\\2 on \\2%s\\2.\"), target, channel);\n\t\treturn;\n\t}\n\telse if ((cb = chanban_find(c, target, 'b')) != NULL || validhostmask(target))\n\t{\n\t\tif (cb)\n\t\t{\n\t\t\tmodestack_mode_param(chansvs.nick, c, MTYPE_DEL, 'b', target);\n\t\t\tchanban_delete(cb);\n\t\t\tlogcommand(si, CMDLOG_DO, \"UNBAN: \\2%s\\2 on \\2%s\\2\", target, mc->name);\n\t\t\tif (si->su == NULL || !chanuser_find(mc->chan, si->su))\n\t\t\t\tcommand_success_nodata(si, _(\"Unbanned \\2%s\\2 on \\2%s\\2.\"), target, channel);\n\t\t}\n\t\telse\n\t\t\tcommand_fail(si, fault_nosuch_key, _(\"No such ban \\2%s\\2 on \\2%s\\2.\"), target, channel);\n\n\t\treturn;\n\t}\n        else\n        {\n\t\tcommand_fail(si, fault_badparams, _(\"Invalid nickname/hostmask provided: \\2%s\\2\"), target);\n\t\tcommand_fail(si, fault_badparams, _(\"Syntax: UNBAN <#channel> [nickname|hostmask]\"));\n\t\treturn;\n        }\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cs_cmd_ban(sourceinfo_t *si, int parc, char *parv[]);",
            "static void cs_cmd_unban(sourceinfo_t *si, int parc, char *parv[]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic void cs_cmd_ban(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_unban(sourceinfo_t *si, int parc, char *parv[]);\n\nstatic void cs_cmd_unban(sourceinfo_t *si, int parc, char *parv[])\n{\n        const char *channel = parv[0];\n        const char *target = parv[1];\n        channel_t *c = channel_find(channel);\n\tmychan_t *mc = mychan_find(channel);\n\tuser_t *tu;\n\tchanban_t *cb;\n\n\tif (!channel)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"UNBAN\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: UNBAN <#channel> <nickname|hostmask>\"));\n\t\treturn;\n\t}\n\n\tif (!target)\n\t{\n\t\tif (si->su == NULL)\n\t\t{\n\t\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"UNBAN\");\n\t\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: UNBAN <#channel> <nickname|hostmask>\"));\n\t\t\treturn;\n\t\t}\n\t\ttarget = si->su->nick;\n\t}\n\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), channel);\n\t\treturn;\n\t}\n\n\tif (!c)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is currently empty.\"), channel);\n\t\treturn;\n\t}\n\n\tif (!chanacs_source_has_flag(mc, si, CA_REMOVE) &&\n\t\t\t(si->su == NULL ||\n\t\t\t !chanacs_source_has_flag(mc, si, CA_EXEMPT) ||\n\t\t\t irccasecmp(target, si->su->nick)))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\treturn;\n\t}\n\n\tif ((tu = user_find_named(target)))\n\t{\n\t\tmowgli_node_t *n, *tn;\n\t\tchar hostbuf2[BUFSIZE];\n\t\tint count = 0;\n\n\t\tsnprintf(hostbuf2, BUFSIZE, \"%s!%s@%s\", tu->nick, tu->user, tu->vhost);\n\t\tfor (n = next_matching_ban(c, tu, 'b', c->bans.head); n != NULL; n = next_matching_ban(c, tu, 'b', tn))\n\t\t{\n\t\t\ttn = n->next;\n\t\t\tcb = n->data;\n\n\t\t\tlogcommand(si, CMDLOG_DO, \"UNBAN: \\2%s\\2 on \\2%s\\2 (for user \\2%s\\2)\", cb->mask, mc->name, hostbuf2);\n\t\t\tmodestack_mode_param(chansvs.nick, c, MTYPE_DEL, cb->type, cb->mask);\n\t\t\tchanban_delete(cb);\n\t\t\tcount++;\n\t\t}\n\t\tif (count > 0)\n\t\t\tcommand_success_nodata(si, _(\"Unbanned \\2%s\\2 on \\2%s\\2 (%d ban%s removed).\"),\n\t\t\t\ttarget, channel, count, (count != 1 ? \"s\" : \"\"));\n\t\telse\n\t\t\tcommand_success_nodata(si, _(\"No bans found matching \\2%s\\2 on \\2%s\\2.\"), target, channel);\n\t\treturn;\n\t}\n\telse if ((cb = chanban_find(c, target, 'b')) != NULL || validhostmask(target))\n\t{\n\t\tif (cb)\n\t\t{\n\t\t\tmodestack_mode_param(chansvs.nick, c, MTYPE_DEL, 'b', target);\n\t\t\tchanban_delete(cb);\n\t\t\tlogcommand(si, CMDLOG_DO, \"UNBAN: \\2%s\\2 on \\2%s\\2\", target, mc->name);\n\t\t\tif (si->su == NULL || !chanuser_find(mc->chan, si->su))\n\t\t\t\tcommand_success_nodata(si, _(\"Unbanned \\2%s\\2 on \\2%s\\2.\"), target, channel);\n\t\t}\n\t\telse\n\t\t\tcommand_fail(si, fault_nosuch_key, _(\"No such ban \\2%s\\2 on \\2%s\\2.\"), target, channel);\n\n\t\treturn;\n\t}\n        else\n        {\n\t\tcommand_fail(si, fault_badparams, _(\"Invalid nickname/hostmask provided: \\2%s\\2\"), target);\n\t\tcommand_fail(si, fault_badparams, _(\"Syntax: UNBAN <#channel> [nickname|hostmask]\"));\n\t\treturn;\n        }\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic void\nantiflood_enforce_kickban(user_t *u, channel_t *c)\n{\n\tchanban_t *cb;\n\n\tban(chansvs.me->me, c, u);\n\tremove_ban_exceptions(chansvs.me->me, c, u);\n\ttry_kick(chansvs.me->me, c, u, \"Flooding\");\n\n\t/* poison tail */\n\tif (c->bans.tail != NULL)\n\t{\n\t\tcb = c->bans.tail->data;\n\t\tcb->flags |= CBAN_ANTIFLOOD;\n\t}\n\telse if (c->bans.head != NULL)\n\t{\n\t\tcb = c->bans.head->data;\n\t\tcb->flags |= CBAN_ANTIFLOOD;\n\t}\n\tslog(LG_INFO, \"ANTIFLOOD:ENFORCE:KICKBAN: \\2%s!%s@%s\\2 from \\2%s\\2\", u->nick, u->user, u->vhost, c->name);\n}"
  },
  {
    "function_name": "antiflood_unenforce_banlike",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
    "lines": "246-261",
    "snippet": "static void\nantiflood_unenforce_banlike(channel_t *c)\n{\n\tmowgli_node_t *n, *tn;\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, c->bans.head)\n\t{\n\t\tchanban_t *cb = n->data;\n\n\t\tif (!(cb->flags & CBAN_ANTIFLOOD))\n\t\t\tcontinue;\n\n\t\tmodestack_mode_param(chansvs.nick, c, MTYPE_DEL, cb->type, cb->mask);\n\t\tchanban_delete(cb);\n\t}\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "chanban_delete",
          "args": [
            "cb"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modestack_mode_param",
          "args": [
            "chansvs.nick",
            "c",
            "MTYPE_DEL",
            "cb->type",
            "cb->mask"
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_ITER_FOREACH_SAFE",
          "args": [
            "n",
            "tn",
            "c->bans.head"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic void\nantiflood_unenforce_banlike(channel_t *c)\n{\n\tmowgli_node_t *n, *tn;\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, c->bans.head)\n\t{\n\t\tchanban_t *cb = n->data;\n\n\t\tif (!(cb->flags & CBAN_ANTIFLOOD))\n\t\t\tcontinue;\n\n\t\tmodestack_mode_param(chansvs.nick, c, MTYPE_DEL, cb->type, cb->mask);\n\t\tchanban_delete(cb);\n\t}\n}"
  },
  {
    "function_name": "antiflood_enforce_quiet",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
    "lines": "227-244",
    "snippet": "static void\nantiflood_enforce_quiet(user_t *u, channel_t *c)\n{\n\tchar hostbuf[BUFSIZE];\n\n\tmowgli_strlcpy(hostbuf, \"*!*@\", sizeof hostbuf);\n\tmowgli_strlcat(hostbuf, u->vhost, sizeof hostbuf);\n\n\tif (place_quietmask != NULL)\n\t{\n\t\tchanban_t *cb;\n\n\t\tcb = place_quietmask(c, MTYPE_ADD, hostbuf);\n\t\tif (cb != NULL)\n\t\t\tcb->flags |= CBAN_ANTIFLOOD;\n\tslog(LG_INFO, \"ANTIFLOOD:ENFORCE:QUIET: \\2%s!%s@%s\\2 on \\2%s\\2\", u->nick, u->user, u->vhost, c->name);\n\t}\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static chanban_t *(*place_quietmask)(channel_t *c, int dir, const char *hostbuf) = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slog",
          "args": [
            "LG_INFO",
            "\"ANTIFLOOD:ENFORCE:QUIET: \\2%s!%s@%s\\2 on \\2%s\\2\"",
            "u->nick",
            "u->user",
            "u->vhost",
            "c->name"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "place_quietmask",
          "args": [
            "c",
            "MTYPE_ADD",
            "hostbuf"
          ],
          "line": 239
        },
        "resolved": true,
        "details": {
          "function_name": "place_quietmask",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/quiet.c",
          "lines": "75-87",
          "snippet": "chanban_t *place_quietmask(channel_t *c, int dir, const char *hostbuf)\n{\n\tchar rhostbuf[BUFSIZE];\n\tchanban_t *cb = NULL;\n\tchar banlike_char = get_quiet_ban_char();\n\n\tmake_extbanmask(rhostbuf, sizeof rhostbuf, hostbuf);\n\tmodestack_mode_param(chansvs.nick, c, MTYPE_ADD, banlike_char,\n\t\t\trhostbuf);\n\tcb = chanban_add(c, rhostbuf, banlike_char);\n\n\treturn cb;\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"atheme.h\"\n\nchanban_t *place_quietmask(channel_t *c, int dir, const char *hostbuf)\n{\n\tchar rhostbuf[BUFSIZE];\n\tchanban_t *cb = NULL;\n\tchar banlike_char = get_quiet_ban_char();\n\n\tmake_extbanmask(rhostbuf, sizeof rhostbuf, hostbuf);\n\tmodestack_mode_param(chansvs.nick, c, MTYPE_ADD, banlike_char,\n\t\t\trhostbuf);\n\tcb = chanban_add(c, rhostbuf, banlike_char);\n\n\treturn cb;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mowgli_strlcat",
          "args": [
            "hostbuf",
            "u->vhost",
            "sizeof hostbuf"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcpy",
          "args": [
            "hostbuf",
            "\"*!*@\"",
            "sizeof hostbuf"
          ],
          "line": 232
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic chanban_t *(*place_quietmask)(channel_t *c, int dir, const char *hostbuf) = NULL;\n\nstatic void\nantiflood_enforce_quiet(user_t *u, channel_t *c)\n{\n\tchar hostbuf[BUFSIZE];\n\n\tmowgli_strlcpy(hostbuf, \"*!*@\", sizeof hostbuf);\n\tmowgli_strlcat(hostbuf, u->vhost, sizeof hostbuf);\n\n\tif (place_quietmask != NULL)\n\t{\n\t\tchanban_t *cb;\n\n\t\tcb = place_quietmask(c, MTYPE_ADD, hostbuf);\n\t\tif (cb != NULL)\n\t\t\tcb->flags |= CBAN_ANTIFLOOD;\n\tslog(LG_INFO, \"ANTIFLOOD:ENFORCE:QUIET: \\2%s!%s@%s\\2 on \\2%s\\2\", u->nick, u->user, u->vhost, c->name);\n\t}\n}"
  },
  {
    "function_name": "mqueue_should_enforce",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
    "lines": "174-222",
    "snippet": "static mqueue_enforce_strategy_t\nmqueue_should_enforce(mqueue_t *mq)\n{\n\tmsg_t *oldest, *newest;\n\ttime_t age_delta;\n\n\tif (MOWGLI_LIST_LENGTH(&mq->entries) < mq->max)\n\t\treturn MQ_ENFORCE_NONE;\n\n\toldest = mq->entries.head->data;\n\tnewest = mq->entries.tail->data;\n\n\tif (oldest == NULL || newest == NULL || oldest == newest)\n\t\treturn MQ_ENFORCE_NONE;\n\n\tage_delta = newest->time - oldest->time;\n\n\tif (age_delta <= antiflood_msg_time)\n\t{\n\t\tmowgli_node_t *n;\n\t\tsize_t msg_matches = 0, usr_matches = 0;\n\t\ttime_t usr_first_seen = 0;\n\n\t\tMOWGLI_ITER_FOREACH(n, mq->entries.head)\n\t\t{\n\t\t\tmsg_t *msg = n->data;\n\n\t\t\tif (!strcasecmp(msg->message, newest->message))\n\t\t\t\tmsg_matches++;\n\n\t\t\tif (msg->source == newest->source)\n\t\t\t{\n\t\t\t\tusr_matches++;\n\n\t\t\t\tif (!usr_first_seen)\n\t\t\t\t\tusr_first_seen = msg->time;\n\t\t\t}\n\t\t}\n\n\t\tif (msg_matches > (antiflood_msg_count / 2))\n\t\t\treturn MQ_ENFORCE_MSG;\n\n\t\tif (usr_matches > (antiflood_msg_count / 2) &&\n\t\t\t((newest->time - usr_first_seen) < antiflood_msg_time / 4))\n\t\t\treturn MQ_ENFORCE_LINE;\n\t}\n\n\treturn MQ_ENFORCE_NONE;\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int antiflood_msg_time = 60;",
      "static int antiflood_msg_count = 10;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "msg->message",
            "newest->message"
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_ITER_FOREACH",
          "args": [
            "n",
            "mq->entries.head"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_LIST_LENGTH",
          "args": [
            "&mq->entries"
          ],
          "line": 180
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic int antiflood_msg_time = 60;\nstatic int antiflood_msg_count = 10;\n\nstatic mqueue_enforce_strategy_t\nmqueue_should_enforce(mqueue_t *mq)\n{\n\tmsg_t *oldest, *newest;\n\ttime_t age_delta;\n\n\tif (MOWGLI_LIST_LENGTH(&mq->entries) < mq->max)\n\t\treturn MQ_ENFORCE_NONE;\n\n\toldest = mq->entries.head->data;\n\tnewest = mq->entries.tail->data;\n\n\tif (oldest == NULL || newest == NULL || oldest == newest)\n\t\treturn MQ_ENFORCE_NONE;\n\n\tage_delta = newest->time - oldest->time;\n\n\tif (age_delta <= antiflood_msg_time)\n\t{\n\t\tmowgli_node_t *n;\n\t\tsize_t msg_matches = 0, usr_matches = 0;\n\t\ttime_t usr_first_seen = 0;\n\n\t\tMOWGLI_ITER_FOREACH(n, mq->entries.head)\n\t\t{\n\t\t\tmsg_t *msg = n->data;\n\n\t\t\tif (!strcasecmp(msg->message, newest->message))\n\t\t\t\tmsg_matches++;\n\n\t\t\tif (msg->source == newest->source)\n\t\t\t{\n\t\t\t\tusr_matches++;\n\n\t\t\t\tif (!usr_first_seen)\n\t\t\t\t\tusr_first_seen = msg->time;\n\t\t\t}\n\t\t}\n\n\t\tif (msg_matches > (antiflood_msg_count / 2))\n\t\t\treturn MQ_ENFORCE_MSG;\n\n\t\tif (usr_matches > (antiflood_msg_count / 2) &&\n\t\t\t((newest->time - usr_first_seen) < antiflood_msg_time / 4))\n\t\t\treturn MQ_ENFORCE_LINE;\n\t}\n\n\treturn MQ_ENFORCE_NONE;\n}"
  },
  {
    "function_name": "mqueue_gc",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
    "lines": "161-172",
    "snippet": "static void\nmqueue_gc(void *unused)\n{\n\tmowgli_patricia_iteration_state_t iter;\n\tmqueue_t *mq;\n\n\tMOWGLI_PATRICIA_FOREACH(mq, &iter, mqueue_trie)\n\t{\n\t\tif ((mq->last_used + 3600) < CURRTIME)\n\t\t\tmqueue_destroy(mq);\n\t}\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static mowgli_patricia_t *mqueue_trie = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mqueue_destroy",
          "args": [
            "mq"
          ],
          "line": 170
        },
        "resolved": true,
        "details": {
          "function_name": "mqueue_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
          "lines": "145-151",
          "snippet": "static void\nmqueue_destroy(mqueue_t *mq)\n{\n\tmowgli_patricia_delete(mqueue_trie, mq->name);\n\n\tmqueue_free(mq);\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static mowgli_patricia_t *mqueue_trie = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic mowgli_patricia_t *mqueue_trie = NULL;\n\nstatic void\nmqueue_destroy(mqueue_t *mq)\n{\n\tmowgli_patricia_delete(mqueue_trie, mq->name);\n\n\tmqueue_free(mq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MOWGLI_PATRICIA_FOREACH",
          "args": [
            "mq",
            "&iter",
            "mqueue_trie"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic mowgli_patricia_t *mqueue_trie = NULL;\n\nstatic void\nmqueue_gc(void *unused)\n{\n\tmowgli_patricia_iteration_state_t iter;\n\tmqueue_t *mq;\n\n\tMOWGLI_PATRICIA_FOREACH(mq, &iter, mqueue_trie)\n\t{\n\t\tif ((mq->last_used + 3600) < CURRTIME)\n\t\t\tmqueue_destroy(mq);\n\t}\n}"
  },
  {
    "function_name": "mqueue_trie_destroy_cb",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
    "lines": "153-159",
    "snippet": "static void\nmqueue_trie_destroy_cb(const char *key, void *data, void *privdata)\n{\n\tmqueue_t *mq = data;\n\n\tmqueue_free(mq);\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "mqueue_free",
          "args": [
            "mq"
          ],
          "line": 158
        },
        "resolved": true,
        "details": {
          "function_name": "mqueue_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
          "lines": "117-131",
          "snippet": "static void\nmqueue_free(mqueue_t *mq)\n{\n\tmowgli_node_t *n, *tn;\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mq->entries.head)\n\t{\n\t\tmsg_t *msg = n->data;\n\n\t\tmsg_destroy(msg, mq);\n\t}\n\n\tfree(mq->name);\n\tmowgli_heap_free(mqueue_heap, mq);\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static mowgli_heap_t *mqueue_heap = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic mowgli_heap_t *mqueue_heap = NULL;\n\nstatic void\nmqueue_free(mqueue_t *mq)\n{\n\tmowgli_node_t *n, *tn;\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mq->entries.head)\n\t{\n\t\tmsg_t *msg = n->data;\n\n\t\tmsg_destroy(msg, mq);\n\t}\n\n\tfree(mq->name);\n\tmowgli_heap_free(mqueue_heap, mq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic void\nmqueue_trie_destroy_cb(const char *key, void *data, void *privdata)\n{\n\tmqueue_t *mq = data;\n\n\tmqueue_free(mq);\n}"
  },
  {
    "function_name": "mqueue_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
    "lines": "145-151",
    "snippet": "static void\nmqueue_destroy(mqueue_t *mq)\n{\n\tmowgli_patricia_delete(mqueue_trie, mq->name);\n\n\tmqueue_free(mq);\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static mowgli_patricia_t *mqueue_trie = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mqueue_free",
          "args": [
            "mq"
          ],
          "line": 150
        },
        "resolved": true,
        "details": {
          "function_name": "mqueue_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
          "lines": "117-131",
          "snippet": "static void\nmqueue_free(mqueue_t *mq)\n{\n\tmowgli_node_t *n, *tn;\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mq->entries.head)\n\t{\n\t\tmsg_t *msg = n->data;\n\n\t\tmsg_destroy(msg, mq);\n\t}\n\n\tfree(mq->name);\n\tmowgli_heap_free(mqueue_heap, mq);\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static mowgli_heap_t *mqueue_heap = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic mowgli_heap_t *mqueue_heap = NULL;\n\nstatic void\nmqueue_free(mqueue_t *mq)\n{\n\tmowgli_node_t *n, *tn;\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mq->entries.head)\n\t{\n\t\tmsg_t *msg = n->data;\n\n\t\tmsg_destroy(msg, mq);\n\t}\n\n\tfree(mq->name);\n\tmowgli_heap_free(mqueue_heap, mq);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mowgli_patricia_delete",
          "args": [
            "mqueue_trie",
            "mq->name"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic mowgli_patricia_t *mqueue_trie = NULL;\n\nstatic void\nmqueue_destroy(mqueue_t *mq)\n{\n\tmowgli_patricia_delete(mqueue_trie, mq->name);\n\n\tmqueue_free(mq);\n}"
  },
  {
    "function_name": "mqueue_get",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
    "lines": "133-143",
    "snippet": "static mqueue_t *\nmqueue_get(mychan_t *mc)\n{\n\tmqueue_t *mq;\n\n\tmq = mowgli_patricia_retrieve(mqueue_trie, mc->name);\n\tif (mq == NULL)\n\t\tmq = mqueue_create(mc->name);\n\n\treturn mq;\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static mowgli_patricia_t *mqueue_trie = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mqueue_create",
          "args": [
            "mc->name"
          ],
          "line": 140
        },
        "resolved": true,
        "details": {
          "function_name": "mqueue_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
          "lines": "102-115",
          "snippet": "static mqueue_t *\nmqueue_create(const char *name)\n{\n\tmqueue_t *mq;\n\n\tmq = mowgli_heap_alloc(mqueue_heap);\n\tmq->name = sstrdup(name);\n\tmq->last_used = CURRTIME;\n\tmq->max = antiflood_msg_count;\n\n\tmowgli_patricia_add(mqueue_trie, mq->name, mq);\n\n\treturn mq;\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static int antiflood_msg_count = 10;",
            "static mowgli_patricia_t *mqueue_trie = NULL;",
            "static mowgli_heap_t *mqueue_heap = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic int antiflood_msg_count = 10;\nstatic mowgli_patricia_t *mqueue_trie = NULL;\nstatic mowgli_heap_t *mqueue_heap = NULL;\n\nstatic mqueue_t *\nmqueue_create(const char *name)\n{\n\tmqueue_t *mq;\n\n\tmq = mowgli_heap_alloc(mqueue_heap);\n\tmq->name = sstrdup(name);\n\tmq->last_used = CURRTIME;\n\tmq->max = antiflood_msg_count;\n\n\tmowgli_patricia_add(mqueue_trie, mq->name, mq);\n\n\treturn mq;\n}"
        }
      },
      {
        "call_info": {
          "callee": "mowgli_patricia_retrieve",
          "args": [
            "mqueue_trie",
            "mc->name"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic mowgli_patricia_t *mqueue_trie = NULL;\n\nstatic mqueue_t *\nmqueue_get(mychan_t *mc)\n{\n\tmqueue_t *mq;\n\n\tmq = mowgli_patricia_retrieve(mqueue_trie, mc->name);\n\tif (mq == NULL)\n\t\tmq = mqueue_create(mc->name);\n\n\treturn mq;\n}"
  },
  {
    "function_name": "mqueue_free",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
    "lines": "117-131",
    "snippet": "static void\nmqueue_free(mqueue_t *mq)\n{\n\tmowgli_node_t *n, *tn;\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mq->entries.head)\n\t{\n\t\tmsg_t *msg = n->data;\n\n\t\tmsg_destroy(msg, mq);\n\t}\n\n\tfree(mq->name);\n\tmowgli_heap_free(mqueue_heap, mq);\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static mowgli_heap_t *mqueue_heap = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mowgli_heap_free",
          "args": [
            "mqueue_heap",
            "mq"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "mq->name"
          ],
          "line": 129
        },
        "resolved": true,
        "details": {
          "function_name": "mqueue_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
          "lines": "117-131",
          "snippet": "static void\nmqueue_free(mqueue_t *mq)\n{\n\tmowgli_node_t *n, *tn;\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mq->entries.head)\n\t{\n\t\tmsg_t *msg = n->data;\n\n\t\tmsg_destroy(msg, mq);\n\t}\n\n\tfree(mq->name);\n\tmowgli_heap_free(mqueue_heap, mq);\n}",
          "note": "cyclic_reference_detected"
        }
      },
      {
        "call_info": {
          "callee": "msg_destroy",
          "args": [
            "msg",
            "mq"
          ],
          "line": 126
        },
        "resolved": true,
        "details": {
          "function_name": "msg_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
          "lines": "66-74",
          "snippet": "static void\nmsg_destroy(msg_t *msg, mqueue_t *mq)\n{\n\tfree(msg->message);\n\tstrshare_unref(msg->source);\n\tmowgli_node_delete(&msg->node, &mq->entries);\n\n\tmowgli_heap_free(msg_heap, msg);\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static mowgli_heap_t *msg_heap = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic mowgli_heap_t *msg_heap = NULL;\n\nstatic void\nmsg_destroy(msg_t *msg, mqueue_t *mq)\n{\n\tfree(msg->message);\n\tstrshare_unref(msg->source);\n\tmowgli_node_delete(&msg->node, &mq->entries);\n\n\tmowgli_heap_free(msg_heap, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MOWGLI_ITER_FOREACH_SAFE",
          "args": [
            "n",
            "tn",
            "mq->entries.head"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic mowgli_heap_t *mqueue_heap = NULL;\n\nstatic void\nmqueue_free(mqueue_t *mq)\n{\n\tmowgli_node_t *n, *tn;\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mq->entries.head)\n\t{\n\t\tmsg_t *msg = n->data;\n\n\t\tmsg_destroy(msg, mq);\n\t}\n\n\tfree(mq->name);\n\tmowgli_heap_free(mqueue_heap, mq);\n}"
  },
  {
    "function_name": "mqueue_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
    "lines": "102-115",
    "snippet": "static mqueue_t *\nmqueue_create(const char *name)\n{\n\tmqueue_t *mq;\n\n\tmq = mowgli_heap_alloc(mqueue_heap);\n\tmq->name = sstrdup(name);\n\tmq->last_used = CURRTIME;\n\tmq->max = antiflood_msg_count;\n\n\tmowgli_patricia_add(mqueue_trie, mq->name, mq);\n\n\treturn mq;\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static int antiflood_msg_count = 10;",
      "static mowgli_patricia_t *mqueue_trie = NULL;",
      "static mowgli_heap_t *mqueue_heap = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mowgli_patricia_add",
          "args": [
            "mqueue_trie",
            "mq->name",
            "mq"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sstrdup",
          "args": [
            "name"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_heap_alloc",
          "args": [
            "mqueue_heap"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic int antiflood_msg_count = 10;\nstatic mowgli_patricia_t *mqueue_trie = NULL;\nstatic mowgli_heap_t *mqueue_heap = NULL;\n\nstatic mqueue_t *\nmqueue_create(const char *name)\n{\n\tmqueue_t *mq;\n\n\tmq = mowgli_heap_alloc(mqueue_heap);\n\tmq->name = sstrdup(name);\n\tmq->last_used = CURRTIME;\n\tmq->max = antiflood_msg_count;\n\n\tmowgli_patricia_add(mqueue_trie, mq->name, mq);\n\n\treturn mq;\n}"
  },
  {
    "function_name": "msg_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
    "lines": "76-96",
    "snippet": "static msg_t *\nmsg_create(mqueue_t *mq, user_t *u, const char *message)\n{\n\tmsg_t *msg;\n\n\tmsg = mowgli_heap_alloc(msg_heap);\n\tmsg->message = sstrdup(message);\n\tmsg->time = CURRTIME;\n\tmsg->source = u->uid != NULL ? strshare_ref(u->uid) : strshare_ref(u->nick);\n\n\tif (MOWGLI_LIST_LENGTH(&mq->entries) > mq->max)\n\t{\n\t\tmsg_t *head_msg = mq->entries.head->data;\n\t\tmsg_destroy(head_msg, mq);\n\t}\n\n\tmowgli_node_add(msg, &msg->node, &mq->entries);\n\tmq->last_used = CURRTIME;\n\n\treturn msg;\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static mowgli_heap_t *msg_heap = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mowgli_node_add",
          "args": [
            "msg",
            "&msg->node",
            "&mq->entries"
          ],
          "line": 92
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "msg_destroy",
          "args": [
            "head_msg",
            "mq"
          ],
          "line": 89
        },
        "resolved": true,
        "details": {
          "function_name": "msg_destroy",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
          "lines": "66-74",
          "snippet": "static void\nmsg_destroy(msg_t *msg, mqueue_t *mq)\n{\n\tfree(msg->message);\n\tstrshare_unref(msg->source);\n\tmowgli_node_delete(&msg->node, &mq->entries);\n\n\tmowgli_heap_free(msg_heap, msg);\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static mowgli_heap_t *msg_heap = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic mowgli_heap_t *msg_heap = NULL;\n\nstatic void\nmsg_destroy(msg_t *msg, mqueue_t *mq)\n{\n\tfree(msg->message);\n\tstrshare_unref(msg->source);\n\tmowgli_node_delete(&msg->node, &mq->entries);\n\n\tmowgli_heap_free(msg_heap, msg);\n}"
        }
      },
      {
        "call_info": {
          "callee": "MOWGLI_LIST_LENGTH",
          "args": [
            "&mq->entries"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strshare_ref",
          "args": [
            "u->nick"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strshare_ref",
          "args": [
            "u->uid"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "sstrdup",
          "args": [
            "message"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_heap_alloc",
          "args": [
            "msg_heap"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic mowgli_heap_t *msg_heap = NULL;\n\nstatic msg_t *\nmsg_create(mqueue_t *mq, user_t *u, const char *message)\n{\n\tmsg_t *msg;\n\n\tmsg = mowgli_heap_alloc(msg_heap);\n\tmsg->message = sstrdup(message);\n\tmsg->time = CURRTIME;\n\tmsg->source = u->uid != NULL ? strshare_ref(u->uid) : strshare_ref(u->nick);\n\n\tif (MOWGLI_LIST_LENGTH(&mq->entries) > mq->max)\n\t{\n\t\tmsg_t *head_msg = mq->entries.head->data;\n\t\tmsg_destroy(head_msg, mq);\n\t}\n\n\tmowgli_node_add(msg, &msg->node, &mq->entries);\n\tmq->last_used = CURRTIME;\n\n\treturn msg;\n}"
  },
  {
    "function_name": "msg_destroy",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
    "lines": "66-74",
    "snippet": "static void\nmsg_destroy(msg_t *msg, mqueue_t *mq)\n{\n\tfree(msg->message);\n\tstrshare_unref(msg->source);\n\tmowgli_node_delete(&msg->node, &mq->entries);\n\n\tmowgli_heap_free(msg_heap, msg);\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static mowgli_heap_t *msg_heap = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mowgli_heap_free",
          "args": [
            "msg_heap",
            "msg"
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_node_delete",
          "args": [
            "&msg->node",
            "&mq->entries"
          ],
          "line": 71
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strshare_unref",
          "args": [
            "msg->source"
          ],
          "line": 70
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "msg->message"
          ],
          "line": 69
        },
        "resolved": true,
        "details": {
          "function_name": "mqueue_free",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/antiflood.c",
          "lines": "117-131",
          "snippet": "static void\nmqueue_free(mqueue_t *mq)\n{\n\tmowgli_node_t *n, *tn;\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mq->entries.head)\n\t{\n\t\tmsg_t *msg = n->data;\n\n\t\tmsg_destroy(msg, mq);\n\t}\n\n\tfree(mq->name);\n\tmowgli_heap_free(mqueue_heap, mq);\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static mowgli_heap_t *mqueue_heap = NULL;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic mowgli_heap_t *mqueue_heap = NULL;\n\nstatic void\nmqueue_free(mqueue_t *mq)\n{\n\tmowgli_node_t *n, *tn;\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mq->entries.head)\n\t{\n\t\tmsg_t *msg = n->data;\n\n\t\tmsg_destroy(msg, mq);\n\t}\n\n\tfree(mq->name);\n\tmowgli_heap_free(mqueue_heap, mq);\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic mowgli_heap_t *msg_heap = NULL;\n\nstatic void\nmsg_destroy(msg_t *msg, mqueue_t *mq)\n{\n\tfree(msg->message);\n\tstrshare_unref(msg->source);\n\tmowgli_node_delete(&msg->node, &mq->entries);\n\n\tmowgli_heap_free(msg_heap, msg);\n}"
  }
]