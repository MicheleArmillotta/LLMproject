[
  {
    "function_name": "cs_cmd_clone",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/clone.c",
    "lines": "32-155",
    "snippet": "static void cs_cmd_clone(sourceinfo_t *si, int parc, char *parv[])\n{\n\tmychan_t *mc, *mc2;\n\tmowgli_node_t *n, *tn;\n\tmowgli_patricia_iteration_state_t state;\n\tmetadata_t *md;\n\tchanacs_t *ca;\n\tchar *source = parv[0];\n\tchar *target = parv[1];\n\n\tif (!source || !target)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"CLONE\");\n\t\tcommand_fail(si, fault_needmoreparams, \"Syntax: CLONE <#source> <#target>\");\n\t\treturn;\n\t}\n\n\tif (!(mc = mychan_find(source)))\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, \"\\2%s\\2 is not registered.\", source);\n\t\treturn;\n\t}\n\n\tif (!(mc2 = mychan_find(target)))\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, \"\\2%s\\2 is not registered.\", target);\n\t\treturn;\n\t}\n\n\tif (mc == mc2)\n\t{\n\t\tcommand_fail(si, fault_nochange, \"Cannot clone a channel to itself.\");\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, \"\\2%s\\2 is closed.\", source);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc2, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, \"\\2%s\\2 is closed.\", target);\n\t\treturn;\n\t}\n\n\tif (!mc->chan)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, \"\\2%s\\2 does not exist.\", source);\n\t\treturn;\n\t}\n\n\tif (!mc2->chan)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, \"\\2%s\\2 does not exist.\", target);\n\t\treturn;\n\t}\n\n\tif (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t{\n\t\tcommand_fail(si, fault_noprivs, \"You are not authorized to perform this operation.\");\n\t\treturn;\n\t}\n\n\tif (!chanacs_source_has_flag(mc2, si, CA_FOUNDER))\n\t{\n\t\tcommand_fail(si, fault_noprivs, \"You are not authorized to perform this operation.\");\n\t\treturn;\n\t}\n\n\t/* Delete almost all chanacs of the target first */\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mc2->chanacs.head)\n\t{\n\t\tca = n->data;\n\n\t\tif (ca->level & CA_FOUNDER)\n\t\t\tcontinue;\n\n\t\tobject_unref(ca);\n\t}\n\n\t/* Copy source chanacs to target */\n\tMOWGLI_ITER_FOREACH(n, mc->chanacs.head)\n\t{\n\t\tca = n->data;\n\n\t\tif (!ca->host)\n\t\t\tchanacs_change_simple(mc2, ca->entity, NULL, ca->level, 0, ca->setter ? myentity_find(ca->setter) : NULL);\n\t\telse if (ca->host != NULL)\n\t\t\tchanacs_change_simple(mc2, NULL, ca->host, ca->level, 0, ca->setter ? myentity_find(ca->setter) : NULL);\n\t}\n\n\t/* Copy ze metadata! */\n\tMOWGLI_PATRICIA_FOREACH(md, &state, object(mc)->metadata)\n\t{\n\t\tif(!strncmp(md->name, \"private:topic:\", 14))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Replace ANTIFLOOD AKILL with QUIET if it exists --shaynejellesma */\n\t\tif((strcasecmp(md->name, \"private:antiflood:enforce-method\") == 0) && (strcasecmp(md->value, \"AKILL\") == 0))\n\t\t{\n\t\t\tmetadata_add(mc2, md->name, \"QUIET\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tmetadata_add(mc2, md->name, md->value);\n\t}\n\n\t/* Copy channel flags */\n\tmc2->flags = mc->flags;\n\n\t/* Remove HOLD flag if it exists --shaynejellesma */\n\tif (mc2->flags & MC_HOLD)\n\t\tmc2->flags &= ~MC_HOLD;\n\n\tcommand_add_flood(si, FLOOD_MODERATE);\n\n\t/* I feel like this should log at a higher level... */\n\tlogcommand(si, CMDLOG_DO, \"CLONE: \\2%s\\2 to \\2%s\\2\", mc->name, mc2->name);\n\tcommand_success_nodata(si, _(\"Cloned \\2%s\\2 to \\2%s\\2.\"), source, target);\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_cmd_clone(sourceinfo_t *si, int parc, char *parv[]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"Cloned \\2%s\\2 to \\2%s\\2.\")",
            "source",
            "target"
          ],
          "line": 154
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Cloned \\2%s\\2 to \\2%s\\2.\""
          ],
          "line": 154
        },
        "resolved": true,
        "details": {
          "function_name": "_moddeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/clone.c",
          "lines": "27-30",
          "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_clone);\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "command_t cs_clone = { \"CLONE\", \"Clones a channel.\", AC_NONE, 2, cs_cmd_clone, { .path = \"cservice/clone\" } };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\ncommand_t cs_clone = { \"CLONE\", \"Clones a channel.\", AC_NONE, 2, cs_cmd_clone, { .path = \"cservice/clone\" } };\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_clone);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_DO",
            "\"CLONE: \\2%s\\2 to \\2%s\\2\"",
            "mc->name",
            "mc2->name"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_add_flood",
          "args": [
            "si",
            "FLOOD_MODERATE"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_add",
          "args": [
            "mc2",
            "md->name",
            "md->value"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_add",
          "args": [
            "mc2",
            "md->name",
            "\"QUIET\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "md->value",
            "\"AKILL\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "md->name",
            "\"private:antiflood:enforce-method\""
          ],
          "line": 134
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strncmp",
          "args": [
            "md->name",
            "\"private:topic:\"",
            "14"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_PATRICIA_FOREACH",
          "args": [
            "md",
            "&state",
            "object(mc)->metadata"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object",
          "args": [
            "mc"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_change_simple",
          "args": [
            "mc2",
            "NULL",
            "ca->host",
            "ca->level",
            "0",
            "ca->setter ? myentity_find(ca->setter) : NULL"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "myentity_find",
          "args": [
            "ca->setter"
          ],
          "line": 122
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_change_simple",
          "args": [
            "mc2",
            "ca->entity",
            "NULL",
            "ca->level",
            "0",
            "ca->setter ? myentity_find(ca->setter) : NULL"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "myentity_find",
          "args": [
            "ca->setter"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_ITER_FOREACH",
          "args": [
            "n",
            "mc->chanacs.head"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_unref",
          "args": [
            "ca"
          ],
          "line": 111
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_ITER_FOREACH_SAFE",
          "args": [
            "n",
            "tn",
            "mc2->chanacs.head"
          ],
          "line": 104
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "\"You are not authorized to perform this operation.\""
          ],
          "line": 99
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_source_has_flag",
          "args": [
            "mc2",
            "si",
            "CA_FOUNDER"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "\"You are not authorized to perform this operation.\""
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_source_has_flag",
          "args": [
            "mc",
            "si",
            "CA_ACLVIEW"
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_target",
            "\"\\2%s\\2 does not exist.\"",
            "target"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_target",
            "\"\\2%s\\2 does not exist.\"",
            "source"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "\"\\2%s\\2 is closed.\"",
            "target"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc2",
            "\"private:close:closer\""
          ],
          "line": 73
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "\"\\2%s\\2 is closed.\"",
            "source"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:close:closer\""
          ],
          "line": 67
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nochange",
            "\"Cannot clone a channel to itself.\""
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_target",
            "\"\\2%s\\2 is not registered.\"",
            "target"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_find",
          "args": [
            "target"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_target",
            "\"\\2%s\\2 is not registered.\"",
            "source"
          ],
          "line": 51
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_find",
          "args": [
            "source"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "\"Syntax: CLONE <#source> <#target>\""
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "STR_INSUFFICIENT_PARAMS",
            "\"CLONE\""
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic void cs_cmd_clone(sourceinfo_t *si, int parc, char *parv[]);\n\nstatic void cs_cmd_clone(sourceinfo_t *si, int parc, char *parv[])\n{\n\tmychan_t *mc, *mc2;\n\tmowgli_node_t *n, *tn;\n\tmowgli_patricia_iteration_state_t state;\n\tmetadata_t *md;\n\tchanacs_t *ca;\n\tchar *source = parv[0];\n\tchar *target = parv[1];\n\n\tif (!source || !target)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"CLONE\");\n\t\tcommand_fail(si, fault_needmoreparams, \"Syntax: CLONE <#source> <#target>\");\n\t\treturn;\n\t}\n\n\tif (!(mc = mychan_find(source)))\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, \"\\2%s\\2 is not registered.\", source);\n\t\treturn;\n\t}\n\n\tif (!(mc2 = mychan_find(target)))\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, \"\\2%s\\2 is not registered.\", target);\n\t\treturn;\n\t}\n\n\tif (mc == mc2)\n\t{\n\t\tcommand_fail(si, fault_nochange, \"Cannot clone a channel to itself.\");\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, \"\\2%s\\2 is closed.\", source);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc2, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, \"\\2%s\\2 is closed.\", target);\n\t\treturn;\n\t}\n\n\tif (!mc->chan)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, \"\\2%s\\2 does not exist.\", source);\n\t\treturn;\n\t}\n\n\tif (!mc2->chan)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, \"\\2%s\\2 does not exist.\", target);\n\t\treturn;\n\t}\n\n\tif (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t{\n\t\tcommand_fail(si, fault_noprivs, \"You are not authorized to perform this operation.\");\n\t\treturn;\n\t}\n\n\tif (!chanacs_source_has_flag(mc2, si, CA_FOUNDER))\n\t{\n\t\tcommand_fail(si, fault_noprivs, \"You are not authorized to perform this operation.\");\n\t\treturn;\n\t}\n\n\t/* Delete almost all chanacs of the target first */\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mc2->chanacs.head)\n\t{\n\t\tca = n->data;\n\n\t\tif (ca->level & CA_FOUNDER)\n\t\t\tcontinue;\n\n\t\tobject_unref(ca);\n\t}\n\n\t/* Copy source chanacs to target */\n\tMOWGLI_ITER_FOREACH(n, mc->chanacs.head)\n\t{\n\t\tca = n->data;\n\n\t\tif (!ca->host)\n\t\t\tchanacs_change_simple(mc2, ca->entity, NULL, ca->level, 0, ca->setter ? myentity_find(ca->setter) : NULL);\n\t\telse if (ca->host != NULL)\n\t\t\tchanacs_change_simple(mc2, NULL, ca->host, ca->level, 0, ca->setter ? myentity_find(ca->setter) : NULL);\n\t}\n\n\t/* Copy ze metadata! */\n\tMOWGLI_PATRICIA_FOREACH(md, &state, object(mc)->metadata)\n\t{\n\t\tif(!strncmp(md->name, \"private:topic:\", 14))\n\t\t{\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* Replace ANTIFLOOD AKILL with QUIET if it exists --shaynejellesma */\n\t\tif((strcasecmp(md->name, \"private:antiflood:enforce-method\") == 0) && (strcasecmp(md->value, \"AKILL\") == 0))\n\t\t{\n\t\t\tmetadata_add(mc2, md->name, \"QUIET\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tmetadata_add(mc2, md->name, md->value);\n\t}\n\n\t/* Copy channel flags */\n\tmc2->flags = mc->flags;\n\n\t/* Remove HOLD flag if it exists --shaynejellesma */\n\tif (mc2->flags & MC_HOLD)\n\t\tmc2->flags &= ~MC_HOLD;\n\n\tcommand_add_flood(si, FLOOD_MODERATE);\n\n\t/* I feel like this should log at a higher level... */\n\tlogcommand(si, CMDLOG_DO, \"CLONE: \\2%s\\2 to \\2%s\\2\", mc->name, mc2->name);\n\tcommand_success_nodata(si, _(\"Cloned \\2%s\\2 to \\2%s\\2.\"), source, target);\n}"
  },
  {
    "function_name": "_moddeinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/clone.c",
    "lines": "27-30",
    "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_clone);\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "command_t cs_clone = { \"CLONE\", \"Clones a channel.\", AC_NONE, 2, cs_cmd_clone, { .path = \"cservice/clone\" } };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "service_named_unbind_command",
          "args": [
            "\"chanserv\"",
            "&cs_clone"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\ncommand_t cs_clone = { \"CLONE\", \"Clones a channel.\", AC_NONE, 2, cs_cmd_clone, { .path = \"cservice/clone\" } };\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_clone);\n}"
  },
  {
    "function_name": "_modinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/clone.c",
    "lines": "22-25",
    "snippet": "void _modinit(module_t *m)\n{\n\tservice_named_bind_command(\"chanserv\", &cs_clone);\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "command_t cs_clone = { \"CLONE\", \"Clones a channel.\", AC_NONE, 2, cs_cmd_clone, { .path = \"cservice/clone\" } };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "service_named_bind_command",
          "args": [
            "\"chanserv\"",
            "&cs_clone"
          ],
          "line": 24
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\ncommand_t cs_clone = { \"CLONE\", \"Clones a channel.\", AC_NONE, 2, cs_cmd_clone, { .path = \"cservice/clone\" } };\n\nvoid _modinit(module_t *m)\n{\n\tservice_named_bind_command(\"chanserv\", &cs_clone);\n}"
  }
]