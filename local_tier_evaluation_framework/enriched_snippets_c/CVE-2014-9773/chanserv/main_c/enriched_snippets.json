[
  {
    "function_name": "cs_bounce_mode_change",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
    "lines": "912-946",
    "snippet": "static void cs_bounce_mode_change(hook_channel_mode_change_t *data)\n{\n\tmychan_t *mc;\n\tchanuser_t *cu;\n\tchannel_t *chan;\n\n\t/* if we have SECURE mode enabled, then we want to bounce any changes */\n\tcu = data->cu;\n\tchan = cu->chan;\n\tmc = chan->mychan;\n\n\tif (mc == NULL || (mc != NULL && !(mc->flags & MC_SECURE)))\n\t\treturn;\n\n\tif (ircd->uses_owner && data->mchar == ircd->owner_mchar[1] && !(chanacs_user_flags(mc, cu->user) & (CA_USEOWNER)))\n\t{\n\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_DEL, ircd->owner_mchar[1], CLIENT_NAME(cu->user));\n\t\tcu->modes &= ~data->mvalue;\n\t}\n\telse if (ircd->uses_protect && data->mchar == ircd->protect_mchar[1] && !(chanacs_user_flags(mc, cu->user) & (CA_USEPROTECT)))\n\t{\n\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_DEL, ircd->protect_mchar[1], CLIENT_NAME(cu->user));\n\t\tcu->modes &= ~data->mvalue;\n\t}\n\telse if (data->mchar == 'o' && !(chanacs_user_flags(mc, cu->user) & (CA_OP | CA_AUTOOP)))\n\t{\n\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_DEL, 'o', CLIENT_NAME(cu->user));\n\t\tcu->modes &= ~data->mvalue;\n\t}\n\telse if (ircd->uses_halfops && data->mchar == ircd->halfops_mchar[1] && !(chanacs_user_flags(mc, cu->user) & (CA_HALFOP | CA_AUTOHALFOP)))\n\t{\n\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_DEL, ircd->halfops_mchar[1], CLIENT_NAME(cu->user));\n\t\tcu->modes &= ~data->mvalue;\n\t}\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"template.h\"",
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_register(hook_channel_req_t *mc);",
      "static void cs_succession(hook_channel_succession_req_t *data);",
      "static void cs_topiccheck(hook_channel_topic_check_t *data);",
      "static void cs_bounce_mode_change(hook_channel_mode_change_t *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "modestack_mode_param",
          "args": [
            "chansvs.nick",
            "chan",
            "MTYPE_DEL",
            "ircd->halfops_mchar[1]",
            "CLIENT_NAME(cu->user)"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLIENT_NAME",
          "args": [
            "cu->user"
          ],
          "line": 943
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_user_flags",
          "args": [
            "mc",
            "cu->user"
          ],
          "line": 941
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modestack_mode_param",
          "args": [
            "chansvs.nick",
            "chan",
            "MTYPE_DEL",
            "'o'",
            "CLIENT_NAME(cu->user)"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLIENT_NAME",
          "args": [
            "cu->user"
          ],
          "line": 938
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_user_flags",
          "args": [
            "mc",
            "cu->user"
          ],
          "line": 936
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modestack_mode_param",
          "args": [
            "chansvs.nick",
            "chan",
            "MTYPE_DEL",
            "ircd->protect_mchar[1]",
            "CLIENT_NAME(cu->user)"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLIENT_NAME",
          "args": [
            "cu->user"
          ],
          "line": 933
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_user_flags",
          "args": [
            "mc",
            "cu->user"
          ],
          "line": 931
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modestack_mode_param",
          "args": [
            "chansvs.nick",
            "chan",
            "MTYPE_DEL",
            "ircd->owner_mchar[1]",
            "CLIENT_NAME(cu->user)"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLIENT_NAME",
          "args": [
            "cu->user"
          ],
          "line": 928
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_user_flags",
          "args": [
            "mc",
            "cu->user"
          ],
          "line": 926
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_register(hook_channel_req_t *mc);\nstatic void cs_succession(hook_channel_succession_req_t *data);\nstatic void cs_topiccheck(hook_channel_topic_check_t *data);\nstatic void cs_bounce_mode_change(hook_channel_mode_change_t *data);\n\nstatic void cs_bounce_mode_change(hook_channel_mode_change_t *data)\n{\n\tmychan_t *mc;\n\tchanuser_t *cu;\n\tchannel_t *chan;\n\n\t/* if we have SECURE mode enabled, then we want to bounce any changes */\n\tcu = data->cu;\n\tchan = cu->chan;\n\tmc = chan->mychan;\n\n\tif (mc == NULL || (mc != NULL && !(mc->flags & MC_SECURE)))\n\t\treturn;\n\n\tif (ircd->uses_owner && data->mchar == ircd->owner_mchar[1] && !(chanacs_user_flags(mc, cu->user) & (CA_USEOWNER)))\n\t{\n\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_DEL, ircd->owner_mchar[1], CLIENT_NAME(cu->user));\n\t\tcu->modes &= ~data->mvalue;\n\t}\n\telse if (ircd->uses_protect && data->mchar == ircd->protect_mchar[1] && !(chanacs_user_flags(mc, cu->user) & (CA_USEPROTECT)))\n\t{\n\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_DEL, ircd->protect_mchar[1], CLIENT_NAME(cu->user));\n\t\tcu->modes &= ~data->mvalue;\n\t}\n\telse if (data->mchar == 'o' && !(chanacs_user_flags(mc, cu->user) & (CA_OP | CA_AUTOOP)))\n\t{\n\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_DEL, 'o', CLIENT_NAME(cu->user));\n\t\tcu->modes &= ~data->mvalue;\n\t}\n\telse if (ircd->uses_halfops && data->mchar == ircd->halfops_mchar[1] && !(chanacs_user_flags(mc, cu->user) & (CA_HALFOP | CA_AUTOHALFOP)))\n\t{\n\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_DEL, ircd->halfops_mchar[1], CLIENT_NAME(cu->user));\n\t\tcu->modes &= ~data->mvalue;\n\t}\n}"
  },
  {
    "function_name": "cs_leave_empty",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
    "lines": "885-910",
    "snippet": "static void cs_leave_empty(void *unused)\n{\n\tmychan_t *mc;\n\tmowgli_patricia_iteration_state_t state;\n\n\t(void)unused;\n\tMOWGLI_PATRICIA_FOREACH(mc, &state, mclist)\n\t{\n\t\tif (!(mc->flags & MC_INHABIT))\n\t\t\tcontinue;\n\t\t/* If there is only one user, stay indefinitely. */\n\t\tif (mc->chan != NULL && mc->chan->nummembers - mc->chan->numsvcmembers == 1)\n\t\t\tcontinue;\n\t\tmc->flags &= ~MC_INHABIT;\n\t\tif (mc->chan != NULL &&\n\t\t\t\t!(mc->chan->flags & CHAN_LOG) &&\n\t\t\t\t(!(mc->flags & MC_GUARD) ||\n\t\t\t\t (config_options.leave_chans && mc->chan->nummembers == mc->chan->numsvcmembers) ||\n\t\t\t\t metadata_find(mc, \"private:close:closer\")) &&\n\t\t\t\tchanuser_find(mc->chan, chansvs.me->me))\n\t\t{\n\t\t\tslog(LG_DEBUG, \"cs_leave_empty(): leaving %s\", mc->chan->name);\n\t\t\tpart(mc->chan->name, chansvs.nick);\n\t\t}\n\t}\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"template.h\"",
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_register(hook_channel_req_t *mc);",
      "static void cs_leave_empty(void *unused);",
      "static void on_shutdown(void *unused);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "part",
          "args": [
            "mc->chan->name",
            "chansvs.nick"
          ],
          "line": 907
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slog",
          "args": [
            "LG_DEBUG",
            "\"cs_leave_empty(): leaving %s\"",
            "mc->chan->name"
          ],
          "line": 906
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanuser_find",
          "args": [
            "mc->chan",
            "chansvs.me->me"
          ],
          "line": 904
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:close:closer\""
          ],
          "line": 903
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_PATRICIA_FOREACH",
          "args": [
            "mc",
            "&state",
            "mclist"
          ],
          "line": 891
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_register(hook_channel_req_t *mc);\nstatic void cs_leave_empty(void *unused);\nstatic void on_shutdown(void *unused);\n\nstatic void cs_leave_empty(void *unused)\n{\n\tmychan_t *mc;\n\tmowgli_patricia_iteration_state_t state;\n\n\t(void)unused;\n\tMOWGLI_PATRICIA_FOREACH(mc, &state, mclist)\n\t{\n\t\tif (!(mc->flags & MC_INHABIT))\n\t\t\tcontinue;\n\t\t/* If there is only one user, stay indefinitely. */\n\t\tif (mc->chan != NULL && mc->chan->nummembers - mc->chan->numsvcmembers == 1)\n\t\t\tcontinue;\n\t\tmc->flags &= ~MC_INHABIT;\n\t\tif (mc->chan != NULL &&\n\t\t\t\t!(mc->chan->flags & CHAN_LOG) &&\n\t\t\t\t(!(mc->flags & MC_GUARD) ||\n\t\t\t\t (config_options.leave_chans && mc->chan->nummembers == mc->chan->numsvcmembers) ||\n\t\t\t\t metadata_find(mc, \"private:close:closer\")) &&\n\t\t\t\tchanuser_find(mc->chan, chansvs.me->me))\n\t\t{\n\t\t\tslog(LG_DEBUG, \"cs_leave_empty(): leaving %s\", mc->chan->name);\n\t\t\tpart(mc->chan->name, chansvs.nick);\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "on_shutdown",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
    "lines": "879-883",
    "snippet": "static void on_shutdown(void *unused)\n{\n\tif (chansvs.me != NULL && chansvs.me->me != NULL)\n\t\tquit_sts(chansvs.me->me, \"shutting down\");\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"template.h\"",
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_leave_empty(void *unused);",
      "static void on_shutdown(void *unused);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "quit_sts",
          "args": [
            "chansvs.me->me",
            "\"shutting down\""
          ],
          "line": 882
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_leave_empty(void *unused);\nstatic void on_shutdown(void *unused);\n\nstatic void on_shutdown(void *unused)\n{\n\tif (chansvs.me != NULL && chansvs.me->me != NULL)\n\t\tquit_sts(chansvs.me->me, \"shutting down\");\n}"
  },
  {
    "function_name": "cs_tschange",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
    "lines": "858-877",
    "snippet": "static void cs_tschange(channel_t *c)\n{\n\tmychan_t *mc;\n\tchar str[21];\n\n\tif (!(mc = mychan_find(c->name)))\n\t\treturn;\n\n\t/* store new TS */\n\tsnprintf(str, sizeof str, \"%lu\", (unsigned long)c->ts);\n\tmetadata_add(mc, \"private:channelts\", str);\n\n\t/* schedule a mode lock check when we know the new modes\n\t * -- jilles */\n\tmc->flags |= MC_MLOCK_CHECK;\n\n\t/* reset the mlock if needed */\n\tmlock_sts(c);\n\ttopiclock_sts(c);\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"template.h\"",
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_register(hook_channel_req_t *mc);",
      "static void cs_newchan(channel_t *c);",
      "static void cs_keeptopic_topicset(channel_t *c);",
      "static void cs_tschange(channel_t *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "topiclock_sts",
          "args": [
            "c"
          ],
          "line": 876
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlock_sts",
          "args": [
            "c"
          ],
          "line": 875
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_add",
          "args": [
            "mc",
            "\"private:channelts\"",
            "str"
          ],
          "line": 868
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "str",
            "sizeof str",
            "\"%lu\"",
            "(unsigned long)c->ts"
          ],
          "line": 867
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_find",
          "args": [
            "c->name"
          ],
          "line": 863
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_register(hook_channel_req_t *mc);\nstatic void cs_newchan(channel_t *c);\nstatic void cs_keeptopic_topicset(channel_t *c);\nstatic void cs_tschange(channel_t *c);\n\nstatic void cs_tschange(channel_t *c)\n{\n\tmychan_t *mc;\n\tchar str[21];\n\n\tif (!(mc = mychan_find(c->name)))\n\t\treturn;\n\n\t/* store new TS */\n\tsnprintf(str, sizeof str, \"%lu\", (unsigned long)c->ts);\n\tmetadata_add(mc, \"private:channelts\", str);\n\n\t/* schedule a mode lock check when we know the new modes\n\t * -- jilles */\n\tmc->flags |= MC_MLOCK_CHECK;\n\n\t/* reset the mlock if needed */\n\tmlock_sts(c);\n\ttopiclock_sts(c);\n}"
  },
  {
    "function_name": "cs_newchan",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
    "lines": "766-856",
    "snippet": "static void cs_newchan(channel_t *c)\n{\n\tmychan_t *mc;\n\tchanuser_t *cu;\n\tmetadata_t *md;\n\tchar *setter;\n\tchar *text;\n\ttime_t channelts = 0;\n\ttime_t topicts;\n\tchar str[21];\n\n\tif (!(mc = mychan_find(c->name)))\n\t\treturn;\n\n\t/* set channel_t.mychan */\n\tc->mychan = mc;\n\n\t/* schedule a mode lock check when we know the current modes\n\t * -- jilles */\n\tmc->flags |= MC_MLOCK_CHECK;\n\n\tmd = metadata_find(mc, \"private:channelts\");\n\tif (md != NULL)\n\t\tchannelts = atol(md->value);\n\tif (channelts == 0)\n\t\tchannelts = mc->registered;\n\n\tif (c->ts > channelts && channelts > 0)\n\t\tmc->flags |= MC_RECREATED;\n\telse\n\t\tmc->flags &= ~MC_RECREATED;\n\n\tif (chansvs.changets && c->ts > channelts && channelts > 0)\n\t{\n\t\tuser_t *u;\n\n\t\tu = get_changets_user(mc);\n\n\t\t/* Stop the splitrider -- jilles */\n\t\tc->ts = channelts;\n\t\tclear_simple_modes(c);\n\t\tc->modes |= CMODE_NOEXT | CMODE_TOPIC;\n\t\tcheck_modes(mc, false);\n\t\t/* No ops to clear */\n\t\tchan_lowerts(c, u);\n\t\tcu = chanuser_add(c, CLIENT_NAME(u));\n\t\tcu->modes |= CSTATUS_OP;\n\t\t/* make sure it parts again sometime (empty SJOIN etc) */\n\t\tmc->flags |= MC_INHABIT;\n\t}\n\telse if (c->ts != channelts)\n\t{\n\t\tsnprintf(str, sizeof str, \"%lu\", (unsigned long)c->ts);\n\t\tmetadata_add(mc, \"private:channelts\", str);\n\t}\n\telse if (!(MC_TOPICLOCK & mc->flags) && MOWGLI_LIST_LENGTH(&c->members) == 0)\n\t{\n\t\tmlock_sts(c);\n\t\t/* Same channel, let's assume ircd has kept topic.\n\t\t * However, if topiclock is enabled, we must change it back\n\t\t * regardless.\n\t\t * Also, if there is someone in this channel already, it is\n\t\t * being created by a service and we must restore.\n\t\t * -- jilles */\n\t\treturn;\n\t}\n\n\tmlock_sts(c);\n\ttopiclock_sts(c);\n\n\tif (!(MC_KEEPTOPIC & mc->flags))\n\t\treturn;\n\n\tmd = metadata_find(mc, \"private:topic:setter\");\n\tif (md == NULL)\n\t\treturn;\n\tsetter = md->value;\n\n\tmd = metadata_find(mc, \"private:topic:text\");\n\tif (md == NULL)\n\t\treturn;\n\ttext = md->value;\n\n\tmd = metadata_find(mc, \"private:topic:ts\");\n\tif (md == NULL)\n\t\treturn;\n\ttopicts = atol(md->value);\n\n\thandle_topic(c, setter, topicts, text);\n\ttopic_sts(c, chansvs.me->me, setter, topicts, 0, text);\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"template.h\"",
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_register(hook_channel_req_t *mc);",
      "static void cs_newchan(channel_t *c);",
      "static void cs_keeptopic_topicset(channel_t *c);",
      "static void cs_tschange(channel_t *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "topic_sts",
          "args": [
            "c",
            "chansvs.me->me",
            "setter",
            "topicts",
            "0",
            "text"
          ],
          "line": 855
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_topic",
          "args": [
            "c",
            "setter",
            "topicts",
            "text"
          ],
          "line": 854
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "md->value"
          ],
          "line": 852
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:topic:ts\""
          ],
          "line": 849
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:topic:text\""
          ],
          "line": 844
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:topic:setter\""
          ],
          "line": 839
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "topiclock_sts",
          "args": [
            "c"
          ],
          "line": 834
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlock_sts",
          "args": [
            "c"
          ],
          "line": 833
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlock_sts",
          "args": [
            "c"
          ],
          "line": 823
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_LIST_LENGTH",
          "args": [
            "&c->members"
          ],
          "line": 821
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_add",
          "args": [
            "mc",
            "\"private:channelts\"",
            "str"
          ],
          "line": 819
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "str",
            "sizeof str",
            "\"%lu\"",
            "(unsigned long)c->ts"
          ],
          "line": 818
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanuser_add",
          "args": [
            "c",
            "CLIENT_NAME(u)"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLIENT_NAME",
          "args": [
            "u"
          ],
          "line": 811
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chan_lowerts",
          "args": [
            "c",
            "u"
          ],
          "line": 810
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_modes",
          "args": [
            "mc",
            "false"
          ],
          "line": 808
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_simple_modes",
          "args": [
            "c"
          ],
          "line": 806
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_changets_user",
          "args": [
            "mc"
          ],
          "line": 802
        },
        "resolved": true,
        "details": {
          "function_name": "get_changets_user",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
          "lines": "645-662",
          "snippet": "static user_t *get_changets_user(mychan_t *mc)\n{\n\tmetadata_t *md;\n\n\treturn_val_if_fail(mc != NULL, chansvs.me->me);\n\n\tmd = metadata_find(mc, \"private:botserv:bot-assigned\");\n\tif (md != NULL)\n\t{\n\t\tuser_t *u = user_find(md->value);\n\n\t\treturn_val_if_fail(is_internal_client(u), chansvs.me->me);\n\n\t\treturn u;\n\t}\n\n\treturn chansvs.me->me;\n}",
          "includes": [
            "#include <limits.h>",
            "#include \"template.h\"",
            "#include \"chanserv.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cs_register(hook_channel_req_t *mc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_register(hook_channel_req_t *mc);\n\nstatic user_t *get_changets_user(mychan_t *mc)\n{\n\tmetadata_t *md;\n\n\treturn_val_if_fail(mc != NULL, chansvs.me->me);\n\n\tmd = metadata_find(mc, \"private:botserv:bot-assigned\");\n\tif (md != NULL)\n\t{\n\t\tuser_t *u = user_find(md->value);\n\n\t\treturn_val_if_fail(is_internal_client(u), chansvs.me->me);\n\n\t\treturn u;\n\t}\n\n\treturn chansvs.me->me;\n}"
        }
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "md->value"
          ],
          "line": 789
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:channelts\""
          ],
          "line": 787
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_find",
          "args": [
            "c->name"
          ],
          "line": 777
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_register(hook_channel_req_t *mc);\nstatic void cs_newchan(channel_t *c);\nstatic void cs_keeptopic_topicset(channel_t *c);\nstatic void cs_tschange(channel_t *c);\n\nstatic void cs_newchan(channel_t *c)\n{\n\tmychan_t *mc;\n\tchanuser_t *cu;\n\tmetadata_t *md;\n\tchar *setter;\n\tchar *text;\n\ttime_t channelts = 0;\n\ttime_t topicts;\n\tchar str[21];\n\n\tif (!(mc = mychan_find(c->name)))\n\t\treturn;\n\n\t/* set channel_t.mychan */\n\tc->mychan = mc;\n\n\t/* schedule a mode lock check when we know the current modes\n\t * -- jilles */\n\tmc->flags |= MC_MLOCK_CHECK;\n\n\tmd = metadata_find(mc, \"private:channelts\");\n\tif (md != NULL)\n\t\tchannelts = atol(md->value);\n\tif (channelts == 0)\n\t\tchannelts = mc->registered;\n\n\tif (c->ts > channelts && channelts > 0)\n\t\tmc->flags |= MC_RECREATED;\n\telse\n\t\tmc->flags &= ~MC_RECREATED;\n\n\tif (chansvs.changets && c->ts > channelts && channelts > 0)\n\t{\n\t\tuser_t *u;\n\n\t\tu = get_changets_user(mc);\n\n\t\t/* Stop the splitrider -- jilles */\n\t\tc->ts = channelts;\n\t\tclear_simple_modes(c);\n\t\tc->modes |= CMODE_NOEXT | CMODE_TOPIC;\n\t\tcheck_modes(mc, false);\n\t\t/* No ops to clear */\n\t\tchan_lowerts(c, u);\n\t\tcu = chanuser_add(c, CLIENT_NAME(u));\n\t\tcu->modes |= CSTATUS_OP;\n\t\t/* make sure it parts again sometime (empty SJOIN etc) */\n\t\tmc->flags |= MC_INHABIT;\n\t}\n\telse if (c->ts != channelts)\n\t{\n\t\tsnprintf(str, sizeof str, \"%lu\", (unsigned long)c->ts);\n\t\tmetadata_add(mc, \"private:channelts\", str);\n\t}\n\telse if (!(MC_TOPICLOCK & mc->flags) && MOWGLI_LIST_LENGTH(&c->members) == 0)\n\t{\n\t\tmlock_sts(c);\n\t\t/* Same channel, let's assume ircd has kept topic.\n\t\t * However, if topiclock is enabled, we must change it back\n\t\t * regardless.\n\t\t * Also, if there is someone in this channel already, it is\n\t\t * being created by a service and we must restore.\n\t\t * -- jilles */\n\t\treturn;\n\t}\n\n\tmlock_sts(c);\n\ttopiclock_sts(c);\n\n\tif (!(MC_KEEPTOPIC & mc->flags))\n\t\treturn;\n\n\tmd = metadata_find(mc, \"private:topic:setter\");\n\tif (md == NULL)\n\t\treturn;\n\tsetter = md->value;\n\n\tmd = metadata_find(mc, \"private:topic:text\");\n\tif (md == NULL)\n\t\treturn;\n\ttext = md->value;\n\n\tmd = metadata_find(mc, \"private:topic:ts\");\n\tif (md == NULL)\n\t\treturn;\n\ttopicts = atol(md->value);\n\n\thandle_topic(c, setter, topicts, text);\n\ttopic_sts(c, chansvs.me->me, setter, topicts, 0, text);\n}"
  },
  {
    "function_name": "cs_topiccheck",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
    "lines": "729-763",
    "snippet": "static void cs_topiccheck(hook_channel_topic_check_t *data)\n{\n\tmychan_t *mc;\n\tunsigned int accessfl = 0;\n\n\tmc = mychan_find(data->c->name);\n\tif (mc == NULL)\n\t\treturn;\n\n\tif ((mc->flags & (MC_KEEPTOPIC | MC_TOPICLOCK)) == (MC_KEEPTOPIC | MC_TOPICLOCK))\n\t{\n\t\tif (data->u == NULL || !((accessfl = chanacs_user_flags(mc, data->u)) & CA_TOPIC))\n\t\t{\n\t\t\t/* topic burst or unauthorized user, revert it */\n\t\t\tdata->approved = 1;\n\t\t\tslog(LG_DEBUG, \"cs_topiccheck(): reverting topic change on channel %s by %s\",\n\t\t\t\t\tdata->c->name,\n\t\t\t\t\tdata->u != NULL ? data->u->nick : \"<server>\");\n\n\t\t\tif (data->u != NULL && !(mc->mlock_off & CMODE_TOPIC))\n\t\t\t{\n\t\t\t\t/* they do not have access to be opped either,\n\t\t\t\t * deop them and set +t */\n\t\t\t\t/* note: channel_mode() takes nicks, not UIDs\n\t\t\t\t * when used with a non-NULL source */\n\t\t\t\tif (ircd->uses_halfops && !(accessfl & (CA_OP | CA_AUTOOP | CA_HALFOP | CA_AUTOHALFOP)))\n\t\t\t\t\tchannel_mode_va(chansvs.me->me, data->c,\n\t\t\t\t\t\t\t3, \"+t-oh\", data->u->nick, data->u->nick);\n\t\t\t\telse if (!ircd->uses_halfops && !(accessfl & (CA_OP | CA_AUTOOP)))\n\t\t\t\t\tchannel_mode_va(chansvs.me->me, data->c,\n\t\t\t\t\t\t\t2, \"+t-o\", data->u->nick);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"template.h\"",
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_register(hook_channel_req_t *mc);",
      "static void cs_succession(hook_channel_succession_req_t *data);",
      "static void cs_newchan(channel_t *c);",
      "static void cs_keeptopic_topicset(channel_t *c);",
      "static void cs_topiccheck(hook_channel_topic_check_t *data);",
      "static void cs_tschange(channel_t *c);",
      "static void cs_bounce_mode_change(hook_channel_mode_change_t *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "channel_mode_va",
          "args": [
            "chansvs.me->me",
            "data->c",
            "2",
            "\"+t-o\"",
            "data->u->nick"
          ],
          "line": 758
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_mode_va",
          "args": [
            "chansvs.me->me",
            "data->c",
            "3",
            "\"+t-oh\"",
            "data->u->nick",
            "data->u->nick"
          ],
          "line": 755
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slog",
          "args": [
            "LG_DEBUG",
            "\"cs_topiccheck(): reverting topic change on channel %s by %s\"",
            "data->c->name",
            "data->u != NULL ? data->u->nick : \"<server>\""
          ],
          "line": 744
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_user_flags",
          "args": [
            "mc",
            "data->u"
          ],
          "line": 740
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_find",
          "args": [
            "data->c->name"
          ],
          "line": 734
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_register(hook_channel_req_t *mc);\nstatic void cs_succession(hook_channel_succession_req_t *data);\nstatic void cs_newchan(channel_t *c);\nstatic void cs_keeptopic_topicset(channel_t *c);\nstatic void cs_topiccheck(hook_channel_topic_check_t *data);\nstatic void cs_tschange(channel_t *c);\nstatic void cs_bounce_mode_change(hook_channel_mode_change_t *data);\n\nstatic void cs_topiccheck(hook_channel_topic_check_t *data)\n{\n\tmychan_t *mc;\n\tunsigned int accessfl = 0;\n\n\tmc = mychan_find(data->c->name);\n\tif (mc == NULL)\n\t\treturn;\n\n\tif ((mc->flags & (MC_KEEPTOPIC | MC_TOPICLOCK)) == (MC_KEEPTOPIC | MC_TOPICLOCK))\n\t{\n\t\tif (data->u == NULL || !((accessfl = chanacs_user_flags(mc, data->u)) & CA_TOPIC))\n\t\t{\n\t\t\t/* topic burst or unauthorized user, revert it */\n\t\t\tdata->approved = 1;\n\t\t\tslog(LG_DEBUG, \"cs_topiccheck(): reverting topic change on channel %s by %s\",\n\t\t\t\t\tdata->c->name,\n\t\t\t\t\tdata->u != NULL ? data->u->nick : \"<server>\");\n\n\t\t\tif (data->u != NULL && !(mc->mlock_off & CMODE_TOPIC))\n\t\t\t{\n\t\t\t\t/* they do not have access to be opped either,\n\t\t\t\t * deop them and set +t */\n\t\t\t\t/* note: channel_mode() takes nicks, not UIDs\n\t\t\t\t * when used with a non-NULL source */\n\t\t\t\tif (ircd->uses_halfops && !(accessfl & (CA_OP | CA_AUTOOP | CA_HALFOP | CA_AUTOHALFOP)))\n\t\t\t\t\tchannel_mode_va(chansvs.me->me, data->c,\n\t\t\t\t\t\t\t3, \"+t-oh\", data->u->nick, data->u->nick);\n\t\t\t\telse if (!ircd->uses_halfops && !(accessfl & (CA_OP | CA_AUTOOP)))\n\t\t\t\t\tchannel_mode_va(chansvs.me->me, data->c,\n\t\t\t\t\t\t\t2, \"+t-o\", data->u->nick);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "cs_keeptopic_topicset",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
    "lines": "688-725",
    "snippet": "static void cs_keeptopic_topicset(channel_t *c)\n{\n\tmychan_t *mc;\n\tmetadata_t *md;\n\n\tmc = mychan_find(c->name);\n\n\tif (mc == NULL)\n\t\treturn;\n\n\tmd = metadata_find(mc, \"private:topic:text\");\n\tif (md != NULL)\n\t{\n\t\tif (c->topic != NULL && !strcmp(md->value, c->topic))\n\t\t\treturn;\n\t\tmetadata_delete(mc, \"private:topic:text\");\n\t}\n\n\tif (metadata_find(mc, \"private:topic:setter\"))\n\t\tmetadata_delete(mc, \"private:topic:setter\");\n\n\tif (metadata_find(mc, \"private:topic:ts\"))\n\t\tmetadata_delete(mc, \"private:topic:ts\");\n\n\tif (c->topic && c->topic_setter)\n\t{\n\t\tslog(LG_DEBUG, \"KeepTopic: topic set for %s by %s: %s\", c->name,\n\t\t\tc->topic_setter, c->topic);\n\t\tmetadata_add(mc, \"private:topic:setter\",\n\t\t\tc->topic_setter);\n\t\tmetadata_add(mc, \"private:topic:text\",\n\t\t\tc->topic);\n\t\tmetadata_add(mc, \"private:topic:ts\",\n\t\t\tnumber_to_string(c->topicts));\n\t}\n\telse\n\t\tslog(LG_DEBUG, \"KeepTopic: topic cleared for %s\", c->name);\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"template.h\"",
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_register(hook_channel_req_t *mc);",
      "static void cs_newchan(channel_t *c);",
      "static void cs_keeptopic_topicset(channel_t *c);",
      "static void cs_tschange(channel_t *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "slog",
          "args": [
            "LG_DEBUG",
            "\"KeepTopic: topic cleared for %s\"",
            "c->name"
          ],
          "line": 724
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_add",
          "args": [
            "mc",
            "\"private:topic:ts\"",
            "number_to_string(c->topicts)"
          ],
          "line": 720
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "number_to_string",
          "args": [
            "c->topicts"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_add",
          "args": [
            "mc",
            "\"private:topic:text\"",
            "c->topic"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_add",
          "args": [
            "mc",
            "\"private:topic:setter\"",
            "c->topic_setter"
          ],
          "line": 716
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slog",
          "args": [
            "LG_DEBUG",
            "\"KeepTopic: topic set for %s by %s: %s\"",
            "c->name",
            "c->topic_setter",
            "c->topic"
          ],
          "line": 714
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_delete",
          "args": [
            "mc",
            "\"private:topic:ts\""
          ],
          "line": 710
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:topic:ts\""
          ],
          "line": 709
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_delete",
          "args": [
            "mc",
            "\"private:topic:setter\""
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:topic:setter\""
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_delete",
          "args": [
            "mc",
            "\"private:topic:text\""
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcmp",
          "args": [
            "md->value",
            "c->topic"
          ],
          "line": 701
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:topic:text\""
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_find",
          "args": [
            "c->name"
          ],
          "line": 693
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_register(hook_channel_req_t *mc);\nstatic void cs_newchan(channel_t *c);\nstatic void cs_keeptopic_topicset(channel_t *c);\nstatic void cs_tschange(channel_t *c);\n\nstatic void cs_keeptopic_topicset(channel_t *c)\n{\n\tmychan_t *mc;\n\tmetadata_t *md;\n\n\tmc = mychan_find(c->name);\n\n\tif (mc == NULL)\n\t\treturn;\n\n\tmd = metadata_find(mc, \"private:topic:text\");\n\tif (md != NULL)\n\t{\n\t\tif (c->topic != NULL && !strcmp(md->value, c->topic))\n\t\t\treturn;\n\t\tmetadata_delete(mc, \"private:topic:text\");\n\t}\n\n\tif (metadata_find(mc, \"private:topic:setter\"))\n\t\tmetadata_delete(mc, \"private:topic:setter\");\n\n\tif (metadata_find(mc, \"private:topic:ts\"))\n\t\tmetadata_delete(mc, \"private:topic:ts\");\n\n\tif (c->topic && c->topic_setter)\n\t{\n\t\tslog(LG_DEBUG, \"KeepTopic: topic set for %s by %s: %s\", c->name,\n\t\t\tc->topic_setter, c->topic);\n\t\tmetadata_add(mc, \"private:topic:setter\",\n\t\t\tc->topic_setter);\n\t\tmetadata_add(mc, \"private:topic:text\",\n\t\t\tc->topic);\n\t\tmetadata_add(mc, \"private:topic:ts\",\n\t\t\tnumber_to_string(c->topicts));\n\t}\n\telse\n\t\tslog(LG_DEBUG, \"KeepTopic: topic cleared for %s\", c->name);\n}"
  },
  {
    "function_name": "cs_succession",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
    "lines": "682-685",
    "snippet": "static void cs_succession(hook_channel_succession_req_t *data)\n{\n\tchanacs_change_simple(data->mc, entity(data->mu), NULL, custom_founder_check(), 0, NULL);\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"template.h\"",
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_register(hook_channel_req_t *mc);",
      "static void cs_succession(hook_channel_succession_req_t *data);",
      "static void cs_topiccheck(hook_channel_topic_check_t *data);",
      "static void cs_bounce_mode_change(hook_channel_mode_change_t *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "chanacs_change_simple",
          "args": [
            "data->mc",
            "entity(data->mu)",
            "NULL",
            "custom_founder_check()",
            "0",
            "NULL"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "custom_founder_check",
          "args": [],
          "line": 684
        },
        "resolved": true,
        "details": {
          "function_name": "custom_founder_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/chanserv.h",
          "lines": "6-14",
          "snippet": "static inline unsigned int custom_founder_check(void)\n{\n\tchar *p;\n\n\tif (chansvs.founder_flags != NULL && (p = strchr(chansvs.founder_flags, 'F')) != NULL)\n\t\treturn flags_to_bitmask(chansvs.founder_flags, 0);\n\telse\n\t\treturn CA_INITIAL & ca_all;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int custom_founder_check(void)\n{\n\tchar *p;\n\n\tif (chansvs.founder_flags != NULL && (p = strchr(chansvs.founder_flags, 'F')) != NULL)\n\t\treturn flags_to_bitmask(chansvs.founder_flags, 0);\n\telse\n\t\treturn CA_INITIAL & ca_all;\n}"
        }
      },
      {
        "call_info": {
          "callee": "entity",
          "args": [
            "data->mu"
          ],
          "line": 684
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_register(hook_channel_req_t *mc);\nstatic void cs_succession(hook_channel_succession_req_t *data);\nstatic void cs_topiccheck(hook_channel_topic_check_t *data);\nstatic void cs_bounce_mode_change(hook_channel_mode_change_t *data);\n\nstatic void cs_succession(hook_channel_succession_req_t *data)\n{\n\tchanacs_change_simple(data->mc, entity(data->mu), NULL, custom_founder_check(), 0, NULL);\n}"
  },
  {
    "function_name": "cs_register",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
    "lines": "664-680",
    "snippet": "static void cs_register(hook_channel_req_t *hdata)\n{\n\tmychan_t *mc;\n\n\tmc = hdata->mc;\n\tif (mc->chan)\n\t{\n\t\tif (mc->flags & MC_GUARD)\n\t\t\tjoin(mc->name, chansvs.nick);\n\t\tif (metadata_find(mc, \"private:botserv:bot-assigned\") != NULL)\n\t\t\treturn;\n\n\t\tmlock_sts(mc->chan);\n\t\ttopiclock_sts(mc->chan);\n\t\tcheck_modes(mc, true);\n\t}\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"template.h\"",
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_join(hook_channel_joinpart_t *hdata);",
      "static void cs_part(hook_channel_joinpart_t *hdata);",
      "static void cs_register(hook_channel_req_t *mc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "check_modes",
          "args": [
            "mc",
            "true"
          ],
          "line": 678
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "topiclock_sts",
          "args": [
            "mc->chan"
          ],
          "line": 677
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mlock_sts",
          "args": [
            "mc->chan"
          ],
          "line": 676
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:botserv:bot-assigned\""
          ],
          "line": 673
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "join",
          "args": [
            "mc->name",
            "chansvs.nick"
          ],
          "line": 672
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_join(hook_channel_joinpart_t *hdata);\nstatic void cs_part(hook_channel_joinpart_t *hdata);\nstatic void cs_register(hook_channel_req_t *mc);\n\nstatic void cs_register(hook_channel_req_t *hdata)\n{\n\tmychan_t *mc;\n\n\tmc = hdata->mc;\n\tif (mc->chan)\n\t{\n\t\tif (mc->flags & MC_GUARD)\n\t\t\tjoin(mc->name, chansvs.nick);\n\t\tif (metadata_find(mc, \"private:botserv:bot-assigned\") != NULL)\n\t\t\treturn;\n\n\t\tmlock_sts(mc->chan);\n\t\ttopiclock_sts(mc->chan);\n\t\tcheck_modes(mc, true);\n\t}\n}"
  },
  {
    "function_name": "get_changets_user",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
    "lines": "645-662",
    "snippet": "static user_t *get_changets_user(mychan_t *mc)\n{\n\tmetadata_t *md;\n\n\treturn_val_if_fail(mc != NULL, chansvs.me->me);\n\n\tmd = metadata_find(mc, \"private:botserv:bot-assigned\");\n\tif (md != NULL)\n\t{\n\t\tuser_t *u = user_find(md->value);\n\n\t\treturn_val_if_fail(is_internal_client(u), chansvs.me->me);\n\n\t\treturn u;\n\t}\n\n\treturn chansvs.me->me;\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"template.h\"",
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_register(hook_channel_req_t *mc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "return_val_if_fail",
          "args": [
            "is_internal_client(u)",
            "chansvs.me->me"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_internal_client",
          "args": [
            "u"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_find",
          "args": [
            "md->value"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:botserv:bot-assigned\""
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "return_val_if_fail",
          "args": [
            "mc != NULL",
            "chansvs.me->me"
          ],
          "line": 649
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_register(hook_channel_req_t *mc);\n\nstatic user_t *get_changets_user(mychan_t *mc)\n{\n\tmetadata_t *md;\n\n\treturn_val_if_fail(mc != NULL, chansvs.me->me);\n\n\tmd = metadata_find(mc, \"private:botserv:bot-assigned\");\n\tif (md != NULL)\n\t{\n\t\tuser_t *u = user_find(md->value);\n\n\t\treturn_val_if_fail(is_internal_client(u), chansvs.me->me);\n\n\t\treturn u;\n\t}\n\n\treturn chansvs.me->me;\n}"
  },
  {
    "function_name": "cs_part",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
    "lines": "594-643",
    "snippet": "static void cs_part(hook_channel_joinpart_t *hdata)\n{\n\tchanuser_t *cu;\n\tmychan_t *mc;\n\n\tcu = hdata->cu;\n\tif (cu == NULL)\n\t\treturn;\n\tmc = mychan_find(cu->chan->name);\n\tif (mc == NULL)\n\t\treturn;\n\tif (metadata_find(mc, \"private:botserv:bot-assigned\") != NULL)\n\t\treturn;\n\n\tif (CURRTIME - mc->used >= 3600)\n\t\tif (chanacs_user_flags(mc, cu->user) & CA_USEDUPDATE)\n\t\t\tmc->used = CURRTIME;\n\n\t/*\n\t * When channel_part is fired, we haven't yet removed the\n\t * user from the room. So, the channel will have two members\n\t * if ChanServ is joining channels: the triggering user and\n\t * itself.\n\t *\n\t * This if block was utter nonsense.  Refactor it into multiple\n\t * branches for better clarity and debugging ability. --nenolod\n\t */\n\n\t/* we're not parting if we've been told to never part. */\n\tif (!config_options.leave_chans)\n\t\treturn;\n\n\t/* we're not parting if the channel has more than one person on it */\n\tif (cu->chan->nummembers - cu->chan->numsvcmembers > 1)\n\t\treturn;\n\n\t/* internal clients parting a channel shouldn't cause chanserv to leave. */\n\tif (is_internal_client(cu->user))\n\t\treturn;\n\n\t/* if we're enforcing an akick, we're MC_INHABIT.  do not part. */\n\tif (mc->flags & MC_INHABIT)\n\t{\n\t\tslog(LG_DEBUG, \"cs_part(): not leaving channel %s due to MC_INHABIT flag\", mc->name);\n\t\treturn;\n\t}\n\n\t/* seems we've met all conditions to be parted from a channel. */\n\tpart(cu->chan->name, chansvs.nick);\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"template.h\"",
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_join(hook_channel_joinpart_t *hdata);",
      "static void cs_part(hook_channel_joinpart_t *hdata);",
      "static void cs_register(hook_channel_req_t *mc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "part",
          "args": [
            "cu->chan->name",
            "chansvs.nick"
          ],
          "line": 642
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slog",
          "args": [
            "LG_DEBUG",
            "\"cs_part(): not leaving channel %s due to MC_INHABIT flag\"",
            "mc->name"
          ],
          "line": 637
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_internal_client",
          "args": [
            "cu->user"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_user_flags",
          "args": [
            "mc",
            "cu->user"
          ],
          "line": 609
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:botserv:bot-assigned\""
          ],
          "line": 605
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_find",
          "args": [
            "cu->chan->name"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_join(hook_channel_joinpart_t *hdata);\nstatic void cs_part(hook_channel_joinpart_t *hdata);\nstatic void cs_register(hook_channel_req_t *mc);\n\nstatic void cs_part(hook_channel_joinpart_t *hdata)\n{\n\tchanuser_t *cu;\n\tmychan_t *mc;\n\n\tcu = hdata->cu;\n\tif (cu == NULL)\n\t\treturn;\n\tmc = mychan_find(cu->chan->name);\n\tif (mc == NULL)\n\t\treturn;\n\tif (metadata_find(mc, \"private:botserv:bot-assigned\") != NULL)\n\t\treturn;\n\n\tif (CURRTIME - mc->used >= 3600)\n\t\tif (chanacs_user_flags(mc, cu->user) & CA_USEDUPDATE)\n\t\t\tmc->used = CURRTIME;\n\n\t/*\n\t * When channel_part is fired, we haven't yet removed the\n\t * user from the room. So, the channel will have two members\n\t * if ChanServ is joining channels: the triggering user and\n\t * itself.\n\t *\n\t * This if block was utter nonsense.  Refactor it into multiple\n\t * branches for better clarity and debugging ability. --nenolod\n\t */\n\n\t/* we're not parting if we've been told to never part. */\n\tif (!config_options.leave_chans)\n\t\treturn;\n\n\t/* we're not parting if the channel has more than one person on it */\n\tif (cu->chan->nummembers - cu->chan->numsvcmembers > 1)\n\t\treturn;\n\n\t/* internal clients parting a channel shouldn't cause chanserv to leave. */\n\tif (is_internal_client(cu->user))\n\t\treturn;\n\n\t/* if we're enforcing an akick, we're MC_INHABIT.  do not part. */\n\tif (mc->flags & MC_INHABIT)\n\t{\n\t\tslog(LG_DEBUG, \"cs_part(): not leaving channel %s due to MC_INHABIT flag\", mc->name);\n\t\treturn;\n\t}\n\n\t/* seems we've met all conditions to be parted from a channel. */\n\tpart(cu->chan->name, chansvs.nick);\n}"
  },
  {
    "function_name": "cs_join",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
    "lines": "344-592",
    "snippet": "static void cs_join(hook_channel_joinpart_t *hdata)\n{\n\tchanuser_t *cu = hdata->cu;\n\tuser_t *u;\n\tchannel_t *chan;\n\tmychan_t *mc;\n\tunsigned int flags;\n\tbool noop;\n\tbool secure;\n\tmetadata_t *md;\n\tchanacs_t *ca2;\n\tchar akickreason[120] = \"User is banned from this channel\", *p;\n\n\tif (cu == NULL || is_internal_client(cu->user))\n\t\treturn;\n\tu = cu->user;\n\tchan = cu->chan;\n\n\t/* first check if this is a registered channel at all */\n\tmc = mychan_find(chan->name);\n\tif (mc == NULL)\n\t\treturn;\n\n\tflags = chanacs_user_flags(mc, u);\n\tnoop = mc->flags & MC_NOOP || (u->myuser != NULL &&\n\t\t\tu->myuser->flags & MU_NOOP);\n\t/* attempt to deop people recreating channels, if the more\n\t * sophisticated mechanism is disabled */\n\tsecure = mc->flags & MC_SECURE || (!chansvs.changets &&\n\t\t\tchan->nummembers == 1 && chan->ts > CURRTIME - 300);\n\n\tif (chan->nummembers == 1 && mc->flags & MC_GUARD &&\n\t\tmetadata_find(mc, \"private:botserv:bot-assigned\") == NULL)\n\t\tjoin(chan->name, chansvs.nick);\n\n\t/*\n\t * CS SET RESTRICTED: if they don't have any access (excluding AKICK)\n\t * or special privs to join restricted chans, boot them. -- w00t\n\t */\n\tif ((mc->flags & MC_RESTRICTED) && !(flags & CA_ALLPRIVS) && !has_priv_user(u, PRIV_JOIN_STAFFONLY))\n\t{\n\t\t/* Stay on channel if this would empty it -- jilles */\n\t\tif (chan->nummembers - chan->numsvcmembers == 1)\n\t\t{\n\t\t\tmc->flags |= MC_INHABIT;\n\t\t\tif (chan->numsvcmembers == 0)\n\t\t\t\tjoin(chan->name, chansvs.nick);\n\t\t}\n\t\tif (mc->mlock_on & CMODE_INVITE || chan->modes & CMODE_INVITE)\n\t\t{\n\t\t\tif (!(chan->modes & CMODE_INVITE))\n\t\t\t\tcheck_modes(mc, true);\n\t\t\tremove_banlike(chansvs.me->me, chan, ircd->invex_mchar, u);\n\t\t\tmodestack_flush_channel(chan);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tban(chansvs.me->me, chan, u);\n\t\t\tremove_ban_exceptions(chansvs.me->me, chan, u);\n\t\t}\n\t\ttry_kick(chansvs.me->me, chan, u, \"You are not authorized to be on this channel\");\n\t\thdata->cu = NULL;\n\t\treturn;\n\t}\n\n\tif (flags & CA_AKICK && !(flags & CA_EXEMPT))\n\t{\n\t\t/* Stay on channel if this would empty it -- jilles */\n\t\tif (chan->nummembers - chan->numsvcmembers == 1)\n\t\t{\n\t\t\tmc->flags |= MC_INHABIT;\n\t\t\tif (chan->numsvcmembers == 0)\n\t\t\t\tjoin(chan->name, chansvs.nick);\n\t\t}\n\t\t/* use a user-given ban mask if possible -- jilles */\n\t\tca2 = chanacs_find_host_by_user(mc, u, CA_AKICK);\n\t\tif (ca2 != NULL)\n\t\t{\n\t\t\tif (chanban_find(chan, ca2->host, 'b') == NULL)\n\t\t\t{\n\t\t\t\tchanban_add(chan, ca2->host, 'b');\n\t\t\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_ADD, 'b', ca2->host);\n\t\t\t\tmodestack_flush_channel(chan);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* XXX this could be done more efficiently */\n\t\t\tca2 = chanacs_find(mc, entity(u->myuser), CA_AKICK);\n\t\t\tban(chansvs.me->me, chan, u);\n\t\t}\n\t\tremove_ban_exceptions(chansvs.me->me, chan, u);\n\t\tif (ca2 != NULL)\n\t\t{\n\t\t\tmd = metadata_find(ca2, \"reason\");\n\t\t\tif (md != NULL && *md->value != '|')\n\t\t\t{\n\t\t\t\tsnprintf(akickreason, sizeof akickreason,\n\t\t\t\t\t\t\"Banned: %s\", md->value);\n\t\t\t\tp = strchr(akickreason, '|');\n\t\t\t\tif (p != NULL)\n\t\t\t\t\t*p = '\\0';\n\t\t\t\telse\n\t\t\t\t\tp = akickreason + strlen(akickreason);\n\t\t\t\t/* strip trailing spaces, so as not to\n\t\t\t\t * disclose the existence of an oper reason */\n\t\t\t\tp--;\n\t\t\t\twhile (p > akickreason && *p == ' ')\n\t\t\t\t\tp--;\n\t\t\t\tp[1] = '\\0';\n\t\t\t}\n\t\t}\n\t\ttry_kick(chansvs.me->me, chan, u, akickreason);\n\t\thdata->cu = NULL;\n\t\treturn;\n\t}\n\n\t/* Kick out users who may be recreating channels mlocked +i.\n\t * Users with +i flag are allowed to join, as are users matching\n\t * an invite exception (the latter only works if the channel already\n\t * exists because members are sent before invite exceptions).\n\t * Because most networks do not use kick_on_split_riding or\n\t * no_create_on_split, do not trust users coming back from splits;\n\t * with the exception of users coming back after a services\n\t * restart if the channel TS did not change.\n\t * Unfortunately, this kicks users who have been invited by a channel\n\t * operator, after a split.\n\t */\n\tif (mc->mlock_on & CMODE_INVITE && !(flags & CA_INVITE) &&\n\t\t\t(!me.bursting || mc->flags & MC_RECREATED) &&\n\t\t\t(!(u->server->flags & SF_EOB) || (chan->nummembers - chan->numsvcmembers == 1)) &&\n\t\t\t(!ircd->invex_mchar || !next_matching_ban(chan, u, ircd->invex_mchar, chan->bans.head)))\n\t{\n\t\tif (chan->nummembers - chan->numsvcmembers == 1)\n\t\t{\n\t\t\tmc->flags |= MC_INHABIT;\n\t\t\tif (chan->numsvcmembers == 0)\n\t\t\t\tjoin(chan->name, chansvs.nick);\n\t\t}\n\t\tif (!(chan->modes & CMODE_INVITE))\n\t\t\tcheck_modes(mc, true);\n\t\tmodestack_flush_channel(chan);\n\t\ttry_kick(chansvs.me->me, chan, u, \"Invite only channel\");\n\t\thdata->cu = NULL;\n\t\treturn;\n\t}\n\n\t/* A second user joined and was not kicked; we do not need\n\t * to stay on the channel artificially.\n\t * If there is only one user, stay in the channel to avoid\n\t * triggering autocycle-for-ops scripts and immediately\n\t * destroying channels with kick on split riding.\n\t */\n\tif (mc->flags & MC_INHABIT && chan->nummembers - chan->numsvcmembers >= 2)\n\t{\n\t\tmc->flags &= ~MC_INHABIT;\n\t\tif (!(mc->flags & MC_GUARD) && !(chan->flags & CHAN_LOG) && chanuser_find(chan, chansvs.me->me))\n\t\t\tpart(chan->name, chansvs.nick);\n\t}\n\n\tif (ircd->uses_owner)\n\t{\n\t\tif (flags & CA_USEOWNER)\n\t\t{\n\t\t\tif (flags & CA_AUTOOP && !(noop || cu->modes & ircd->owner_mode))\n\t\t\t{\n\t\t\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_ADD, ircd->owner_mchar[1], CLIENT_NAME(u));\n\t\t\t\tcu->modes |= ircd->owner_mode;\n\t\t\t}\n\t\t}\n\t\telse if (secure && (cu->modes & ircd->owner_mode))\n\t\t{\n\t\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_DEL, ircd->owner_mchar[1], CLIENT_NAME(u));\n\t\t\tcu->modes &= ~ircd->owner_mode;\n\t\t}\n\t}\n\n\tif (ircd->uses_protect)\n\t{\n\t\tif (flags & CA_USEPROTECT)\n\t\t{\n\t\t\tif (flags & CA_AUTOOP && !(noop || cu->modes & ircd->protect_mode || (ircd->uses_owner && cu->modes & ircd->owner_mode)))\n\t\t\t{\n\t\t\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_ADD, ircd->protect_mchar[1], CLIENT_NAME(u));\n\t\t\t\tcu->modes |= ircd->protect_mode;\n\t\t\t}\n\t\t}\n\t\telse if (secure && (cu->modes & ircd->protect_mode))\n\t\t{\n\t\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_DEL, ircd->protect_mchar[1], CLIENT_NAME(u));\n\t\t\tcu->modes &= ~ircd->protect_mode;\n\t\t}\n\t}\n\n\tif (flags & CA_AUTOOP)\n\t{\n\t\tif (!(noop || cu->modes & CSTATUS_OP))\n\t\t{\n\t\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_ADD, 'o', CLIENT_NAME(u));\n\t\t\tcu->modes |= CSTATUS_OP;\n\t\t}\n\t}\n\telse if (secure && (cu->modes & CSTATUS_OP) && !(flags & CA_OP))\n\t{\n\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_DEL, 'o', CLIENT_NAME(u));\n\t\tcu->modes &= ~CSTATUS_OP;\n\t}\n\n\tif (ircd->uses_halfops)\n\t{\n\t\tif (flags & CA_AUTOHALFOP)\n\t\t{\n\t\t\tif (!(noop || cu->modes & (CSTATUS_OP | ircd->halfops_mode)))\n\t\t\t{\n\t\t\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_ADD, 'h', CLIENT_NAME(u));\n\t\t\t\tcu->modes |= ircd->halfops_mode;\n\t\t\t}\n\t\t}\n\t\telse if (secure && (cu->modes & ircd->halfops_mode) && !(flags & CA_HALFOP))\n\t\t{\n\t\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_DEL, 'h', CLIENT_NAME(u));\n\t\t\tcu->modes &= ~ircd->halfops_mode;\n\t\t}\n\t}\n\n\tif (flags & CA_AUTOVOICE)\n\t{\n\t\tif (!(noop || cu->modes & (CSTATUS_OP | ircd->halfops_mode | CSTATUS_VOICE)))\n\t\t{\n\t\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_ADD, 'v', CLIENT_NAME(u));\n\t\t\tcu->modes |= CSTATUS_VOICE;\n\t\t}\n\t}\n\n\tif (u->server->flags & SF_EOB && (md = metadata_find(mc, \"private:entrymsg\")))\n\t{\n\t\tif (metadata_find(mc, \"private:botserv:bot-assigned\") == NULL)\n\t\t{\n\t\t\tif (!u->myuser || !(u->myuser->flags & MU_NOGREET))\n\t\t\t\tnotice(chansvs.nick, cu->user->nick, \"[%s] %s\", mc->name, md->value);\n\t\t}\n\t}\n\n\tif (u->server->flags & SF_EOB && (md = metadata_find(mc, \"url\")))\n\t\tnumeric_sts(me.me, 328, cu->user, \"%s :%s\", mc->name, md->value);\n\n\tif (flags & CA_USEDUPDATE)\n\t\tmc->used = CURRTIME;\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"template.h\"",
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_join(hook_channel_joinpart_t *hdata);",
      "static void cs_part(hook_channel_joinpart_t *hdata);",
      "static void cs_register(hook_channel_req_t *mc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "numeric_sts",
          "args": [
            "me.me",
            "328",
            "cu->user",
            "\"%s :%s\"",
            "mc->name",
            "md->value"
          ],
          "line": 588
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"url\""
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "notice",
          "args": [
            "chansvs.nick",
            "cu->user->nick",
            "\"[%s] %s\"",
            "mc->name",
            "md->value"
          ],
          "line": 583
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:botserv:bot-assigned\""
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:entrymsg\""
          ],
          "line": 578
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modestack_mode_param",
          "args": [
            "chansvs.nick",
            "chan",
            "MTYPE_ADD",
            "'v'",
            "CLIENT_NAME(u)"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLIENT_NAME",
          "args": [
            "u"
          ],
          "line": 573
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modestack_mode_param",
          "args": [
            "chansvs.nick",
            "chan",
            "MTYPE_DEL",
            "'h'",
            "CLIENT_NAME(u)"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLIENT_NAME",
          "args": [
            "u"
          ],
          "line": 564
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modestack_mode_param",
          "args": [
            "chansvs.nick",
            "chan",
            "MTYPE_ADD",
            "'h'",
            "CLIENT_NAME(u)"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLIENT_NAME",
          "args": [
            "u"
          ],
          "line": 558
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modestack_mode_param",
          "args": [
            "chansvs.nick",
            "chan",
            "MTYPE_DEL",
            "'o'",
            "CLIENT_NAME(u)"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLIENT_NAME",
          "args": [
            "u"
          ],
          "line": 548
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modestack_mode_param",
          "args": [
            "chansvs.nick",
            "chan",
            "MTYPE_ADD",
            "'o'",
            "CLIENT_NAME(u)"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLIENT_NAME",
          "args": [
            "u"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modestack_mode_param",
          "args": [
            "chansvs.nick",
            "chan",
            "MTYPE_DEL",
            "ircd->protect_mchar[1]",
            "CLIENT_NAME(u)"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLIENT_NAME",
          "args": [
            "u"
          ],
          "line": 533
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modestack_mode_param",
          "args": [
            "chansvs.nick",
            "chan",
            "MTYPE_ADD",
            "ircd->protect_mchar[1]",
            "CLIENT_NAME(u)"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLIENT_NAME",
          "args": [
            "u"
          ],
          "line": 527
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modestack_mode_param",
          "args": [
            "chansvs.nick",
            "chan",
            "MTYPE_DEL",
            "ircd->owner_mchar[1]",
            "CLIENT_NAME(u)"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLIENT_NAME",
          "args": [
            "u"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modestack_mode_param",
          "args": [
            "chansvs.nick",
            "chan",
            "MTYPE_ADD",
            "ircd->owner_mchar[1]",
            "CLIENT_NAME(u)"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLIENT_NAME",
          "args": [
            "u"
          ],
          "line": 510
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "part",
          "args": [
            "chan->name",
            "chansvs.nick"
          ],
          "line": 501
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanuser_find",
          "args": [
            "chan",
            "chansvs.me->me"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_kick",
          "args": [
            "chansvs.me->me",
            "chan",
            "u",
            "\"Invite only channel\""
          ],
          "line": 486
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modestack_flush_channel",
          "args": [
            "chan"
          ],
          "line": 485
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_modes",
          "args": [
            "mc",
            "true"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "join",
          "args": [
            "chan->name",
            "chansvs.nick"
          ],
          "line": 481
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_matching_ban",
          "args": [
            "chan",
            "u",
            "ircd->invex_mchar",
            "chan->bans.head"
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_kick",
          "args": [
            "chansvs.me->me",
            "chan",
            "u",
            "akickreason"
          ],
          "line": 456
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "akickreason"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "akickreason",
            "'|'"
          ],
          "line": 443
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "akickreason",
            "sizeof akickreason",
            "\"Banned: %s\"",
            "md->value"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "ca2",
            "\"reason\""
          ],
          "line": 438
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_ban_exceptions",
          "args": [
            "chansvs.me->me",
            "chan",
            "u"
          ],
          "line": 435
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ban",
          "args": [
            "chansvs.me->me",
            "chan",
            "u"
          ],
          "line": 433
        },
        "resolved": true,
        "details": {
          "function_name": "cs_cmd_unban",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/ban.c",
          "lines": "111-204",
          "snippet": "static void cs_cmd_unban(sourceinfo_t *si, int parc, char *parv[])\n{\n        const char *channel = parv[0];\n        const char *target = parv[1];\n        channel_t *c = channel_find(channel);\n\tmychan_t *mc = mychan_find(channel);\n\tuser_t *tu;\n\tchanban_t *cb;\n\n\tif (!channel)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"UNBAN\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: UNBAN <#channel> <nickname|hostmask>\"));\n\t\treturn;\n\t}\n\n\tif (!target)\n\t{\n\t\tif (si->su == NULL)\n\t\t{\n\t\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"UNBAN\");\n\t\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: UNBAN <#channel> <nickname|hostmask>\"));\n\t\t\treturn;\n\t\t}\n\t\ttarget = si->su->nick;\n\t}\n\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), channel);\n\t\treturn;\n\t}\n\n\tif (!c)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is currently empty.\"), channel);\n\t\treturn;\n\t}\n\n\tif (!chanacs_source_has_flag(mc, si, CA_REMOVE) &&\n\t\t\t(si->su == NULL ||\n\t\t\t !chanacs_source_has_flag(mc, si, CA_EXEMPT) ||\n\t\t\t irccasecmp(target, si->su->nick)))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\treturn;\n\t}\n\n\tif ((tu = user_find_named(target)))\n\t{\n\t\tmowgli_node_t *n, *tn;\n\t\tchar hostbuf2[BUFSIZE];\n\t\tint count = 0;\n\n\t\tsnprintf(hostbuf2, BUFSIZE, \"%s!%s@%s\", tu->nick, tu->user, tu->vhost);\n\t\tfor (n = next_matching_ban(c, tu, 'b', c->bans.head); n != NULL; n = next_matching_ban(c, tu, 'b', tn))\n\t\t{\n\t\t\ttn = n->next;\n\t\t\tcb = n->data;\n\n\t\t\tlogcommand(si, CMDLOG_DO, \"UNBAN: \\2%s\\2 on \\2%s\\2 (for user \\2%s\\2)\", cb->mask, mc->name, hostbuf2);\n\t\t\tmodestack_mode_param(chansvs.nick, c, MTYPE_DEL, cb->type, cb->mask);\n\t\t\tchanban_delete(cb);\n\t\t\tcount++;\n\t\t}\n\t\tif (count > 0)\n\t\t\tcommand_success_nodata(si, _(\"Unbanned \\2%s\\2 on \\2%s\\2 (%d ban%s removed).\"),\n\t\t\t\ttarget, channel, count, (count != 1 ? \"s\" : \"\"));\n\t\telse\n\t\t\tcommand_success_nodata(si, _(\"No bans found matching \\2%s\\2 on \\2%s\\2.\"), target, channel);\n\t\treturn;\n\t}\n\telse if ((cb = chanban_find(c, target, 'b')) != NULL || validhostmask(target))\n\t{\n\t\tif (cb)\n\t\t{\n\t\t\tmodestack_mode_param(chansvs.nick, c, MTYPE_DEL, 'b', target);\n\t\t\tchanban_delete(cb);\n\t\t\tlogcommand(si, CMDLOG_DO, \"UNBAN: \\2%s\\2 on \\2%s\\2\", target, mc->name);\n\t\t\tif (si->su == NULL || !chanuser_find(mc->chan, si->su))\n\t\t\t\tcommand_success_nodata(si, _(\"Unbanned \\2%s\\2 on \\2%s\\2.\"), target, channel);\n\t\t}\n\t\telse\n\t\t\tcommand_fail(si, fault_nosuch_key, _(\"No such ban \\2%s\\2 on \\2%s\\2.\"), target, channel);\n\n\t\treturn;\n\t}\n        else\n        {\n\t\tcommand_fail(si, fault_badparams, _(\"Invalid nickname/hostmask provided: \\2%s\\2\"), target);\n\t\tcommand_fail(si, fault_badparams, _(\"Syntax: UNBAN <#channel> [nickname|hostmask]\"));\n\t\treturn;\n        }\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cs_cmd_ban(sourceinfo_t *si, int parc, char *parv[]);",
            "static void cs_cmd_unban(sourceinfo_t *si, int parc, char *parv[]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic void cs_cmd_ban(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_unban(sourceinfo_t *si, int parc, char *parv[]);\n\nstatic void cs_cmd_unban(sourceinfo_t *si, int parc, char *parv[])\n{\n        const char *channel = parv[0];\n        const char *target = parv[1];\n        channel_t *c = channel_find(channel);\n\tmychan_t *mc = mychan_find(channel);\n\tuser_t *tu;\n\tchanban_t *cb;\n\n\tif (!channel)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"UNBAN\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: UNBAN <#channel> <nickname|hostmask>\"));\n\t\treturn;\n\t}\n\n\tif (!target)\n\t{\n\t\tif (si->su == NULL)\n\t\t{\n\t\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"UNBAN\");\n\t\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: UNBAN <#channel> <nickname|hostmask>\"));\n\t\t\treturn;\n\t\t}\n\t\ttarget = si->su->nick;\n\t}\n\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), channel);\n\t\treturn;\n\t}\n\n\tif (!c)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is currently empty.\"), channel);\n\t\treturn;\n\t}\n\n\tif (!chanacs_source_has_flag(mc, si, CA_REMOVE) &&\n\t\t\t(si->su == NULL ||\n\t\t\t !chanacs_source_has_flag(mc, si, CA_EXEMPT) ||\n\t\t\t irccasecmp(target, si->su->nick)))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\treturn;\n\t}\n\n\tif ((tu = user_find_named(target)))\n\t{\n\t\tmowgli_node_t *n, *tn;\n\t\tchar hostbuf2[BUFSIZE];\n\t\tint count = 0;\n\n\t\tsnprintf(hostbuf2, BUFSIZE, \"%s!%s@%s\", tu->nick, tu->user, tu->vhost);\n\t\tfor (n = next_matching_ban(c, tu, 'b', c->bans.head); n != NULL; n = next_matching_ban(c, tu, 'b', tn))\n\t\t{\n\t\t\ttn = n->next;\n\t\t\tcb = n->data;\n\n\t\t\tlogcommand(si, CMDLOG_DO, \"UNBAN: \\2%s\\2 on \\2%s\\2 (for user \\2%s\\2)\", cb->mask, mc->name, hostbuf2);\n\t\t\tmodestack_mode_param(chansvs.nick, c, MTYPE_DEL, cb->type, cb->mask);\n\t\t\tchanban_delete(cb);\n\t\t\tcount++;\n\t\t}\n\t\tif (count > 0)\n\t\t\tcommand_success_nodata(si, _(\"Unbanned \\2%s\\2 on \\2%s\\2 (%d ban%s removed).\"),\n\t\t\t\ttarget, channel, count, (count != 1 ? \"s\" : \"\"));\n\t\telse\n\t\t\tcommand_success_nodata(si, _(\"No bans found matching \\2%s\\2 on \\2%s\\2.\"), target, channel);\n\t\treturn;\n\t}\n\telse if ((cb = chanban_find(c, target, 'b')) != NULL || validhostmask(target))\n\t{\n\t\tif (cb)\n\t\t{\n\t\t\tmodestack_mode_param(chansvs.nick, c, MTYPE_DEL, 'b', target);\n\t\t\tchanban_delete(cb);\n\t\t\tlogcommand(si, CMDLOG_DO, \"UNBAN: \\2%s\\2 on \\2%s\\2\", target, mc->name);\n\t\t\tif (si->su == NULL || !chanuser_find(mc->chan, si->su))\n\t\t\t\tcommand_success_nodata(si, _(\"Unbanned \\2%s\\2 on \\2%s\\2.\"), target, channel);\n\t\t}\n\t\telse\n\t\t\tcommand_fail(si, fault_nosuch_key, _(\"No such ban \\2%s\\2 on \\2%s\\2.\"), target, channel);\n\n\t\treturn;\n\t}\n        else\n        {\n\t\tcommand_fail(si, fault_badparams, _(\"Invalid nickname/hostmask provided: \\2%s\\2\"), target);\n\t\tcommand_fail(si, fault_badparams, _(\"Syntax: UNBAN <#channel> [nickname|hostmask]\"));\n\t\treturn;\n        }\n}"
        }
      },
      {
        "call_info": {
          "callee": "chanacs_find",
          "args": [
            "mc",
            "entity(u->myuser)",
            "CA_AKICK"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entity",
          "args": [
            "u->myuser"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modestack_flush_channel",
          "args": [
            "chan"
          ],
          "line": 426
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modestack_mode_param",
          "args": [
            "chansvs.nick",
            "chan",
            "MTYPE_ADD",
            "'b'",
            "ca2->host"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanban_add",
          "args": [
            "chan",
            "ca2->host",
            "'b'"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanban_find",
          "args": [
            "chan",
            "ca2->host",
            "'b'"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_find_host_by_user",
          "args": [
            "mc",
            "u",
            "CA_AKICK"
          ],
          "line": 419
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "join",
          "args": [
            "chan->name",
            "chansvs.nick"
          ],
          "line": 416
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "try_kick",
          "args": [
            "chansvs.me->me",
            "chan",
            "u",
            "\"You are not authorized to be on this channel\""
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_ban_exceptions",
          "args": [
            "chansvs.me->me",
            "chan",
            "u"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modestack_flush_channel",
          "args": [
            "chan"
          ],
          "line": 397
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "remove_banlike",
          "args": [
            "chansvs.me->me",
            "chan",
            "ircd->invex_mchar",
            "u"
          ],
          "line": 396
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_modes",
          "args": [
            "mc",
            "true"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "join",
          "args": [
            "chan->name",
            "chansvs.nick"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_priv_user",
          "args": [
            "u",
            "PRIV_JOIN_STAFFONLY"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "join",
          "args": [
            "chan->name",
            "chansvs.nick"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:botserv:bot-assigned\""
          ],
          "line": 376
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_user_flags",
          "args": [
            "mc",
            "u"
          ],
          "line": 367
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_find",
          "args": [
            "chan->name"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_internal_client",
          "args": [
            "cu->user"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_join(hook_channel_joinpart_t *hdata);\nstatic void cs_part(hook_channel_joinpart_t *hdata);\nstatic void cs_register(hook_channel_req_t *mc);\n\nstatic void cs_join(hook_channel_joinpart_t *hdata)\n{\n\tchanuser_t *cu = hdata->cu;\n\tuser_t *u;\n\tchannel_t *chan;\n\tmychan_t *mc;\n\tunsigned int flags;\n\tbool noop;\n\tbool secure;\n\tmetadata_t *md;\n\tchanacs_t *ca2;\n\tchar akickreason[120] = \"User is banned from this channel\", *p;\n\n\tif (cu == NULL || is_internal_client(cu->user))\n\t\treturn;\n\tu = cu->user;\n\tchan = cu->chan;\n\n\t/* first check if this is a registered channel at all */\n\tmc = mychan_find(chan->name);\n\tif (mc == NULL)\n\t\treturn;\n\n\tflags = chanacs_user_flags(mc, u);\n\tnoop = mc->flags & MC_NOOP || (u->myuser != NULL &&\n\t\t\tu->myuser->flags & MU_NOOP);\n\t/* attempt to deop people recreating channels, if the more\n\t * sophisticated mechanism is disabled */\n\tsecure = mc->flags & MC_SECURE || (!chansvs.changets &&\n\t\t\tchan->nummembers == 1 && chan->ts > CURRTIME - 300);\n\n\tif (chan->nummembers == 1 && mc->flags & MC_GUARD &&\n\t\tmetadata_find(mc, \"private:botserv:bot-assigned\") == NULL)\n\t\tjoin(chan->name, chansvs.nick);\n\n\t/*\n\t * CS SET RESTRICTED: if they don't have any access (excluding AKICK)\n\t * or special privs to join restricted chans, boot them. -- w00t\n\t */\n\tif ((mc->flags & MC_RESTRICTED) && !(flags & CA_ALLPRIVS) && !has_priv_user(u, PRIV_JOIN_STAFFONLY))\n\t{\n\t\t/* Stay on channel if this would empty it -- jilles */\n\t\tif (chan->nummembers - chan->numsvcmembers == 1)\n\t\t{\n\t\t\tmc->flags |= MC_INHABIT;\n\t\t\tif (chan->numsvcmembers == 0)\n\t\t\t\tjoin(chan->name, chansvs.nick);\n\t\t}\n\t\tif (mc->mlock_on & CMODE_INVITE || chan->modes & CMODE_INVITE)\n\t\t{\n\t\t\tif (!(chan->modes & CMODE_INVITE))\n\t\t\t\tcheck_modes(mc, true);\n\t\t\tremove_banlike(chansvs.me->me, chan, ircd->invex_mchar, u);\n\t\t\tmodestack_flush_channel(chan);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tban(chansvs.me->me, chan, u);\n\t\t\tremove_ban_exceptions(chansvs.me->me, chan, u);\n\t\t}\n\t\ttry_kick(chansvs.me->me, chan, u, \"You are not authorized to be on this channel\");\n\t\thdata->cu = NULL;\n\t\treturn;\n\t}\n\n\tif (flags & CA_AKICK && !(flags & CA_EXEMPT))\n\t{\n\t\t/* Stay on channel if this would empty it -- jilles */\n\t\tif (chan->nummembers - chan->numsvcmembers == 1)\n\t\t{\n\t\t\tmc->flags |= MC_INHABIT;\n\t\t\tif (chan->numsvcmembers == 0)\n\t\t\t\tjoin(chan->name, chansvs.nick);\n\t\t}\n\t\t/* use a user-given ban mask if possible -- jilles */\n\t\tca2 = chanacs_find_host_by_user(mc, u, CA_AKICK);\n\t\tif (ca2 != NULL)\n\t\t{\n\t\t\tif (chanban_find(chan, ca2->host, 'b') == NULL)\n\t\t\t{\n\t\t\t\tchanban_add(chan, ca2->host, 'b');\n\t\t\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_ADD, 'b', ca2->host);\n\t\t\t\tmodestack_flush_channel(chan);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* XXX this could be done more efficiently */\n\t\t\tca2 = chanacs_find(mc, entity(u->myuser), CA_AKICK);\n\t\t\tban(chansvs.me->me, chan, u);\n\t\t}\n\t\tremove_ban_exceptions(chansvs.me->me, chan, u);\n\t\tif (ca2 != NULL)\n\t\t{\n\t\t\tmd = metadata_find(ca2, \"reason\");\n\t\t\tif (md != NULL && *md->value != '|')\n\t\t\t{\n\t\t\t\tsnprintf(akickreason, sizeof akickreason,\n\t\t\t\t\t\t\"Banned: %s\", md->value);\n\t\t\t\tp = strchr(akickreason, '|');\n\t\t\t\tif (p != NULL)\n\t\t\t\t\t*p = '\\0';\n\t\t\t\telse\n\t\t\t\t\tp = akickreason + strlen(akickreason);\n\t\t\t\t/* strip trailing spaces, so as not to\n\t\t\t\t * disclose the existence of an oper reason */\n\t\t\t\tp--;\n\t\t\t\twhile (p > akickreason && *p == ' ')\n\t\t\t\t\tp--;\n\t\t\t\tp[1] = '\\0';\n\t\t\t}\n\t\t}\n\t\ttry_kick(chansvs.me->me, chan, u, akickreason);\n\t\thdata->cu = NULL;\n\t\treturn;\n\t}\n\n\t/* Kick out users who may be recreating channels mlocked +i.\n\t * Users with +i flag are allowed to join, as are users matching\n\t * an invite exception (the latter only works if the channel already\n\t * exists because members are sent before invite exceptions).\n\t * Because most networks do not use kick_on_split_riding or\n\t * no_create_on_split, do not trust users coming back from splits;\n\t * with the exception of users coming back after a services\n\t * restart if the channel TS did not change.\n\t * Unfortunately, this kicks users who have been invited by a channel\n\t * operator, after a split.\n\t */\n\tif (mc->mlock_on & CMODE_INVITE && !(flags & CA_INVITE) &&\n\t\t\t(!me.bursting || mc->flags & MC_RECREATED) &&\n\t\t\t(!(u->server->flags & SF_EOB) || (chan->nummembers - chan->numsvcmembers == 1)) &&\n\t\t\t(!ircd->invex_mchar || !next_matching_ban(chan, u, ircd->invex_mchar, chan->bans.head)))\n\t{\n\t\tif (chan->nummembers - chan->numsvcmembers == 1)\n\t\t{\n\t\t\tmc->flags |= MC_INHABIT;\n\t\t\tif (chan->numsvcmembers == 0)\n\t\t\t\tjoin(chan->name, chansvs.nick);\n\t\t}\n\t\tif (!(chan->modes & CMODE_INVITE))\n\t\t\tcheck_modes(mc, true);\n\t\tmodestack_flush_channel(chan);\n\t\ttry_kick(chansvs.me->me, chan, u, \"Invite only channel\");\n\t\thdata->cu = NULL;\n\t\treturn;\n\t}\n\n\t/* A second user joined and was not kicked; we do not need\n\t * to stay on the channel artificially.\n\t * If there is only one user, stay in the channel to avoid\n\t * triggering autocycle-for-ops scripts and immediately\n\t * destroying channels with kick on split riding.\n\t */\n\tif (mc->flags & MC_INHABIT && chan->nummembers - chan->numsvcmembers >= 2)\n\t{\n\t\tmc->flags &= ~MC_INHABIT;\n\t\tif (!(mc->flags & MC_GUARD) && !(chan->flags & CHAN_LOG) && chanuser_find(chan, chansvs.me->me))\n\t\t\tpart(chan->name, chansvs.nick);\n\t}\n\n\tif (ircd->uses_owner)\n\t{\n\t\tif (flags & CA_USEOWNER)\n\t\t{\n\t\t\tif (flags & CA_AUTOOP && !(noop || cu->modes & ircd->owner_mode))\n\t\t\t{\n\t\t\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_ADD, ircd->owner_mchar[1], CLIENT_NAME(u));\n\t\t\t\tcu->modes |= ircd->owner_mode;\n\t\t\t}\n\t\t}\n\t\telse if (secure && (cu->modes & ircd->owner_mode))\n\t\t{\n\t\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_DEL, ircd->owner_mchar[1], CLIENT_NAME(u));\n\t\t\tcu->modes &= ~ircd->owner_mode;\n\t\t}\n\t}\n\n\tif (ircd->uses_protect)\n\t{\n\t\tif (flags & CA_USEPROTECT)\n\t\t{\n\t\t\tif (flags & CA_AUTOOP && !(noop || cu->modes & ircd->protect_mode || (ircd->uses_owner && cu->modes & ircd->owner_mode)))\n\t\t\t{\n\t\t\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_ADD, ircd->protect_mchar[1], CLIENT_NAME(u));\n\t\t\t\tcu->modes |= ircd->protect_mode;\n\t\t\t}\n\t\t}\n\t\telse if (secure && (cu->modes & ircd->protect_mode))\n\t\t{\n\t\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_DEL, ircd->protect_mchar[1], CLIENT_NAME(u));\n\t\t\tcu->modes &= ~ircd->protect_mode;\n\t\t}\n\t}\n\n\tif (flags & CA_AUTOOP)\n\t{\n\t\tif (!(noop || cu->modes & CSTATUS_OP))\n\t\t{\n\t\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_ADD, 'o', CLIENT_NAME(u));\n\t\t\tcu->modes |= CSTATUS_OP;\n\t\t}\n\t}\n\telse if (secure && (cu->modes & CSTATUS_OP) && !(flags & CA_OP))\n\t{\n\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_DEL, 'o', CLIENT_NAME(u));\n\t\tcu->modes &= ~CSTATUS_OP;\n\t}\n\n\tif (ircd->uses_halfops)\n\t{\n\t\tif (flags & CA_AUTOHALFOP)\n\t\t{\n\t\t\tif (!(noop || cu->modes & (CSTATUS_OP | ircd->halfops_mode)))\n\t\t\t{\n\t\t\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_ADD, 'h', CLIENT_NAME(u));\n\t\t\t\tcu->modes |= ircd->halfops_mode;\n\t\t\t}\n\t\t}\n\t\telse if (secure && (cu->modes & ircd->halfops_mode) && !(flags & CA_HALFOP))\n\t\t{\n\t\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_DEL, 'h', CLIENT_NAME(u));\n\t\t\tcu->modes &= ~ircd->halfops_mode;\n\t\t}\n\t}\n\n\tif (flags & CA_AUTOVOICE)\n\t{\n\t\tif (!(noop || cu->modes & (CSTATUS_OP | ircd->halfops_mode | CSTATUS_VOICE)))\n\t\t{\n\t\t\tmodestack_mode_param(chansvs.nick, chan, MTYPE_ADD, 'v', CLIENT_NAME(u));\n\t\t\tcu->modes |= CSTATUS_VOICE;\n\t\t}\n\t}\n\n\tif (u->server->flags & SF_EOB && (md = metadata_find(mc, \"private:entrymsg\")))\n\t{\n\t\tif (metadata_find(mc, \"private:botserv:bot-assigned\") == NULL)\n\t\t{\n\t\t\tif (!u->myuser || !(u->myuser->flags & MU_NOGREET))\n\t\t\t\tnotice(chansvs.nick, cu->user->nick, \"[%s] %s\", mc->name, md->value);\n\t\t}\n\t}\n\n\tif (u->server->flags & SF_EOB && (md = metadata_find(mc, \"url\")))\n\t\tnumeric_sts(me.me, 328, cu->user, \"%s :%s\", mc->name, md->value);\n\n\tif (flags & CA_USEDUPDATE)\n\t\tmc->used = CURRTIME;\n}"
  },
  {
    "function_name": "_moddeinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
    "lines": "317-342",
    "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tif (chansvs.me)\n\t{\n\t\tchansvs.nick = NULL;\n\t\tchansvs.user = NULL;\n\t\tchansvs.host = NULL;\n\t\tchansvs.real = NULL;\n\t\tservice_delete(chansvs.me);\n\t\tchansvs.me = NULL;\n\t}\n\n\thook_del_config_ready(chanserv_config_ready);\n\thook_del_channel_join(cs_join);\n\thook_del_channel_part(cs_part);\n\thook_del_channel_register(cs_register);\n\thook_del_channel_succession(cs_succession);\n\thook_del_channel_add(cs_newchan);\n\thook_del_channel_topic(cs_keeptopic_topicset);\n\thook_del_channel_can_change_topic(cs_topiccheck);\n\thook_del_channel_tschange(cs_tschange);\n\thook_del_channel_mode_change(cs_bounce_mode_change);\n\thook_del_shutdown(on_shutdown);\n\n\tmowgli_timer_destroy(base_eventloop, cs_leave_empty_timer);\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"template.h\"",
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static mowgli_eventloop_timer_t *cs_leave_empty_timer = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mowgli_timer_destroy",
          "args": [
            "base_eventloop",
            "cs_leave_empty_timer"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_del_shutdown",
          "args": [
            "on_shutdown"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_del_channel_mode_change",
          "args": [
            "cs_bounce_mode_change"
          ],
          "line": 338
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_del_channel_tschange",
          "args": [
            "cs_tschange"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_del_channel_can_change_topic",
          "args": [
            "cs_topiccheck"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_del_channel_topic",
          "args": [
            "cs_keeptopic_topicset"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_del_channel_add",
          "args": [
            "cs_newchan"
          ],
          "line": 334
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_del_channel_succession",
          "args": [
            "cs_succession"
          ],
          "line": 333
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_del_channel_register",
          "args": [
            "cs_register"
          ],
          "line": 332
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_del_channel_part",
          "args": [
            "cs_part"
          ],
          "line": 331
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_del_channel_join",
          "args": [
            "cs_join"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_del_config_ready",
          "args": [
            "chanserv_config_ready"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_delete",
          "args": [
            "chansvs.me"
          ],
          "line": 325
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic mowgli_eventloop_timer_t *cs_leave_empty_timer = NULL;\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tif (chansvs.me)\n\t{\n\t\tchansvs.nick = NULL;\n\t\tchansvs.user = NULL;\n\t\tchansvs.host = NULL;\n\t\tchansvs.real = NULL;\n\t\tservice_delete(chansvs.me);\n\t\tchansvs.me = NULL;\n\t}\n\n\thook_del_config_ready(chanserv_config_ready);\n\thook_del_channel_join(cs_join);\n\thook_del_channel_part(cs_part);\n\thook_del_channel_register(cs_register);\n\thook_del_channel_succession(cs_succession);\n\thook_del_channel_add(cs_newchan);\n\thook_del_channel_topic(cs_keeptopic_topicset);\n\thook_del_channel_can_change_topic(cs_topiccheck);\n\thook_del_channel_tschange(cs_tschange);\n\thook_del_channel_mode_change(cs_bounce_mode_change);\n\thook_del_shutdown(on_shutdown);\n\n\tmowgli_timer_destroy(base_eventloop, cs_leave_empty_timer);\n}"
  },
  {
    "function_name": "_modinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
    "lines": "267-315",
    "snippet": "void _modinit(module_t *m)\n{\n\thook_add_event(\"config_ready\");\n\thook_add_config_ready(chanserv_config_ready);\n\n\tchansvs.me = service_add(\"chanserv\", chanserv);\n\n\thook_add_event(\"channel_join\");\n\thook_add_event(\"channel_part\");\n\thook_add_event(\"channel_register\");\n\thook_add_event(\"channel_succession\");\n\thook_add_event(\"channel_add\");\n\thook_add_event(\"channel_topic\");\n\thook_add_event(\"channel_can_change_topic\");\n\thook_add_event(\"channel_tschange\");\n\thook_add_event(\"channel_mode_change\");\n\thook_add_event(\"user_identify\");\n\thook_add_event(\"shutdown\");\n\thook_add_channel_join(cs_join);\n\thook_add_channel_part(cs_part);\n\thook_add_channel_register(cs_register);\n\thook_add_channel_succession(cs_succession);\n\thook_add_channel_add(cs_newchan);\n\thook_add_channel_topic(cs_keeptopic_topicset);\n\thook_add_channel_can_change_topic(cs_topiccheck);\n\thook_add_channel_tschange(cs_tschange);\n\thook_add_channel_mode_change(cs_bounce_mode_change);\n\thook_add_shutdown(on_shutdown);\n\n\tcs_leave_empty_timer = mowgli_timer_add(base_eventloop, \"cs_leave_empty\", cs_leave_empty, NULL, 300);\n\n\t/* chanserv{} block */\n\tadd_bool_conf_item(\"FANTASY\", &chansvs.me->conf_table, 0, &chansvs.fantasy, false);\n\tadd_conf_item(\"VOP\", &chansvs.me->conf_table, c_ci_vop);\n\tadd_conf_item(\"HOP\", &chansvs.me->conf_table, c_ci_hop);\n\tadd_conf_item(\"AOP\", &chansvs.me->conf_table, c_ci_aop);\n\tadd_conf_item(\"SOP\", &chansvs.me->conf_table, c_ci_sop);\n\tadd_conf_item(\"TEMPLATES\", &chansvs.me->conf_table, c_ci_templates);\n\tadd_bool_conf_item(\"CHANGETS\", &chansvs.me->conf_table, 0, &chansvs.changets, false);\n\tadd_bool_conf_item(\"HIDE_XOP\", &chansvs.me->conf_table, 0, &chansvs.hide_xop, false);\n\tadd_dupstr_conf_item(\"TRIGGER\", &chansvs.me->conf_table, 0, &chansvs.trigger, \"!\");\n\tadd_duration_conf_item(\"EXPIRE\", &chansvs.me->conf_table, 0, &chansvs.expiry, \"d\", 0);\n\tadd_uint_conf_item(\"MAXCHANS\", &chansvs.me->conf_table, 0, &chansvs.maxchans, 1, INT_MAX, 5);\n\tadd_uint_conf_item(\"MAXCHANACS\", &chansvs.me->conf_table, 0, &chansvs.maxchanacs, 0, INT_MAX, 0);\n\tadd_uint_conf_item(\"MAXFOUNDERS\", &chansvs.me->conf_table, 0, &chansvs.maxfounders, 1, (512 - 60) / (9 + 2), 4); /* fit on a line */\n\tadd_dupstr_conf_item(\"FOUNDER_FLAGS\", &chansvs.me->conf_table, 0, &chansvs.founder_flags, NULL);\n\tadd_dupstr_conf_item(\"DEFTEMPLATES\", &chansvs.me->conf_table, 0, &chansvs.deftemplates, NULL);\n\tadd_duration_conf_item(\"AKICK_TIME\", &chansvs.me->conf_table, 0, &chansvs.akick_time, \"m\", 0);\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"template.h\"",
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static mowgli_eventloop_timer_t *cs_leave_empty_timer = NULL;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "add_duration_conf_item",
          "args": [
            "\"AKICK_TIME\"",
            "&chansvs.me->conf_table",
            "0",
            "&chansvs.akick_time",
            "\"m\"",
            "0"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_dupstr_conf_item",
          "args": [
            "\"DEFTEMPLATES\"",
            "&chansvs.me->conf_table",
            "0",
            "&chansvs.deftemplates",
            "NULL"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_dupstr_conf_item",
          "args": [
            "\"FOUNDER_FLAGS\"",
            "&chansvs.me->conf_table",
            "0",
            "&chansvs.founder_flags",
            "NULL"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_uint_conf_item",
          "args": [
            "\"MAXFOUNDERS\"",
            "&chansvs.me->conf_table",
            "0",
            "&chansvs.maxfounders",
            "1",
            "(512 - 60) / (9 + 2)",
            "4"
          ],
          "line": 311
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_uint_conf_item",
          "args": [
            "\"MAXCHANACS\"",
            "&chansvs.me->conf_table",
            "0",
            "&chansvs.maxchanacs",
            "0",
            "INT_MAX",
            "0"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_uint_conf_item",
          "args": [
            "\"MAXCHANS\"",
            "&chansvs.me->conf_table",
            "0",
            "&chansvs.maxchans",
            "1",
            "INT_MAX",
            "5"
          ],
          "line": 309
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_duration_conf_item",
          "args": [
            "\"EXPIRE\"",
            "&chansvs.me->conf_table",
            "0",
            "&chansvs.expiry",
            "\"d\"",
            "0"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_dupstr_conf_item",
          "args": [
            "\"TRIGGER\"",
            "&chansvs.me->conf_table",
            "0",
            "&chansvs.trigger",
            "\"!\""
          ],
          "line": 307
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_bool_conf_item",
          "args": [
            "\"HIDE_XOP\"",
            "&chansvs.me->conf_table",
            "0",
            "&chansvs.hide_xop",
            "false"
          ],
          "line": 306
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_bool_conf_item",
          "args": [
            "\"CHANGETS\"",
            "&chansvs.me->conf_table",
            "0",
            "&chansvs.changets",
            "false"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_conf_item",
          "args": [
            "\"TEMPLATES\"",
            "&chansvs.me->conf_table",
            "c_ci_templates"
          ],
          "line": 304
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_conf_item",
          "args": [
            "\"SOP\"",
            "&chansvs.me->conf_table",
            "c_ci_sop"
          ],
          "line": 303
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_conf_item",
          "args": [
            "\"AOP\"",
            "&chansvs.me->conf_table",
            "c_ci_aop"
          ],
          "line": 302
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_conf_item",
          "args": [
            "\"HOP\"",
            "&chansvs.me->conf_table",
            "c_ci_hop"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_conf_item",
          "args": [
            "\"VOP\"",
            "&chansvs.me->conf_table",
            "c_ci_vop"
          ],
          "line": 300
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "add_bool_conf_item",
          "args": [
            "\"FANTASY\"",
            "&chansvs.me->conf_table",
            "0",
            "&chansvs.fantasy",
            "false"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_timer_add",
          "args": [
            "base_eventloop",
            "\"cs_leave_empty\"",
            "cs_leave_empty",
            "NULL",
            "300"
          ],
          "line": 296
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_shutdown",
          "args": [
            "on_shutdown"
          ],
          "line": 294
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_channel_mode_change",
          "args": [
            "cs_bounce_mode_change"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_channel_tschange",
          "args": [
            "cs_tschange"
          ],
          "line": 292
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_channel_can_change_topic",
          "args": [
            "cs_topiccheck"
          ],
          "line": 291
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_channel_topic",
          "args": [
            "cs_keeptopic_topicset"
          ],
          "line": 290
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_channel_add",
          "args": [
            "cs_newchan"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_channel_succession",
          "args": [
            "cs_succession"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_channel_register",
          "args": [
            "cs_register"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_channel_part",
          "args": [
            "cs_part"
          ],
          "line": 286
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_channel_join",
          "args": [
            "cs_join"
          ],
          "line": 285
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_event",
          "args": [
            "\"shutdown\""
          ],
          "line": 284
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_event",
          "args": [
            "\"user_identify\""
          ],
          "line": 283
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_event",
          "args": [
            "\"channel_mode_change\""
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_event",
          "args": [
            "\"channel_tschange\""
          ],
          "line": 281
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_event",
          "args": [
            "\"channel_can_change_topic\""
          ],
          "line": 280
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_event",
          "args": [
            "\"channel_topic\""
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_event",
          "args": [
            "\"channel_add\""
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_event",
          "args": [
            "\"channel_succession\""
          ],
          "line": 277
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_event",
          "args": [
            "\"channel_register\""
          ],
          "line": 276
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_event",
          "args": [
            "\"channel_part\""
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_event",
          "args": [
            "\"channel_join\""
          ],
          "line": 274
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_add",
          "args": [
            "\"chanserv\"",
            "chanserv"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_config_ready",
          "args": [
            "chanserv_config_ready"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_event",
          "args": [
            "\"config_ready\""
          ],
          "line": 269
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic mowgli_eventloop_timer_t *cs_leave_empty_timer = NULL;\n\nvoid _modinit(module_t *m)\n{\n\thook_add_event(\"config_ready\");\n\thook_add_config_ready(chanserv_config_ready);\n\n\tchansvs.me = service_add(\"chanserv\", chanserv);\n\n\thook_add_event(\"channel_join\");\n\thook_add_event(\"channel_part\");\n\thook_add_event(\"channel_register\");\n\thook_add_event(\"channel_succession\");\n\thook_add_event(\"channel_add\");\n\thook_add_event(\"channel_topic\");\n\thook_add_event(\"channel_can_change_topic\");\n\thook_add_event(\"channel_tschange\");\n\thook_add_event(\"channel_mode_change\");\n\thook_add_event(\"user_identify\");\n\thook_add_event(\"shutdown\");\n\thook_add_channel_join(cs_join);\n\thook_add_channel_part(cs_part);\n\thook_add_channel_register(cs_register);\n\thook_add_channel_succession(cs_succession);\n\thook_add_channel_add(cs_newchan);\n\thook_add_channel_topic(cs_keeptopic_topicset);\n\thook_add_channel_can_change_topic(cs_topiccheck);\n\thook_add_channel_tschange(cs_tschange);\n\thook_add_channel_mode_change(cs_bounce_mode_change);\n\thook_add_shutdown(on_shutdown);\n\n\tcs_leave_empty_timer = mowgli_timer_add(base_eventloop, \"cs_leave_empty\", cs_leave_empty, NULL, 300);\n\n\t/* chanserv{} block */\n\tadd_bool_conf_item(\"FANTASY\", &chansvs.me->conf_table, 0, &chansvs.fantasy, false);\n\tadd_conf_item(\"VOP\", &chansvs.me->conf_table, c_ci_vop);\n\tadd_conf_item(\"HOP\", &chansvs.me->conf_table, c_ci_hop);\n\tadd_conf_item(\"AOP\", &chansvs.me->conf_table, c_ci_aop);\n\tadd_conf_item(\"SOP\", &chansvs.me->conf_table, c_ci_sop);\n\tadd_conf_item(\"TEMPLATES\", &chansvs.me->conf_table, c_ci_templates);\n\tadd_bool_conf_item(\"CHANGETS\", &chansvs.me->conf_table, 0, &chansvs.changets, false);\n\tadd_bool_conf_item(\"HIDE_XOP\", &chansvs.me->conf_table, 0, &chansvs.hide_xop, false);\n\tadd_dupstr_conf_item(\"TRIGGER\", &chansvs.me->conf_table, 0, &chansvs.trigger, \"!\");\n\tadd_duration_conf_item(\"EXPIRE\", &chansvs.me->conf_table, 0, &chansvs.expiry, \"d\", 0);\n\tadd_uint_conf_item(\"MAXCHANS\", &chansvs.me->conf_table, 0, &chansvs.maxchans, 1, INT_MAX, 5);\n\tadd_uint_conf_item(\"MAXCHANACS\", &chansvs.me->conf_table, 0, &chansvs.maxchanacs, 0, INT_MAX, 0);\n\tadd_uint_conf_item(\"MAXFOUNDERS\", &chansvs.me->conf_table, 0, &chansvs.maxfounders, 1, (512 - 60) / (9 + 2), 4); /* fit on a line */\n\tadd_dupstr_conf_item(\"FOUNDER_FLAGS\", &chansvs.me->conf_table, 0, &chansvs.founder_flags, NULL);\n\tadd_dupstr_conf_item(\"DEFTEMPLATES\", &chansvs.me->conf_table, 0, &chansvs.deftemplates, NULL);\n\tadd_duration_conf_item(\"AKICK_TIME\", &chansvs.me->conf_table, 0, &chansvs.akick_time, \"m\", 0);\n}"
  },
  {
    "function_name": "c_ci_templates",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
    "lines": "249-265",
    "snippet": "static int c_ci_templates(mowgli_config_file_entry_t *ce)\n{\n\tmowgli_config_file_entry_t *flce;\n\n\tMOWGLI_ITER_FOREACH(flce, ce->entries)\n\t{\n\t\tif (flce->vardata == NULL)\n\t\t{\n\t\t\tconf_report_warning(ce, \"no parameter for configuration option\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tset_global_template_flags(flce->varname, flags_to_bitmask(flce->vardata, 0));\n\t}\n\n\treturn 0;\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"template.h\"",
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_global_template_flags",
          "args": [
            "flce->varname",
            "flags_to_bitmask(flce->vardata, 0)"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flags_to_bitmask",
          "args": [
            "flce->vardata",
            "0"
          ],
          "line": 261
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conf_report_warning",
          "args": [
            "ce",
            "\"no parameter for configuration option\""
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_ITER_FOREACH",
          "args": [
            "flce",
            "ce->entries"
          ],
          "line": 253
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic int c_ci_templates(mowgli_config_file_entry_t *ce)\n{\n\tmowgli_config_file_entry_t *flce;\n\n\tMOWGLI_ITER_FOREACH(flce, ce->entries)\n\t{\n\t\tif (flce->vardata == NULL)\n\t\t{\n\t\t\tconf_report_warning(ce, \"no parameter for configuration option\");\n\t\t\treturn 0;\n\t\t}\n\n\t\tset_global_template_flags(flce->varname, flags_to_bitmask(flce->vardata, 0));\n\t}\n\n\treturn 0;\n}"
  },
  {
    "function_name": "c_ci_sop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
    "lines": "236-247",
    "snippet": "static int c_ci_sop(mowgli_config_file_entry_t *ce)\n{\n\tif (ce->vardata == NULL)\n\t{\n\t\tconf_report_warning(ce, \"no parameter for configuration option\");\n\t\treturn 0;\n\t}\n\n\tset_global_template_flags(\"SOP\", flags_to_bitmask(ce->vardata, 0));\n\n\treturn 0;\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"template.h\"",
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_global_template_flags",
          "args": [
            "\"SOP\"",
            "flags_to_bitmask(ce->vardata, 0)"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flags_to_bitmask",
          "args": [
            "ce->vardata",
            "0"
          ],
          "line": 244
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conf_report_warning",
          "args": [
            "ce",
            "\"no parameter for configuration option\""
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic int c_ci_sop(mowgli_config_file_entry_t *ce)\n{\n\tif (ce->vardata == NULL)\n\t{\n\t\tconf_report_warning(ce, \"no parameter for configuration option\");\n\t\treturn 0;\n\t}\n\n\tset_global_template_flags(\"SOP\", flags_to_bitmask(ce->vardata, 0));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "c_ci_aop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
    "lines": "223-234",
    "snippet": "static int c_ci_aop(mowgli_config_file_entry_t *ce)\n{\n\tif (ce->vardata == NULL)\n\t{\n\t\tconf_report_warning(ce, \"no parameter for configuration option\");\n\t\treturn 0;\n\t}\n\n\tset_global_template_flags(\"AOP\", flags_to_bitmask(ce->vardata, 0));\n\n\treturn 0;\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"template.h\"",
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_global_template_flags",
          "args": [
            "\"AOP\"",
            "flags_to_bitmask(ce->vardata, 0)"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flags_to_bitmask",
          "args": [
            "ce->vardata",
            "0"
          ],
          "line": 231
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conf_report_warning",
          "args": [
            "ce",
            "\"no parameter for configuration option\""
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic int c_ci_aop(mowgli_config_file_entry_t *ce)\n{\n\tif (ce->vardata == NULL)\n\t{\n\t\tconf_report_warning(ce, \"no parameter for configuration option\");\n\t\treturn 0;\n\t}\n\n\tset_global_template_flags(\"AOP\", flags_to_bitmask(ce->vardata, 0));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "c_ci_hop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
    "lines": "210-221",
    "snippet": "static int c_ci_hop(mowgli_config_file_entry_t *ce)\n{\n\tif (ce->vardata == NULL)\n\t{\n\t\tconf_report_warning(ce, \"no parameter for configuration option\");\n\t\treturn 0;\n\t}\n\n\tset_global_template_flags(\"HOP\", flags_to_bitmask(ce->vardata, 0));\n\n\treturn 0;\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"template.h\"",
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_global_template_flags",
          "args": [
            "\"HOP\"",
            "flags_to_bitmask(ce->vardata, 0)"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flags_to_bitmask",
          "args": [
            "ce->vardata",
            "0"
          ],
          "line": 218
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conf_report_warning",
          "args": [
            "ce",
            "\"no parameter for configuration option\""
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic int c_ci_hop(mowgli_config_file_entry_t *ce)\n{\n\tif (ce->vardata == NULL)\n\t{\n\t\tconf_report_warning(ce, \"no parameter for configuration option\");\n\t\treturn 0;\n\t}\n\n\tset_global_template_flags(\"HOP\", flags_to_bitmask(ce->vardata, 0));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "c_ci_vop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
    "lines": "197-208",
    "snippet": "static int c_ci_vop(mowgli_config_file_entry_t *ce)\n{\n\tif (ce->vardata == NULL)\n\t{\n\t\tconf_report_warning(ce, \"no parameter for configuration option\");\n\t\treturn 0;\n\t}\n\n\tset_global_template_flags(\"VOP\", flags_to_bitmask(ce->vardata, 0));\n\n\treturn 0;\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"template.h\"",
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "set_global_template_flags",
          "args": [
            "\"VOP\"",
            "flags_to_bitmask(ce->vardata, 0)"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "flags_to_bitmask",
          "args": [
            "ce->vardata",
            "0"
          ],
          "line": 205
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "conf_report_warning",
          "args": [
            "ce",
            "\"no parameter for configuration option\""
          ],
          "line": 201
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic int c_ci_vop(mowgli_config_file_entry_t *ce)\n{\n\tif (ce->vardata == NULL)\n\t{\n\t\tconf_report_warning(ce, \"no parameter for configuration option\");\n\t\treturn 0;\n\t}\n\n\tset_global_template_flags(\"VOP\", flags_to_bitmask(ce->vardata, 0));\n\n\treturn 0;\n}"
  },
  {
    "function_name": "chanserv_config_ready",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
    "lines": "184-195",
    "snippet": "static void chanserv_config_ready(void *unused)\n{\n\tchansvs.nick = chansvs.me->nick;\n\tchansvs.user = chansvs.me->user;\n\tchansvs.host = chansvs.me->host;\n\tchansvs.real = chansvs.me->real;\n\n\tservice_set_chanmsg(chansvs.me, true);\n\n\tif (me.connected)\n\t\tjoin_registered(false); /* !config_options.leave_chans */\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"template.h\"",
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_leave_empty(void *unused);",
      "static void on_shutdown(void *unused);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "join_registered",
          "args": [
            "false"
          ],
          "line": 194
        },
        "resolved": true,
        "details": {
          "function_name": "join_registered",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
          "lines": "35-58",
          "snippet": "static void join_registered(bool all)\n{\n\tmychan_t *mc;\n\tmowgli_patricia_iteration_state_t state;\n\n\tMOWGLI_PATRICIA_FOREACH(mc, &state, mclist)\n\t{\n\t\tif (!(mc->flags & MC_GUARD))\n\t\t\tcontinue;\n\t\tif (metadata_find(mc, \"private:botserv:bot-assigned\") != NULL)\n\t\t\tcontinue;\n\n\t\tif (all)\n\t\t{\n\t\t\tjoin(mc->name, chansvs.nick);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (mc->chan != NULL && mc->chan->members.count != 0)\n\t\t{\n\t\t\tjoin(mc->name, chansvs.nick);\n\t\t\tcontinue;\n\t\t}\n\t}\n}",
          "includes": [
            "#include <limits.h>",
            "#include \"template.h\"",
            "#include \"chanserv.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cs_register(hook_channel_req_t *mc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_register(hook_channel_req_t *mc);\n\nstatic void join_registered(bool all)\n{\n\tmychan_t *mc;\n\tmowgli_patricia_iteration_state_t state;\n\n\tMOWGLI_PATRICIA_FOREACH(mc, &state, mclist)\n\t{\n\t\tif (!(mc->flags & MC_GUARD))\n\t\t\tcontinue;\n\t\tif (metadata_find(mc, \"private:botserv:bot-assigned\") != NULL)\n\t\t\tcontinue;\n\n\t\tif (all)\n\t\t{\n\t\t\tjoin(mc->name, chansvs.nick);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (mc->chan != NULL && mc->chan->members.count != 0)\n\t\t{\n\t\t\tjoin(mc->name, chansvs.nick);\n\t\t\tcontinue;\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "service_set_chanmsg",
          "args": [
            "chansvs.me",
            "true"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_leave_empty(void *unused);\nstatic void on_shutdown(void *unused);\n\nstatic void chanserv_config_ready(void *unused)\n{\n\tchansvs.nick = chansvs.me->nick;\n\tchansvs.user = chansvs.me->user;\n\tchansvs.host = chansvs.me->host;\n\tchansvs.real = chansvs.me->real;\n\n\tservice_set_chanmsg(chansvs.me, true);\n\n\tif (me.connected)\n\t\tjoin_registered(false); /* !config_options.leave_chans */\n}"
  },
  {
    "function_name": "chanserv",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
    "lines": "61-182",
    "snippet": "static void chanserv(sourceinfo_t *si, int parc, char *parv[])\n{\n\tmychan_t *mc = NULL;\n\tchar orig[BUFSIZE];\n\tchar newargs[BUFSIZE];\n\tchar *cmd;\n\tchar *args;\n\n\t/* this should never happen */\n\tif (parv[parc - 2][0] == '&')\n\t{\n\t\tslog(LG_ERROR, \"services(): got parv with local channel: %s\", parv[0]);\n\t\treturn;\n\t}\n\n\t/* is this a fantasy command? */\n\tif (parv[parc - 2][0] == '#')\n\t{\n\t\tmetadata_t *md;\n\n\t\tif (chansvs.fantasy == false)\n\t\t{\n\t\t\t/* *all* fantasy disabled */\n\t\t\treturn;\n\t\t}\n\n\t\tmc = mychan_find(parv[parc - 2]);\n\t\tif (!mc)\n\t\t{\n\t\t\t/* unregistered, NFI how we got this message, but let's leave it alone! */\n\t\t\treturn;\n\t\t}\n\n\t\tmd = metadata_find(mc, \"disable_fantasy\");\n\t\tif (md)\n\t\t{\n\t\t\t/* fantasy disabled on this channel. don't message them, just bail. */\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* make a copy of the original for debugging */\n\tmowgli_strlcpy(orig, parv[parc - 1], BUFSIZE);\n\n\t/* lets go through this to get the command */\n\tcmd = strtok(parv[parc - 1], \" \");\n\n\tif (!cmd)\n\t\treturn;\n\tif (*orig == '\\001')\n\t{\n\t\thandle_ctcp_common(si, cmd, strtok(NULL, \"\"));\n\t\treturn;\n\t}\n\n\t/* take the command through the hash table */\n\tif (mc == NULL)\n\t\tcommand_exec_split(si->service, si, cmd, strtok(NULL, \"\"), si->service->commands);\n\telse\n\t{\n\t\tmetadata_t *md = metadata_find(mc, \"private:prefix\");\n\t\tconst char *prefix = (md ? md->value : chansvs.trigger);\n\n\t\tif (strlen(cmd) >= 2 && strchr(prefix, cmd[0]) && isalpha((unsigned char)*++cmd))\n\t\t{\n\t\t\tconst char *realcmd = service_resolve_alias(si->service, NULL, cmd);\n\n\t\t\t/* XXX not really nice to look up the command twice\n\t\t\t * -- jilles */\n\t\t\tif (command_find(si->service->commands, realcmd) == NULL)\n\t\t\t\treturn;\n\t\t\tif (floodcheck(si->su, si->service->me))\n\t\t\t\treturn;\n\t\t\t/* construct <channel> <args> */\n\t\t\tmowgli_strlcpy(newargs, parv[parc - 2], sizeof newargs);\n\t\t\targs = strtok(NULL, \"\");\n\t\t\tif (args != NULL)\n\t\t\t{\n\t\t\t\tmowgli_strlcat(newargs, \" \", sizeof newargs);\n\t\t\t\tmowgli_strlcat(newargs, args, sizeof newargs);\n\t\t\t}\n\t\t\t/* let the command know it's called as fantasy cmd */\n\t\t\tsi->c = mc->chan;\n\t\t\t/* fantasy commands are always verbose\n\t\t\t * (a little ugly but this way we can !set verbose)\n\t\t\t */\n\t\t\tmc->flags |= MC_FORCEVERBOSE;\n\t\t\tcommand_exec_split(si->service, si, realcmd, newargs, si->service->commands);\n\t\t\tmc->flags &= ~MC_FORCEVERBOSE;\n\t\t}\n\t\telse if (!ircncasecmp(cmd, chansvs.nick, strlen(chansvs.nick)) && !isalnum((unsigned char)cmd[strlen(chansvs.nick)]) && (cmd = strtok(NULL, \"\")) != NULL)\n\t\t{\n\t\t\tconst char *realcmd;\n\t\t\tchar *pptr;\n\n\t\t\tmowgli_strlcpy(newargs, parv[parc - 2], sizeof newargs);\n\t\t\twhile (*cmd == ' ')\n\t\t\t\tcmd++;\n\t\t\tif ((pptr = strchr(cmd, ' ')) != NULL)\n\t\t\t{\n\t\t\t\tmowgli_strlcat(newargs, pptr, sizeof newargs);\n\t\t\t\t*pptr = '\\0';\n\t\t\t}\n\n\t\t\trealcmd = service_resolve_alias(si->service, NULL, cmd);\n\n\t\t\tif (command_find(si->service->commands, realcmd) == NULL)\n\t\t\t\treturn;\n\t\t\tif (floodcheck(si->su, si->service->me))\n\t\t\t\treturn;\n\n\t\t\tsi->c = mc->chan;\n\n\t\t\t/* fantasy commands are always verbose\n\t\t\t * (a little ugly but this way we can !set verbose)\n\t\t\t */\n\t\t\tmc->flags |= MC_FORCEVERBOSE;\n\t\t\tcommand_exec_split(si->service, si, realcmd, newargs, si->service->commands);\n\t\t\tmc->flags &= ~MC_FORCEVERBOSE;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"template.h\"",
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_register(hook_channel_req_t *mc);",
      "static void cs_newchan(channel_t *c);",
      "static void cs_keeptopic_topicset(channel_t *c);",
      "static void cs_tschange(channel_t *c);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "command_exec_split",
          "args": [
            "si->service",
            "si",
            "realcmd",
            "newargs",
            "si->service->commands"
          ],
          "line": 178
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "floodcheck",
          "args": [
            "si->su",
            "si->service->me"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_find",
          "args": [
            "si->service->commands",
            "realcmd"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_resolve_alias",
          "args": [
            "si->service",
            "NULL",
            "cmd"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcat",
          "args": [
            "newargs",
            "pptr",
            "sizeof newargs"
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "cmd",
            "' '"
          ],
          "line": 159
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcpy",
          "args": [
            "newargs",
            "parv[parc - 2]",
            "sizeof newargs"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\"\""
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalnum",
          "args": [
            "(unsigned char)cmd[strlen(chansvs.nick)]"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "chansvs.nick"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "ircncasecmp",
          "args": [
            "cmd",
            "chansvs.nick",
            "strlen(chansvs.nick)"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "chansvs.nick"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_exec_split",
          "args": [
            "si->service",
            "si",
            "realcmd",
            "newargs",
            "si->service->commands"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcat",
          "args": [
            "newargs",
            "args",
            "sizeof newargs"
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcat",
          "args": [
            "newargs",
            "\" \"",
            "sizeof newargs"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\"\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcpy",
          "args": [
            "newargs",
            "parv[parc - 2]",
            "sizeof newargs"
          ],
          "line": 135
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "floodcheck",
          "args": [
            "si->su",
            "si->service->me"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_find",
          "args": [
            "si->service->commands",
            "realcmd"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_resolve_alias",
          "args": [
            "si->service",
            "NULL",
            "cmd"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isalpha",
          "args": [
            "(unsigned char)*++cmd"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strchr",
          "args": [
            "prefix",
            "cmd[0]"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strlen",
          "args": [
            "cmd"
          ],
          "line": 124
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:prefix\""
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_exec_split",
          "args": [
            "si->service",
            "si",
            "cmd",
            "strtok(NULL, \"\")",
            "si->service->commands"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\"\""
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "handle_ctcp_common",
          "args": [
            "si",
            "cmd",
            "strtok(NULL, \"\")"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\"\""
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "parv[parc - 1]",
            "\" \""
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcpy",
          "args": [
            "orig",
            "parv[parc - 1]",
            "BUFSIZE"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"disable_fantasy\""
          ],
          "line": 94
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_find",
          "args": [
            "parv[parc - 2]"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slog",
          "args": [
            "LG_ERROR",
            "\"services(): got parv with local channel: %s\"",
            "parv[0]"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_register(hook_channel_req_t *mc);\nstatic void cs_newchan(channel_t *c);\nstatic void cs_keeptopic_topicset(channel_t *c);\nstatic void cs_tschange(channel_t *c);\n\nstatic void chanserv(sourceinfo_t *si, int parc, char *parv[])\n{\n\tmychan_t *mc = NULL;\n\tchar orig[BUFSIZE];\n\tchar newargs[BUFSIZE];\n\tchar *cmd;\n\tchar *args;\n\n\t/* this should never happen */\n\tif (parv[parc - 2][0] == '&')\n\t{\n\t\tslog(LG_ERROR, \"services(): got parv with local channel: %s\", parv[0]);\n\t\treturn;\n\t}\n\n\t/* is this a fantasy command? */\n\tif (parv[parc - 2][0] == '#')\n\t{\n\t\tmetadata_t *md;\n\n\t\tif (chansvs.fantasy == false)\n\t\t{\n\t\t\t/* *all* fantasy disabled */\n\t\t\treturn;\n\t\t}\n\n\t\tmc = mychan_find(parv[parc - 2]);\n\t\tif (!mc)\n\t\t{\n\t\t\t/* unregistered, NFI how we got this message, but let's leave it alone! */\n\t\t\treturn;\n\t\t}\n\n\t\tmd = metadata_find(mc, \"disable_fantasy\");\n\t\tif (md)\n\t\t{\n\t\t\t/* fantasy disabled on this channel. don't message them, just bail. */\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* make a copy of the original for debugging */\n\tmowgli_strlcpy(orig, parv[parc - 1], BUFSIZE);\n\n\t/* lets go through this to get the command */\n\tcmd = strtok(parv[parc - 1], \" \");\n\n\tif (!cmd)\n\t\treturn;\n\tif (*orig == '\\001')\n\t{\n\t\thandle_ctcp_common(si, cmd, strtok(NULL, \"\"));\n\t\treturn;\n\t}\n\n\t/* take the command through the hash table */\n\tif (mc == NULL)\n\t\tcommand_exec_split(si->service, si, cmd, strtok(NULL, \"\"), si->service->commands);\n\telse\n\t{\n\t\tmetadata_t *md = metadata_find(mc, \"private:prefix\");\n\t\tconst char *prefix = (md ? md->value : chansvs.trigger);\n\n\t\tif (strlen(cmd) >= 2 && strchr(prefix, cmd[0]) && isalpha((unsigned char)*++cmd))\n\t\t{\n\t\t\tconst char *realcmd = service_resolve_alias(si->service, NULL, cmd);\n\n\t\t\t/* XXX not really nice to look up the command twice\n\t\t\t * -- jilles */\n\t\t\tif (command_find(si->service->commands, realcmd) == NULL)\n\t\t\t\treturn;\n\t\t\tif (floodcheck(si->su, si->service->me))\n\t\t\t\treturn;\n\t\t\t/* construct <channel> <args> */\n\t\t\tmowgli_strlcpy(newargs, parv[parc - 2], sizeof newargs);\n\t\t\targs = strtok(NULL, \"\");\n\t\t\tif (args != NULL)\n\t\t\t{\n\t\t\t\tmowgli_strlcat(newargs, \" \", sizeof newargs);\n\t\t\t\tmowgli_strlcat(newargs, args, sizeof newargs);\n\t\t\t}\n\t\t\t/* let the command know it's called as fantasy cmd */\n\t\t\tsi->c = mc->chan;\n\t\t\t/* fantasy commands are always verbose\n\t\t\t * (a little ugly but this way we can !set verbose)\n\t\t\t */\n\t\t\tmc->flags |= MC_FORCEVERBOSE;\n\t\t\tcommand_exec_split(si->service, si, realcmd, newargs, si->service->commands);\n\t\t\tmc->flags &= ~MC_FORCEVERBOSE;\n\t\t}\n\t\telse if (!ircncasecmp(cmd, chansvs.nick, strlen(chansvs.nick)) && !isalnum((unsigned char)cmd[strlen(chansvs.nick)]) && (cmd = strtok(NULL, \"\")) != NULL)\n\t\t{\n\t\t\tconst char *realcmd;\n\t\t\tchar *pptr;\n\n\t\t\tmowgli_strlcpy(newargs, parv[parc - 2], sizeof newargs);\n\t\t\twhile (*cmd == ' ')\n\t\t\t\tcmd++;\n\t\t\tif ((pptr = strchr(cmd, ' ')) != NULL)\n\t\t\t{\n\t\t\t\tmowgli_strlcat(newargs, pptr, sizeof newargs);\n\t\t\t\t*pptr = '\\0';\n\t\t\t}\n\n\t\t\trealcmd = service_resolve_alias(si->service, NULL, cmd);\n\n\t\t\tif (command_find(si->service->commands, realcmd) == NULL)\n\t\t\t\treturn;\n\t\t\tif (floodcheck(si->su, si->service->me))\n\t\t\t\treturn;\n\n\t\t\tsi->c = mc->chan;\n\n\t\t\t/* fantasy commands are always verbose\n\t\t\t * (a little ugly but this way we can !set verbose)\n\t\t\t */\n\t\t\tmc->flags |= MC_FORCEVERBOSE;\n\t\t\tcommand_exec_split(si->service, si, realcmd, newargs, si->service->commands);\n\t\t\tmc->flags &= ~MC_FORCEVERBOSE;\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "join_registered",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/main.c",
    "lines": "35-58",
    "snippet": "static void join_registered(bool all)\n{\n\tmychan_t *mc;\n\tmowgli_patricia_iteration_state_t state;\n\n\tMOWGLI_PATRICIA_FOREACH(mc, &state, mclist)\n\t{\n\t\tif (!(mc->flags & MC_GUARD))\n\t\t\tcontinue;\n\t\tif (metadata_find(mc, \"private:botserv:bot-assigned\") != NULL)\n\t\t\tcontinue;\n\n\t\tif (all)\n\t\t{\n\t\t\tjoin(mc->name, chansvs.nick);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (mc->chan != NULL && mc->chan->members.count != 0)\n\t\t{\n\t\t\tjoin(mc->name, chansvs.nick);\n\t\t\tcontinue;\n\t\t}\n\t}\n}",
    "includes": [
      "#include <limits.h>",
      "#include \"template.h\"",
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_register(hook_channel_req_t *mc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "join",
          "args": [
            "mc->name",
            "chansvs.nick"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "join",
          "args": [
            "mc->name",
            "chansvs.nick"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:botserv:bot-assigned\""
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_PATRICIA_FOREACH",
          "args": [
            "mc",
            "&state",
            "mclist"
          ],
          "line": 40
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include <limits.h>\n#include \"template.h\"\n#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_register(hook_channel_req_t *mc);\n\nstatic void join_registered(bool all)\n{\n\tmychan_t *mc;\n\tmowgli_patricia_iteration_state_t state;\n\n\tMOWGLI_PATRICIA_FOREACH(mc, &state, mclist)\n\t{\n\t\tif (!(mc->flags & MC_GUARD))\n\t\t\tcontinue;\n\t\tif (metadata_find(mc, \"private:botserv:bot-assigned\") != NULL)\n\t\t\tcontinue;\n\n\t\tif (all)\n\t\t{\n\t\t\tjoin(mc->name, chansvs.nick);\n\t\t\tcontinue;\n\t\t}\n\t\telse if (mc->chan != NULL && mc->chan->members.count != 0)\n\t\t{\n\t\t\tjoin(mc->name, chansvs.nick);\n\t\t\tcontinue;\n\t\t}\n\t}\n}"
  }
]