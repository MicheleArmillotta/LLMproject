[
  {
    "function_name": "akickdel_list_create",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/akick.c",
    "lines": "755-796",
    "snippet": "void akickdel_list_create(void *arg)\n{\n\tmychan_t *mc;\n\tmowgli_node_t *n, *tn;\n\tchanacs_t *ca;\n\tmetadata_t *md;\n\ttime_t expireson;\n\n\tmowgli_patricia_iteration_state_t state;\n\n\tMOWGLI_PATRICIA_FOREACH(mc, &state, mclist)\n\t{\n\t\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mc->chanacs.head)\n\t\t{\n\t\t\tca = (chanacs_t *)n->data;\n\n\t\t\tif (!(ca->level & CA_AKICK))\n\t\t\t\tcontinue;\n\n\t\t\tmd = metadata_find(ca, \"expires\");\n\n\t\t\tif (!md)\n\t\t\t\tcontinue;\n\n\t\t\texpireson = atol(md->value);\n\n\t\t\tif (CURRTIME > expireson)\n\t\t\t{\n\t\t\t\tchanacs_modify_simple(ca, 0, CA_AKICK);\n\t\t\t\tchanacs_close(ca);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* overcomplicate the logic here a tiny bit */\n\t\t\t\tif (ca->host == NULL && ca->entity != NULL)\n\t\t\t\t\takick_add_timeout(mc, ca->entity, entity(ca->entity)->name, expireson);\n\t\t\t\telse if (ca->host != NULL && ca->entity == NULL)\n\t\t\t\t\takick_add_timeout(mc, NULL, ca->host, expireson);\n\t\t\t}\n\t\t}\n\t}\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void akick_timeout_check(void *arg);",
      "static void akickdel_list_create(void *arg);",
      "static akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "akick_add_timeout",
          "args": [
            "mc",
            "NULL",
            "ca->host",
            "expireson"
          ],
          "line": 792
        },
        "resolved": true,
        "details": {
          "function_name": "akick_add_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/akick.c",
          "lines": "726-753",
          "snippet": "static akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson)\n{\n\tmowgli_node_t *n;\n\takick_timeout_t *timeout, *timeout2;\n\n\ttimeout = mowgli_heap_alloc(akick_timeout_heap);\n\n\ttimeout->entity = mt;\n\ttimeout->chan = mc;\n\ttimeout->expiration = expireson;\n\n\tmowgli_strlcpy(timeout->host, host, sizeof timeout->host);\n\n\tMOWGLI_ITER_FOREACH_PREV(n, akickdel_list.tail)\n\t{\n\t\ttimeout2 = n->data;\n\t\tif (timeout2->expiration <= timeout->expiration)\n\t\t\tbreak;\n\t}\n\tif (n == NULL)\n\t\tmowgli_node_add_head(timeout, &timeout->node, &akickdel_list);\n\telse if (n->next == NULL)\n\t\tmowgli_node_add(timeout, &timeout->node, &akickdel_list);\n\telse\n\t\tmowgli_node_add_before(timeout, &timeout->node, &akickdel_list, n->next);\n\n\treturn timeout;\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "mowgli_list_t akickdel_list;",
            "static akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson);",
            "mowgli_heap_t *akick_timeout_heap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nmowgli_list_t akickdel_list;\nstatic akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson);\nmowgli_heap_t *akick_timeout_heap;\n\nstatic akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson)\n{\n\tmowgli_node_t *n;\n\takick_timeout_t *timeout, *timeout2;\n\n\ttimeout = mowgli_heap_alloc(akick_timeout_heap);\n\n\ttimeout->entity = mt;\n\ttimeout->chan = mc;\n\ttimeout->expiration = expireson;\n\n\tmowgli_strlcpy(timeout->host, host, sizeof timeout->host);\n\n\tMOWGLI_ITER_FOREACH_PREV(n, akickdel_list.tail)\n\t{\n\t\ttimeout2 = n->data;\n\t\tif (timeout2->expiration <= timeout->expiration)\n\t\t\tbreak;\n\t}\n\tif (n == NULL)\n\t\tmowgli_node_add_head(timeout, &timeout->node, &akickdel_list);\n\telse if (n->next == NULL)\n\t\tmowgli_node_add(timeout, &timeout->node, &akickdel_list);\n\telse\n\t\tmowgli_node_add_before(timeout, &timeout->node, &akickdel_list, n->next);\n\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "entity",
          "args": [
            "ca->entity"
          ],
          "line": 790
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca"
          ],
          "line": 784
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_modify_simple",
          "args": [
            "ca",
            "0",
            "CA_AKICK"
          ],
          "line": 783
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "md->value"
          ],
          "line": 779
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "ca",
            "\"expires\""
          ],
          "line": 774
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_ITER_FOREACH_SAFE",
          "args": [
            "n",
            "tn",
            "mc->chanacs.head"
          ],
          "line": 767
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_PATRICIA_FOREACH",
          "args": [
            "mc",
            "&state",
            "mclist"
          ],
          "line": 765
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic void akick_timeout_check(void *arg);\nstatic void akickdel_list_create(void *arg);\nstatic akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson);\n\nvoid akickdel_list_create(void *arg)\n{\n\tmychan_t *mc;\n\tmowgli_node_t *n, *tn;\n\tchanacs_t *ca;\n\tmetadata_t *md;\n\ttime_t expireson;\n\n\tmowgli_patricia_iteration_state_t state;\n\n\tMOWGLI_PATRICIA_FOREACH(mc, &state, mclist)\n\t{\n\t\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mc->chanacs.head)\n\t\t{\n\t\t\tca = (chanacs_t *)n->data;\n\n\t\t\tif (!(ca->level & CA_AKICK))\n\t\t\t\tcontinue;\n\n\t\t\tmd = metadata_find(ca, \"expires\");\n\n\t\t\tif (!md)\n\t\t\t\tcontinue;\n\n\t\t\texpireson = atol(md->value);\n\n\t\t\tif (CURRTIME > expireson)\n\t\t\t{\n\t\t\t\tchanacs_modify_simple(ca, 0, CA_AKICK);\n\t\t\t\tchanacs_close(ca);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* overcomplicate the logic here a tiny bit */\n\t\t\t\tif (ca->host == NULL && ca->entity != NULL)\n\t\t\t\t\takick_add_timeout(mc, ca->entity, entity(ca->entity)->name, expireson);\n\t\t\t\telse if (ca->host != NULL && ca->entity == NULL)\n\t\t\t\t\takick_add_timeout(mc, NULL, ca->host, expireson);\n\t\t\t}\n\t\t}\n\t}\n}"
  },
  {
    "function_name": "akick_add_timeout",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/akick.c",
    "lines": "726-753",
    "snippet": "static akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson)\n{\n\tmowgli_node_t *n;\n\takick_timeout_t *timeout, *timeout2;\n\n\ttimeout = mowgli_heap_alloc(akick_timeout_heap);\n\n\ttimeout->entity = mt;\n\ttimeout->chan = mc;\n\ttimeout->expiration = expireson;\n\n\tmowgli_strlcpy(timeout->host, host, sizeof timeout->host);\n\n\tMOWGLI_ITER_FOREACH_PREV(n, akickdel_list.tail)\n\t{\n\t\ttimeout2 = n->data;\n\t\tif (timeout2->expiration <= timeout->expiration)\n\t\t\tbreak;\n\t}\n\tif (n == NULL)\n\t\tmowgli_node_add_head(timeout, &timeout->node, &akickdel_list);\n\telse if (n->next == NULL)\n\t\tmowgli_node_add(timeout, &timeout->node, &akickdel_list);\n\telse\n\t\tmowgli_node_add_before(timeout, &timeout->node, &akickdel_list, n->next);\n\n\treturn timeout;\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "mowgli_list_t akickdel_list;",
      "static akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson);",
      "mowgli_heap_t *akick_timeout_heap;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mowgli_node_add_before",
          "args": [
            "timeout",
            "&timeout->node",
            "&akickdel_list",
            "n->next"
          ],
          "line": 750
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_node_add",
          "args": [
            "timeout",
            "&timeout->node",
            "&akickdel_list"
          ],
          "line": 748
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_node_add_head",
          "args": [
            "timeout",
            "&timeout->node",
            "&akickdel_list"
          ],
          "line": 746
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_ITER_FOREACH_PREV",
          "args": [
            "n",
            "akickdel_list.tail"
          ],
          "line": 739
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcpy",
          "args": [
            "timeout->host",
            "host",
            "sizeof timeout->host"
          ],
          "line": 737
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_heap_alloc",
          "args": [
            "akick_timeout_heap"
          ],
          "line": 731
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nmowgli_list_t akickdel_list;\nstatic akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson);\nmowgli_heap_t *akick_timeout_heap;\n\nstatic akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson)\n{\n\tmowgli_node_t *n;\n\takick_timeout_t *timeout, *timeout2;\n\n\ttimeout = mowgli_heap_alloc(akick_timeout_heap);\n\n\ttimeout->entity = mt;\n\ttimeout->chan = mc;\n\ttimeout->expiration = expireson;\n\n\tmowgli_strlcpy(timeout->host, host, sizeof timeout->host);\n\n\tMOWGLI_ITER_FOREACH_PREV(n, akickdel_list.tail)\n\t{\n\t\ttimeout2 = n->data;\n\t\tif (timeout2->expiration <= timeout->expiration)\n\t\t\tbreak;\n\t}\n\tif (n == NULL)\n\t\tmowgli_node_add_head(timeout, &timeout->node, &akickdel_list);\n\telse if (n->next == NULL)\n\t\tmowgli_node_add(timeout, &timeout->node, &akickdel_list);\n\telse\n\t\tmowgli_node_add_before(timeout, &timeout->node, &akickdel_list, n->next);\n\n\treturn timeout;\n}"
  },
  {
    "function_name": "akick_timeout_check",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/akick.c",
    "lines": "669-724",
    "snippet": "void akick_timeout_check(void *arg)\n{\n\tmowgli_node_t *n, *tn;\n\takick_timeout_t *timeout;\n\tchanacs_t *ca;\n\tmychan_t *mc;\n\n\tchanban_t *cb;\n\takickdel_next = 0;\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, akickdel_list.head)\n\t{\n\t\ttimeout = n->data;\n\t\tmc = timeout->chan;\n\n\t\tif (timeout->expiration > CURRTIME)\n\t\t{\n\t\t\takickdel_next = timeout->expiration;\n\t\t\takick_timeout_check_timer = mowgli_timer_add_once(base_eventloop, \"akick_timeout_check\", akick_timeout_check, NULL, akickdel_next - CURRTIME);\n\t\t\tbreak;\n\t\t}\n\n\t\tca = NULL;\n\n\t\tif (timeout->entity == NULL)\n\t\t{\n\t\t\tif ((ca = chanacs_find_host_literal(mc, timeout->host, CA_AKICK)) && mc->chan != NULL && (cb = chanban_find(mc->chan, ca->host, 'b')))\n\t\t\t{\n\t\t\t\tmodestack_mode_param(chansvs.nick, mc->chan, MTYPE_DEL, cb->type, cb->mask);\n\t\t\t\tchanban_delete(cb);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tca = chanacs_find_literal(mc, timeout->entity, CA_AKICK);\n\t\t\tif (ca == NULL)\n\t\t\t{\n\t\t\t\tmowgli_node_delete(&timeout->node, &akickdel_list);\n\t\t\t\tmowgli_heap_free(akick_timeout_heap, timeout);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tclear_bans_matching_entity(mc, timeout->entity);\n\t\t}\n\n\t\tif (ca)\n\t\t{\n\t\t\tchanacs_modify_simple(ca, 0, CA_AKICK);\n\t\t\tchanacs_close(ca);\n\t\t}\n\n\t\tmowgli_node_delete(&timeout->node, &akickdel_list);\n\t\tmowgli_heap_free(akick_timeout_heap, timeout);\n\t}\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void akick_timeout_check(void *arg);",
      "static void akickdel_list_create(void *arg);",
      "time_t akickdel_next;",
      "mowgli_list_t akickdel_list;",
      "mowgli_eventloop_timer_t *akick_timeout_check_timer = NULL;",
      "mowgli_heap_t *akick_timeout_heap;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mowgli_heap_free",
          "args": [
            "akick_timeout_heap",
            "timeout"
          ],
          "line": 722
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_node_delete",
          "args": [
            "&timeout->node",
            "&akickdel_list"
          ],
          "line": 721
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca"
          ],
          "line": 718
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_modify_simple",
          "args": [
            "ca",
            "0",
            "CA_AKICK"
          ],
          "line": 717
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bans_matching_entity",
          "args": [
            "mc",
            "timeout->entity"
          ],
          "line": 712
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bans_matching_entity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/akick.c",
          "lines": "90-126",
          "snippet": "static void clear_bans_matching_entity(mychan_t *mc, myentity_t *mt)\n{\n\tmowgli_node_t *n;\n\tmyuser_t *tmu;\n\n\tif (mc->chan == NULL)\n\t\treturn;\n\n\tif (!isuser(mt))\n\t\treturn;\n\n\ttmu = user(mt);\n\n\tMOWGLI_ITER_FOREACH(n, tmu->logins.head)\n\t{\n\t\tuser_t *tu;\n\t\tmowgli_node_t *it, *itn;\n\n\t\tchar hostbuf2[BUFSIZE];\n\n\t\ttu = n->data;\n\n\t\tsnprintf(hostbuf2, BUFSIZE, \"%s!%s@%s\", tu->nick, tu->user, tu->vhost);\n\t\tfor (it = next_matching_ban(mc->chan, tu, 'b', mc->chan->bans.head); it != NULL; it = next_matching_ban(mc->chan, tu, 'b', itn))\n\t\t{\n\t\t\tchanban_t *cb;\n\n\t\t\titn = it->next;\n\t\t\tcb = it->data;\n\n\t\t\tmodestack_mode_param(chansvs.nick, mc->chan, MTYPE_DEL, cb->type, cb->mask);\n\t\t\tchanban_delete(cb);\n\t\t}\n\t}\n\n\tmodestack_flush_channel(mc->chan);\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic void clear_bans_matching_entity(mychan_t *mc, myentity_t *mt)\n{\n\tmowgli_node_t *n;\n\tmyuser_t *tmu;\n\n\tif (mc->chan == NULL)\n\t\treturn;\n\n\tif (!isuser(mt))\n\t\treturn;\n\n\ttmu = user(mt);\n\n\tMOWGLI_ITER_FOREACH(n, tmu->logins.head)\n\t{\n\t\tuser_t *tu;\n\t\tmowgli_node_t *it, *itn;\n\n\t\tchar hostbuf2[BUFSIZE];\n\n\t\ttu = n->data;\n\n\t\tsnprintf(hostbuf2, BUFSIZE, \"%s!%s@%s\", tu->nick, tu->user, tu->vhost);\n\t\tfor (it = next_matching_ban(mc->chan, tu, 'b', mc->chan->bans.head); it != NULL; it = next_matching_ban(mc->chan, tu, 'b', itn))\n\t\t{\n\t\t\tchanban_t *cb;\n\n\t\t\titn = it->next;\n\t\t\tcb = it->data;\n\n\t\t\tmodestack_mode_param(chansvs.nick, mc->chan, MTYPE_DEL, cb->type, cb->mask);\n\t\t\tchanban_delete(cb);\n\t\t}\n\t}\n\n\tmodestack_flush_channel(mc->chan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "mowgli_heap_free",
          "args": [
            "akick_timeout_heap",
            "timeout"
          ],
          "line": 707
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_node_delete",
          "args": [
            "&timeout->node",
            "&akickdel_list"
          ],
          "line": 706
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_find_literal",
          "args": [
            "mc",
            "timeout->entity",
            "CA_AKICK"
          ],
          "line": 703
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanban_delete",
          "args": [
            "cb"
          ],
          "line": 698
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modestack_mode_param",
          "args": [
            "chansvs.nick",
            "mc->chan",
            "MTYPE_DEL",
            "cb->type",
            "cb->mask"
          ],
          "line": 697
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanban_find",
          "args": [
            "mc->chan",
            "ca->host",
            "'b'"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_find_host_literal",
          "args": [
            "mc",
            "timeout->host",
            "CA_AKICK"
          ],
          "line": 695
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_timer_add_once",
          "args": [
            "base_eventloop",
            "\"akick_timeout_check\"",
            "akick_timeout_check",
            "NULL",
            "akickdel_next - CURRTIME"
          ],
          "line": 687
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_ITER_FOREACH_SAFE",
          "args": [
            "n",
            "tn",
            "akickdel_list.head"
          ],
          "line": 679
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic void akick_timeout_check(void *arg);\nstatic void akickdel_list_create(void *arg);\ntime_t akickdel_next;\nmowgli_list_t akickdel_list;\nmowgli_eventloop_timer_t *akick_timeout_check_timer = NULL;\nmowgli_heap_t *akick_timeout_heap;\n\nvoid akick_timeout_check(void *arg)\n{\n\tmowgli_node_t *n, *tn;\n\takick_timeout_t *timeout;\n\tchanacs_t *ca;\n\tmychan_t *mc;\n\n\tchanban_t *cb;\n\takickdel_next = 0;\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, akickdel_list.head)\n\t{\n\t\ttimeout = n->data;\n\t\tmc = timeout->chan;\n\n\t\tif (timeout->expiration > CURRTIME)\n\t\t{\n\t\t\takickdel_next = timeout->expiration;\n\t\t\takick_timeout_check_timer = mowgli_timer_add_once(base_eventloop, \"akick_timeout_check\", akick_timeout_check, NULL, akickdel_next - CURRTIME);\n\t\t\tbreak;\n\t\t}\n\n\t\tca = NULL;\n\n\t\tif (timeout->entity == NULL)\n\t\t{\n\t\t\tif ((ca = chanacs_find_host_literal(mc, timeout->host, CA_AKICK)) && mc->chan != NULL && (cb = chanban_find(mc->chan, ca->host, 'b')))\n\t\t\t{\n\t\t\t\tmodestack_mode_param(chansvs.nick, mc->chan, MTYPE_DEL, cb->type, cb->mask);\n\t\t\t\tchanban_delete(cb);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tca = chanacs_find_literal(mc, timeout->entity, CA_AKICK);\n\t\t\tif (ca == NULL)\n\t\t\t{\n\t\t\t\tmowgli_node_delete(&timeout->node, &akickdel_list);\n\t\t\t\tmowgli_heap_free(akick_timeout_heap, timeout);\n\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tclear_bans_matching_entity(mc, timeout->entity);\n\t\t}\n\n\t\tif (ca)\n\t\t{\n\t\t\tchanacs_modify_simple(ca, 0, CA_AKICK);\n\t\t\tchanacs_close(ca);\n\t\t}\n\n\t\tmowgli_node_delete(&timeout->node, &akickdel_list);\n\t\tmowgli_heap_free(akick_timeout_heap, timeout);\n\t}\n}"
  },
  {
    "function_name": "cs_cmd_akick_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/akick.c",
    "lines": "556-667",
    "snippet": "void cs_cmd_akick_list(sourceinfo_t *si, int parc, char *parv[])\n{\n\tmychan_t *mc;\n\tchanacs_t *ca;\n\tmetadata_t *md, *md2;\n\tmowgli_node_t *n, *tn;\n\tbool operoverride = false;\n\tchar *chan = parv[0];\n\tchar expiry[512];\n\n\tif (!chan)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"AKICK\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: AKICK <#channel> LIST\"));\n\t\treturn;\n\t}\n\n\t/* make sure they're registered, logged in\n\t * and the founder of the channel before\n\t * we go any further.\n\t */\n\tif (!si->smu)\n\t{\n\t\t/* if they're opers and just want to LIST, they don't have to log in */\n\t\tif (!(has_priv(si, PRIV_CHAN_AUSPEX)))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not logged in.\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tint i = 0;\n\n\tif (!chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t{\n\t\tif (has_priv(si, PRIV_CHAN_AUSPEX))\n\t\t\toperoverride = true;\n\t\telse\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t}\n\tcommand_success_nodata(si, _(\"AKICK list for \\2%s\\2:\"), mc->name);\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mc->chanacs.head)\n\t{\n\t\ttime_t expires_on = 0;\n\t\tchar *ago;\n\t\tlong time_left = 0;\n\n\t\tca = (chanacs_t *)n->data;\n\n\t\tif (ca->level == CA_AKICK)\n\t\t{\n\t\t\tchar buf[BUFSIZE], *buf_iter;\n\n\t\t\tmd = metadata_find(ca, \"reason\");\n\n\t\t\t/* check if it's a temporary akick */\n\t\t\tif ((md2 = metadata_find(ca, \"expires\")))\n\t\t\t{\n\t\t\t\tsnprintf(expiry, sizeof expiry, \"%s\", md2->value);\n\t\t\t\texpires_on = (time_t)atol(expiry);\n\t\t\t\ttime_left = difftime(expires_on, CURRTIME);\n\t\t\t}\n\t\t\tago = ca->tmodified ? time_ago(ca->tmodified) : \"?\";\n\n\t\t\tbuf_iter = buf;\n\t\t\tbuf_iter += snprintf(buf_iter, sizeof(buf) - (buf_iter - buf), _(\"%d: \\2%s\\2 (\\2%s\\2) [\"),\n\t\t\t\t\t     ++i, ca->entity != NULL ? ca->entity->name : ca->host,\n\t\t\t\t\t     md != NULL ? md->value : _(\"no AKICK reason specified\"));\n\n\t\t\tif (ca->setter)\n\t\t\t\tbuf_iter += snprintf(buf_iter, sizeof(buf) - (buf_iter - buf), _(\"setter: %s\"),\n\t\t\t\t\t\t     ca->setter);\n\n\t\t\tif (expires_on > 0)\n\t\t\t\tbuf_iter += snprintf(buf_iter, sizeof(buf) - (buf_iter - buf), _(\"%sexpires: %s\"),\n\t\t\t\t\t\t     ca->setter != NULL ? \", \" : \"\", timediff(time_left));\n\n\t\t\tif (ca->tmodified)\n\t\t\t\tbuf_iter += snprintf(buf_iter, sizeof(buf) - (buf_iter - buf), _(\"%smodified: %s\"),\n\t\t\t\t\t\t     expires_on > 0 || ca->setter != NULL ? \", \" : \"\", ago);\n\n\t\t\tmowgli_strlcat(buf, \"]\", sizeof buf);\n\n\t\t\tcommand_success_nodata(si, \"%s\", buf);\n\t\t}\n\n\t}\n\n\tcommand_success_nodata(si, _(\"Total of \\2%d\\2 %s in \\2%s\\2's AKICK list.\"), i, (i == 1) ? \"entry\" : \"entries\", mc->name);\n\n\tif (operoverride)\n\t\tlogcommand(si, CMDLOG_ADMIN, \"AKICK:LIST: \\2%s\\2 (oper override)\", mc->name);\n\telse\n\t\tlogcommand(si, CMDLOG_GET, \"AKICK:LIST: \\2%s\\2\", mc->name);\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_cmd_akick(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_akick_add(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_akick_del(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_akick_list(sourceinfo_t *si, int parc, char *parv[]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_GET",
            "\"AKICK:LIST: \\2%s\\2\"",
            "mc->name"
          ],
          "line": 666
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_ADMIN",
            "\"AKICK:LIST: \\2%s\\2 (oper override)\"",
            "mc->name"
          ],
          "line": 664
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"Total of \\2%d\\2 %s in \\2%s\\2's AKICK list.\")",
            "i",
            "(i == 1) ? \"entry\" : \"entries\"",
            "mc->name"
          ],
          "line": 661
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Total of \\2%d\\2 %s in \\2%s\\2's AKICK list.\""
          ],
          "line": 661
        },
        "resolved": true,
        "details": {
          "function_name": "akickdel_list_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/akick.c",
          "lines": "755-796",
          "snippet": "void akickdel_list_create(void *arg)\n{\n\tmychan_t *mc;\n\tmowgli_node_t *n, *tn;\n\tchanacs_t *ca;\n\tmetadata_t *md;\n\ttime_t expireson;\n\n\tmowgli_patricia_iteration_state_t state;\n\n\tMOWGLI_PATRICIA_FOREACH(mc, &state, mclist)\n\t{\n\t\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mc->chanacs.head)\n\t\t{\n\t\t\tca = (chanacs_t *)n->data;\n\n\t\t\tif (!(ca->level & CA_AKICK))\n\t\t\t\tcontinue;\n\n\t\t\tmd = metadata_find(ca, \"expires\");\n\n\t\t\tif (!md)\n\t\t\t\tcontinue;\n\n\t\t\texpireson = atol(md->value);\n\n\t\t\tif (CURRTIME > expireson)\n\t\t\t{\n\t\t\t\tchanacs_modify_simple(ca, 0, CA_AKICK);\n\t\t\t\tchanacs_close(ca);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* overcomplicate the logic here a tiny bit */\n\t\t\t\tif (ca->host == NULL && ca->entity != NULL)\n\t\t\t\t\takick_add_timeout(mc, ca->entity, entity(ca->entity)->name, expireson);\n\t\t\t\telse if (ca->host != NULL && ca->entity == NULL)\n\t\t\t\t\takick_add_timeout(mc, NULL, ca->host, expireson);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void akick_timeout_check(void *arg);",
            "static void akickdel_list_create(void *arg);",
            "static akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic void akick_timeout_check(void *arg);\nstatic void akickdel_list_create(void *arg);\nstatic akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson);\n\nvoid akickdel_list_create(void *arg)\n{\n\tmychan_t *mc;\n\tmowgli_node_t *n, *tn;\n\tchanacs_t *ca;\n\tmetadata_t *md;\n\ttime_t expireson;\n\n\tmowgli_patricia_iteration_state_t state;\n\n\tMOWGLI_PATRICIA_FOREACH(mc, &state, mclist)\n\t{\n\t\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mc->chanacs.head)\n\t\t{\n\t\t\tca = (chanacs_t *)n->data;\n\n\t\t\tif (!(ca->level & CA_AKICK))\n\t\t\t\tcontinue;\n\n\t\t\tmd = metadata_find(ca, \"expires\");\n\n\t\t\tif (!md)\n\t\t\t\tcontinue;\n\n\t\t\texpireson = atol(md->value);\n\n\t\t\tif (CURRTIME > expireson)\n\t\t\t{\n\t\t\t\tchanacs_modify_simple(ca, 0, CA_AKICK);\n\t\t\t\tchanacs_close(ca);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* overcomplicate the logic here a tiny bit */\n\t\t\t\tif (ca->host == NULL && ca->entity != NULL)\n\t\t\t\t\takick_add_timeout(mc, ca->entity, entity(ca->entity)->name, expireson);\n\t\t\t\telse if (ca->host != NULL && ca->entity == NULL)\n\t\t\t\t\takick_add_timeout(mc, NULL, ca->host, expireson);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "\"%s\"",
            "buf"
          ],
          "line": 656
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcat",
          "args": [
            "buf",
            "\"]\"",
            "sizeof buf"
          ],
          "line": 654
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf_iter",
            "sizeof(buf) - (buf_iter - buf)",
            "_(\"%smodified: %s\")",
            "expires_on > 0 || ca->setter != NULL ? \", \" : \"\"",
            "ago"
          ],
          "line": 651
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf_iter",
            "sizeof(buf) - (buf_iter - buf)",
            "_(\"%sexpires: %s\")",
            "ca->setter != NULL ? \", \" : \"\"",
            "timediff(time_left)"
          ],
          "line": 647
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timediff",
          "args": [
            "time_left"
          ],
          "line": 648
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf_iter",
            "sizeof(buf) - (buf_iter - buf)",
            "_(\"setter: %s\")",
            "ca->setter"
          ],
          "line": 643
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "buf_iter",
            "sizeof(buf) - (buf_iter - buf)",
            "_(\"%d: \\2%s\\2 (\\2%s\\2) [\")",
            "++i",
            "ca->entity != NULL ? ca->entity->name : ca->host",
            "md != NULL ? md->value : _(\"no AKICK reason specified\")"
          ],
          "line": 638
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "time_ago",
          "args": [
            "ca->tmodified"
          ],
          "line": 635
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "difftime",
          "args": [
            "expires_on",
            "CURRTIME"
          ],
          "line": 633
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "expiry"
          ],
          "line": 632
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "expiry",
            "sizeof expiry",
            "\"%s\"",
            "md2->value"
          ],
          "line": 631
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "ca",
            "\"expires\""
          ],
          "line": 629
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "ca",
            "\"reason\""
          ],
          "line": 626
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_ITER_FOREACH_SAFE",
          "args": [
            "n",
            "tn",
            "mc->chanacs.head"
          ],
          "line": 614
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"AKICK list for \\2%s\\2:\")",
            "mc->name"
          ],
          "line": 612
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not authorized to perform this operation.\")"
          ],
          "line": 608
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_priv",
          "args": [
            "si",
            "PRIV_CHAN_AUSPEX"
          ],
          "line": 604
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_source_has_flag",
          "args": [
            "mc",
            "si",
            "CA_ACLVIEW"
          ],
          "line": 602
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"\\2%s\\2 is closed.\")",
            "chan"
          ],
          "line": 596
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:close:closer\""
          ],
          "line": 594
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_target",
            "_(\"Channel \\2%s\\2 is not registered.\")",
            "chan"
          ],
          "line": 590
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_find",
          "args": [
            "chan"
          ],
          "line": 587
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not logged in.\")"
          ],
          "line": 582
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_priv",
          "args": [
            "si",
            "PRIV_CHAN_AUSPEX"
          ],
          "line": 580
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "_(\"Syntax: AKICK <#channel> LIST\")"
          ],
          "line": 569
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "STR_INSUFFICIENT_PARAMS",
            "\"AKICK\""
          ],
          "line": 568
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic void cs_cmd_akick(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_akick_add(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_akick_del(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_akick_list(sourceinfo_t *si, int parc, char *parv[]);\n\nvoid cs_cmd_akick_list(sourceinfo_t *si, int parc, char *parv[])\n{\n\tmychan_t *mc;\n\tchanacs_t *ca;\n\tmetadata_t *md, *md2;\n\tmowgli_node_t *n, *tn;\n\tbool operoverride = false;\n\tchar *chan = parv[0];\n\tchar expiry[512];\n\n\tif (!chan)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"AKICK\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: AKICK <#channel> LIST\"));\n\t\treturn;\n\t}\n\n\t/* make sure they're registered, logged in\n\t * and the founder of the channel before\n\t * we go any further.\n\t */\n\tif (!si->smu)\n\t{\n\t\t/* if they're opers and just want to LIST, they don't have to log in */\n\t\tif (!(has_priv(si, PRIV_CHAN_AUSPEX)))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not logged in.\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tint i = 0;\n\n\tif (!chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t{\n\t\tif (has_priv(si, PRIV_CHAN_AUSPEX))\n\t\t\toperoverride = true;\n\t\telse\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t}\n\tcommand_success_nodata(si, _(\"AKICK list for \\2%s\\2:\"), mc->name);\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mc->chanacs.head)\n\t{\n\t\ttime_t expires_on = 0;\n\t\tchar *ago;\n\t\tlong time_left = 0;\n\n\t\tca = (chanacs_t *)n->data;\n\n\t\tif (ca->level == CA_AKICK)\n\t\t{\n\t\t\tchar buf[BUFSIZE], *buf_iter;\n\n\t\t\tmd = metadata_find(ca, \"reason\");\n\n\t\t\t/* check if it's a temporary akick */\n\t\t\tif ((md2 = metadata_find(ca, \"expires\")))\n\t\t\t{\n\t\t\t\tsnprintf(expiry, sizeof expiry, \"%s\", md2->value);\n\t\t\t\texpires_on = (time_t)atol(expiry);\n\t\t\t\ttime_left = difftime(expires_on, CURRTIME);\n\t\t\t}\n\t\t\tago = ca->tmodified ? time_ago(ca->tmodified) : \"?\";\n\n\t\t\tbuf_iter = buf;\n\t\t\tbuf_iter += snprintf(buf_iter, sizeof(buf) - (buf_iter - buf), _(\"%d: \\2%s\\2 (\\2%s\\2) [\"),\n\t\t\t\t\t     ++i, ca->entity != NULL ? ca->entity->name : ca->host,\n\t\t\t\t\t     md != NULL ? md->value : _(\"no AKICK reason specified\"));\n\n\t\t\tif (ca->setter)\n\t\t\t\tbuf_iter += snprintf(buf_iter, sizeof(buf) - (buf_iter - buf), _(\"setter: %s\"),\n\t\t\t\t\t\t     ca->setter);\n\n\t\t\tif (expires_on > 0)\n\t\t\t\tbuf_iter += snprintf(buf_iter, sizeof(buf) - (buf_iter - buf), _(\"%sexpires: %s\"),\n\t\t\t\t\t\t     ca->setter != NULL ? \", \" : \"\", timediff(time_left));\n\n\t\t\tif (ca->tmodified)\n\t\t\t\tbuf_iter += snprintf(buf_iter, sizeof(buf) - (buf_iter - buf), _(\"%smodified: %s\"),\n\t\t\t\t\t\t     expires_on > 0 || ca->setter != NULL ? \", \" : \"\", ago);\n\n\t\t\tmowgli_strlcat(buf, \"]\", sizeof buf);\n\n\t\t\tcommand_success_nodata(si, \"%s\", buf);\n\t\t}\n\n\t}\n\n\tcommand_success_nodata(si, _(\"Total of \\2%d\\2 %s in \\2%s\\2's AKICK list.\"), i, (i == 1) ? \"entry\" : \"entries\", mc->name);\n\n\tif (operoverride)\n\t\tlogcommand(si, CMDLOG_ADMIN, \"AKICK:LIST: \\2%s\\2 (oper override)\", mc->name);\n\telse\n\t\tlogcommand(si, CMDLOG_GET, \"AKICK:LIST: \\2%s\\2\", mc->name);\n}"
  },
  {
    "function_name": "cs_cmd_akick_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/akick.c",
    "lines": "434-554",
    "snippet": "void cs_cmd_akick_del(sourceinfo_t *si, int parc, char *parv[])\n{\n\tmyentity_t *mt;\n\tmychan_t *mc;\n\thook_channel_acl_req_t req;\n\tchanacs_t *ca;\n\tmowgli_node_t *n, *tn;\n\tchar *chan = parv[0];\n\tchar *uname = parv[1];\n\n\tif (!chan || !uname)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"AKICK\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: AKICK <#channel> DEL <nickname|hostmask>\"));\n\t\treturn;\n\t}\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\takick_timeout_t *timeout;\n\tchanban_t *cb;\n\n\tif ((chanacs_source_flags(mc, si) & (CA_FLAGS | CA_REMOVE)) != (CA_FLAGS | CA_REMOVE))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\treturn;\n\t}\n\n\tmt = myentity_find_ext(uname);\n\tif (!mt)\n\t{\n\t\t/* we might be deleting a hostmask */\n\t\tca = chanacs_find_host_literal(mc, uname, CA_AKICK);\n\t\tif (ca == NULL)\n\t\t{\n\t\t\tca = chanacs_find_host(mc, uname, CA_AKICK);\n\t\t\tif (ca != NULL)\n\t\t\t\tcommand_fail(si, fault_nosuch_key, _(\"\\2%s\\2 is not on the AKICK list for \\2%s\\2, however \\2%s\\2 is.\"), uname, mc->name, ca->host);\n\t\t\telse\n\t\t\t\tcommand_fail(si, fault_nosuch_key, _(\"\\2%s\\2 is not on the AKICK list for \\2%s\\2.\"), uname, mc->name);\n\t\t\treturn;\n\t\t}\n\n\t\treq.ca = ca;\n\t\treq.oldlevel = ca->level;\n\n\t\tchanacs_modify_simple(ca, 0, CA_AKICK);\n\n\t\treq.newlevel = ca->level;\n\n\t\thook_call_channel_acl_change(&req);\n\t\tchanacs_close(ca);\n\n\t\tverbose(mc, \"\\2%s\\2 removed \\2%s\\2 from the AKICK list.\", get_source_name(si), uname);\n\t\tlogcommand(si, CMDLOG_SET, \"AKICK:DEL: \\2%s\\2 on \\2%s\\2\", uname, mc->name);\n\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been removed from the AKICK list for \\2%s\\2.\"), uname, mc->name);\n\n\t\tMOWGLI_ITER_FOREACH_SAFE(n, tn, akickdel_list.head)\n\t\t{\n\t\t\ttimeout = n->data;\n\t\t\tif (!match(timeout->host, uname) && timeout->chan == mc)\n\t\t\t{\n\t\t\t\tmowgli_node_delete(&timeout->node, &akickdel_list);\n\t\t\t\tmowgli_heap_free(akick_timeout_heap, timeout);\n\t\t\t}\n\t\t}\n\n\t\tif (mc->chan != NULL && (cb = chanban_find(mc->chan, uname, 'b')))\n\t\t{\n\t\t\tmodestack_mode_param(chansvs.nick, mc->chan, MTYPE_DEL, cb->type, cb->mask);\n\t\t\tchanban_delete(cb);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (!(ca = chanacs_find_literal(mc, mt, CA_AKICK)))\n\t{\n\t\tcommand_fail(si, fault_nosuch_key, _(\"\\2%s\\2 is not on the AKICK list for \\2%s\\2.\"), mt->name, mc->name);\n\t\treturn;\n\t}\n\n\tclear_bans_matching_entity(mc, mt);\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, akickdel_list.head)\n\t{\n\t\ttimeout = n->data;\n\t\tif (timeout->entity == mt && timeout->chan == mc)\n\t\t{\n\t\t\tmowgli_node_delete(&timeout->node, &akickdel_list);\n\t\t\tmowgli_heap_free(akick_timeout_heap, timeout);\n\t\t}\n\t}\n\n\treq.ca = ca;\n\treq.oldlevel = ca->level;\n\n\tchanacs_modify_simple(ca, 0, CA_AKICK);\n\n\treq.newlevel = ca->level;\n\n\thook_call_channel_acl_change(&req);\n\tchanacs_close(ca);\n\n\tcommand_success_nodata(si, _(\"\\2%s\\2 has been removed from the AKICK list for \\2%s\\2.\"), mt->name, mc->name);\n\tlogcommand(si, CMDLOG_SET, \"AKICK:DEL: \\2%s\\2 on \\2%s\\2\", mt->name, mc->name);\n\tverbose(mc, \"\\2%s\\2 removed \\2%s\\2 from the AKICK list.\", get_source_name(si), mt->name);\n\n\treturn;\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_cmd_akick(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_akick_add(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_akick_del(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_akick_list(sourceinfo_t *si, int parc, char *parv[]);",
      "mowgli_list_t akickdel_list;",
      "mowgli_heap_t *akick_timeout_heap;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "mc",
            "\"\\2%s\\2 removed \\2%s\\2 from the AKICK list.\"",
            "get_source_name(si)",
            "mt->name"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_source_name",
          "args": [
            "si"
          ],
          "line": 551
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_SET",
            "\"AKICK:DEL: \\2%s\\2 on \\2%s\\2\"",
            "mt->name",
            "mc->name"
          ],
          "line": 550
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"\\2%s\\2 has been removed from the AKICK list for \\2%s\\2.\")",
            "mt->name",
            "mc->name"
          ],
          "line": 549
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"\\2%s\\2 has been removed from the AKICK list for \\2%s\\2.\""
          ],
          "line": 549
        },
        "resolved": true,
        "details": {
          "function_name": "akickdel_list_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/akick.c",
          "lines": "755-796",
          "snippet": "void akickdel_list_create(void *arg)\n{\n\tmychan_t *mc;\n\tmowgli_node_t *n, *tn;\n\tchanacs_t *ca;\n\tmetadata_t *md;\n\ttime_t expireson;\n\n\tmowgli_patricia_iteration_state_t state;\n\n\tMOWGLI_PATRICIA_FOREACH(mc, &state, mclist)\n\t{\n\t\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mc->chanacs.head)\n\t\t{\n\t\t\tca = (chanacs_t *)n->data;\n\n\t\t\tif (!(ca->level & CA_AKICK))\n\t\t\t\tcontinue;\n\n\t\t\tmd = metadata_find(ca, \"expires\");\n\n\t\t\tif (!md)\n\t\t\t\tcontinue;\n\n\t\t\texpireson = atol(md->value);\n\n\t\t\tif (CURRTIME > expireson)\n\t\t\t{\n\t\t\t\tchanacs_modify_simple(ca, 0, CA_AKICK);\n\t\t\t\tchanacs_close(ca);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* overcomplicate the logic here a tiny bit */\n\t\t\t\tif (ca->host == NULL && ca->entity != NULL)\n\t\t\t\t\takick_add_timeout(mc, ca->entity, entity(ca->entity)->name, expireson);\n\t\t\t\telse if (ca->host != NULL && ca->entity == NULL)\n\t\t\t\t\takick_add_timeout(mc, NULL, ca->host, expireson);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void akick_timeout_check(void *arg);",
            "static void akickdel_list_create(void *arg);",
            "static akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic void akick_timeout_check(void *arg);\nstatic void akickdel_list_create(void *arg);\nstatic akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson);\n\nvoid akickdel_list_create(void *arg)\n{\n\tmychan_t *mc;\n\tmowgli_node_t *n, *tn;\n\tchanacs_t *ca;\n\tmetadata_t *md;\n\ttime_t expireson;\n\n\tmowgli_patricia_iteration_state_t state;\n\n\tMOWGLI_PATRICIA_FOREACH(mc, &state, mclist)\n\t{\n\t\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mc->chanacs.head)\n\t\t{\n\t\t\tca = (chanacs_t *)n->data;\n\n\t\t\tif (!(ca->level & CA_AKICK))\n\t\t\t\tcontinue;\n\n\t\t\tmd = metadata_find(ca, \"expires\");\n\n\t\t\tif (!md)\n\t\t\t\tcontinue;\n\n\t\t\texpireson = atol(md->value);\n\n\t\t\tif (CURRTIME > expireson)\n\t\t\t{\n\t\t\t\tchanacs_modify_simple(ca, 0, CA_AKICK);\n\t\t\t\tchanacs_close(ca);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* overcomplicate the logic here a tiny bit */\n\t\t\t\tif (ca->host == NULL && ca->entity != NULL)\n\t\t\t\t\takick_add_timeout(mc, ca->entity, entity(ca->entity)->name, expireson);\n\t\t\t\telse if (ca->host != NULL && ca->entity == NULL)\n\t\t\t\t\takick_add_timeout(mc, NULL, ca->host, expireson);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca"
          ],
          "line": 547
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_call_channel_acl_change",
          "args": [
            "&req"
          ],
          "line": 546
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_modify_simple",
          "args": [
            "ca",
            "0",
            "CA_AKICK"
          ],
          "line": 542
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_heap_free",
          "args": [
            "akick_timeout_heap",
            "timeout"
          ],
          "line": 535
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_node_delete",
          "args": [
            "&timeout->node",
            "&akickdel_list"
          ],
          "line": 534
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_ITER_FOREACH_SAFE",
          "args": [
            "n",
            "tn",
            "akickdel_list.head"
          ],
          "line": 529
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "clear_bans_matching_entity",
          "args": [
            "mc",
            "mt"
          ],
          "line": 527
        },
        "resolved": true,
        "details": {
          "function_name": "clear_bans_matching_entity",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/akick.c",
          "lines": "90-126",
          "snippet": "static void clear_bans_matching_entity(mychan_t *mc, myentity_t *mt)\n{\n\tmowgli_node_t *n;\n\tmyuser_t *tmu;\n\n\tif (mc->chan == NULL)\n\t\treturn;\n\n\tif (!isuser(mt))\n\t\treturn;\n\n\ttmu = user(mt);\n\n\tMOWGLI_ITER_FOREACH(n, tmu->logins.head)\n\t{\n\t\tuser_t *tu;\n\t\tmowgli_node_t *it, *itn;\n\n\t\tchar hostbuf2[BUFSIZE];\n\n\t\ttu = n->data;\n\n\t\tsnprintf(hostbuf2, BUFSIZE, \"%s!%s@%s\", tu->nick, tu->user, tu->vhost);\n\t\tfor (it = next_matching_ban(mc->chan, tu, 'b', mc->chan->bans.head); it != NULL; it = next_matching_ban(mc->chan, tu, 'b', itn))\n\t\t{\n\t\t\tchanban_t *cb;\n\n\t\t\titn = it->next;\n\t\t\tcb = it->data;\n\n\t\t\tmodestack_mode_param(chansvs.nick, mc->chan, MTYPE_DEL, cb->type, cb->mask);\n\t\t\tchanban_delete(cb);\n\t\t}\n\t}\n\n\tmodestack_flush_channel(mc->chan);\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic void clear_bans_matching_entity(mychan_t *mc, myentity_t *mt)\n{\n\tmowgli_node_t *n;\n\tmyuser_t *tmu;\n\n\tif (mc->chan == NULL)\n\t\treturn;\n\n\tif (!isuser(mt))\n\t\treturn;\n\n\ttmu = user(mt);\n\n\tMOWGLI_ITER_FOREACH(n, tmu->logins.head)\n\t{\n\t\tuser_t *tu;\n\t\tmowgli_node_t *it, *itn;\n\n\t\tchar hostbuf2[BUFSIZE];\n\n\t\ttu = n->data;\n\n\t\tsnprintf(hostbuf2, BUFSIZE, \"%s!%s@%s\", tu->nick, tu->user, tu->vhost);\n\t\tfor (it = next_matching_ban(mc->chan, tu, 'b', mc->chan->bans.head); it != NULL; it = next_matching_ban(mc->chan, tu, 'b', itn))\n\t\t{\n\t\t\tchanban_t *cb;\n\n\t\t\titn = it->next;\n\t\t\tcb = it->data;\n\n\t\t\tmodestack_mode_param(chansvs.nick, mc->chan, MTYPE_DEL, cb->type, cb->mask);\n\t\t\tchanban_delete(cb);\n\t\t}\n\t}\n\n\tmodestack_flush_channel(mc->chan);\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_key",
            "_(\"\\2%s\\2 is not on the AKICK list for \\2%s\\2.\")",
            "mt->name",
            "mc->name"
          ],
          "line": 523
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_find_literal",
          "args": [
            "mc",
            "mt",
            "CA_AKICK"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanban_delete",
          "args": [
            "cb"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modestack_mode_param",
          "args": [
            "chansvs.nick",
            "mc->chan",
            "MTYPE_DEL",
            "cb->type",
            "cb->mask"
          ],
          "line": 514
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanban_find",
          "args": [
            "mc->chan",
            "uname",
            "'b'"
          ],
          "line": 512
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_heap_free",
          "args": [
            "akick_timeout_heap",
            "timeout"
          ],
          "line": 508
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_node_delete",
          "args": [
            "&timeout->node",
            "&akickdel_list"
          ],
          "line": 507
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_ITER_FOREACH_SAFE",
          "args": [
            "n",
            "tn",
            "akickdel_list.head"
          ],
          "line": 502
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"\\2%s\\2 has been removed from the AKICK list for \\2%s\\2.\")",
            "uname",
            "mc->name"
          ],
          "line": 500
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_SET",
            "\"AKICK:DEL: \\2%s\\2 on \\2%s\\2\"",
            "uname",
            "mc->name"
          ],
          "line": 499
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "mc",
            "\"\\2%s\\2 removed \\2%s\\2 from the AKICK list.\"",
            "get_source_name(si)",
            "uname"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_source_name",
          "args": [
            "si"
          ],
          "line": 498
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca"
          ],
          "line": 496
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_call_channel_acl_change",
          "args": [
            "&req"
          ],
          "line": 495
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_modify_simple",
          "args": [
            "ca",
            "0",
            "CA_AKICK"
          ],
          "line": 491
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_key",
            "_(\"\\2%s\\2 is not on the AKICK list for \\2%s\\2.\")",
            "uname",
            "mc->name"
          ],
          "line": 484
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_key",
            "_(\"\\2%s\\2 is not on the AKICK list for \\2%s\\2, however \\2%s\\2 is.\")",
            "uname",
            "mc->name",
            "ca->host"
          ],
          "line": 482
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_find_host",
          "args": [
            "mc",
            "uname",
            "CA_AKICK"
          ],
          "line": 480
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_find_host_literal",
          "args": [
            "mc",
            "uname",
            "CA_AKICK"
          ],
          "line": 477
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "myentity_find_ext",
          "args": [
            "uname"
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not authorized to perform this operation.\")"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_source_flags",
          "args": [
            "mc",
            "si"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"\\2%s\\2 is closed.\")",
            "chan"
          ],
          "line": 460
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:close:closer\""
          ],
          "line": 458
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_target",
            "_(\"Channel \\2%s\\2 is not registered.\")",
            "chan"
          ],
          "line": 454
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_find",
          "args": [
            "chan"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "_(\"Syntax: AKICK <#channel> DEL <nickname|hostmask>\")"
          ],
          "line": 447
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "STR_INSUFFICIENT_PARAMS",
            "\"AKICK\""
          ],
          "line": 446
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic void cs_cmd_akick(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_akick_add(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_akick_del(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_akick_list(sourceinfo_t *si, int parc, char *parv[]);\nmowgli_list_t akickdel_list;\nmowgli_heap_t *akick_timeout_heap;\n\nvoid cs_cmd_akick_del(sourceinfo_t *si, int parc, char *parv[])\n{\n\tmyentity_t *mt;\n\tmychan_t *mc;\n\thook_channel_acl_req_t req;\n\tchanacs_t *ca;\n\tmowgli_node_t *n, *tn;\n\tchar *chan = parv[0];\n\tchar *uname = parv[1];\n\n\tif (!chan || !uname)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"AKICK\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: AKICK <#channel> DEL <nickname|hostmask>\"));\n\t\treturn;\n\t}\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\takick_timeout_t *timeout;\n\tchanban_t *cb;\n\n\tif ((chanacs_source_flags(mc, si) & (CA_FLAGS | CA_REMOVE)) != (CA_FLAGS | CA_REMOVE))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\treturn;\n\t}\n\n\tmt = myentity_find_ext(uname);\n\tif (!mt)\n\t{\n\t\t/* we might be deleting a hostmask */\n\t\tca = chanacs_find_host_literal(mc, uname, CA_AKICK);\n\t\tif (ca == NULL)\n\t\t{\n\t\t\tca = chanacs_find_host(mc, uname, CA_AKICK);\n\t\t\tif (ca != NULL)\n\t\t\t\tcommand_fail(si, fault_nosuch_key, _(\"\\2%s\\2 is not on the AKICK list for \\2%s\\2, however \\2%s\\2 is.\"), uname, mc->name, ca->host);\n\t\t\telse\n\t\t\t\tcommand_fail(si, fault_nosuch_key, _(\"\\2%s\\2 is not on the AKICK list for \\2%s\\2.\"), uname, mc->name);\n\t\t\treturn;\n\t\t}\n\n\t\treq.ca = ca;\n\t\treq.oldlevel = ca->level;\n\n\t\tchanacs_modify_simple(ca, 0, CA_AKICK);\n\n\t\treq.newlevel = ca->level;\n\n\t\thook_call_channel_acl_change(&req);\n\t\tchanacs_close(ca);\n\n\t\tverbose(mc, \"\\2%s\\2 removed \\2%s\\2 from the AKICK list.\", get_source_name(si), uname);\n\t\tlogcommand(si, CMDLOG_SET, \"AKICK:DEL: \\2%s\\2 on \\2%s\\2\", uname, mc->name);\n\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been removed from the AKICK list for \\2%s\\2.\"), uname, mc->name);\n\n\t\tMOWGLI_ITER_FOREACH_SAFE(n, tn, akickdel_list.head)\n\t\t{\n\t\t\ttimeout = n->data;\n\t\t\tif (!match(timeout->host, uname) && timeout->chan == mc)\n\t\t\t{\n\t\t\t\tmowgli_node_delete(&timeout->node, &akickdel_list);\n\t\t\t\tmowgli_heap_free(akick_timeout_heap, timeout);\n\t\t\t}\n\t\t}\n\n\t\tif (mc->chan != NULL && (cb = chanban_find(mc->chan, uname, 'b')))\n\t\t{\n\t\t\tmodestack_mode_param(chansvs.nick, mc->chan, MTYPE_DEL, cb->type, cb->mask);\n\t\t\tchanban_delete(cb);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tif (!(ca = chanacs_find_literal(mc, mt, CA_AKICK)))\n\t{\n\t\tcommand_fail(si, fault_nosuch_key, _(\"\\2%s\\2 is not on the AKICK list for \\2%s\\2.\"), mt->name, mc->name);\n\t\treturn;\n\t}\n\n\tclear_bans_matching_entity(mc, mt);\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, akickdel_list.head)\n\t{\n\t\ttimeout = n->data;\n\t\tif (timeout->entity == mt && timeout->chan == mc)\n\t\t{\n\t\t\tmowgli_node_delete(&timeout->node, &akickdel_list);\n\t\t\tmowgli_heap_free(akick_timeout_heap, timeout);\n\t\t}\n\t}\n\n\treq.ca = ca;\n\treq.oldlevel = ca->level;\n\n\tchanacs_modify_simple(ca, 0, CA_AKICK);\n\n\treq.newlevel = ca->level;\n\n\thook_call_channel_acl_change(&req);\n\tchanacs_close(ca);\n\n\tcommand_success_nodata(si, _(\"\\2%s\\2 has been removed from the AKICK list for \\2%s\\2.\"), mt->name, mc->name);\n\tlogcommand(si, CMDLOG_SET, \"AKICK:DEL: \\2%s\\2 on \\2%s\\2\", mt->name, mc->name);\n\tverbose(mc, \"\\2%s\\2 removed \\2%s\\2 from the AKICK list.\", get_source_name(si), mt->name);\n\n\treturn;\n}"
  },
  {
    "function_name": "cs_cmd_akick_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/akick.c",
    "lines": "163-432",
    "snippet": "void cs_cmd_akick_add(sourceinfo_t *si, int parc, char *parv[])\n{\n\tmyentity_t *mt;\n\tmychan_t *mc;\n\thook_channel_acl_req_t req;\n\tchanacs_t *ca, *ca2;\n\tchar *chan = parv[0];\n\tlong duration;\n\tchar expiry[512];\n\tchar *s;\n\tchar *target;\n\tchar *uname;\n\tchar *token;\n\tchar *treason, reason[BUFSIZE];\n\n\ttarget = parv[1];\n\ttoken = strtok(parv[2], \" \");\n\n\tif (!target)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"AKICK\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: AKICK <#channel> ADD <nickname|hostmask> [!P|!T <minutes>] [reason]\"));\n\t\treturn;\n\t}\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\t/* A duration, reason or duration and reason. */\n\tif (token)\n\t{\n\t\tif (!strcasecmp(token, \"!P\")) /* A duration [permanent] */\n\t\t{\n\t\t\tduration = 0;\n\t\t\ttreason = strtok(NULL, \"\");\n\n\t\t\tif (treason)\n\t\t\t\tmowgli_strlcpy(reason, treason, BUFSIZE);\n\t\t\telse\n\t\t\t\treason[0] = 0;\n\t\t}\n\t\telse if (!strcasecmp(token, \"!T\")) /* A duration [temporary] */\n\t\t{\n\t\t\ts = strtok(NULL, \" \");\n\t\t\ttreason = strtok(NULL, \"\");\n\n\t\t\tif (treason)\n\t\t\t\tmowgli_strlcpy(reason, treason, BUFSIZE);\n\t\t\telse\n\t\t\t\treason[0] = 0;\n\n\t\t\tif (s)\n\t\t\t{\n\t\t\t\tduration = (atol(s) * 60);\n\t\t\t\twhile (isdigit((unsigned char)*s))\n\t\t\t\t\ts++;\n\t\t\t\tif (*s == 'h' || *s == 'H')\n\t\t\t\t\tduration *= 60;\n\t\t\t\telse if (*s == 'd' || *s == 'D')\n\t\t\t\t\tduration *= 1440;\n\t\t\t\telse if (*s == 'w' || *s == 'W')\n\t\t\t\t\tduration *= 10080;\n\t\t\t\telse if (*s == '\\0')\n\t\t\t\t\t;\n\t\t\t\telse\n\t\t\t\t\tduration = 0;\n\n\t\t\t\tif (duration == 0)\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_badparams, _(\"Invalid duration given.\"));\n\t\t\t\t\tcommand_fail(si, fault_badparams, _(\"Syntax: AKICK <#channel> ADD <nick|hostmask> [!P|!T <minutes>] [reason]\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"AKICK ADD\");\n\t\t\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: AKICK <#channel> ADD <nick|hostmask> [!P|!T <minutes>] [reason]\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tduration = chansvs.akick_time;\n\t\t\tmowgli_strlcpy(reason, token, BUFSIZE);\n\t\t\ttreason = strtok(NULL, \"\");\n\n\t\t\tif (treason)\n\t\t\t{\n\t\t\t\tmowgli_strlcat(reason, \" \", BUFSIZE);\n\t\t\t\tmowgli_strlcat(reason, treason, BUFSIZE);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{ /* No reason and no duration */\n\t\tduration = chansvs.akick_time;\n\t\treason[0] = 0;\n\t}\n\n\tif ((chanacs_source_flags(mc, si) & (CA_FLAGS | CA_REMOVE)) != (CA_FLAGS | CA_REMOVE))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\treturn;\n\t}\n\n\tmt = myentity_find_ext(target);\n\tif (!mt)\n\t{\n\t\tuname = pretty_mask(target);\n\t\tif (uname == NULL)\n\t\t\tuname = target;\n\n\t\t/* we might be adding a hostmask */\n\t\tif (!validhostmask(uname))\n\t\t{\n\t\t\tcommand_fail(si, fault_badparams, _(\"\\2%s\\2 is neither a nickname nor a hostmask.\"), uname);\n\t\t\treturn;\n\t\t}\n\n\t\tuname = collapse(uname);\n\n\t\tca = chanacs_find_host_literal(mc, uname, 0);\n\t\tif (ca != NULL)\n\t\t{\n\t\t\tif (ca->level & CA_AKICK)\n\t\t\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is already on the AKICK list for \\2%s\\2\"), uname, mc->name);\n\t\t\telse\n\t\t\t\tcommand_fail(si, fault_alreadyexists, _(\"\\2%s\\2 already has flags \\2%s\\2 on \\2%s\\2\"), uname, bitmask_to_flags(ca->level), mc->name);\n\t\t\treturn;\n\t\t}\n\n\t\tca = chanacs_find_host(mc, uname, CA_AKICK);\n\t\tif (ca != NULL)\n\t\t{\n\t\t\tcommand_fail(si, fault_nochange, _(\"The more general mask \\2%s\\2 is already on the AKICK list for \\2%s\\2\"), ca->host, mc->name);\n\t\t\treturn;\n\t\t}\n\n\t\t/* new entry */\n\t\tca2 = chanacs_open(mc, NULL, uname, true, entity(si->smu));\n\t\tif (chanacs_is_table_full(ca2))\n\t\t{\n\t\t\tcommand_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);\n\t\t\tchanacs_close(ca2);\n\t\t\treturn;\n\t\t}\n\n\t\treq.ca = ca2;\n\t\treq.oldlevel = ca2->level;\n\n\t\tchanacs_modify_simple(ca2, CA_AKICK, 0);\n\n\t\treq.newlevel = ca2->level;\n\n\t\tif (reason[0])\n\t\t\tmetadata_add(ca2, \"reason\", reason);\n\n\t\tif (duration > 0)\n\t\t{\n\t\t\takick_timeout_t *timeout;\n\t\t\ttime_t expireson = ca2->tmodified+duration;\n\n\t\t\tsnprintf(expiry, sizeof expiry, \"%ld\", expireson);\n\t\t\tmetadata_add(ca2, \"expires\", expiry);\n\n\t\t\tverbose(mc, \"\\2%s\\2 added \\2%s\\2 to the AKICK list, expires in %s.\", get_source_name(si), uname,timediff(duration));\n\t\t\tlogcommand(si, CMDLOG_SET, \"AKICK:ADD: \\2%s\\2 on \\2%s\\2, expires in %s.\", uname, mc->name,timediff(duration));\n\t\t\tcommand_success_nodata(si, _(\"AKICK on \\2%s\\2 was successfully added for \\2%s\\2 and will expire in %s.\"), uname, mc->name,timediff(duration) );\n\n\t\t\ttimeout = akick_add_timeout(mc, NULL, uname, expireson);\n\n\t\t\tif (akickdel_next == 0 || akickdel_next > timeout->expiration)\n\t\t\t{\n\t\t\t\tif (akickdel_next != 0)\n\t\t\t\t\tmowgli_timer_destroy(base_eventloop, akick_timeout_check_timer);\n\n\t\t\t\takickdel_next = timeout->expiration;\n\t\t\t\takick_timeout_check_timer = mowgli_timer_add_once(base_eventloop, \"akick_timeout_check\", akick_timeout_check, NULL, akickdel_next - CURRTIME);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tverbose(mc, \"\\2%s\\2 added \\2%s\\2 to the AKICK list.\", get_source_name(si), uname);\n\t\t\tlogcommand(si, CMDLOG_SET, \"AKICK:ADD: \\2%s\\2 on \\2%s\\2\", uname, mc->name);\n\n\t\t\tcommand_success_nodata(si, _(\"AKICK on \\2%s\\2 was successfully added to the AKICK list for \\2%s\\2.\"), uname, mc->name);\n\t\t}\n\n\t\thook_call_channel_acl_change(&req);\n\t\tchanacs_close(ca2);\n\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tif ((ca = chanacs_find_literal(mc, mt, 0x0)))\n\t\t{\n\t\t\tif (ca->level & CA_AKICK)\n\t\t\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is already on the AKICK list for \\2%s\\2\"), mt->name, mc->name);\n\t\t\telse\n\t\t\t\tcommand_fail(si, fault_alreadyexists, _(\"\\2%s\\2 already has flags \\2%s\\2 on \\2%s\\2\"), mt->name, bitmask_to_flags(ca->level), mc->name);\n\t\t\treturn;\n\t\t}\n\n\t\t/* new entry */\n\t\tca2 = chanacs_open(mc, mt, NULL, true, entity(si->smu));\n\t\tif (chanacs_is_table_full(ca2))\n\t\t{\n\t\t\tcommand_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);\n\t\t\tchanacs_close(ca2);\n\t\t\treturn;\n\t\t}\n\n\t\treq.ca = ca2;\n\t\treq.oldlevel = ca2->level;\n\n\t\tchanacs_modify_simple(ca2, CA_AKICK, 0);\n\n\t\treq.newlevel = ca2->level;\n\n\t\tif (reason[0])\n\t\t\tmetadata_add(ca2, \"reason\", reason);\n\n\t\tif (duration > 0)\n\t\t{\n\t\t\takick_timeout_t *timeout;\n\t\t\ttime_t expireson = ca2->tmodified+duration;\n\n\t\t\tsnprintf(expiry, sizeof expiry, \"%ld\", expireson);\n\t\t\tmetadata_add(ca2, \"expires\", expiry);\n\n\t\t\tcommand_success_nodata(si, _(\"AKICK on \\2%s\\2 was successfully added for \\2%s\\2 and will expire in %s.\"), mt->name, mc->name, timediff(duration));\n\t\t\tverbose(mc, \"\\2%s\\2 added \\2%s\\2 to the AKICK list, expires in %s.\", get_source_name(si), mt->name, timediff(duration));\n\t\t\tlogcommand(si, CMDLOG_SET, \"AKICK:ADD: \\2%s\\2 on \\2%s\\2, expires in %s\", mt->name, mc->name, timediff(duration));\n\n\t\t\ttimeout = akick_add_timeout(mc, mt, mt->name, expireson);\n\n\t\t\tif (akickdel_next == 0 || akickdel_next > timeout->expiration)\n\t\t\t{\n\t\t\t\tif (akickdel_next != 0)\n\t\t\t\t\tmowgli_timer_destroy(base_eventloop, akick_timeout_check_timer);\n\n\t\t\t\takickdel_next = timeout->expiration;\n\t\t\t\takick_timeout_check_timer = mowgli_timer_add_once(base_eventloop, \"akick_timeout_check\", akick_timeout_check, NULL, akickdel_next - CURRTIME);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcommand_success_nodata(si, _(\"AKICK on \\2%s\\2 was successfully added to the AKICK list for \\2%s\\2.\"), mt->name, mc->name);\n\n\t\t\tverbose(mc, \"\\2%s\\2 added \\2%s\\2 to the AKICK list.\", get_source_name(si), mt->name);\n\t\t\tlogcommand(si, CMDLOG_SET, \"AKICK:ADD: \\2%s\\2 on \\2%s\\2\", mt->name, mc->name);\n\t\t}\n\n\t\thook_call_channel_acl_change(&req);\n\t\tchanacs_close(ca2);\n\t\treturn;\n\t}\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_cmd_akick(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_akick_add(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_akick_del(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_akick_list(sourceinfo_t *si, int parc, char *parv[]);",
      "time_t akickdel_next;",
      "mowgli_eventloop_timer_t *akick_timeout_check_timer = NULL;",
      "static akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca2"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_call_channel_acl_change",
          "args": [
            "&req"
          ],
          "line": 428
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_SET",
            "\"AKICK:ADD: \\2%s\\2 on \\2%s\\2\"",
            "mt->name",
            "mc->name"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "mc",
            "\"\\2%s\\2 added \\2%s\\2 to the AKICK list.\"",
            "get_source_name(si)",
            "mt->name"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_source_name",
          "args": [
            "si"
          ],
          "line": 424
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"AKICK on \\2%s\\2 was successfully added to the AKICK list for \\2%s\\2.\")",
            "mt->name",
            "mc->name"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"AKICK on \\2%s\\2 was successfully added to the AKICK list for \\2%s\\2.\""
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "akickdel_list_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/akick.c",
          "lines": "755-796",
          "snippet": "void akickdel_list_create(void *arg)\n{\n\tmychan_t *mc;\n\tmowgli_node_t *n, *tn;\n\tchanacs_t *ca;\n\tmetadata_t *md;\n\ttime_t expireson;\n\n\tmowgli_patricia_iteration_state_t state;\n\n\tMOWGLI_PATRICIA_FOREACH(mc, &state, mclist)\n\t{\n\t\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mc->chanacs.head)\n\t\t{\n\t\t\tca = (chanacs_t *)n->data;\n\n\t\t\tif (!(ca->level & CA_AKICK))\n\t\t\t\tcontinue;\n\n\t\t\tmd = metadata_find(ca, \"expires\");\n\n\t\t\tif (!md)\n\t\t\t\tcontinue;\n\n\t\t\texpireson = atol(md->value);\n\n\t\t\tif (CURRTIME > expireson)\n\t\t\t{\n\t\t\t\tchanacs_modify_simple(ca, 0, CA_AKICK);\n\t\t\t\tchanacs_close(ca);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* overcomplicate the logic here a tiny bit */\n\t\t\t\tif (ca->host == NULL && ca->entity != NULL)\n\t\t\t\t\takick_add_timeout(mc, ca->entity, entity(ca->entity)->name, expireson);\n\t\t\t\telse if (ca->host != NULL && ca->entity == NULL)\n\t\t\t\t\takick_add_timeout(mc, NULL, ca->host, expireson);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void akick_timeout_check(void *arg);",
            "static void akickdel_list_create(void *arg);",
            "static akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic void akick_timeout_check(void *arg);\nstatic void akickdel_list_create(void *arg);\nstatic akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson);\n\nvoid akickdel_list_create(void *arg)\n{\n\tmychan_t *mc;\n\tmowgli_node_t *n, *tn;\n\tchanacs_t *ca;\n\tmetadata_t *md;\n\ttime_t expireson;\n\n\tmowgli_patricia_iteration_state_t state;\n\n\tMOWGLI_PATRICIA_FOREACH(mc, &state, mclist)\n\t{\n\t\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mc->chanacs.head)\n\t\t{\n\t\t\tca = (chanacs_t *)n->data;\n\n\t\t\tif (!(ca->level & CA_AKICK))\n\t\t\t\tcontinue;\n\n\t\t\tmd = metadata_find(ca, \"expires\");\n\n\t\t\tif (!md)\n\t\t\t\tcontinue;\n\n\t\t\texpireson = atol(md->value);\n\n\t\t\tif (CURRTIME > expireson)\n\t\t\t{\n\t\t\t\tchanacs_modify_simple(ca, 0, CA_AKICK);\n\t\t\t\tchanacs_close(ca);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* overcomplicate the logic here a tiny bit */\n\t\t\t\tif (ca->host == NULL && ca->entity != NULL)\n\t\t\t\t\takick_add_timeout(mc, ca->entity, entity(ca->entity)->name, expireson);\n\t\t\t\telse if (ca->host != NULL && ca->entity == NULL)\n\t\t\t\t\takick_add_timeout(mc, NULL, ca->host, expireson);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "mowgli_timer_add_once",
          "args": [
            "base_eventloop",
            "\"akick_timeout_check\"",
            "akick_timeout_check",
            "NULL",
            "akickdel_next - CURRTIME"
          ],
          "line": 417
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_timer_destroy",
          "args": [
            "base_eventloop",
            "akick_timeout_check_timer"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "akick_add_timeout",
          "args": [
            "mc",
            "mt",
            "mt->name",
            "expireson"
          ],
          "line": 409
        },
        "resolved": true,
        "details": {
          "function_name": "akick_add_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/akick.c",
          "lines": "726-753",
          "snippet": "static akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson)\n{\n\tmowgli_node_t *n;\n\takick_timeout_t *timeout, *timeout2;\n\n\ttimeout = mowgli_heap_alloc(akick_timeout_heap);\n\n\ttimeout->entity = mt;\n\ttimeout->chan = mc;\n\ttimeout->expiration = expireson;\n\n\tmowgli_strlcpy(timeout->host, host, sizeof timeout->host);\n\n\tMOWGLI_ITER_FOREACH_PREV(n, akickdel_list.tail)\n\t{\n\t\ttimeout2 = n->data;\n\t\tif (timeout2->expiration <= timeout->expiration)\n\t\t\tbreak;\n\t}\n\tif (n == NULL)\n\t\tmowgli_node_add_head(timeout, &timeout->node, &akickdel_list);\n\telse if (n->next == NULL)\n\t\tmowgli_node_add(timeout, &timeout->node, &akickdel_list);\n\telse\n\t\tmowgli_node_add_before(timeout, &timeout->node, &akickdel_list, n->next);\n\n\treturn timeout;\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "mowgli_list_t akickdel_list;",
            "static akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson);",
            "mowgli_heap_t *akick_timeout_heap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nmowgli_list_t akickdel_list;\nstatic akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson);\nmowgli_heap_t *akick_timeout_heap;\n\nstatic akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson)\n{\n\tmowgli_node_t *n;\n\takick_timeout_t *timeout, *timeout2;\n\n\ttimeout = mowgli_heap_alloc(akick_timeout_heap);\n\n\ttimeout->entity = mt;\n\ttimeout->chan = mc;\n\ttimeout->expiration = expireson;\n\n\tmowgli_strlcpy(timeout->host, host, sizeof timeout->host);\n\n\tMOWGLI_ITER_FOREACH_PREV(n, akickdel_list.tail)\n\t{\n\t\ttimeout2 = n->data;\n\t\tif (timeout2->expiration <= timeout->expiration)\n\t\t\tbreak;\n\t}\n\tif (n == NULL)\n\t\tmowgli_node_add_head(timeout, &timeout->node, &akickdel_list);\n\telse if (n->next == NULL)\n\t\tmowgli_node_add(timeout, &timeout->node, &akickdel_list);\n\telse\n\t\tmowgli_node_add_before(timeout, &timeout->node, &akickdel_list, n->next);\n\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_SET",
            "\"AKICK:ADD: \\2%s\\2 on \\2%s\\2, expires in %s\"",
            "mt->name",
            "mc->name",
            "timediff(duration)"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timediff",
          "args": [
            "duration"
          ],
          "line": 407
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "mc",
            "\"\\2%s\\2 added \\2%s\\2 to the AKICK list, expires in %s.\"",
            "get_source_name(si)",
            "mt->name",
            "timediff(duration)"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timediff",
          "args": [
            "duration"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_source_name",
          "args": [
            "si"
          ],
          "line": 406
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"AKICK on \\2%s\\2 was successfully added for \\2%s\\2 and will expire in %s.\")",
            "mt->name",
            "mc->name",
            "timediff(duration)"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timediff",
          "args": [
            "duration"
          ],
          "line": 405
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_add",
          "args": [
            "ca2",
            "\"expires\"",
            "expiry"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "expiry",
            "sizeof expiry",
            "\"%ld\"",
            "expireson"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_add",
          "args": [
            "ca2",
            "\"reason\"",
            "reason"
          ],
          "line": 395
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_modify_simple",
          "args": [
            "ca2",
            "CA_AKICK",
            "0"
          ],
          "line": 390
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca2"
          ],
          "line": 383
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_toomany",
            "_(\"Channel %s access list is full.\")",
            "mc->name"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_is_table_full",
          "args": [
            "ca2"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_open",
          "args": [
            "mc",
            "mt",
            "NULL",
            "true",
            "entity(si->smu)"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entity",
          "args": [
            "si->smu"
          ],
          "line": 379
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_alreadyexists",
            "_(\"\\2%s\\2 already has flags \\2%s\\2 on \\2%s\\2\")",
            "mt->name",
            "bitmask_to_flags(ca->level)",
            "mc->name"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmask_to_flags",
          "args": [
            "ca->level"
          ],
          "line": 374
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nochange",
            "_(\"\\2%s\\2 is already on the AKICK list for \\2%s\\2\")",
            "mt->name",
            "mc->name"
          ],
          "line": 372
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_find_literal",
          "args": [
            "mc",
            "mt",
            "0x0"
          ],
          "line": 369
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca2"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_call_channel_acl_change",
          "args": [
            "&req"
          ],
          "line": 362
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"AKICK on \\2%s\\2 was successfully added to the AKICK list for \\2%s\\2.\")",
            "uname",
            "mc->name"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_SET",
            "\"AKICK:ADD: \\2%s\\2 on \\2%s\\2\"",
            "uname",
            "mc->name"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "mc",
            "\"\\2%s\\2 added \\2%s\\2 to the AKICK list.\"",
            "get_source_name(si)",
            "uname"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_source_name",
          "args": [
            "si"
          ],
          "line": 356
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_timer_add_once",
          "args": [
            "base_eventloop",
            "\"akick_timeout_check\"",
            "akick_timeout_check",
            "NULL",
            "akickdel_next - CURRTIME"
          ],
          "line": 351
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_timer_destroy",
          "args": [
            "base_eventloop",
            "akick_timeout_check_timer"
          ],
          "line": 348
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"AKICK on \\2%s\\2 was successfully added for \\2%s\\2 and will expire in %s.\")",
            "uname",
            "mc->name",
            "timediff(duration)"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timediff",
          "args": [
            "duration"
          ],
          "line": 341
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_SET",
            "\"AKICK:ADD: \\2%s\\2 on \\2%s\\2, expires in %s.\"",
            "uname",
            "mc->name",
            "timediff(duration)"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timediff",
          "args": [
            "duration"
          ],
          "line": 340
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "mc",
            "\"\\2%s\\2 added \\2%s\\2 to the AKICK list, expires in %s.\"",
            "get_source_name(si)",
            "uname",
            "timediff(duration)"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "timediff",
          "args": [
            "duration"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_source_name",
          "args": [
            "si"
          ],
          "line": 339
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_add",
          "args": [
            "ca2",
            "\"expires\"",
            "expiry"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "expiry",
            "sizeof expiry",
            "\"%ld\"",
            "expireson"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_add",
          "args": [
            "ca2",
            "\"reason\"",
            "reason"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_modify_simple",
          "args": [
            "ca2",
            "CA_AKICK",
            "0"
          ],
          "line": 324
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca2"
          ],
          "line": 317
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_toomany",
            "_(\"Channel %s access list is full.\")",
            "mc->name"
          ],
          "line": 316
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_is_table_full",
          "args": [
            "ca2"
          ],
          "line": 314
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_open",
          "args": [
            "mc",
            "NULL",
            "uname",
            "true",
            "entity(si->smu)"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entity",
          "args": [
            "si->smu"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nochange",
            "_(\"The more general mask \\2%s\\2 is already on the AKICK list for \\2%s\\2\")",
            "ca->host",
            "mc->name"
          ],
          "line": 308
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_find_host",
          "args": [
            "mc",
            "uname",
            "CA_AKICK"
          ],
          "line": 305
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_alreadyexists",
            "_(\"\\2%s\\2 already has flags \\2%s\\2 on \\2%s\\2\")",
            "uname",
            "bitmask_to_flags(ca->level)",
            "mc->name"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmask_to_flags",
          "args": [
            "ca->level"
          ],
          "line": 301
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nochange",
            "_(\"\\2%s\\2 is already on the AKICK list for \\2%s\\2\")",
            "uname",
            "mc->name"
          ],
          "line": 299
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_find_host_literal",
          "args": [
            "mc",
            "uname",
            "0"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "collapse",
          "args": [
            "uname"
          ],
          "line": 293
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_badparams",
            "_(\"\\2%s\\2 is neither a nickname nor a hostmask.\")",
            "uname"
          ],
          "line": 289
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validhostmask",
          "args": [
            "uname"
          ],
          "line": 287
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "pretty_mask",
          "args": [
            "target"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "myentity_find_ext",
          "args": [
            "target"
          ],
          "line": 279
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not authorized to perform this operation.\")"
          ],
          "line": 275
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_source_flags",
          "args": [
            "mc",
            "si"
          ],
          "line": 273
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcat",
          "args": [
            "reason",
            "treason",
            "BUFSIZE"
          ],
          "line": 263
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcat",
          "args": [
            "reason",
            "\" \"",
            "BUFSIZE"
          ],
          "line": 262
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\"\""
          ],
          "line": 258
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcpy",
          "args": [
            "reason",
            "token",
            "BUFSIZE"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "_(\"Syntax: AKICK <#channel> ADD <nick|hostmask> [!P|!T <minutes>] [reason]\")"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "STR_INSUFFICIENT_PARAMS",
            "\"AKICK ADD\""
          ],
          "line": 249
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_badparams",
            "_(\"Syntax: AKICK <#channel> ADD <nick|hostmask> [!P|!T <minutes>] [reason]\")"
          ],
          "line": 243
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_badparams",
            "_(\"Invalid duration given.\")"
          ],
          "line": 242
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "isdigit",
          "args": [
            "(unsigned char)*s"
          ],
          "line": 227
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "atol",
          "args": [
            "s"
          ],
          "line": 226
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcpy",
          "args": [
            "reason",
            "treason",
            "BUFSIZE"
          ],
          "line": 220
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\"\""
          ],
          "line": 217
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\" \""
          ],
          "line": 216
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "token",
            "\"!T\""
          ],
          "line": 214
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_strlcpy",
          "args": [
            "reason",
            "treason",
            "BUFSIZE"
          ],
          "line": 210
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "NULL",
            "\"\""
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "token",
            "\"!P\""
          ],
          "line": 204
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"\\2%s\\2 is closed.\")",
            "chan"
          ],
          "line": 197
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:close:closer\""
          ],
          "line": 195
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_target",
            "_(\"Channel \\2%s\\2 is not registered.\")",
            "chan"
          ],
          "line": 191
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_find",
          "args": [
            "chan"
          ],
          "line": 188
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "_(\"Syntax: AKICK <#channel> ADD <nickname|hostmask> [!P|!T <minutes>] [reason]\")"
          ],
          "line": 184
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "STR_INSUFFICIENT_PARAMS",
            "\"AKICK\""
          ],
          "line": 183
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strtok",
          "args": [
            "parv[2]",
            "\" \""
          ],
          "line": 179
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic void cs_cmd_akick(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_akick_add(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_akick_del(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_akick_list(sourceinfo_t *si, int parc, char *parv[]);\ntime_t akickdel_next;\nmowgli_eventloop_timer_t *akick_timeout_check_timer = NULL;\nstatic akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson);\n\nvoid cs_cmd_akick_add(sourceinfo_t *si, int parc, char *parv[])\n{\n\tmyentity_t *mt;\n\tmychan_t *mc;\n\thook_channel_acl_req_t req;\n\tchanacs_t *ca, *ca2;\n\tchar *chan = parv[0];\n\tlong duration;\n\tchar expiry[512];\n\tchar *s;\n\tchar *target;\n\tchar *uname;\n\tchar *token;\n\tchar *treason, reason[BUFSIZE];\n\n\ttarget = parv[1];\n\ttoken = strtok(parv[2], \" \");\n\n\tif (!target)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"AKICK\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: AKICK <#channel> ADD <nickname|hostmask> [!P|!T <minutes>] [reason]\"));\n\t\treturn;\n\t}\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\t/* A duration, reason or duration and reason. */\n\tif (token)\n\t{\n\t\tif (!strcasecmp(token, \"!P\")) /* A duration [permanent] */\n\t\t{\n\t\t\tduration = 0;\n\t\t\ttreason = strtok(NULL, \"\");\n\n\t\t\tif (treason)\n\t\t\t\tmowgli_strlcpy(reason, treason, BUFSIZE);\n\t\t\telse\n\t\t\t\treason[0] = 0;\n\t\t}\n\t\telse if (!strcasecmp(token, \"!T\")) /* A duration [temporary] */\n\t\t{\n\t\t\ts = strtok(NULL, \" \");\n\t\t\ttreason = strtok(NULL, \"\");\n\n\t\t\tif (treason)\n\t\t\t\tmowgli_strlcpy(reason, treason, BUFSIZE);\n\t\t\telse\n\t\t\t\treason[0] = 0;\n\n\t\t\tif (s)\n\t\t\t{\n\t\t\t\tduration = (atol(s) * 60);\n\t\t\t\twhile (isdigit((unsigned char)*s))\n\t\t\t\t\ts++;\n\t\t\t\tif (*s == 'h' || *s == 'H')\n\t\t\t\t\tduration *= 60;\n\t\t\t\telse if (*s == 'd' || *s == 'D')\n\t\t\t\t\tduration *= 1440;\n\t\t\t\telse if (*s == 'w' || *s == 'W')\n\t\t\t\t\tduration *= 10080;\n\t\t\t\telse if (*s == '\\0')\n\t\t\t\t\t;\n\t\t\t\telse\n\t\t\t\t\tduration = 0;\n\n\t\t\t\tif (duration == 0)\n\t\t\t\t{\n\t\t\t\t\tcommand_fail(si, fault_badparams, _(\"Invalid duration given.\"));\n\t\t\t\t\tcommand_fail(si, fault_badparams, _(\"Syntax: AKICK <#channel> ADD <nick|hostmask> [!P|!T <minutes>] [reason]\"));\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"AKICK ADD\");\n\t\t\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: AKICK <#channel> ADD <nick|hostmask> [!P|!T <minutes>] [reason]\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tduration = chansvs.akick_time;\n\t\t\tmowgli_strlcpy(reason, token, BUFSIZE);\n\t\t\ttreason = strtok(NULL, \"\");\n\n\t\t\tif (treason)\n\t\t\t{\n\t\t\t\tmowgli_strlcat(reason, \" \", BUFSIZE);\n\t\t\t\tmowgli_strlcat(reason, treason, BUFSIZE);\n\t\t\t}\n\t\t}\n\t}\n\telse\n\t{ /* No reason and no duration */\n\t\tduration = chansvs.akick_time;\n\t\treason[0] = 0;\n\t}\n\n\tif ((chanacs_source_flags(mc, si) & (CA_FLAGS | CA_REMOVE)) != (CA_FLAGS | CA_REMOVE))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\treturn;\n\t}\n\n\tmt = myentity_find_ext(target);\n\tif (!mt)\n\t{\n\t\tuname = pretty_mask(target);\n\t\tif (uname == NULL)\n\t\t\tuname = target;\n\n\t\t/* we might be adding a hostmask */\n\t\tif (!validhostmask(uname))\n\t\t{\n\t\t\tcommand_fail(si, fault_badparams, _(\"\\2%s\\2 is neither a nickname nor a hostmask.\"), uname);\n\t\t\treturn;\n\t\t}\n\n\t\tuname = collapse(uname);\n\n\t\tca = chanacs_find_host_literal(mc, uname, 0);\n\t\tif (ca != NULL)\n\t\t{\n\t\t\tif (ca->level & CA_AKICK)\n\t\t\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is already on the AKICK list for \\2%s\\2\"), uname, mc->name);\n\t\t\telse\n\t\t\t\tcommand_fail(si, fault_alreadyexists, _(\"\\2%s\\2 already has flags \\2%s\\2 on \\2%s\\2\"), uname, bitmask_to_flags(ca->level), mc->name);\n\t\t\treturn;\n\t\t}\n\n\t\tca = chanacs_find_host(mc, uname, CA_AKICK);\n\t\tif (ca != NULL)\n\t\t{\n\t\t\tcommand_fail(si, fault_nochange, _(\"The more general mask \\2%s\\2 is already on the AKICK list for \\2%s\\2\"), ca->host, mc->name);\n\t\t\treturn;\n\t\t}\n\n\t\t/* new entry */\n\t\tca2 = chanacs_open(mc, NULL, uname, true, entity(si->smu));\n\t\tif (chanacs_is_table_full(ca2))\n\t\t{\n\t\t\tcommand_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);\n\t\t\tchanacs_close(ca2);\n\t\t\treturn;\n\t\t}\n\n\t\treq.ca = ca2;\n\t\treq.oldlevel = ca2->level;\n\n\t\tchanacs_modify_simple(ca2, CA_AKICK, 0);\n\n\t\treq.newlevel = ca2->level;\n\n\t\tif (reason[0])\n\t\t\tmetadata_add(ca2, \"reason\", reason);\n\n\t\tif (duration > 0)\n\t\t{\n\t\t\takick_timeout_t *timeout;\n\t\t\ttime_t expireson = ca2->tmodified+duration;\n\n\t\t\tsnprintf(expiry, sizeof expiry, \"%ld\", expireson);\n\t\t\tmetadata_add(ca2, \"expires\", expiry);\n\n\t\t\tverbose(mc, \"\\2%s\\2 added \\2%s\\2 to the AKICK list, expires in %s.\", get_source_name(si), uname,timediff(duration));\n\t\t\tlogcommand(si, CMDLOG_SET, \"AKICK:ADD: \\2%s\\2 on \\2%s\\2, expires in %s.\", uname, mc->name,timediff(duration));\n\t\t\tcommand_success_nodata(si, _(\"AKICK on \\2%s\\2 was successfully added for \\2%s\\2 and will expire in %s.\"), uname, mc->name,timediff(duration) );\n\n\t\t\ttimeout = akick_add_timeout(mc, NULL, uname, expireson);\n\n\t\t\tif (akickdel_next == 0 || akickdel_next > timeout->expiration)\n\t\t\t{\n\t\t\t\tif (akickdel_next != 0)\n\t\t\t\t\tmowgli_timer_destroy(base_eventloop, akick_timeout_check_timer);\n\n\t\t\t\takickdel_next = timeout->expiration;\n\t\t\t\takick_timeout_check_timer = mowgli_timer_add_once(base_eventloop, \"akick_timeout_check\", akick_timeout_check, NULL, akickdel_next - CURRTIME);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tverbose(mc, \"\\2%s\\2 added \\2%s\\2 to the AKICK list.\", get_source_name(si), uname);\n\t\t\tlogcommand(si, CMDLOG_SET, \"AKICK:ADD: \\2%s\\2 on \\2%s\\2\", uname, mc->name);\n\n\t\t\tcommand_success_nodata(si, _(\"AKICK on \\2%s\\2 was successfully added to the AKICK list for \\2%s\\2.\"), uname, mc->name);\n\t\t}\n\n\t\thook_call_channel_acl_change(&req);\n\t\tchanacs_close(ca2);\n\n\t\treturn;\n\t}\n\telse\n\t{\n\t\tif ((ca = chanacs_find_literal(mc, mt, 0x0)))\n\t\t{\n\t\t\tif (ca->level & CA_AKICK)\n\t\t\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is already on the AKICK list for \\2%s\\2\"), mt->name, mc->name);\n\t\t\telse\n\t\t\t\tcommand_fail(si, fault_alreadyexists, _(\"\\2%s\\2 already has flags \\2%s\\2 on \\2%s\\2\"), mt->name, bitmask_to_flags(ca->level), mc->name);\n\t\t\treturn;\n\t\t}\n\n\t\t/* new entry */\n\t\tca2 = chanacs_open(mc, mt, NULL, true, entity(si->smu));\n\t\tif (chanacs_is_table_full(ca2))\n\t\t{\n\t\t\tcommand_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);\n\t\t\tchanacs_close(ca2);\n\t\t\treturn;\n\t\t}\n\n\t\treq.ca = ca2;\n\t\treq.oldlevel = ca2->level;\n\n\t\tchanacs_modify_simple(ca2, CA_AKICK, 0);\n\n\t\treq.newlevel = ca2->level;\n\n\t\tif (reason[0])\n\t\t\tmetadata_add(ca2, \"reason\", reason);\n\n\t\tif (duration > 0)\n\t\t{\n\t\t\takick_timeout_t *timeout;\n\t\t\ttime_t expireson = ca2->tmodified+duration;\n\n\t\t\tsnprintf(expiry, sizeof expiry, \"%ld\", expireson);\n\t\t\tmetadata_add(ca2, \"expires\", expiry);\n\n\t\t\tcommand_success_nodata(si, _(\"AKICK on \\2%s\\2 was successfully added for \\2%s\\2 and will expire in %s.\"), mt->name, mc->name, timediff(duration));\n\t\t\tverbose(mc, \"\\2%s\\2 added \\2%s\\2 to the AKICK list, expires in %s.\", get_source_name(si), mt->name, timediff(duration));\n\t\t\tlogcommand(si, CMDLOG_SET, \"AKICK:ADD: \\2%s\\2 on \\2%s\\2, expires in %s\", mt->name, mc->name, timediff(duration));\n\n\t\t\ttimeout = akick_add_timeout(mc, mt, mt->name, expireson);\n\n\t\t\tif (akickdel_next == 0 || akickdel_next > timeout->expiration)\n\t\t\t{\n\t\t\t\tif (akickdel_next != 0)\n\t\t\t\t\tmowgli_timer_destroy(base_eventloop, akick_timeout_check_timer);\n\n\t\t\t\takickdel_next = timeout->expiration;\n\t\t\t\takick_timeout_check_timer = mowgli_timer_add_once(base_eventloop, \"akick_timeout_check\", akick_timeout_check, NULL, akickdel_next - CURRTIME);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcommand_success_nodata(si, _(\"AKICK on \\2%s\\2 was successfully added to the AKICK list for \\2%s\\2.\"), mt->name, mc->name);\n\n\t\t\tverbose(mc, \"\\2%s\\2 added \\2%s\\2 to the AKICK list.\", get_source_name(si), mt->name);\n\t\t\tlogcommand(si, CMDLOG_SET, \"AKICK:ADD: \\2%s\\2 on \\2%s\\2\", mt->name, mc->name);\n\t\t}\n\n\t\thook_call_channel_acl_change(&req);\n\t\tchanacs_close(ca2);\n\t\treturn;\n\t}\n}"
  },
  {
    "function_name": "cs_cmd_akick",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/akick.c",
    "lines": "128-161",
    "snippet": "static void cs_cmd_akick(sourceinfo_t *si, int parc, char *parv[])\n{\n\tchar *chan;\n\tchar *cmd;\n\tcommand_t *c;\n\n\tif (parc < 2)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"AKICK\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: AKICK <#channel> <ADD|DEL|LIST> [parameters]\"));\n\t\treturn;\n\t}\n\n\tif (parv[0][0] == '#')\n\t\tchan = parv[0], cmd = parv[1];\n\telse if (parv[1][0] == '#')\n\t\tcmd = parv[0], chan = parv[1];\n\telse\n\t{\n\t\tcommand_fail(si, fault_badparams, STR_INVALID_PARAMS, \"AKICK\");\n\t\tcommand_fail(si, fault_badparams, _(\"Syntax: AKICK <#channel> <ADD|DEL|LIST> [parameters]\"));\n\t\treturn;\n\t}\n\n\tc = command_find(cs_akick_cmds, cmd);\n\tif (c == NULL)\n\t{\n\t\tcommand_fail(si, fault_badparams, _(\"Invalid command. Use \\2/%s%s help\\2 for a command listing.\"), (ircd->uses_rcommand == false) ? \"msg \" : \"\", chansvs.me->disp);\n\t\treturn;\n\t}\n\n\tparv[1] = chan;\n\tcommand_exec(si->service, si, c, parc - 1, parv + 1);\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_cmd_akick(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_akick_add(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_akick_del(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_akick_list(sourceinfo_t *si, int parc, char *parv[]);",
      "mowgli_patricia_t *cs_akick_cmds;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "command_exec",
          "args": [
            "si->service",
            "si",
            "c",
            "parc - 1",
            "parv + 1"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_badparams",
            "_(\"Invalid command. Use \\2/%s%s help\\2 for a command listing.\")",
            "(ircd->uses_rcommand == false) ? \"msg \" : \"\"",
            "chansvs.me->disp"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Invalid command. Use \\2/%s%s help\\2 for a command listing.\""
          ],
          "line": 155
        },
        "resolved": true,
        "details": {
          "function_name": "akickdel_list_create",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/akick.c",
          "lines": "755-796",
          "snippet": "void akickdel_list_create(void *arg)\n{\n\tmychan_t *mc;\n\tmowgli_node_t *n, *tn;\n\tchanacs_t *ca;\n\tmetadata_t *md;\n\ttime_t expireson;\n\n\tmowgli_patricia_iteration_state_t state;\n\n\tMOWGLI_PATRICIA_FOREACH(mc, &state, mclist)\n\t{\n\t\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mc->chanacs.head)\n\t\t{\n\t\t\tca = (chanacs_t *)n->data;\n\n\t\t\tif (!(ca->level & CA_AKICK))\n\t\t\t\tcontinue;\n\n\t\t\tmd = metadata_find(ca, \"expires\");\n\n\t\t\tif (!md)\n\t\t\t\tcontinue;\n\n\t\t\texpireson = atol(md->value);\n\n\t\t\tif (CURRTIME > expireson)\n\t\t\t{\n\t\t\t\tchanacs_modify_simple(ca, 0, CA_AKICK);\n\t\t\t\tchanacs_close(ca);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* overcomplicate the logic here a tiny bit */\n\t\t\t\tif (ca->host == NULL && ca->entity != NULL)\n\t\t\t\t\takick_add_timeout(mc, ca->entity, entity(ca->entity)->name, expireson);\n\t\t\t\telse if (ca->host != NULL && ca->entity == NULL)\n\t\t\t\t\takick_add_timeout(mc, NULL, ca->host, expireson);\n\t\t\t}\n\t\t}\n\t}\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void akick_timeout_check(void *arg);",
            "static void akickdel_list_create(void *arg);",
            "static akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic void akick_timeout_check(void *arg);\nstatic void akickdel_list_create(void *arg);\nstatic akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson);\n\nvoid akickdel_list_create(void *arg)\n{\n\tmychan_t *mc;\n\tmowgli_node_t *n, *tn;\n\tchanacs_t *ca;\n\tmetadata_t *md;\n\ttime_t expireson;\n\n\tmowgli_patricia_iteration_state_t state;\n\n\tMOWGLI_PATRICIA_FOREACH(mc, &state, mclist)\n\t{\n\t\tMOWGLI_ITER_FOREACH_SAFE(n, tn, mc->chanacs.head)\n\t\t{\n\t\t\tca = (chanacs_t *)n->data;\n\n\t\t\tif (!(ca->level & CA_AKICK))\n\t\t\t\tcontinue;\n\n\t\t\tmd = metadata_find(ca, \"expires\");\n\n\t\t\tif (!md)\n\t\t\t\tcontinue;\n\n\t\t\texpireson = atol(md->value);\n\n\t\t\tif (CURRTIME > expireson)\n\t\t\t{\n\t\t\t\tchanacs_modify_simple(ca, 0, CA_AKICK);\n\t\t\t\tchanacs_close(ca);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t/* overcomplicate the logic here a tiny bit */\n\t\t\t\tif (ca->host == NULL && ca->entity != NULL)\n\t\t\t\t\takick_add_timeout(mc, ca->entity, entity(ca->entity)->name, expireson);\n\t\t\t\telse if (ca->host != NULL && ca->entity == NULL)\n\t\t\t\t\takick_add_timeout(mc, NULL, ca->host, expireson);\n\t\t\t}\n\t\t}\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_find",
          "args": [
            "cs_akick_cmds",
            "cmd"
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_badparams",
            "_(\"Syntax: AKICK <#channel> <ADD|DEL|LIST> [parameters]\")"
          ],
          "line": 148
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_badparams",
            "STR_INVALID_PARAMS",
            "\"AKICK\""
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "_(\"Syntax: AKICK <#channel> <ADD|DEL|LIST> [parameters]\")"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "STR_INSUFFICIENT_PARAMS",
            "\"AKICK\""
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic void cs_cmd_akick(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_akick_add(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_akick_del(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_akick_list(sourceinfo_t *si, int parc, char *parv[]);\nmowgli_patricia_t *cs_akick_cmds;\n\nstatic void cs_cmd_akick(sourceinfo_t *si, int parc, char *parv[])\n{\n\tchar *chan;\n\tchar *cmd;\n\tcommand_t *c;\n\n\tif (parc < 2)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"AKICK\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: AKICK <#channel> <ADD|DEL|LIST> [parameters]\"));\n\t\treturn;\n\t}\n\n\tif (parv[0][0] == '#')\n\t\tchan = parv[0], cmd = parv[1];\n\telse if (parv[1][0] == '#')\n\t\tcmd = parv[0], chan = parv[1];\n\telse\n\t{\n\t\tcommand_fail(si, fault_badparams, STR_INVALID_PARAMS, \"AKICK\");\n\t\tcommand_fail(si, fault_badparams, _(\"Syntax: AKICK <#channel> <ADD|DEL|LIST> [parameters]\"));\n\t\treturn;\n\t}\n\n\tc = command_find(cs_akick_cmds, cmd);\n\tif (c == NULL)\n\t{\n\t\tcommand_fail(si, fault_badparams, _(\"Invalid command. Use \\2/%s%s help\\2 for a command listing.\"), (ircd->uses_rcommand == false) ? \"msg \" : \"\", chansvs.me->disp);\n\t\treturn;\n\t}\n\n\tparv[1] = chan;\n\tcommand_exec(si->service, si, c, parc - 1, parv + 1);\n}"
  },
  {
    "function_name": "clear_bans_matching_entity",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/akick.c",
    "lines": "90-126",
    "snippet": "static void clear_bans_matching_entity(mychan_t *mc, myentity_t *mt)\n{\n\tmowgli_node_t *n;\n\tmyuser_t *tmu;\n\n\tif (mc->chan == NULL)\n\t\treturn;\n\n\tif (!isuser(mt))\n\t\treturn;\n\n\ttmu = user(mt);\n\n\tMOWGLI_ITER_FOREACH(n, tmu->logins.head)\n\t{\n\t\tuser_t *tu;\n\t\tmowgli_node_t *it, *itn;\n\n\t\tchar hostbuf2[BUFSIZE];\n\n\t\ttu = n->data;\n\n\t\tsnprintf(hostbuf2, BUFSIZE, \"%s!%s@%s\", tu->nick, tu->user, tu->vhost);\n\t\tfor (it = next_matching_ban(mc->chan, tu, 'b', mc->chan->bans.head); it != NULL; it = next_matching_ban(mc->chan, tu, 'b', itn))\n\t\t{\n\t\t\tchanban_t *cb;\n\n\t\t\titn = it->next;\n\t\t\tcb = it->data;\n\n\t\t\tmodestack_mode_param(chansvs.nick, mc->chan, MTYPE_DEL, cb->type, cb->mask);\n\t\t\tchanban_delete(cb);\n\t\t}\n\t}\n\n\tmodestack_flush_channel(mc->chan);\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [],
    "called_functions": [
      {
        "call_info": {
          "callee": "modestack_flush_channel",
          "args": [
            "mc->chan"
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanban_delete",
          "args": [
            "cb"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modestack_mode_param",
          "args": [
            "chansvs.nick",
            "mc->chan",
            "MTYPE_DEL",
            "cb->type",
            "cb->mask"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_matching_ban",
          "args": [
            "mc->chan",
            "tu",
            "'b'",
            "itn"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "next_matching_ban",
          "args": [
            "mc->chan",
            "tu",
            "'b'",
            "mc->chan->bans.head"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "snprintf",
          "args": [
            "hostbuf2",
            "BUFSIZE",
            "\"%s!%s@%s\"",
            "tu->nick",
            "tu->user",
            "tu->vhost"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_ITER_FOREACH",
          "args": [
            "n",
            "tmu->logins.head"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user",
          "args": [
            "mt"
          ],
          "line": 101
        },
        "resolved": true,
        "details": {
          "function_name": "sync_myuser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/sync.c",
          "lines": "266-276",
          "snippet": "static void sync_myuser(myuser_t *mu)\n{\n\tmowgli_node_t *iter;\n\n\treturn_if_fail(mu != NULL);\n\n\tMOWGLI_ITER_FOREACH(iter, mu->logins.head)\n\t{\n\t\tsync_user(iter->data);\n\t}\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic void sync_myuser(myuser_t *mu)\n{\n\tmowgli_node_t *iter;\n\n\treturn_if_fail(mu != NULL);\n\n\tMOWGLI_ITER_FOREACH(iter, mu->logins.head)\n\t{\n\t\tsync_user(iter->data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isuser",
          "args": [
            "mt"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic void clear_bans_matching_entity(mychan_t *mc, myentity_t *mt)\n{\n\tmowgli_node_t *n;\n\tmyuser_t *tmu;\n\n\tif (mc->chan == NULL)\n\t\treturn;\n\n\tif (!isuser(mt))\n\t\treturn;\n\n\ttmu = user(mt);\n\n\tMOWGLI_ITER_FOREACH(n, tmu->logins.head)\n\t{\n\t\tuser_t *tu;\n\t\tmowgli_node_t *it, *itn;\n\n\t\tchar hostbuf2[BUFSIZE];\n\n\t\ttu = n->data;\n\n\t\tsnprintf(hostbuf2, BUFSIZE, \"%s!%s@%s\", tu->nick, tu->user, tu->vhost);\n\t\tfor (it = next_matching_ban(mc->chan, tu, 'b', mc->chan->bans.head); it != NULL; it = next_matching_ban(mc->chan, tu, 'b', itn))\n\t\t{\n\t\t\tchanban_t *cb;\n\n\t\t\titn = it->next;\n\t\t\tcb = it->data;\n\n\t\t\tmodestack_mode_param(chansvs.nick, mc->chan, MTYPE_DEL, cb->type, cb->mask);\n\t\t\tchanban_delete(cb);\n\t\t}\n\t}\n\n\tmodestack_flush_channel(mc->chan);\n}"
  },
  {
    "function_name": "_moddeinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/akick.c",
    "lines": "77-88",
    "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_akick);\n\n\t/* Delete sub-commands */\n\tcommand_delete(&cs_akick_add, cs_akick_cmds);\n\tcommand_delete(&cs_akick_del, cs_akick_cmds);\n\tcommand_delete(&cs_akick_list, cs_akick_cmds);\n\n\tmowgli_heap_destroy(akick_timeout_heap);\n\tmowgli_patricia_destroy(cs_akick_cmds, NULL, NULL);\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "command_t cs_akick = { \"AKICK\", N_(\"Manipulates a channel's AKICK list.\"),\n                        AC_NONE, 4, cs_cmd_akick, { .path = \"cservice/akick\" } };",
      "command_t cs_akick_add = { \"ADD\", N_(\"Adds a channel AKICK.\"),\n                        AC_NONE, 4, cs_cmd_akick_add, { .path = \"\" } };",
      "command_t cs_akick_del = { \"DEL\", N_(\"Deletes a channel AKICK.\"),\n                        AC_NONE, 3, cs_cmd_akick_del, { .path = \"\" } };",
      "command_t cs_akick_list = { \"LIST\", N_(\"Displays a channel's AKICK list.\"),\n                        AC_NONE, 2, cs_cmd_akick_list, { .path = \"\" } };",
      "mowgli_patricia_t *cs_akick_cmds;",
      "mowgli_heap_t *akick_timeout_heap;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mowgli_patricia_destroy",
          "args": [
            "cs_akick_cmds",
            "NULL",
            "NULL"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_heap_destroy",
          "args": [
            "akick_timeout_heap"
          ],
          "line": 86
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_delete",
          "args": [
            "&cs_akick_list",
            "cs_akick_cmds"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_delete",
          "args": [
            "&cs_akick_del",
            "cs_akick_cmds"
          ],
          "line": 83
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_delete",
          "args": [
            "&cs_akick_add",
            "cs_akick_cmds"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_named_unbind_command",
          "args": [
            "\"chanserv\"",
            "&cs_akick"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\ncommand_t cs_akick = { \"AKICK\", N_(\"Manipulates a channel's AKICK list.\"),\n                        AC_NONE, 4, cs_cmd_akick, { .path = \"cservice/akick\" } };\ncommand_t cs_akick_add = { \"ADD\", N_(\"Adds a channel AKICK.\"),\n                        AC_NONE, 4, cs_cmd_akick_add, { .path = \"\" } };\ncommand_t cs_akick_del = { \"DEL\", N_(\"Deletes a channel AKICK.\"),\n                        AC_NONE, 3, cs_cmd_akick_del, { .path = \"\" } };\ncommand_t cs_akick_list = { \"LIST\", N_(\"Displays a channel's AKICK list.\"),\n                        AC_NONE, 2, cs_cmd_akick_list, { .path = \"\" } };\nmowgli_patricia_t *cs_akick_cmds;\nmowgli_heap_t *akick_timeout_heap;\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_akick);\n\n\t/* Delete sub-commands */\n\tcommand_delete(&cs_akick_add, cs_akick_cmds);\n\tcommand_delete(&cs_akick_del, cs_akick_cmds);\n\tcommand_delete(&cs_akick_list, cs_akick_cmds);\n\n\tmowgli_heap_destroy(akick_timeout_heap);\n\tmowgli_patricia_destroy(cs_akick_cmds, NULL, NULL);\n}"
  },
  {
    "function_name": "_modinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/akick.c",
    "lines": "55-75",
    "snippet": "void _modinit(module_t *m)\n{\n        service_named_bind_command(\"chanserv\", &cs_akick);\n\n\tcs_akick_cmds = mowgli_patricia_create(strcasecanon);\n\n\t/* Add sub-commands */\n\tcommand_add(&cs_akick_add, cs_akick_cmds);\n\tcommand_add(&cs_akick_del, cs_akick_cmds);\n\tcommand_add(&cs_akick_list, cs_akick_cmds);\n\n        akick_timeout_heap = mowgli_heap_create(sizeof(akick_timeout_t), 512, BH_NOW);\n\n    \tif (akick_timeout_heap == NULL)\n    \t{\n    \t\tm->mflags = MODTYPE_FAIL;\n    \t\treturn;\n    \t}\n\n\tmowgli_timer_add_once(base_eventloop, \"akickdel_list_create\", akickdel_list_create, NULL, 0);\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "command_t cs_akick = { \"AKICK\", N_(\"Manipulates a channel's AKICK list.\"),\n                        AC_NONE, 4, cs_cmd_akick, { .path = \"cservice/akick\" } };",
      "command_t cs_akick_add = { \"ADD\", N_(\"Adds a channel AKICK.\"),\n                        AC_NONE, 4, cs_cmd_akick_add, { .path = \"\" } };",
      "command_t cs_akick_del = { \"DEL\", N_(\"Deletes a channel AKICK.\"),\n                        AC_NONE, 3, cs_cmd_akick_del, { .path = \"\" } };",
      "command_t cs_akick_list = { \"LIST\", N_(\"Displays a channel's AKICK list.\"),\n                        AC_NONE, 2, cs_cmd_akick_list, { .path = \"\" } };",
      "mowgli_patricia_t *cs_akick_cmds;",
      "mowgli_heap_t *akick_timeout_heap;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "mowgli_timer_add_once",
          "args": [
            "base_eventloop",
            "\"akickdel_list_create\"",
            "akickdel_list_create",
            "NULL",
            "0"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_heap_create",
          "args": [
            "sizeof(akick_timeout_t)",
            "512",
            "BH_NOW"
          ],
          "line": 66
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_add",
          "args": [
            "&cs_akick_list",
            "cs_akick_cmds"
          ],
          "line": 64
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_add",
          "args": [
            "&cs_akick_del",
            "cs_akick_cmds"
          ],
          "line": 63
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_add",
          "args": [
            "&cs_akick_add",
            "cs_akick_cmds"
          ],
          "line": 62
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mowgli_patricia_create",
          "args": [
            "strcasecanon"
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_named_bind_command",
          "args": [
            "\"chanserv\"",
            "&cs_akick"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\ncommand_t cs_akick = { \"AKICK\", N_(\"Manipulates a channel's AKICK list.\"),\n                        AC_NONE, 4, cs_cmd_akick, { .path = \"cservice/akick\" } };\ncommand_t cs_akick_add = { \"ADD\", N_(\"Adds a channel AKICK.\"),\n                        AC_NONE, 4, cs_cmd_akick_add, { .path = \"\" } };\ncommand_t cs_akick_del = { \"DEL\", N_(\"Deletes a channel AKICK.\"),\n                        AC_NONE, 3, cs_cmd_akick_del, { .path = \"\" } };\ncommand_t cs_akick_list = { \"LIST\", N_(\"Displays a channel's AKICK list.\"),\n                        AC_NONE, 2, cs_cmd_akick_list, { .path = \"\" } };\nmowgli_patricia_t *cs_akick_cmds;\nmowgli_heap_t *akick_timeout_heap;\n\nvoid _modinit(module_t *m)\n{\n        service_named_bind_command(\"chanserv\", &cs_akick);\n\n\tcs_akick_cmds = mowgli_patricia_create(strcasecanon);\n\n\t/* Add sub-commands */\n\tcommand_add(&cs_akick_add, cs_akick_cmds);\n\tcommand_add(&cs_akick_del, cs_akick_cmds);\n\tcommand_add(&cs_akick_list, cs_akick_cmds);\n\n        akick_timeout_heap = mowgli_heap_create(sizeof(akick_timeout_t), 512, BH_NOW);\n\n    \tif (akick_timeout_heap == NULL)\n    \t{\n    \t\tm->mflags = MODTYPE_FAIL;\n    \t\treturn;\n    \t}\n\n\tmowgli_timer_add_once(base_eventloop, \"akickdel_list_create\", akickdel_list_create, NULL, 0);\n}"
  }
]