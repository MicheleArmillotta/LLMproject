[
  {
    "function_name": "cs_cmd_deop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/op.c",
    "lines": "138-148",
    "snippet": "static void cs_cmd_deop(sourceinfo_t *si, int parc, char *parv[])\n{\n\tif (!parv[0])\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"DEOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: DEOP <#channel> [nickname] [...]\"));\n\t\treturn;\n\t}\n\n\tcmd_op(si, false, parc, parv);\n}",
    "includes": [
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_cmd_op(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_deop(sourceinfo_t *si, int parc, char *parv[]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmd_op",
          "args": [
            "si",
            "false",
            "parc",
            "parv"
          ],
          "line": 147
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/op.c",
          "lines": "41-124",
          "snippet": "static void cmd_op(sourceinfo_t *si, bool opping, int parc, char *parv[])\n{\n\tchar *chan = parv[0];\n\tchar *nick = parv[1];\n\tmychan_t *mc;\n\tuser_t *tu;\n\tchanuser_t *cu;\n\tchar *nicks;\n\tbool op;\n\tmowgli_node_t *n;\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tnicks = (!nick ? strdup(si->su->nick) : strdup(nick));\n\tprefix_action_set_all(&op_actions, opping, nicks);\n\tfree(nicks);\n\n\tMOWGLI_LIST_FOREACH(n, op_actions.head)\n\t{\n\t\tstruct prefix_action *act = n->data;\n\t\tnick = act->nick;\n\t\top = act->en;\n\n\t\t/* figure out who we're going to op */\n\t\tif (!(tu = user_find_named(nick)))\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not online.\"), nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!chanacs_source_has_flag(mc, si, CA_OP) && (tu != si->su || !chanacs_source_has_flag(mc, si, CA_AUTOOP)))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to (de)op \\2%s\\2 on \\2%s\\2.\"), nick, mc->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!op && is_service(tu))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is a network service; you cannot kick or deop them.\"), tu->nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* SECURE check; we can skip this if deopping or sender == target, because we already verified */\n\t\tif (op && (si->su != tu) && (mc->flags & MC_SECURE) && !chanacs_user_has_flag(mc, tu, CA_OP) && !chanacs_user_has_flag(mc, tu, CA_AUTOOP))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 has the SECURE option enabled, and \\2%s\\2 does not have appropriate access.\"), mc->name, tu->nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcu = chanuser_find(mc->chan, tu);\n\t\tif (!cu)\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not on \\2%s\\2.\"), tu->nick, mc->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmodestack_mode_param(chansvs.nick, mc->chan, op ? MTYPE_ADD : MTYPE_DEL, 'o', CLIENT_NAME(tu));\n\t\tif (op)\n\t\t\tcu->modes |= CSTATUS_OP;\n\t\telse\n\t\t\tcu->modes &= ~CSTATUS_OP;\n\n\t\tif (si->c == NULL && tu != si->su)\n\t\t\tchange_notify(chansvs.nick, tu, \"You have been %sopped on %s by %s\", op ? \"\" : \"de\", mc->name, get_source_name(si));\n\n\t\tlogcommand(si, CMDLOG_DO, \"%sOP: \\2%s!%s@%s\\2 on \\2%s\\2\", op ? \"\" : \"DE\", tu->nick, tu->user, tu->vhost, mc->name);\n\t\tif (si->su == NULL || !chanuser_find(mc->chan, si->su))\n\t\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been %sopped on \\2%s\\2.\"), tu->nick, op ? \"\" : \"de\", mc->name);\n\t}\n\n\tprefix_action_clear(&op_actions);\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cs_cmd_op(sourceinfo_t *si, int parc, char *parv[]);",
            "static void cs_cmd_deop(sourceinfo_t *si, int parc, char *parv[]);",
            "static mowgli_list_t op_actions;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_cmd_op(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_deop(sourceinfo_t *si, int parc, char *parv[]);\nstatic mowgli_list_t op_actions;\n\nstatic void cmd_op(sourceinfo_t *si, bool opping, int parc, char *parv[])\n{\n\tchar *chan = parv[0];\n\tchar *nick = parv[1];\n\tmychan_t *mc;\n\tuser_t *tu;\n\tchanuser_t *cu;\n\tchar *nicks;\n\tbool op;\n\tmowgli_node_t *n;\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tnicks = (!nick ? strdup(si->su->nick) : strdup(nick));\n\tprefix_action_set_all(&op_actions, opping, nicks);\n\tfree(nicks);\n\n\tMOWGLI_LIST_FOREACH(n, op_actions.head)\n\t{\n\t\tstruct prefix_action *act = n->data;\n\t\tnick = act->nick;\n\t\top = act->en;\n\n\t\t/* figure out who we're going to op */\n\t\tif (!(tu = user_find_named(nick)))\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not online.\"), nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!chanacs_source_has_flag(mc, si, CA_OP) && (tu != si->su || !chanacs_source_has_flag(mc, si, CA_AUTOOP)))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to (de)op \\2%s\\2 on \\2%s\\2.\"), nick, mc->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!op && is_service(tu))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is a network service; you cannot kick or deop them.\"), tu->nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* SECURE check; we can skip this if deopping or sender == target, because we already verified */\n\t\tif (op && (si->su != tu) && (mc->flags & MC_SECURE) && !chanacs_user_has_flag(mc, tu, CA_OP) && !chanacs_user_has_flag(mc, tu, CA_AUTOOP))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 has the SECURE option enabled, and \\2%s\\2 does not have appropriate access.\"), mc->name, tu->nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcu = chanuser_find(mc->chan, tu);\n\t\tif (!cu)\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not on \\2%s\\2.\"), tu->nick, mc->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmodestack_mode_param(chansvs.nick, mc->chan, op ? MTYPE_ADD : MTYPE_DEL, 'o', CLIENT_NAME(tu));\n\t\tif (op)\n\t\t\tcu->modes |= CSTATUS_OP;\n\t\telse\n\t\t\tcu->modes &= ~CSTATUS_OP;\n\n\t\tif (si->c == NULL && tu != si->su)\n\t\t\tchange_notify(chansvs.nick, tu, \"You have been %sopped on %s by %s\", op ? \"\" : \"de\", mc->name, get_source_name(si));\n\n\t\tlogcommand(si, CMDLOG_DO, \"%sOP: \\2%s!%s@%s\\2 on \\2%s\\2\", op ? \"\" : \"DE\", tu->nick, tu->user, tu->vhost, mc->name);\n\t\tif (si->su == NULL || !chanuser_find(mc->chan, si->su))\n\t\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been %sopped on \\2%s\\2.\"), tu->nick, op ? \"\" : \"de\", mc->name);\n\t}\n\n\tprefix_action_clear(&op_actions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "_(\"Syntax: DEOP <#channel> [nickname] [...]\")"
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Syntax: DEOP <#channel> [nickname] [...]\""
          ],
          "line": 143
        },
        "resolved": true,
        "details": {
          "function_name": "_moddeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/op.c",
          "lines": "33-37",
          "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_op);\n\tservice_named_unbind_command(\"chanserv\", &cs_deop);\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "command_t cs_op = { \"OP\", N_(\"Gives channel ops to a user.\"),\n                        AC_NONE, 2, cs_cmd_op, { .path = \"cservice/op_voice\" } };",
            "command_t cs_deop = { \"DEOP\", N_(\"Removes channel ops from a user.\"),\n                        AC_NONE, 2, cs_cmd_deop, { .path = \"cservice/op_voice\" } };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"atheme.h\"\n\ncommand_t cs_op = { \"OP\", N_(\"Gives channel ops to a user.\"),\n                        AC_NONE, 2, cs_cmd_op, { .path = \"cservice/op_voice\" } };\ncommand_t cs_deop = { \"DEOP\", N_(\"Removes channel ops from a user.\"),\n                        AC_NONE, 2, cs_cmd_deop, { .path = \"cservice/op_voice\" } };\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_op);\n\tservice_named_unbind_command(\"chanserv\", &cs_deop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "STR_INSUFFICIENT_PARAMS",
            "\"DEOP\""
          ],
          "line": 142
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_cmd_op(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_deop(sourceinfo_t *si, int parc, char *parv[]);\n\nstatic void cs_cmd_deop(sourceinfo_t *si, int parc, char *parv[])\n{\n\tif (!parv[0])\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"DEOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: DEOP <#channel> [nickname] [...]\"));\n\t\treturn;\n\t}\n\n\tcmd_op(si, false, parc, parv);\n}"
  },
  {
    "function_name": "cs_cmd_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/op.c",
    "lines": "126-136",
    "snippet": "static void cs_cmd_op(sourceinfo_t *si, int parc, char *parv[])\n{\n\tif (!parv[0])\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"OP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: OP <#channel> [nickname] [...]\"));\n\t\treturn;\n\t}\n\n\tcmd_op(si, true, parc, parv);\n}",
    "includes": [
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_cmd_op(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_deop(sourceinfo_t *si, int parc, char *parv[]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmd_op",
          "args": [
            "si",
            "true",
            "parc",
            "parv"
          ],
          "line": 135
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_op",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/op.c",
          "lines": "41-124",
          "snippet": "static void cmd_op(sourceinfo_t *si, bool opping, int parc, char *parv[])\n{\n\tchar *chan = parv[0];\n\tchar *nick = parv[1];\n\tmychan_t *mc;\n\tuser_t *tu;\n\tchanuser_t *cu;\n\tchar *nicks;\n\tbool op;\n\tmowgli_node_t *n;\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tnicks = (!nick ? strdup(si->su->nick) : strdup(nick));\n\tprefix_action_set_all(&op_actions, opping, nicks);\n\tfree(nicks);\n\n\tMOWGLI_LIST_FOREACH(n, op_actions.head)\n\t{\n\t\tstruct prefix_action *act = n->data;\n\t\tnick = act->nick;\n\t\top = act->en;\n\n\t\t/* figure out who we're going to op */\n\t\tif (!(tu = user_find_named(nick)))\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not online.\"), nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!chanacs_source_has_flag(mc, si, CA_OP) && (tu != si->su || !chanacs_source_has_flag(mc, si, CA_AUTOOP)))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to (de)op \\2%s\\2 on \\2%s\\2.\"), nick, mc->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!op && is_service(tu))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is a network service; you cannot kick or deop them.\"), tu->nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* SECURE check; we can skip this if deopping or sender == target, because we already verified */\n\t\tif (op && (si->su != tu) && (mc->flags & MC_SECURE) && !chanacs_user_has_flag(mc, tu, CA_OP) && !chanacs_user_has_flag(mc, tu, CA_AUTOOP))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 has the SECURE option enabled, and \\2%s\\2 does not have appropriate access.\"), mc->name, tu->nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcu = chanuser_find(mc->chan, tu);\n\t\tif (!cu)\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not on \\2%s\\2.\"), tu->nick, mc->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmodestack_mode_param(chansvs.nick, mc->chan, op ? MTYPE_ADD : MTYPE_DEL, 'o', CLIENT_NAME(tu));\n\t\tif (op)\n\t\t\tcu->modes |= CSTATUS_OP;\n\t\telse\n\t\t\tcu->modes &= ~CSTATUS_OP;\n\n\t\tif (si->c == NULL && tu != si->su)\n\t\t\tchange_notify(chansvs.nick, tu, \"You have been %sopped on %s by %s\", op ? \"\" : \"de\", mc->name, get_source_name(si));\n\n\t\tlogcommand(si, CMDLOG_DO, \"%sOP: \\2%s!%s@%s\\2 on \\2%s\\2\", op ? \"\" : \"DE\", tu->nick, tu->user, tu->vhost, mc->name);\n\t\tif (si->su == NULL || !chanuser_find(mc->chan, si->su))\n\t\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been %sopped on \\2%s\\2.\"), tu->nick, op ? \"\" : \"de\", mc->name);\n\t}\n\n\tprefix_action_clear(&op_actions);\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cs_cmd_op(sourceinfo_t *si, int parc, char *parv[]);",
            "static void cs_cmd_deop(sourceinfo_t *si, int parc, char *parv[]);",
            "static mowgli_list_t op_actions;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_cmd_op(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_deop(sourceinfo_t *si, int parc, char *parv[]);\nstatic mowgli_list_t op_actions;\n\nstatic void cmd_op(sourceinfo_t *si, bool opping, int parc, char *parv[])\n{\n\tchar *chan = parv[0];\n\tchar *nick = parv[1];\n\tmychan_t *mc;\n\tuser_t *tu;\n\tchanuser_t *cu;\n\tchar *nicks;\n\tbool op;\n\tmowgli_node_t *n;\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tnicks = (!nick ? strdup(si->su->nick) : strdup(nick));\n\tprefix_action_set_all(&op_actions, opping, nicks);\n\tfree(nicks);\n\n\tMOWGLI_LIST_FOREACH(n, op_actions.head)\n\t{\n\t\tstruct prefix_action *act = n->data;\n\t\tnick = act->nick;\n\t\top = act->en;\n\n\t\t/* figure out who we're going to op */\n\t\tif (!(tu = user_find_named(nick)))\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not online.\"), nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!chanacs_source_has_flag(mc, si, CA_OP) && (tu != si->su || !chanacs_source_has_flag(mc, si, CA_AUTOOP)))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to (de)op \\2%s\\2 on \\2%s\\2.\"), nick, mc->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!op && is_service(tu))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is a network service; you cannot kick or deop them.\"), tu->nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* SECURE check; we can skip this if deopping or sender == target, because we already verified */\n\t\tif (op && (si->su != tu) && (mc->flags & MC_SECURE) && !chanacs_user_has_flag(mc, tu, CA_OP) && !chanacs_user_has_flag(mc, tu, CA_AUTOOP))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 has the SECURE option enabled, and \\2%s\\2 does not have appropriate access.\"), mc->name, tu->nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcu = chanuser_find(mc->chan, tu);\n\t\tif (!cu)\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not on \\2%s\\2.\"), tu->nick, mc->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmodestack_mode_param(chansvs.nick, mc->chan, op ? MTYPE_ADD : MTYPE_DEL, 'o', CLIENT_NAME(tu));\n\t\tif (op)\n\t\t\tcu->modes |= CSTATUS_OP;\n\t\telse\n\t\t\tcu->modes &= ~CSTATUS_OP;\n\n\t\tif (si->c == NULL && tu != si->su)\n\t\t\tchange_notify(chansvs.nick, tu, \"You have been %sopped on %s by %s\", op ? \"\" : \"de\", mc->name, get_source_name(si));\n\n\t\tlogcommand(si, CMDLOG_DO, \"%sOP: \\2%s!%s@%s\\2 on \\2%s\\2\", op ? \"\" : \"DE\", tu->nick, tu->user, tu->vhost, mc->name);\n\t\tif (si->su == NULL || !chanuser_find(mc->chan, si->su))\n\t\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been %sopped on \\2%s\\2.\"), tu->nick, op ? \"\" : \"de\", mc->name);\n\t}\n\n\tprefix_action_clear(&op_actions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "_(\"Syntax: OP <#channel> [nickname] [...]\")"
          ],
          "line": 131
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Syntax: OP <#channel> [nickname] [...]\""
          ],
          "line": 131
        },
        "resolved": true,
        "details": {
          "function_name": "_moddeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/op.c",
          "lines": "33-37",
          "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_op);\n\tservice_named_unbind_command(\"chanserv\", &cs_deop);\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "command_t cs_op = { \"OP\", N_(\"Gives channel ops to a user.\"),\n                        AC_NONE, 2, cs_cmd_op, { .path = \"cservice/op_voice\" } };",
            "command_t cs_deop = { \"DEOP\", N_(\"Removes channel ops from a user.\"),\n                        AC_NONE, 2, cs_cmd_deop, { .path = \"cservice/op_voice\" } };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"atheme.h\"\n\ncommand_t cs_op = { \"OP\", N_(\"Gives channel ops to a user.\"),\n                        AC_NONE, 2, cs_cmd_op, { .path = \"cservice/op_voice\" } };\ncommand_t cs_deop = { \"DEOP\", N_(\"Removes channel ops from a user.\"),\n                        AC_NONE, 2, cs_cmd_deop, { .path = \"cservice/op_voice\" } };\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_op);\n\tservice_named_unbind_command(\"chanserv\", &cs_deop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "STR_INSUFFICIENT_PARAMS",
            "\"OP\""
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_cmd_op(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_deop(sourceinfo_t *si, int parc, char *parv[]);\n\nstatic void cs_cmd_op(sourceinfo_t *si, int parc, char *parv[])\n{\n\tif (!parv[0])\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"OP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: OP <#channel> [nickname] [...]\"));\n\t\treturn;\n\t}\n\n\tcmd_op(si, true, parc, parv);\n}"
  },
  {
    "function_name": "cmd_op",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/op.c",
    "lines": "41-124",
    "snippet": "static void cmd_op(sourceinfo_t *si, bool opping, int parc, char *parv[])\n{\n\tchar *chan = parv[0];\n\tchar *nick = parv[1];\n\tmychan_t *mc;\n\tuser_t *tu;\n\tchanuser_t *cu;\n\tchar *nicks;\n\tbool op;\n\tmowgli_node_t *n;\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tnicks = (!nick ? strdup(si->su->nick) : strdup(nick));\n\tprefix_action_set_all(&op_actions, opping, nicks);\n\tfree(nicks);\n\n\tMOWGLI_LIST_FOREACH(n, op_actions.head)\n\t{\n\t\tstruct prefix_action *act = n->data;\n\t\tnick = act->nick;\n\t\top = act->en;\n\n\t\t/* figure out who we're going to op */\n\t\tif (!(tu = user_find_named(nick)))\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not online.\"), nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!chanacs_source_has_flag(mc, si, CA_OP) && (tu != si->su || !chanacs_source_has_flag(mc, si, CA_AUTOOP)))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to (de)op \\2%s\\2 on \\2%s\\2.\"), nick, mc->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!op && is_service(tu))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is a network service; you cannot kick or deop them.\"), tu->nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* SECURE check; we can skip this if deopping or sender == target, because we already verified */\n\t\tif (op && (si->su != tu) && (mc->flags & MC_SECURE) && !chanacs_user_has_flag(mc, tu, CA_OP) && !chanacs_user_has_flag(mc, tu, CA_AUTOOP))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 has the SECURE option enabled, and \\2%s\\2 does not have appropriate access.\"), mc->name, tu->nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcu = chanuser_find(mc->chan, tu);\n\t\tif (!cu)\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not on \\2%s\\2.\"), tu->nick, mc->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmodestack_mode_param(chansvs.nick, mc->chan, op ? MTYPE_ADD : MTYPE_DEL, 'o', CLIENT_NAME(tu));\n\t\tif (op)\n\t\t\tcu->modes |= CSTATUS_OP;\n\t\telse\n\t\t\tcu->modes &= ~CSTATUS_OP;\n\n\t\tif (si->c == NULL && tu != si->su)\n\t\t\tchange_notify(chansvs.nick, tu, \"You have been %sopped on %s by %s\", op ? \"\" : \"de\", mc->name, get_source_name(si));\n\n\t\tlogcommand(si, CMDLOG_DO, \"%sOP: \\2%s!%s@%s\\2 on \\2%s\\2\", op ? \"\" : \"DE\", tu->nick, tu->user, tu->vhost, mc->name);\n\t\tif (si->su == NULL || !chanuser_find(mc->chan, si->su))\n\t\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been %sopped on \\2%s\\2.\"), tu->nick, op ? \"\" : \"de\", mc->name);\n\t}\n\n\tprefix_action_clear(&op_actions);\n}",
    "includes": [
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_cmd_op(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_deop(sourceinfo_t *si, int parc, char *parv[]);",
      "static mowgli_list_t op_actions;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prefix_action_clear",
          "args": [
            "&op_actions"
          ],
          "line": 123
        },
        "resolved": true,
        "details": {
          "function_name": "prefix_action_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/chanserv.h",
          "lines": "72-82",
          "snippet": "static inline void prefix_action_clear(mowgli_list_t *actions)\n{\n\tmowgli_node_t *n, *tn;\n\n\tMOWGLI_LIST_FOREACH_SAFE(n, tn, actions->head)\n\t{\n\t\tfree(n->data);\n\t\tmowgli_node_delete(n, actions);\n\t\tmowgli_node_free(n);\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void prefix_action_clear(mowgli_list_t *actions)\n{\n\tmowgli_node_t *n, *tn;\n\n\tMOWGLI_LIST_FOREACH_SAFE(n, tn, actions->head)\n\t{\n\t\tfree(n->data);\n\t\tmowgli_node_delete(n, actions);\n\t\tmowgli_node_free(n);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"\\2%s\\2 has been %sopped on \\2%s\\2.\")",
            "tu->nick",
            "op ? \"\" : \"de\"",
            "mc->name"
          ],
          "line": 120
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"\\2%s\\2 has been %sopped on \\2%s\\2.\""
          ],
          "line": 120
        },
        "resolved": true,
        "details": {
          "function_name": "_moddeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/op.c",
          "lines": "33-37",
          "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_op);\n\tservice_named_unbind_command(\"chanserv\", &cs_deop);\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "command_t cs_op = { \"OP\", N_(\"Gives channel ops to a user.\"),\n                        AC_NONE, 2, cs_cmd_op, { .path = \"cservice/op_voice\" } };",
            "command_t cs_deop = { \"DEOP\", N_(\"Removes channel ops from a user.\"),\n                        AC_NONE, 2, cs_cmd_deop, { .path = \"cservice/op_voice\" } };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"atheme.h\"\n\ncommand_t cs_op = { \"OP\", N_(\"Gives channel ops to a user.\"),\n                        AC_NONE, 2, cs_cmd_op, { .path = \"cservice/op_voice\" } };\ncommand_t cs_deop = { \"DEOP\", N_(\"Removes channel ops from a user.\"),\n                        AC_NONE, 2, cs_cmd_deop, { .path = \"cservice/op_voice\" } };\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_op);\n\tservice_named_unbind_command(\"chanserv\", &cs_deop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chanuser_find",
          "args": [
            "mc->chan",
            "si->su"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_DO",
            "\"%sOP: \\2%s!%s@%s\\2 on \\2%s\\2\"",
            "op ? \"\" : \"DE\"",
            "tu->nick",
            "tu->user",
            "tu->vhost",
            "mc->name"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "change_notify",
          "args": [
            "chansvs.nick",
            "tu",
            "\"You have been %sopped on %s by %s\"",
            "op ? \"\" : \"de\"",
            "mc->name",
            "get_source_name(si)"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_source_name",
          "args": [
            "si"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modestack_mode_param",
          "args": [
            "chansvs.nick",
            "mc->chan",
            "op ? MTYPE_ADD : MTYPE_DEL",
            "'o'",
            "CLIENT_NAME(tu)"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLIENT_NAME",
          "args": [
            "tu"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_target",
            "_(\"\\2%s\\2 is not on \\2%s\\2.\")",
            "tu->nick",
            "mc->name"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanuser_find",
          "args": [
            "mc->chan",
            "tu"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"\\2%s\\2 has the SECURE option enabled, and \\2%s\\2 does not have appropriate access.\")",
            "mc->name",
            "tu->nick"
          ],
          "line": 98
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not authorized to perform this operation.\")"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_user_has_flag",
          "args": [
            "mc",
            "tu",
            "CA_AUTOOP"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_user_has_flag",
          "args": [
            "mc",
            "tu",
            "CA_OP"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"\\2%s\\2 is a network service; you cannot kick or deop them.\")",
            "tu->nick"
          ],
          "line": 90
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_service",
          "args": [
            "tu"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not authorized to (de)op \\2%s\\2 on \\2%s\\2.\")",
            "nick",
            "mc->name"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_source_has_flag",
          "args": [
            "mc",
            "si",
            "CA_AUTOOP"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_source_has_flag",
          "args": [
            "mc",
            "si",
            "CA_OP"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_target",
            "_(\"\\2%s\\2 is not online.\")",
            "nick"
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_find_named",
          "args": [
            "nick"
          ],
          "line": 76
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_LIST_FOREACH",
          "args": [
            "n",
            "op_actions.head"
          ],
          "line": 69
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "nicks"
          ],
          "line": 67
        },
        "resolved": true,
        "details": {
          "function_name": "free_template_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/access.c",
          "lines": "358-371",
          "snippet": "static void free_template_list(mowgli_list_t *l)\n{\n\tmowgli_node_t *n, *tn;\n\n\treturn_if_fail(l != NULL);\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, l->head)\n\t{\n\t\ttemplate_t *t = n->data;\n\n\t\tmowgli_node_delete(&t->node, l);\n\t\tfree(t);\n\t}\n}",
          "includes": [
            "#include \"template.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void free_template_list(mowgli_list_t *l)\n{\n\tmowgli_node_t *n, *tn;\n\n\treturn_if_fail(l != NULL);\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, l->head)\n\t{\n\t\ttemplate_t *t = n->data;\n\n\t\tmowgli_node_delete(&t->node, l);\n\t\tfree(t);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefix_action_set_all",
          "args": [
            "&op_actions",
            "opping",
            "nicks"
          ],
          "line": 66
        },
        "resolved": true,
        "details": {
          "function_name": "prefix_action_set_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/chanserv.h",
          "lines": "43-70",
          "snippet": "static inline void prefix_action_set_all(mowgli_list_t *actions, bool dfl, char *nicks)\n{\n\tchar *nick, *strtokctx = NULL;\n\tbool en;\n\n\tnick = strtok_r(nicks, \" \", &strtokctx);\n\tdo\n\t{\n\t\tswitch (*nick)\n\t\t{\n\t\tcase '-':\n\t\t\ten = false;\n\t\t\tnick++;\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\ten = true;\n\t\t\tnick++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ten = dfl;\n\t\t}\n\n\t\tif (!strcmp(nick, \"\"))\n\t\t\tcontinue;\n\n\t\tprefix_action_set(actions, nick, en);\n\t} while ((nick = strtok_r(NULL, \" \", &strtokctx)) != NULL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void prefix_action_set_all(mowgli_list_t *actions, bool dfl, char *nicks)\n{\n\tchar *nick, *strtokctx = NULL;\n\tbool en;\n\n\tnick = strtok_r(nicks, \" \", &strtokctx);\n\tdo\n\t{\n\t\tswitch (*nick)\n\t\t{\n\t\tcase '-':\n\t\t\ten = false;\n\t\t\tnick++;\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\ten = true;\n\t\t\tnick++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ten = dfl;\n\t\t}\n\n\t\tif (!strcmp(nick, \"\"))\n\t\t\tcontinue;\n\n\t\tprefix_action_set(actions, nick, en);\n\t} while ((nick = strtok_r(NULL, \" \", &strtokctx)) != NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "nick"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "si->su->nick"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"\\2%s\\2 is closed.\")",
            "chan"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:close:closer\""
          ],
          "line": 59
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_target",
            "_(\"Channel \\2%s\\2 is not registered.\")",
            "chan"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_find",
          "args": [
            "chan"
          ],
          "line": 52
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_cmd_op(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_deop(sourceinfo_t *si, int parc, char *parv[]);\nstatic mowgli_list_t op_actions;\n\nstatic void cmd_op(sourceinfo_t *si, bool opping, int parc, char *parv[])\n{\n\tchar *chan = parv[0];\n\tchar *nick = parv[1];\n\tmychan_t *mc;\n\tuser_t *tu;\n\tchanuser_t *cu;\n\tchar *nicks;\n\tbool op;\n\tmowgli_node_t *n;\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tnicks = (!nick ? strdup(si->su->nick) : strdup(nick));\n\tprefix_action_set_all(&op_actions, opping, nicks);\n\tfree(nicks);\n\n\tMOWGLI_LIST_FOREACH(n, op_actions.head)\n\t{\n\t\tstruct prefix_action *act = n->data;\n\t\tnick = act->nick;\n\t\top = act->en;\n\n\t\t/* figure out who we're going to op */\n\t\tif (!(tu = user_find_named(nick)))\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not online.\"), nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!chanacs_source_has_flag(mc, si, CA_OP) && (tu != si->su || !chanacs_source_has_flag(mc, si, CA_AUTOOP)))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to (de)op \\2%s\\2 on \\2%s\\2.\"), nick, mc->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!op && is_service(tu))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is a network service; you cannot kick or deop them.\"), tu->nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* SECURE check; we can skip this if deopping or sender == target, because we already verified */\n\t\tif (op && (si->su != tu) && (mc->flags & MC_SECURE) && !chanacs_user_has_flag(mc, tu, CA_OP) && !chanacs_user_has_flag(mc, tu, CA_AUTOOP))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 has the SECURE option enabled, and \\2%s\\2 does not have appropriate access.\"), mc->name, tu->nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcu = chanuser_find(mc->chan, tu);\n\t\tif (!cu)\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not on \\2%s\\2.\"), tu->nick, mc->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmodestack_mode_param(chansvs.nick, mc->chan, op ? MTYPE_ADD : MTYPE_DEL, 'o', CLIENT_NAME(tu));\n\t\tif (op)\n\t\t\tcu->modes |= CSTATUS_OP;\n\t\telse\n\t\t\tcu->modes &= ~CSTATUS_OP;\n\n\t\tif (si->c == NULL && tu != si->su)\n\t\t\tchange_notify(chansvs.nick, tu, \"You have been %sopped on %s by %s\", op ? \"\" : \"de\", mc->name, get_source_name(si));\n\n\t\tlogcommand(si, CMDLOG_DO, \"%sOP: \\2%s!%s@%s\\2 on \\2%s\\2\", op ? \"\" : \"DE\", tu->nick, tu->user, tu->vhost, mc->name);\n\t\tif (si->su == NULL || !chanuser_find(mc->chan, si->su))\n\t\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been %sopped on \\2%s\\2.\"), tu->nick, op ? \"\" : \"de\", mc->name);\n\t}\n\n\tprefix_action_clear(&op_actions);\n}"
  },
  {
    "function_name": "_moddeinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/op.c",
    "lines": "33-37",
    "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_op);\n\tservice_named_unbind_command(\"chanserv\", &cs_deop);\n}",
    "includes": [
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "command_t cs_op = { \"OP\", N_(\"Gives channel ops to a user.\"),\n                        AC_NONE, 2, cs_cmd_op, { .path = \"cservice/op_voice\" } };",
      "command_t cs_deop = { \"DEOP\", N_(\"Removes channel ops from a user.\"),\n                        AC_NONE, 2, cs_cmd_deop, { .path = \"cservice/op_voice\" } };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "service_named_unbind_command",
          "args": [
            "\"chanserv\"",
            "&cs_deop"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_named_unbind_command",
          "args": [
            "\"chanserv\"",
            "&cs_op"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"chanserv.h\"\n#include \"atheme.h\"\n\ncommand_t cs_op = { \"OP\", N_(\"Gives channel ops to a user.\"),\n                        AC_NONE, 2, cs_cmd_op, { .path = \"cservice/op_voice\" } };\ncommand_t cs_deop = { \"DEOP\", N_(\"Removes channel ops from a user.\"),\n                        AC_NONE, 2, cs_cmd_deop, { .path = \"cservice/op_voice\" } };\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_op);\n\tservice_named_unbind_command(\"chanserv\", &cs_deop);\n}"
  },
  {
    "function_name": "_modinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/op.c",
    "lines": "27-31",
    "snippet": "void _modinit(module_t *m)\n{\n        service_named_bind_command(\"chanserv\", &cs_op);\n        service_named_bind_command(\"chanserv\", &cs_deop);\n}",
    "includes": [
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "command_t cs_op = { \"OP\", N_(\"Gives channel ops to a user.\"),\n                        AC_NONE, 2, cs_cmd_op, { .path = \"cservice/op_voice\" } };",
      "command_t cs_deop = { \"DEOP\", N_(\"Removes channel ops from a user.\"),\n                        AC_NONE, 2, cs_cmd_deop, { .path = \"cservice/op_voice\" } };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "service_named_bind_command",
          "args": [
            "\"chanserv\"",
            "&cs_deop"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_named_bind_command",
          "args": [
            "\"chanserv\"",
            "&cs_op"
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"chanserv.h\"\n#include \"atheme.h\"\n\ncommand_t cs_op = { \"OP\", N_(\"Gives channel ops to a user.\"),\n                        AC_NONE, 2, cs_cmd_op, { .path = \"cservice/op_voice\" } };\ncommand_t cs_deop = { \"DEOP\", N_(\"Removes channel ops from a user.\"),\n                        AC_NONE, 2, cs_cmd_deop, { .path = \"cservice/op_voice\" } };\n\nvoid _modinit(module_t *m)\n{\n        service_named_bind_command(\"chanserv\", &cs_op);\n        service_named_bind_command(\"chanserv\", &cs_deop);\n}"
  }
]