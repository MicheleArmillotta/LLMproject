[
  {
    "function_name": "cs_cmd_forcexop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
    "lines": "437-522",
    "snippet": "static void cs_cmd_forcexop(sourceinfo_t *si, int parc, char *parv[])\n{\n\tchar *chan = parv[0];\n\tchanacs_t *ca;\n\tmychan_t *mc = mychan_find(chan);\n\tmowgli_node_t *n;\n\tint changes;\n\tunsigned int newlevel;\n\tconst char *desc;\n\tunsigned int ca_sop, ca_aop, ca_hop, ca_vop;\n\n\tif (!chan)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"FORCEXOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: FORCEXOP <#channel>\"));\n\t\treturn;\n\t}\n\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tif (!is_founder(mc, entity(si->smu)))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\treturn;\n\t}\n\n\tca_sop = get_template_flags(mc, \"SOP\");\n\tca_aop = get_template_flags(mc, \"AOP\");\n\tca_hop = get_template_flags(mc, \"HOP\");\n\tca_vop = get_template_flags(mc, \"VOP\");\n\n\tchanges = 0;\n\tMOWGLI_ITER_FOREACH(n, mc->chanacs.head)\n\t{\n\t\tca = (chanacs_t *)n->data;\n\n\t\tif (ca->level & CA_AKICK)\n\t\t\tcontinue;\n\t\tif (ca->level & CA_FOUNDER)\n\t\t\tnewlevel = custom_founder_check(), desc = \"Founder\";\n\t\telse if (!(~ca->level & ca_sop))\n\t\t\tnewlevel = ca_sop, desc = \"SOP\";\n\t\telse if (ca->level == ca_aop)\n\t\t\tnewlevel = ca_aop, desc = \"AOP\";\n\t\telse if (ca->level == ca_hop)\n\t\t\tnewlevel = ca_hop, desc = \"HOP\";\n\t\telse if (ca->level == ca_vop)\n\t\t\tnewlevel = ca_vop, desc = \"VOP\";\n\t\telse if (ca->level & (CA_SET | CA_RECOVER | CA_FLAGS))\n\t\t\tnewlevel = ca_sop, desc = \"SOP\";\n\t\telse if (ca->level & (CA_OP | CA_AUTOOP | CA_REMOVE))\n\t\t\tnewlevel = ca_aop, desc = \"AOP\";\n\t\telse if (ca->level & (CA_HALFOP | CA_AUTOHALFOP | CA_TOPIC))\n\t\t{\n\t\t\tif (ca_hop == ca_vop)\n\t\t\t\tnewlevel = ca_aop, desc = \"AOP\";\n\t\t\telse\n\t\t\t\tnewlevel = ca_hop, desc = \"HOP\";\n\t\t}\n\t\telse /*if (ca->level & CA_AUTOVOICE)*/\n\t\t\tnewlevel = ca_vop, desc = \"VOP\";\n#if 0\n\t\telse\n\t\t\tnewlevel = 0;\n#endif\n\t\tif (newlevel == ca->level)\n\t\t\tcontinue;\n\t\tchanges++;\n\t\tcommand_success_nodata(si, \"%s: %s -> %s\", ca->entity != NULL ? ca->entity->name : ca->host, bitmask_to_flags(ca->level), desc);\n\t\tchanacs_modify_simple(ca, newlevel, ~newlevel);\n\t}\n\tcommand_success_nodata(si, _(\"FORCEXOP \\2%s\\2 done (\\2%d\\2 changes)\"), mc->name, changes);\n\tif (changes > 0)\n\t\tverbose(mc, \"\\2%s\\2 reset access levels to xOP (\\2%d\\2 changes)\", get_source_name(si), changes);\n\tlogcommand(si, CMDLOG_SET, \"FORCEXOP: \\2%s\\2 (\\2%d\\2 changes)\", mc->name, changes);\n}",
    "includes": [
      "#include \"chanserv.h\"",
      "#include \"template.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_cmd_sop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_aop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_hop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_vop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_forcexop(sourceinfo_t *si, int parc, char *parv[]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_SET",
            "\"FORCEXOP: \\2%s\\2 (\\2%d\\2 changes)\"",
            "mc->name",
            "changes"
          ],
          "line": 521
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "mc",
            "\"\\2%s\\2 reset access levels to xOP (\\2%d\\2 changes)\"",
            "get_source_name(si)",
            "changes"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_source_name",
          "args": [
            "si"
          ],
          "line": 520
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"FORCEXOP \\2%s\\2 done (\\2%d\\2 changes)\")",
            "mc->name",
            "changes"
          ],
          "line": 518
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"FORCEXOP \\2%s\\2 done (\\2%d\\2 changes)\""
          ],
          "line": 518
        },
        "resolved": true,
        "details": {
          "function_name": "_moddeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
          "lines": "52-59",
          "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_aop);\n\tservice_named_unbind_command(\"chanserv\", &cs_sop);\n\tservice_named_unbind_command(\"chanserv\", &cs_hop);\n\tservice_named_unbind_command(\"chanserv\", &cs_vop);\n\tservice_named_unbind_command(\"chanserv\", &cs_forcexop);\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"template.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "command_t cs_sop = { \"SOP\", N_(\"Manipulates a channel SOP list.\"),\n                        AC_NONE, 3, cs_cmd_sop, { .path = \"cservice/xop\" } };",
            "command_t cs_aop = { \"AOP\", N_(\"Manipulates a channel AOP list.\"),\n                        AC_NONE, 3, cs_cmd_aop, { .path = \"cservice/xop\" } };",
            "command_t cs_hop = { \"HOP\", N_(\"Manipulates a channel HOP list.\"),\n\t\t\tAC_NONE, 3, cs_cmd_hop, { .path = \"cservice/xop\" } };",
            "command_t cs_vop = { \"VOP\", N_(\"Manipulates a channel VOP list.\"),\n                        AC_NONE, 3, cs_cmd_vop, { .path = \"cservice/xop\" } };",
            "command_t cs_forcexop = { \"FORCEXOP\", N_(\"Forces access levels to xOP levels.\"),\n                         AC_NONE, 1, cs_cmd_forcexop, { .path = \"cservice/forcexop\" } };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\ncommand_t cs_sop = { \"SOP\", N_(\"Manipulates a channel SOP list.\"),\n                        AC_NONE, 3, cs_cmd_sop, { .path = \"cservice/xop\" } };\ncommand_t cs_aop = { \"AOP\", N_(\"Manipulates a channel AOP list.\"),\n                        AC_NONE, 3, cs_cmd_aop, { .path = \"cservice/xop\" } };\ncommand_t cs_hop = { \"HOP\", N_(\"Manipulates a channel HOP list.\"),\n\t\t\tAC_NONE, 3, cs_cmd_hop, { .path = \"cservice/xop\" } };\ncommand_t cs_vop = { \"VOP\", N_(\"Manipulates a channel VOP list.\"),\n                        AC_NONE, 3, cs_cmd_vop, { .path = \"cservice/xop\" } };\ncommand_t cs_forcexop = { \"FORCEXOP\", N_(\"Forces access levels to xOP levels.\"),\n                         AC_NONE, 1, cs_cmd_forcexop, { .path = \"cservice/forcexop\" } };\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_aop);\n\tservice_named_unbind_command(\"chanserv\", &cs_sop);\n\tservice_named_unbind_command(\"chanserv\", &cs_hop);\n\tservice_named_unbind_command(\"chanserv\", &cs_vop);\n\tservice_named_unbind_command(\"chanserv\", &cs_forcexop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chanacs_modify_simple",
          "args": [
            "ca",
            "newlevel",
            "~newlevel"
          ],
          "line": 516
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "\"%s: %s -> %s\"",
            "ca->entity != NULL ? ca->entity->name : ca->host",
            "bitmask_to_flags(ca->level)",
            "desc"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "bitmask_to_flags",
          "args": [
            "ca->level"
          ],
          "line": 515
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "custom_founder_check",
          "args": [],
          "line": 486
        },
        "resolved": true,
        "details": {
          "function_name": "custom_founder_check",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/chanserv.h",
          "lines": "6-14",
          "snippet": "static inline unsigned int custom_founder_check(void)\n{\n\tchar *p;\n\n\tif (chansvs.founder_flags != NULL && (p = strchr(chansvs.founder_flags, 'F')) != NULL)\n\t\treturn flags_to_bitmask(chansvs.founder_flags, 0);\n\telse\n\t\treturn CA_INITIAL & ca_all;\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline unsigned int custom_founder_check(void)\n{\n\tchar *p;\n\n\tif (chansvs.founder_flags != NULL && (p = strchr(chansvs.founder_flags, 'F')) != NULL)\n\t\treturn flags_to_bitmask(chansvs.founder_flags, 0);\n\telse\n\t\treturn CA_INITIAL & ca_all;\n}"
        }
      },
      {
        "call_info": {
          "callee": "MOWGLI_ITER_FOREACH",
          "args": [
            "n",
            "mc->chanacs.head"
          ],
          "line": 479
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_template_flags",
          "args": [
            "mc",
            "\"VOP\""
          ],
          "line": 476
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_template_flags",
          "args": [
            "mc",
            "\"HOP\""
          ],
          "line": 475
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_template_flags",
          "args": [
            "mc",
            "\"AOP\""
          ],
          "line": 474
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_template_flags",
          "args": [
            "mc",
            "\"SOP\""
          ],
          "line": 473
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not authorized to perform this operation.\")"
          ],
          "line": 469
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_founder",
          "args": [
            "mc",
            "entity(si->smu)"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entity",
          "args": [
            "si->smu"
          ],
          "line": 467
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"\\2%s\\2 is closed.\")",
            "chan"
          ],
          "line": 463
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:close:closer\""
          ],
          "line": 461
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_target",
            "_(\"Channel \\2%s\\2 is not registered.\")",
            "chan"
          ],
          "line": 457
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "_(\"Syntax: FORCEXOP <#channel>\")"
          ],
          "line": 451
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "STR_INSUFFICIENT_PARAMS",
            "\"FORCEXOP\""
          ],
          "line": 450
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_find",
          "args": [
            "chan"
          ],
          "line": 441
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void cs_cmd_sop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_aop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_hop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_vop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_forcexop(sourceinfo_t *si, int parc, char *parv[]);\n\nstatic void cs_cmd_forcexop(sourceinfo_t *si, int parc, char *parv[])\n{\n\tchar *chan = parv[0];\n\tchanacs_t *ca;\n\tmychan_t *mc = mychan_find(chan);\n\tmowgli_node_t *n;\n\tint changes;\n\tunsigned int newlevel;\n\tconst char *desc;\n\tunsigned int ca_sop, ca_aop, ca_hop, ca_vop;\n\n\tif (!chan)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"FORCEXOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: FORCEXOP <#channel>\"));\n\t\treturn;\n\t}\n\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tif (!is_founder(mc, entity(si->smu)))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\treturn;\n\t}\n\n\tca_sop = get_template_flags(mc, \"SOP\");\n\tca_aop = get_template_flags(mc, \"AOP\");\n\tca_hop = get_template_flags(mc, \"HOP\");\n\tca_vop = get_template_flags(mc, \"VOP\");\n\n\tchanges = 0;\n\tMOWGLI_ITER_FOREACH(n, mc->chanacs.head)\n\t{\n\t\tca = (chanacs_t *)n->data;\n\n\t\tif (ca->level & CA_AKICK)\n\t\t\tcontinue;\n\t\tif (ca->level & CA_FOUNDER)\n\t\t\tnewlevel = custom_founder_check(), desc = \"Founder\";\n\t\telse if (!(~ca->level & ca_sop))\n\t\t\tnewlevel = ca_sop, desc = \"SOP\";\n\t\telse if (ca->level == ca_aop)\n\t\t\tnewlevel = ca_aop, desc = \"AOP\";\n\t\telse if (ca->level == ca_hop)\n\t\t\tnewlevel = ca_hop, desc = \"HOP\";\n\t\telse if (ca->level == ca_vop)\n\t\t\tnewlevel = ca_vop, desc = \"VOP\";\n\t\telse if (ca->level & (CA_SET | CA_RECOVER | CA_FLAGS))\n\t\t\tnewlevel = ca_sop, desc = \"SOP\";\n\t\telse if (ca->level & (CA_OP | CA_AUTOOP | CA_REMOVE))\n\t\t\tnewlevel = ca_aop, desc = \"AOP\";\n\t\telse if (ca->level & (CA_HALFOP | CA_AUTOHALFOP | CA_TOPIC))\n\t\t{\n\t\t\tif (ca_hop == ca_vop)\n\t\t\t\tnewlevel = ca_aop, desc = \"AOP\";\n\t\t\telse\n\t\t\t\tnewlevel = ca_hop, desc = \"HOP\";\n\t\t}\n\t\telse /*if (ca->level & CA_AUTOVOICE)*/\n\t\t\tnewlevel = ca_vop, desc = \"VOP\";\n#if 0\n\t\telse\n\t\t\tnewlevel = 0;\n#endif\n\t\tif (newlevel == ca->level)\n\t\t\tcontinue;\n\t\tchanges++;\n\t\tcommand_success_nodata(si, \"%s: %s -> %s\", ca->entity != NULL ? ca->entity->name : ca->host, bitmask_to_flags(ca->level), desc);\n\t\tchanacs_modify_simple(ca, newlevel, ~newlevel);\n\t}\n\tcommand_success_nodata(si, _(\"FORCEXOP \\2%s\\2 done (\\2%d\\2 changes)\"), mc->name, changes);\n\tif (changes > 0)\n\t\tverbose(mc, \"\\2%s\\2 reset access levels to xOP (\\2%d\\2 changes)\", get_source_name(si), changes);\n\tlogcommand(si, CMDLOG_SET, \"FORCEXOP: \\2%s\\2 (\\2%d\\2 changes)\", mc->name, changes);\n}"
  },
  {
    "function_name": "cs_xop_do_list",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
    "lines": "408-435",
    "snippet": "static void cs_xop_do_list(sourceinfo_t *si, mychan_t *mc, unsigned int level, const char *leveldesc, bool operoverride)\n{\n\tchanacs_t *ca;\n\tint i = 0;\n\tmowgli_node_t *n;\n\n\tcommand_success_nodata(si, _(\"%s list for \\2%s\\2:\"), leveldesc ,mc->name);\n\tMOWGLI_ITER_FOREACH(n, mc->chanacs.head)\n\t{\n\t\tca = (chanacs_t *)n->data;\n\t\tif (ca->level == level)\n\t\t{\n\t\t\tif (ca->entity == NULL)\n\t\t\t\tcommand_success_nodata(si, \"%d: \\2%s\\2\", ++i, ca->host);\n\t\t\telse if (isuser(ca->entity) && MOWGLI_LIST_LENGTH(&user(ca->entity)->logins))\n\t\t\t\tcommand_success_nodata(si, _(\"%d: \\2%s\\2 (logged in)\"), ++i, ca->entity->name);\n\t\t\telse\n\t\t\t\tcommand_success_nodata(si, _(\"%d: \\2%s\\2 (not logged in)\"), ++i, ca->entity->name);\n\t\t}\n\t}\n\t/* XXX */\n\tcommand_success_nodata(si, _(\"Total of \\2%d\\2 %s in %s list of \\2%s\\2.\"), i, (i == 1) ? \"entry\" : \"entries\", leveldesc, mc->name);\n\n\tif (operoverride)\n\t\tlogcommand(si, CMDLOG_ADMIN, \"LIST: \\2%s\\2 \\2%s\\2 (oper override)\", mc->name, leveldesc);\n\telse\n\t\tlogcommand(si, CMDLOG_GET, \"LIST: \\2%s\\2 \\2%s\\2\", mc->name, leveldesc);\n}",
    "includes": [
      "#include \"chanserv.h\"",
      "#include \"template.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc);",
      "static void cs_xop_do_list(sourceinfo_t *si, mychan_t *mc, unsigned int level, const char *leveldesc, bool operoverride);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_GET",
            "\"LIST: \\2%s\\2 \\2%s\\2\"",
            "mc->name",
            "leveldesc"
          ],
          "line": 434
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_ADMIN",
            "\"LIST: \\2%s\\2 \\2%s\\2 (oper override)\"",
            "mc->name",
            "leveldesc"
          ],
          "line": 432
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"Total of \\2%d\\2 %s in %s list of \\2%s\\2.\")",
            "i",
            "(i == 1) ? \"entry\" : \"entries\"",
            "leveldesc",
            "mc->name"
          ],
          "line": 429
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Total of \\2%d\\2 %s in %s list of \\2%s\\2.\""
          ],
          "line": 429
        },
        "resolved": true,
        "details": {
          "function_name": "_moddeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
          "lines": "52-59",
          "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_aop);\n\tservice_named_unbind_command(\"chanserv\", &cs_sop);\n\tservice_named_unbind_command(\"chanserv\", &cs_hop);\n\tservice_named_unbind_command(\"chanserv\", &cs_vop);\n\tservice_named_unbind_command(\"chanserv\", &cs_forcexop);\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"template.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "command_t cs_sop = { \"SOP\", N_(\"Manipulates a channel SOP list.\"),\n                        AC_NONE, 3, cs_cmd_sop, { .path = \"cservice/xop\" } };",
            "command_t cs_aop = { \"AOP\", N_(\"Manipulates a channel AOP list.\"),\n                        AC_NONE, 3, cs_cmd_aop, { .path = \"cservice/xop\" } };",
            "command_t cs_hop = { \"HOP\", N_(\"Manipulates a channel HOP list.\"),\n\t\t\tAC_NONE, 3, cs_cmd_hop, { .path = \"cservice/xop\" } };",
            "command_t cs_vop = { \"VOP\", N_(\"Manipulates a channel VOP list.\"),\n                        AC_NONE, 3, cs_cmd_vop, { .path = \"cservice/xop\" } };",
            "command_t cs_forcexop = { \"FORCEXOP\", N_(\"Forces access levels to xOP levels.\"),\n                         AC_NONE, 1, cs_cmd_forcexop, { .path = \"cservice/forcexop\" } };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\ncommand_t cs_sop = { \"SOP\", N_(\"Manipulates a channel SOP list.\"),\n                        AC_NONE, 3, cs_cmd_sop, { .path = \"cservice/xop\" } };\ncommand_t cs_aop = { \"AOP\", N_(\"Manipulates a channel AOP list.\"),\n                        AC_NONE, 3, cs_cmd_aop, { .path = \"cservice/xop\" } };\ncommand_t cs_hop = { \"HOP\", N_(\"Manipulates a channel HOP list.\"),\n\t\t\tAC_NONE, 3, cs_cmd_hop, { .path = \"cservice/xop\" } };\ncommand_t cs_vop = { \"VOP\", N_(\"Manipulates a channel VOP list.\"),\n                        AC_NONE, 3, cs_cmd_vop, { .path = \"cservice/xop\" } };\ncommand_t cs_forcexop = { \"FORCEXOP\", N_(\"Forces access levels to xOP levels.\"),\n                         AC_NONE, 1, cs_cmd_forcexop, { .path = \"cservice/forcexop\" } };\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_aop);\n\tservice_named_unbind_command(\"chanserv\", &cs_sop);\n\tservice_named_unbind_command(\"chanserv\", &cs_hop);\n\tservice_named_unbind_command(\"chanserv\", &cs_vop);\n\tservice_named_unbind_command(\"chanserv\", &cs_forcexop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"%d: \\2%s\\2 (not logged in)\")",
            "++i",
            "ca->entity->name"
          ],
          "line": 425
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"%d: \\2%s\\2 (logged in)\")",
            "++i",
            "ca->entity->name"
          ],
          "line": 423
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_LIST_LENGTH",
          "args": [
            "&user(ca->entity)->logins"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user",
          "args": [
            "ca->entity"
          ],
          "line": 422
        },
        "resolved": true,
        "details": {
          "function_name": "sync_myuser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/sync.c",
          "lines": "266-276",
          "snippet": "static void sync_myuser(myuser_t *mu)\n{\n\tmowgli_node_t *iter;\n\n\treturn_if_fail(mu != NULL);\n\n\tMOWGLI_ITER_FOREACH(iter, mu->logins.head)\n\t{\n\t\tsync_user(iter->data);\n\t}\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic void sync_myuser(myuser_t *mu)\n{\n\tmowgli_node_t *iter;\n\n\treturn_if_fail(mu != NULL);\n\n\tMOWGLI_ITER_FOREACH(iter, mu->logins.head)\n\t{\n\t\tsync_user(iter->data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isuser",
          "args": [
            "ca->entity"
          ],
          "line": 422
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "\"%d: \\2%s\\2\"",
            "++i",
            "ca->host"
          ],
          "line": 421
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_ITER_FOREACH",
          "args": [
            "n",
            "mc->chanacs.head"
          ],
          "line": 415
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"%s list for \\2%s\\2:\")",
            "leveldesc",
            "mc->name"
          ],
          "line": 414
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc);\nstatic void cs_xop_do_list(sourceinfo_t *si, mychan_t *mc, unsigned int level, const char *leveldesc, bool operoverride);\n\nstatic void cs_xop_do_list(sourceinfo_t *si, mychan_t *mc, unsigned int level, const char *leveldesc, bool operoverride)\n{\n\tchanacs_t *ca;\n\tint i = 0;\n\tmowgli_node_t *n;\n\n\tcommand_success_nodata(si, _(\"%s list for \\2%s\\2:\"), leveldesc ,mc->name);\n\tMOWGLI_ITER_FOREACH(n, mc->chanacs.head)\n\t{\n\t\tca = (chanacs_t *)n->data;\n\t\tif (ca->level == level)\n\t\t{\n\t\t\tif (ca->entity == NULL)\n\t\t\t\tcommand_success_nodata(si, \"%d: \\2%s\\2\", ++i, ca->host);\n\t\t\telse if (isuser(ca->entity) && MOWGLI_LIST_LENGTH(&user(ca->entity)->logins))\n\t\t\t\tcommand_success_nodata(si, _(\"%d: \\2%s\\2 (logged in)\"), ++i, ca->entity->name);\n\t\t\telse\n\t\t\t\tcommand_success_nodata(si, _(\"%d: \\2%s\\2 (not logged in)\"), ++i, ca->entity->name);\n\t\t}\n\t}\n\t/* XXX */\n\tcommand_success_nodata(si, _(\"Total of \\2%d\\2 %s in %s list of \\2%s\\2.\"), i, (i == 1) ? \"entry\" : \"entries\", leveldesc, mc->name);\n\n\tif (operoverride)\n\t\tlogcommand(si, CMDLOG_ADMIN, \"LIST: \\2%s\\2 \\2%s\\2 (oper override)\", mc->name, leveldesc);\n\telse\n\t\tlogcommand(si, CMDLOG_GET, \"LIST: \\2%s\\2 \\2%s\\2\", mc->name, leveldesc);\n}"
  },
  {
    "function_name": "cs_xop_do_del",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
    "lines": "348-405",
    "snippet": "static void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc)\n{\n\tchanacs_t *ca;\n\thook_channel_acl_req_t req;\n\n\t/* let's finally make this sane.. --w00t */\n\tif (!mt)\n\t{\n\t\t/* we might be deleting a hostmask */\n\t\tif (!validhostmask(target))\n\t\t{\n\t\t\tcommand_fail(si, fault_badparams, _(\"\\2%s\\2 is neither a nickname nor a hostmask.\"), target);\n\t\t\treturn;\n\t\t}\n\n\t\tca = chanacs_find_host_literal(mc, target, level);\n\t\tif (ca == NULL || ca->level != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is not on the %s list for \\2%s\\2.\"), target, leveldesc, mc->name);\n\t\t\treturn;\n\t\t}\n\n\t\treq.ca = ca;\n\t\treq.oldlevel = ca->level;\n\n\t\tca->level = 0;\n\n\t\treq.newlevel = ca->level;\n\n\t\thook_call_channel_acl_change(&req);\n\t\tobject_unref(ca);\n\n\t\tverbose(mc, \"\\2%s\\2 removed \\2%s\\2 from the %s list.\", get_source_name(si), target, leveldesc);\n\t\tlogcommand(si, CMDLOG_SET, \"DEL: \\2%s\\2 \\2%s\\2 from \\2%s\\2\", mc->name, leveldesc, target);\n\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been removed from the %s list for \\2%s\\2.\"), target, leveldesc, mc->name);\n\t\treturn;\n\t}\n\n\tif (!(ca = chanacs_find_literal(mc, mt, level)) || ca->level != level)\n\t{\n\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is not on the %s list for \\2%s\\2.\"), mt->name, leveldesc, mc->name);\n\t\treturn;\n\t}\n\n\treq.ca = ca;\n\treq.oldlevel = ca->level;\n\n\tca->level = 0;\n\n\treq.newlevel = ca->level;\n\n\thook_call_channel_acl_change(&req);\n\tobject_unref(ca);\n\n\tcommand_success_nodata(si, _(\"\\2%s\\2 has been removed from the %s list for \\2%s\\2.\"), mt->name, leveldesc, mc->name);\n\tlogcommand(si, CMDLOG_SET, \"DEL: \\2%s\\2 \\2%s\\2 from \\2%s\\2\", mc->name, leveldesc, mt->name);\n\tverbose(mc, \"\\2%s\\2 removed \\2%s\\2 from the %s list.\", get_source_name(si), mt->name, leveldesc);\n}",
    "includes": [
      "#include \"chanserv.h\"",
      "#include \"template.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "mc",
            "\"\\2%s\\2 removed \\2%s\\2 from the %s list.\"",
            "get_source_name(si)",
            "mt->name",
            "leveldesc"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_source_name",
          "args": [
            "si"
          ],
          "line": 404
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_SET",
            "\"DEL: \\2%s\\2 \\2%s\\2 from \\2%s\\2\"",
            "mc->name",
            "leveldesc",
            "mt->name"
          ],
          "line": 403
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"\\2%s\\2 has been removed from the %s list for \\2%s\\2.\")",
            "mt->name",
            "leveldesc",
            "mc->name"
          ],
          "line": 402
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"\\2%s\\2 has been removed from the %s list for \\2%s\\2.\""
          ],
          "line": 402
        },
        "resolved": true,
        "details": {
          "function_name": "_moddeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
          "lines": "52-59",
          "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_aop);\n\tservice_named_unbind_command(\"chanserv\", &cs_sop);\n\tservice_named_unbind_command(\"chanserv\", &cs_hop);\n\tservice_named_unbind_command(\"chanserv\", &cs_vop);\n\tservice_named_unbind_command(\"chanserv\", &cs_forcexop);\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"template.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "command_t cs_sop = { \"SOP\", N_(\"Manipulates a channel SOP list.\"),\n                        AC_NONE, 3, cs_cmd_sop, { .path = \"cservice/xop\" } };",
            "command_t cs_aop = { \"AOP\", N_(\"Manipulates a channel AOP list.\"),\n                        AC_NONE, 3, cs_cmd_aop, { .path = \"cservice/xop\" } };",
            "command_t cs_hop = { \"HOP\", N_(\"Manipulates a channel HOP list.\"),\n\t\t\tAC_NONE, 3, cs_cmd_hop, { .path = \"cservice/xop\" } };",
            "command_t cs_vop = { \"VOP\", N_(\"Manipulates a channel VOP list.\"),\n                        AC_NONE, 3, cs_cmd_vop, { .path = \"cservice/xop\" } };",
            "command_t cs_forcexop = { \"FORCEXOP\", N_(\"Forces access levels to xOP levels.\"),\n                         AC_NONE, 1, cs_cmd_forcexop, { .path = \"cservice/forcexop\" } };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\ncommand_t cs_sop = { \"SOP\", N_(\"Manipulates a channel SOP list.\"),\n                        AC_NONE, 3, cs_cmd_sop, { .path = \"cservice/xop\" } };\ncommand_t cs_aop = { \"AOP\", N_(\"Manipulates a channel AOP list.\"),\n                        AC_NONE, 3, cs_cmd_aop, { .path = \"cservice/xop\" } };\ncommand_t cs_hop = { \"HOP\", N_(\"Manipulates a channel HOP list.\"),\n\t\t\tAC_NONE, 3, cs_cmd_hop, { .path = \"cservice/xop\" } };\ncommand_t cs_vop = { \"VOP\", N_(\"Manipulates a channel VOP list.\"),\n                        AC_NONE, 3, cs_cmd_vop, { .path = \"cservice/xop\" } };\ncommand_t cs_forcexop = { \"FORCEXOP\", N_(\"Forces access levels to xOP levels.\"),\n                         AC_NONE, 1, cs_cmd_forcexop, { .path = \"cservice/forcexop\" } };\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_aop);\n\tservice_named_unbind_command(\"chanserv\", &cs_sop);\n\tservice_named_unbind_command(\"chanserv\", &cs_hop);\n\tservice_named_unbind_command(\"chanserv\", &cs_vop);\n\tservice_named_unbind_command(\"chanserv\", &cs_forcexop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "object_unref",
          "args": [
            "ca"
          ],
          "line": 400
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_call_channel_acl_change",
          "args": [
            "&req"
          ],
          "line": 399
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nochange",
            "_(\"\\2%s\\2 is not on the %s list for \\2%s\\2.\")",
            "mt->name",
            "leveldesc",
            "mc->name"
          ],
          "line": 388
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_find_literal",
          "args": [
            "mc",
            "mt",
            "level"
          ],
          "line": 386
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"\\2%s\\2 has been removed from the %s list for \\2%s\\2.\")",
            "target",
            "leveldesc",
            "mc->name"
          ],
          "line": 382
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_SET",
            "\"DEL: \\2%s\\2 \\2%s\\2 from \\2%s\\2\"",
            "mc->name",
            "leveldesc",
            "target"
          ],
          "line": 381
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "mc",
            "\"\\2%s\\2 removed \\2%s\\2 from the %s list.\"",
            "get_source_name(si)",
            "target",
            "leveldesc"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_source_name",
          "args": [
            "si"
          ],
          "line": 380
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "object_unref",
          "args": [
            "ca"
          ],
          "line": 378
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_call_channel_acl_change",
          "args": [
            "&req"
          ],
          "line": 377
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nochange",
            "_(\"\\2%s\\2 is not on the %s list for \\2%s\\2.\")",
            "target",
            "leveldesc",
            "mc->name"
          ],
          "line": 366
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_find_host_literal",
          "args": [
            "mc",
            "target",
            "level"
          ],
          "line": 363
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_badparams",
            "_(\"\\2%s\\2 is neither a nickname nor a hostmask.\")",
            "target"
          ],
          "line": 359
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validhostmask",
          "args": [
            "target"
          ],
          "line": 357
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc);\n\nstatic void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc)\n{\n\tchanacs_t *ca;\n\thook_channel_acl_req_t req;\n\n\t/* let's finally make this sane.. --w00t */\n\tif (!mt)\n\t{\n\t\t/* we might be deleting a hostmask */\n\t\tif (!validhostmask(target))\n\t\t{\n\t\t\tcommand_fail(si, fault_badparams, _(\"\\2%s\\2 is neither a nickname nor a hostmask.\"), target);\n\t\t\treturn;\n\t\t}\n\n\t\tca = chanacs_find_host_literal(mc, target, level);\n\t\tif (ca == NULL || ca->level != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is not on the %s list for \\2%s\\2.\"), target, leveldesc, mc->name);\n\t\t\treturn;\n\t\t}\n\n\t\treq.ca = ca;\n\t\treq.oldlevel = ca->level;\n\n\t\tca->level = 0;\n\n\t\treq.newlevel = ca->level;\n\n\t\thook_call_channel_acl_change(&req);\n\t\tobject_unref(ca);\n\n\t\tverbose(mc, \"\\2%s\\2 removed \\2%s\\2 from the %s list.\", get_source_name(si), target, leveldesc);\n\t\tlogcommand(si, CMDLOG_SET, \"DEL: \\2%s\\2 \\2%s\\2 from \\2%s\\2\", mc->name, leveldesc, target);\n\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been removed from the %s list for \\2%s\\2.\"), target, leveldesc, mc->name);\n\t\treturn;\n\t}\n\n\tif (!(ca = chanacs_find_literal(mc, mt, level)) || ca->level != level)\n\t{\n\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is not on the %s list for \\2%s\\2.\"), mt->name, leveldesc, mc->name);\n\t\treturn;\n\t}\n\n\treq.ca = ca;\n\treq.oldlevel = ca->level;\n\n\tca->level = 0;\n\n\treq.newlevel = ca->level;\n\n\thook_call_channel_acl_change(&req);\n\tobject_unref(ca);\n\n\tcommand_success_nodata(si, _(\"\\2%s\\2 has been removed from the %s list for \\2%s\\2.\"), mt->name, leveldesc, mc->name);\n\tlogcommand(si, CMDLOG_SET, \"DEL: \\2%s\\2 \\2%s\\2 from \\2%s\\2\", mc->name, leveldesc, mt->name);\n\tverbose(mc, \"\\2%s\\2 removed \\2%s\\2 from the %s list.\", get_source_name(si), mt->name, leveldesc);\n}"
  },
  {
    "function_name": "cs_xop_do_add",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
    "lines": "213-346",
    "snippet": "static void cs_xop_do_add(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc, unsigned int restrictflags)\n{\n\tchanacs_t *ca;\n\tunsigned int addflags = level, removeflags = ~level;\n\tbool isnew;\n\thook_channel_acl_req_t req;\n\n\tif (!mt)\n\t{\n\t\t/* we might be adding a hostmask */\n\t\tif (!validhostmask(target))\n\t\t{\n\t\t\tcommand_fail(si, fault_badparams, _(\"\\2%s\\2 is neither a registered account nor a hostmask.\"), target);\n\t\t\treturn;\n\t\t}\n\n\t\ttarget = collapse(target);\n\t\tca = chanacs_open(mc, NULL, target, true, entity(si->smu));\n\t\tif (ca->level == level)\n\t\t{\n\t\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is already on the %s list for \\2%s\\2\"), target, leveldesc, mc->name);\n\t\t\treturn;\n\t\t}\n\t\tisnew = ca->level == 0;\n\n\t\tif (isnew && chanacs_is_table_full(ca))\n\t\t{\n\t\t\tcommand_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);\n\t\t\tchanacs_close(ca);\n\t\t\treturn;\n\t\t}\n\n\t\treq.ca = ca;\n\t\treq.oldlevel = ca->level;\n\n\t\tif (!chanacs_modify(ca, &addflags, &removeflags, restrictflags))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to modify the access entry for \\2%s\\2 on \\2%s\\2.\"), target, mc->name);\n\t\t\tchanacs_close(ca);\n\t\t\treturn;\n\t\t}\n\n\t\treq.newlevel = ca->level;\n\n\t\thook_call_channel_acl_change(&req);\n\n\t\tchanacs_close(ca);\n\n\t\tif (!isnew)\n\t\t{\n\t\t\t/* they have access? change it! */\n\t\t\tlogcommand(si, CMDLOG_SET, \"ADD: \\2%s\\2 \\2%s\\2 on \\2%s\\2 (changed access)\", mc->name, leveldesc, target);\n\t\t\tcommand_success_nodata(si, _(\"\\2%s\\2's access on \\2%s\\2 has been changed to \\2%s\\2.\"), target, mc->name, leveldesc);\n\t\t\tverbose(mc, \"\\2%s\\2 changed \\2%s\\2's access to \\2%s\\2.\", get_source_name(si), target, leveldesc);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogcommand(si, CMDLOG_SET, \"ADD: \\2%s\\2 \\2%s\\2 on \\2%s\\2\", mc->name, leveldesc, target);\n\t\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been added to the %s list for \\2%s\\2.\"), target, leveldesc, mc->name);\n\t\t\tverbose(mc, \"\\2%s\\2 added \\2%s\\2 to the %s list.\", get_source_name(si), target, leveldesc);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tca = chanacs_open(mc, mt, NULL, true, entity(si->smu));\n\n\tif (ca->level & CA_FOUNDER)\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is the founder for \\2%s\\2 and may not be added to the %s list.\"), mt->name, mc->name, leveldesc);\n\t\treturn;\n\t}\n\n\tif (ca->level == level)\n\t{\n\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is already on the %s list for \\2%s\\2.\"), mt->name, leveldesc, mc->name);\n\t\treturn;\n\t}\n\n\t/* NEVEROP logic moved here\n\t * Allow changing access level, but not adding\n\t * -- jilles */\n\tif (isuser(mt) && MU_NEVEROP & user(mt)->flags && (ca->level == 0 || ca->level == CA_AKICK))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 does not wish to be added to channel access lists (NEVEROP set).\"), mt->name);\n\t\tchanacs_close(ca);\n\t\treturn;\n\t}\n\n\t/*\n\t * this is a little more cryptic than it used to be, but much cleaner. Functionally should be\n\t * the same, with the exception that if they had access before, now it doesn't tell what it got\n\t * changed from (I considered the effort to put an extra lookup in not worth it. --w00t\n\t */\n\t/* just assume there's just one entry for that user -- jilles */\n\n\tisnew = ca->level == 0;\n\tif (isnew && chanacs_is_table_full(ca))\n\t{\n\t\tcommand_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);\n\t\tchanacs_close(ca);\n\t\treturn;\n\t}\n\n\treq.ca = ca;\n\treq.oldlevel = ca->level;\n\n\tif (!chanacs_modify(ca, &addflags, &removeflags, restrictflags))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to modify the access entry for \\2%s\\2 on \\2%s\\2.\"), mt->name, mc->name);\n\t\tchanacs_close(ca);\n\t\treturn;\n\t}\n\n\treq.newlevel = ca->level;\n\n\thook_call_channel_acl_change(&req);\n\tchanacs_close(ca);\n\n\tif (!isnew)\n\t{\n\t\t/* they have access? change it! */\n\t\tlogcommand(si, CMDLOG_SET, \"ADD: \\2%s\\2 \\2%s\\2 on \\2%s\\2 (changed access)\", mc->name, leveldesc, mt->name);\n\t\tcommand_success_nodata(si, _(\"\\2%s\\2's access on \\2%s\\2 has been changed to \\2%s\\2.\"), mt->name, mc->name, leveldesc);\n\t\tverbose(mc, \"\\2%s\\2 changed \\2%s\\2's access to \\2%s\\2.\", get_source_name(si), mt->name, leveldesc);\n\t}\n\telse\n\t{\n\t\t/* they have no access, add */\n\t\tlogcommand(si, CMDLOG_SET, \"ADD: \\2%s\\2 \\2%s\\2 on \\2%s\\2\", mc->name, leveldesc, mt->name);\n\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been added to the %s list for \\2%s\\2.\"), mt->name, leveldesc, mc->name);\n\t\tverbose(mc, \"\\2%s\\2 added \\2%s\\2 to the %s list.\", get_source_name(si), mt->name, leveldesc);\n\t}\n}",
    "includes": [
      "#include \"chanserv.h\"",
      "#include \"template.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_xop_do_add(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc, unsigned int restrictflags);",
      "static void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "mc",
            "\"\\2%s\\2 added \\2%s\\2 to the %s list.\"",
            "get_source_name(si)",
            "mt->name",
            "leveldesc"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_source_name",
          "args": [
            "si"
          ],
          "line": 344
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"\\2%s\\2 has been added to the %s list for \\2%s\\2.\")",
            "mt->name",
            "leveldesc",
            "mc->name"
          ],
          "line": 343
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"\\2%s\\2 has been added to the %s list for \\2%s\\2.\""
          ],
          "line": 343
        },
        "resolved": true,
        "details": {
          "function_name": "_moddeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
          "lines": "52-59",
          "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_aop);\n\tservice_named_unbind_command(\"chanserv\", &cs_sop);\n\tservice_named_unbind_command(\"chanserv\", &cs_hop);\n\tservice_named_unbind_command(\"chanserv\", &cs_vop);\n\tservice_named_unbind_command(\"chanserv\", &cs_forcexop);\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"template.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "command_t cs_sop = { \"SOP\", N_(\"Manipulates a channel SOP list.\"),\n                        AC_NONE, 3, cs_cmd_sop, { .path = \"cservice/xop\" } };",
            "command_t cs_aop = { \"AOP\", N_(\"Manipulates a channel AOP list.\"),\n                        AC_NONE, 3, cs_cmd_aop, { .path = \"cservice/xop\" } };",
            "command_t cs_hop = { \"HOP\", N_(\"Manipulates a channel HOP list.\"),\n\t\t\tAC_NONE, 3, cs_cmd_hop, { .path = \"cservice/xop\" } };",
            "command_t cs_vop = { \"VOP\", N_(\"Manipulates a channel VOP list.\"),\n                        AC_NONE, 3, cs_cmd_vop, { .path = \"cservice/xop\" } };",
            "command_t cs_forcexop = { \"FORCEXOP\", N_(\"Forces access levels to xOP levels.\"),\n                         AC_NONE, 1, cs_cmd_forcexop, { .path = \"cservice/forcexop\" } };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\ncommand_t cs_sop = { \"SOP\", N_(\"Manipulates a channel SOP list.\"),\n                        AC_NONE, 3, cs_cmd_sop, { .path = \"cservice/xop\" } };\ncommand_t cs_aop = { \"AOP\", N_(\"Manipulates a channel AOP list.\"),\n                        AC_NONE, 3, cs_cmd_aop, { .path = \"cservice/xop\" } };\ncommand_t cs_hop = { \"HOP\", N_(\"Manipulates a channel HOP list.\"),\n\t\t\tAC_NONE, 3, cs_cmd_hop, { .path = \"cservice/xop\" } };\ncommand_t cs_vop = { \"VOP\", N_(\"Manipulates a channel VOP list.\"),\n                        AC_NONE, 3, cs_cmd_vop, { .path = \"cservice/xop\" } };\ncommand_t cs_forcexop = { \"FORCEXOP\", N_(\"Forces access levels to xOP levels.\"),\n                         AC_NONE, 1, cs_cmd_forcexop, { .path = \"cservice/forcexop\" } };\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_aop);\n\tservice_named_unbind_command(\"chanserv\", &cs_sop);\n\tservice_named_unbind_command(\"chanserv\", &cs_hop);\n\tservice_named_unbind_command(\"chanserv\", &cs_vop);\n\tservice_named_unbind_command(\"chanserv\", &cs_forcexop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_SET",
            "\"ADD: \\2%s\\2 \\2%s\\2 on \\2%s\\2\"",
            "mc->name",
            "leveldesc",
            "mt->name"
          ],
          "line": 342
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "mc",
            "\"\\2%s\\2 changed \\2%s\\2's access to \\2%s\\2.\"",
            "get_source_name(si)",
            "mt->name",
            "leveldesc"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_source_name",
          "args": [
            "si"
          ],
          "line": 337
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"\\2%s\\2's access on \\2%s\\2 has been changed to \\2%s\\2.\")",
            "mt->name",
            "mc->name",
            "leveldesc"
          ],
          "line": 336
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_SET",
            "\"ADD: \\2%s\\2 \\2%s\\2 on \\2%s\\2 (changed access)\"",
            "mc->name",
            "leveldesc",
            "mt->name"
          ],
          "line": 335
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca"
          ],
          "line": 330
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_call_channel_acl_change",
          "args": [
            "&req"
          ],
          "line": 329
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca"
          ],
          "line": 323
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not authorized to modify the access entry for \\2%s\\2 on \\2%s\\2.\")",
            "mt->name",
            "mc->name"
          ],
          "line": 322
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_modify",
          "args": [
            "ca",
            "&addflags",
            "&removeflags",
            "restrictflags"
          ],
          "line": 320
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca"
          ],
          "line": 313
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_toomany",
            "_(\"Channel %s access list is full.\")",
            "mc->name"
          ],
          "line": 312
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_is_table_full",
          "args": [
            "ca"
          ],
          "line": 310
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca"
          ],
          "line": 298
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"\\2%s\\2 does not wish to be added to channel access lists (NEVEROP set).\")",
            "mt->name"
          ],
          "line": 297
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user",
          "args": [
            "mt"
          ],
          "line": 295
        },
        "resolved": true,
        "details": {
          "function_name": "sync_myuser",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/sync.c",
          "lines": "266-276",
          "snippet": "static void sync_myuser(myuser_t *mu)\n{\n\tmowgli_node_t *iter;\n\n\treturn_if_fail(mu != NULL);\n\n\tMOWGLI_ITER_FOREACH(iter, mu->logins.head)\n\t{\n\t\tsync_user(iter->data);\n\t}\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic void sync_myuser(myuser_t *mu)\n{\n\tmowgli_node_t *iter;\n\n\treturn_if_fail(mu != NULL);\n\n\tMOWGLI_ITER_FOREACH(iter, mu->logins.head)\n\t{\n\t\tsync_user(iter->data);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "isuser",
          "args": [
            "mt"
          ],
          "line": 295
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nochange",
            "_(\"\\2%s\\2 is already on the %s list for \\2%s\\2.\")",
            "mt->name",
            "leveldesc",
            "mc->name"
          ],
          "line": 288
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"\\2%s\\2 is the founder for \\2%s\\2 and may not be added to the %s list.\")",
            "mt->name",
            "mc->name",
            "leveldesc"
          ],
          "line": 282
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_open",
          "args": [
            "mc",
            "mt",
            "NULL",
            "true",
            "entity(si->smu)"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entity",
          "args": [
            "si->smu"
          ],
          "line": 278
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "mc",
            "\"\\2%s\\2 added \\2%s\\2 to the %s list.\"",
            "get_source_name(si)",
            "target",
            "leveldesc"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_source_name",
          "args": [
            "si"
          ],
          "line": 272
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"\\2%s\\2 has been added to the %s list for \\2%s\\2.\")",
            "target",
            "leveldesc",
            "mc->name"
          ],
          "line": 271
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_SET",
            "\"ADD: \\2%s\\2 \\2%s\\2 on \\2%s\\2\"",
            "mc->name",
            "leveldesc",
            "target"
          ],
          "line": 270
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "verbose",
          "args": [
            "mc",
            "\"\\2%s\\2 changed \\2%s\\2's access to \\2%s\\2.\"",
            "get_source_name(si)",
            "target",
            "leveldesc"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_source_name",
          "args": [
            "si"
          ],
          "line": 266
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"\\2%s\\2's access on \\2%s\\2 has been changed to \\2%s\\2.\")",
            "target",
            "mc->name",
            "leveldesc"
          ],
          "line": 265
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_SET",
            "\"ADD: \\2%s\\2 \\2%s\\2 on \\2%s\\2 (changed access)\"",
            "mc->name",
            "leveldesc",
            "target"
          ],
          "line": 264
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca"
          ],
          "line": 259
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_call_channel_acl_change",
          "args": [
            "&req"
          ],
          "line": 257
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca"
          ],
          "line": 251
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not authorized to modify the access entry for \\2%s\\2 on \\2%s\\2.\")",
            "target",
            "mc->name"
          ],
          "line": 250
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_modify",
          "args": [
            "ca",
            "&addflags",
            "&removeflags",
            "restrictflags"
          ],
          "line": 248
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_close",
          "args": [
            "ca"
          ],
          "line": 241
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_toomany",
            "_(\"Channel %s access list is full.\")",
            "mc->name"
          ],
          "line": 240
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_is_table_full",
          "args": [
            "ca"
          ],
          "line": 238
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nochange",
            "_(\"\\2%s\\2 is already on the %s list for \\2%s\\2\")",
            "target",
            "leveldesc",
            "mc->name"
          ],
          "line": 233
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_open",
          "args": [
            "mc",
            "NULL",
            "target",
            "true",
            "entity(si->smu)"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entity",
          "args": [
            "si->smu"
          ],
          "line": 230
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "collapse",
          "args": [
            "target"
          ],
          "line": 229
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_badparams",
            "_(\"\\2%s\\2 is neither a registered account nor a hostmask.\")",
            "target"
          ],
          "line": 225
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "validhostmask",
          "args": [
            "target"
          ],
          "line": 223
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void cs_xop_do_add(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc, unsigned int restrictflags);\nstatic void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc);\n\nstatic void cs_xop_do_add(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc, unsigned int restrictflags)\n{\n\tchanacs_t *ca;\n\tunsigned int addflags = level, removeflags = ~level;\n\tbool isnew;\n\thook_channel_acl_req_t req;\n\n\tif (!mt)\n\t{\n\t\t/* we might be adding a hostmask */\n\t\tif (!validhostmask(target))\n\t\t{\n\t\t\tcommand_fail(si, fault_badparams, _(\"\\2%s\\2 is neither a registered account nor a hostmask.\"), target);\n\t\t\treturn;\n\t\t}\n\n\t\ttarget = collapse(target);\n\t\tca = chanacs_open(mc, NULL, target, true, entity(si->smu));\n\t\tif (ca->level == level)\n\t\t{\n\t\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is already on the %s list for \\2%s\\2\"), target, leveldesc, mc->name);\n\t\t\treturn;\n\t\t}\n\t\tisnew = ca->level == 0;\n\n\t\tif (isnew && chanacs_is_table_full(ca))\n\t\t{\n\t\t\tcommand_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);\n\t\t\tchanacs_close(ca);\n\t\t\treturn;\n\t\t}\n\n\t\treq.ca = ca;\n\t\treq.oldlevel = ca->level;\n\n\t\tif (!chanacs_modify(ca, &addflags, &removeflags, restrictflags))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to modify the access entry for \\2%s\\2 on \\2%s\\2.\"), target, mc->name);\n\t\t\tchanacs_close(ca);\n\t\t\treturn;\n\t\t}\n\n\t\treq.newlevel = ca->level;\n\n\t\thook_call_channel_acl_change(&req);\n\n\t\tchanacs_close(ca);\n\n\t\tif (!isnew)\n\t\t{\n\t\t\t/* they have access? change it! */\n\t\t\tlogcommand(si, CMDLOG_SET, \"ADD: \\2%s\\2 \\2%s\\2 on \\2%s\\2 (changed access)\", mc->name, leveldesc, target);\n\t\t\tcommand_success_nodata(si, _(\"\\2%s\\2's access on \\2%s\\2 has been changed to \\2%s\\2.\"), target, mc->name, leveldesc);\n\t\t\tverbose(mc, \"\\2%s\\2 changed \\2%s\\2's access to \\2%s\\2.\", get_source_name(si), target, leveldesc);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogcommand(si, CMDLOG_SET, \"ADD: \\2%s\\2 \\2%s\\2 on \\2%s\\2\", mc->name, leveldesc, target);\n\t\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been added to the %s list for \\2%s\\2.\"), target, leveldesc, mc->name);\n\t\t\tverbose(mc, \"\\2%s\\2 added \\2%s\\2 to the %s list.\", get_source_name(si), target, leveldesc);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tca = chanacs_open(mc, mt, NULL, true, entity(si->smu));\n\n\tif (ca->level & CA_FOUNDER)\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is the founder for \\2%s\\2 and may not be added to the %s list.\"), mt->name, mc->name, leveldesc);\n\t\treturn;\n\t}\n\n\tif (ca->level == level)\n\t{\n\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is already on the %s list for \\2%s\\2.\"), mt->name, leveldesc, mc->name);\n\t\treturn;\n\t}\n\n\t/* NEVEROP logic moved here\n\t * Allow changing access level, but not adding\n\t * -- jilles */\n\tif (isuser(mt) && MU_NEVEROP & user(mt)->flags && (ca->level == 0 || ca->level == CA_AKICK))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 does not wish to be added to channel access lists (NEVEROP set).\"), mt->name);\n\t\tchanacs_close(ca);\n\t\treturn;\n\t}\n\n\t/*\n\t * this is a little more cryptic than it used to be, but much cleaner. Functionally should be\n\t * the same, with the exception that if they had access before, now it doesn't tell what it got\n\t * changed from (I considered the effort to put an extra lookup in not worth it. --w00t\n\t */\n\t/* just assume there's just one entry for that user -- jilles */\n\n\tisnew = ca->level == 0;\n\tif (isnew && chanacs_is_table_full(ca))\n\t{\n\t\tcommand_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);\n\t\tchanacs_close(ca);\n\t\treturn;\n\t}\n\n\treq.ca = ca;\n\treq.oldlevel = ca->level;\n\n\tif (!chanacs_modify(ca, &addflags, &removeflags, restrictflags))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to modify the access entry for \\2%s\\2 on \\2%s\\2.\"), mt->name, mc->name);\n\t\tchanacs_close(ca);\n\t\treturn;\n\t}\n\n\treq.newlevel = ca->level;\n\n\thook_call_channel_acl_change(&req);\n\tchanacs_close(ca);\n\n\tif (!isnew)\n\t{\n\t\t/* they have access? change it! */\n\t\tlogcommand(si, CMDLOG_SET, \"ADD: \\2%s\\2 \\2%s\\2 on \\2%s\\2 (changed access)\", mc->name, leveldesc, mt->name);\n\t\tcommand_success_nodata(si, _(\"\\2%s\\2's access on \\2%s\\2 has been changed to \\2%s\\2.\"), mt->name, mc->name, leveldesc);\n\t\tverbose(mc, \"\\2%s\\2 changed \\2%s\\2's access to \\2%s\\2.\", get_source_name(si), mt->name, leveldesc);\n\t}\n\telse\n\t{\n\t\t/* they have no access, add */\n\t\tlogcommand(si, CMDLOG_SET, \"ADD: \\2%s\\2 \\2%s\\2 on \\2%s\\2\", mc->name, leveldesc, mt->name);\n\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been added to the %s list for \\2%s\\2.\"), mt->name, leveldesc, mc->name);\n\t\tverbose(mc, \"\\2%s\\2 added \\2%s\\2 to the %s list.\", get_source_name(si), mt->name, leveldesc);\n\t}\n}"
  },
  {
    "function_name": "cs_cmd_hop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
    "lines": "200-210",
    "snippet": "static void cs_cmd_hop(sourceinfo_t *si, int parc, char *parv[])\n{\n\t/* Don't reject the command. This helps the rare case where\n\t * a network switches to a non-halfop ircd: users can still\n\t * remove pre-transition HOP entries.\n\t */\n\tif (!ircd->uses_halfops && si->su != NULL)\n\t\tnotice(chansvs.nick, si->su->nick, \"Warning: Your IRC server does not support halfops.\");\n\n\tcs_xop(si, parc, parv, \"HOP\");\n}",
    "includes": [
      "#include \"chanserv.h\"",
      "#include \"template.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_cmd_sop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_aop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_hop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_vop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_forcexop(sourceinfo_t *si, int parc, char *parv[]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cs_xop",
          "args": [
            "si",
            "parc",
            "parv",
            "\"HOP\""
          ],
          "line": 209
        },
        "resolved": true,
        "details": {
          "function_name": "cs_xop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
          "lines": "61-183",
          "snippet": "static void cs_xop(sourceinfo_t *si, int parc, char *parv[], const char *leveldesc)\n{\n\tmyentity_t *mt;\n\tmychan_t *mc;\n\tbool operoverride = false;\n\tunsigned int restrictflags;\n\tconst char *chan = parv[0];\n\tconst char *cmd = parv[1];\n\tchar *uname = parv[2];\n\tunsigned int level;\n\n\tif (!cmd || !chan)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"xOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: SOP|AOP|HOP|VOP <#channel> ADD|DEL|LIST <nickname>\"));\n\t\treturn;\n\t}\n\n\tif ((strcasecmp(\"LIST\", cmd)) && (!uname))\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"xOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: SOP|AOP|HOP|VOP <#channel> ADD|DEL|LIST <nickname>\"));\n\t\treturn;\n\t}\n\n\t/* make sure they're registered, logged in\n\t * and the founder of the channel before\n\t * we go any further.\n\t */\n\tif (!si->smu)\n\t{\n\t\t/* if they're opers and just want to LIST, they don't have to log in */\n\t\tif (!(has_priv(si, PRIV_CHAN_AUSPEX) && !strcasecmp(\"LIST\", cmd)))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not logged in.\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\") && (!has_priv(si, PRIV_CHAN_AUSPEX) || strcasecmp(\"LIST\", cmd)))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tlevel = get_template_flags(mc, leveldesc);\n\tif (level & CA_FOUNDER)\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 %s template has founder flag, not allowing xOP command.\"), chan, leveldesc);\n\t\treturn;\n\t}\n\n\t/* ADD */\n\tif (!strcasecmp(\"ADD\", cmd))\n\t{\n\t\tmt = myentity_find_ext(uname);\n\n\t\t/* As in /cs flags, allow founder to do anything */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER)\n\t\t\trestrictflags = ca_all;\n\t\t/* The following is a bit complicated, to allow for\n\t\t * possible future denial of granting +f */\n\t\tif (!(restrictflags & CA_FLAGS))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\tif ((restrictflags & level) != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\tcs_xop_do_add(si, mc, mt, uname, level, leveldesc, restrictflags);\n\t}\n\n\telse if (!strcasecmp(\"DEL\", cmd))\n\t{\n\t\tmt = myentity_find_ext(uname);\n\n\t\t/* As in /cs flags, allow founder to do anything -- fix for #64: allow self removal. */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER || entity(si->smu) == mt)\n\t\t\trestrictflags = ca_all;\n\t\t/* The following is a bit complicated, to allow for\n\t\t * possible future denial of granting +f */\n\t\tif (!(restrictflags & CA_FLAGS))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\tif ((restrictflags & level) != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\tcs_xop_do_del(si, mc, mt, uname, level, leveldesc);\n\t}\n\n\telse if (!strcasecmp(\"LIST\", cmd))\n\t{\n\t\tif (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t\t{\n\t\t\tif (has_priv(si, PRIV_CHAN_AUSPEX))\n\t\t\t\toperoverride = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcs_xop_do_list(si, mc, level, leveldesc, operoverride);\n\t}\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"template.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cs_xop_do_add(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc, unsigned int restrictflags);",
            "static void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc);",
            "static void cs_xop_do_list(sourceinfo_t *si, mychan_t *mc, unsigned int level, const char *leveldesc, bool operoverride);",
            "static void cs_cmd_sop(sourceinfo_t *si, int parc, char *parv[]);",
            "static void cs_cmd_aop(sourceinfo_t *si, int parc, char *parv[]);",
            "static void cs_cmd_hop(sourceinfo_t *si, int parc, char *parv[]);",
            "static void cs_cmd_vop(sourceinfo_t *si, int parc, char *parv[]);",
            "static void cs_cmd_forcexop(sourceinfo_t *si, int parc, char *parv[]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void cs_xop_do_add(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc, unsigned int restrictflags);\nstatic void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc);\nstatic void cs_xop_do_list(sourceinfo_t *si, mychan_t *mc, unsigned int level, const char *leveldesc, bool operoverride);\nstatic void cs_cmd_sop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_aop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_hop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_vop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_forcexop(sourceinfo_t *si, int parc, char *parv[]);\n\nstatic void cs_xop(sourceinfo_t *si, int parc, char *parv[], const char *leveldesc)\n{\n\tmyentity_t *mt;\n\tmychan_t *mc;\n\tbool operoverride = false;\n\tunsigned int restrictflags;\n\tconst char *chan = parv[0];\n\tconst char *cmd = parv[1];\n\tchar *uname = parv[2];\n\tunsigned int level;\n\n\tif (!cmd || !chan)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"xOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: SOP|AOP|HOP|VOP <#channel> ADD|DEL|LIST <nickname>\"));\n\t\treturn;\n\t}\n\n\tif ((strcasecmp(\"LIST\", cmd)) && (!uname))\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"xOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: SOP|AOP|HOP|VOP <#channel> ADD|DEL|LIST <nickname>\"));\n\t\treturn;\n\t}\n\n\t/* make sure they're registered, logged in\n\t * and the founder of the channel before\n\t * we go any further.\n\t */\n\tif (!si->smu)\n\t{\n\t\t/* if they're opers and just want to LIST, they don't have to log in */\n\t\tif (!(has_priv(si, PRIV_CHAN_AUSPEX) && !strcasecmp(\"LIST\", cmd)))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not logged in.\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\") && (!has_priv(si, PRIV_CHAN_AUSPEX) || strcasecmp(\"LIST\", cmd)))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tlevel = get_template_flags(mc, leveldesc);\n\tif (level & CA_FOUNDER)\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 %s template has founder flag, not allowing xOP command.\"), chan, leveldesc);\n\t\treturn;\n\t}\n\n\t/* ADD */\n\tif (!strcasecmp(\"ADD\", cmd))\n\t{\n\t\tmt = myentity_find_ext(uname);\n\n\t\t/* As in /cs flags, allow founder to do anything */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER)\n\t\t\trestrictflags = ca_all;\n\t\t/* The following is a bit complicated, to allow for\n\t\t * possible future denial of granting +f */\n\t\tif (!(restrictflags & CA_FLAGS))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\tif ((restrictflags & level) != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\tcs_xop_do_add(si, mc, mt, uname, level, leveldesc, restrictflags);\n\t}\n\n\telse if (!strcasecmp(\"DEL\", cmd))\n\t{\n\t\tmt = myentity_find_ext(uname);\n\n\t\t/* As in /cs flags, allow founder to do anything -- fix for #64: allow self removal. */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER || entity(si->smu) == mt)\n\t\t\trestrictflags = ca_all;\n\t\t/* The following is a bit complicated, to allow for\n\t\t * possible future denial of granting +f */\n\t\tif (!(restrictflags & CA_FLAGS))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\tif ((restrictflags & level) != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\tcs_xop_do_del(si, mc, mt, uname, level, leveldesc);\n\t}\n\n\telse if (!strcasecmp(\"LIST\", cmd))\n\t{\n\t\tif (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t\t{\n\t\t\tif (has_priv(si, PRIV_CHAN_AUSPEX))\n\t\t\t\toperoverride = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcs_xop_do_list(si, mc, level, leveldesc, operoverride);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "notice",
          "args": [
            "chansvs.nick",
            "si->su->nick",
            "\"Warning: Your IRC server does not support halfops.\""
          ],
          "line": 207
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void cs_cmd_sop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_aop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_hop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_vop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_forcexop(sourceinfo_t *si, int parc, char *parv[]);\n\nstatic void cs_cmd_hop(sourceinfo_t *si, int parc, char *parv[])\n{\n\t/* Don't reject the command. This helps the rare case where\n\t * a network switches to a non-halfop ircd: users can still\n\t * remove pre-transition HOP entries.\n\t */\n\tif (!ircd->uses_halfops && si->su != NULL)\n\t\tnotice(chansvs.nick, si->su->nick, \"Warning: Your IRC server does not support halfops.\");\n\n\tcs_xop(si, parc, parv, \"HOP\");\n}"
  },
  {
    "function_name": "cs_cmd_vop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
    "lines": "195-198",
    "snippet": "static void cs_cmd_vop(sourceinfo_t *si, int parc, char *parv[])\n{\n\tcs_xop(si, parc, parv, \"VOP\");\n}",
    "includes": [
      "#include \"chanserv.h\"",
      "#include \"template.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_cmd_sop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_aop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_hop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_vop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_forcexop(sourceinfo_t *si, int parc, char *parv[]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cs_xop",
          "args": [
            "si",
            "parc",
            "parv",
            "\"VOP\""
          ],
          "line": 197
        },
        "resolved": true,
        "details": {
          "function_name": "cs_xop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
          "lines": "61-183",
          "snippet": "static void cs_xop(sourceinfo_t *si, int parc, char *parv[], const char *leveldesc)\n{\n\tmyentity_t *mt;\n\tmychan_t *mc;\n\tbool operoverride = false;\n\tunsigned int restrictflags;\n\tconst char *chan = parv[0];\n\tconst char *cmd = parv[1];\n\tchar *uname = parv[2];\n\tunsigned int level;\n\n\tif (!cmd || !chan)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"xOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: SOP|AOP|HOP|VOP <#channel> ADD|DEL|LIST <nickname>\"));\n\t\treturn;\n\t}\n\n\tif ((strcasecmp(\"LIST\", cmd)) && (!uname))\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"xOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: SOP|AOP|HOP|VOP <#channel> ADD|DEL|LIST <nickname>\"));\n\t\treturn;\n\t}\n\n\t/* make sure they're registered, logged in\n\t * and the founder of the channel before\n\t * we go any further.\n\t */\n\tif (!si->smu)\n\t{\n\t\t/* if they're opers and just want to LIST, they don't have to log in */\n\t\tif (!(has_priv(si, PRIV_CHAN_AUSPEX) && !strcasecmp(\"LIST\", cmd)))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not logged in.\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\") && (!has_priv(si, PRIV_CHAN_AUSPEX) || strcasecmp(\"LIST\", cmd)))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tlevel = get_template_flags(mc, leveldesc);\n\tif (level & CA_FOUNDER)\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 %s template has founder flag, not allowing xOP command.\"), chan, leveldesc);\n\t\treturn;\n\t}\n\n\t/* ADD */\n\tif (!strcasecmp(\"ADD\", cmd))\n\t{\n\t\tmt = myentity_find_ext(uname);\n\n\t\t/* As in /cs flags, allow founder to do anything */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER)\n\t\t\trestrictflags = ca_all;\n\t\t/* The following is a bit complicated, to allow for\n\t\t * possible future denial of granting +f */\n\t\tif (!(restrictflags & CA_FLAGS))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\tif ((restrictflags & level) != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\tcs_xop_do_add(si, mc, mt, uname, level, leveldesc, restrictflags);\n\t}\n\n\telse if (!strcasecmp(\"DEL\", cmd))\n\t{\n\t\tmt = myentity_find_ext(uname);\n\n\t\t/* As in /cs flags, allow founder to do anything -- fix for #64: allow self removal. */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER || entity(si->smu) == mt)\n\t\t\trestrictflags = ca_all;\n\t\t/* The following is a bit complicated, to allow for\n\t\t * possible future denial of granting +f */\n\t\tif (!(restrictflags & CA_FLAGS))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\tif ((restrictflags & level) != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\tcs_xop_do_del(si, mc, mt, uname, level, leveldesc);\n\t}\n\n\telse if (!strcasecmp(\"LIST\", cmd))\n\t{\n\t\tif (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t\t{\n\t\t\tif (has_priv(si, PRIV_CHAN_AUSPEX))\n\t\t\t\toperoverride = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcs_xop_do_list(si, mc, level, leveldesc, operoverride);\n\t}\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"template.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cs_xop_do_add(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc, unsigned int restrictflags);",
            "static void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc);",
            "static void cs_xop_do_list(sourceinfo_t *si, mychan_t *mc, unsigned int level, const char *leveldesc, bool operoverride);",
            "static void cs_cmd_sop(sourceinfo_t *si, int parc, char *parv[]);",
            "static void cs_cmd_aop(sourceinfo_t *si, int parc, char *parv[]);",
            "static void cs_cmd_hop(sourceinfo_t *si, int parc, char *parv[]);",
            "static void cs_cmd_vop(sourceinfo_t *si, int parc, char *parv[]);",
            "static void cs_cmd_forcexop(sourceinfo_t *si, int parc, char *parv[]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void cs_xop_do_add(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc, unsigned int restrictflags);\nstatic void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc);\nstatic void cs_xop_do_list(sourceinfo_t *si, mychan_t *mc, unsigned int level, const char *leveldesc, bool operoverride);\nstatic void cs_cmd_sop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_aop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_hop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_vop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_forcexop(sourceinfo_t *si, int parc, char *parv[]);\n\nstatic void cs_xop(sourceinfo_t *si, int parc, char *parv[], const char *leveldesc)\n{\n\tmyentity_t *mt;\n\tmychan_t *mc;\n\tbool operoverride = false;\n\tunsigned int restrictflags;\n\tconst char *chan = parv[0];\n\tconst char *cmd = parv[1];\n\tchar *uname = parv[2];\n\tunsigned int level;\n\n\tif (!cmd || !chan)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"xOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: SOP|AOP|HOP|VOP <#channel> ADD|DEL|LIST <nickname>\"));\n\t\treturn;\n\t}\n\n\tif ((strcasecmp(\"LIST\", cmd)) && (!uname))\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"xOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: SOP|AOP|HOP|VOP <#channel> ADD|DEL|LIST <nickname>\"));\n\t\treturn;\n\t}\n\n\t/* make sure they're registered, logged in\n\t * and the founder of the channel before\n\t * we go any further.\n\t */\n\tif (!si->smu)\n\t{\n\t\t/* if they're opers and just want to LIST, they don't have to log in */\n\t\tif (!(has_priv(si, PRIV_CHAN_AUSPEX) && !strcasecmp(\"LIST\", cmd)))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not logged in.\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\") && (!has_priv(si, PRIV_CHAN_AUSPEX) || strcasecmp(\"LIST\", cmd)))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tlevel = get_template_flags(mc, leveldesc);\n\tif (level & CA_FOUNDER)\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 %s template has founder flag, not allowing xOP command.\"), chan, leveldesc);\n\t\treturn;\n\t}\n\n\t/* ADD */\n\tif (!strcasecmp(\"ADD\", cmd))\n\t{\n\t\tmt = myentity_find_ext(uname);\n\n\t\t/* As in /cs flags, allow founder to do anything */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER)\n\t\t\trestrictflags = ca_all;\n\t\t/* The following is a bit complicated, to allow for\n\t\t * possible future denial of granting +f */\n\t\tif (!(restrictflags & CA_FLAGS))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\tif ((restrictflags & level) != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\tcs_xop_do_add(si, mc, mt, uname, level, leveldesc, restrictflags);\n\t}\n\n\telse if (!strcasecmp(\"DEL\", cmd))\n\t{\n\t\tmt = myentity_find_ext(uname);\n\n\t\t/* As in /cs flags, allow founder to do anything -- fix for #64: allow self removal. */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER || entity(si->smu) == mt)\n\t\t\trestrictflags = ca_all;\n\t\t/* The following is a bit complicated, to allow for\n\t\t * possible future denial of granting +f */\n\t\tif (!(restrictflags & CA_FLAGS))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\tif ((restrictflags & level) != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\tcs_xop_do_del(si, mc, mt, uname, level, leveldesc);\n\t}\n\n\telse if (!strcasecmp(\"LIST\", cmd))\n\t{\n\t\tif (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t\t{\n\t\t\tif (has_priv(si, PRIV_CHAN_AUSPEX))\n\t\t\t\toperoverride = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcs_xop_do_list(si, mc, level, leveldesc, operoverride);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void cs_cmd_sop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_aop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_hop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_vop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_forcexop(sourceinfo_t *si, int parc, char *parv[]);\n\nstatic void cs_cmd_vop(sourceinfo_t *si, int parc, char *parv[])\n{\n\tcs_xop(si, parc, parv, \"VOP\");\n}"
  },
  {
    "function_name": "cs_cmd_aop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
    "lines": "190-193",
    "snippet": "static void cs_cmd_aop(sourceinfo_t *si, int parc, char *parv[])\n{\n\tcs_xop(si, parc, parv, \"AOP\");\n}",
    "includes": [
      "#include \"chanserv.h\"",
      "#include \"template.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_cmd_sop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_aop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_hop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_vop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_forcexop(sourceinfo_t *si, int parc, char *parv[]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cs_xop",
          "args": [
            "si",
            "parc",
            "parv",
            "\"AOP\""
          ],
          "line": 192
        },
        "resolved": true,
        "details": {
          "function_name": "cs_xop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
          "lines": "61-183",
          "snippet": "static void cs_xop(sourceinfo_t *si, int parc, char *parv[], const char *leveldesc)\n{\n\tmyentity_t *mt;\n\tmychan_t *mc;\n\tbool operoverride = false;\n\tunsigned int restrictflags;\n\tconst char *chan = parv[0];\n\tconst char *cmd = parv[1];\n\tchar *uname = parv[2];\n\tunsigned int level;\n\n\tif (!cmd || !chan)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"xOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: SOP|AOP|HOP|VOP <#channel> ADD|DEL|LIST <nickname>\"));\n\t\treturn;\n\t}\n\n\tif ((strcasecmp(\"LIST\", cmd)) && (!uname))\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"xOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: SOP|AOP|HOP|VOP <#channel> ADD|DEL|LIST <nickname>\"));\n\t\treturn;\n\t}\n\n\t/* make sure they're registered, logged in\n\t * and the founder of the channel before\n\t * we go any further.\n\t */\n\tif (!si->smu)\n\t{\n\t\t/* if they're opers and just want to LIST, they don't have to log in */\n\t\tif (!(has_priv(si, PRIV_CHAN_AUSPEX) && !strcasecmp(\"LIST\", cmd)))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not logged in.\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\") && (!has_priv(si, PRIV_CHAN_AUSPEX) || strcasecmp(\"LIST\", cmd)))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tlevel = get_template_flags(mc, leveldesc);\n\tif (level & CA_FOUNDER)\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 %s template has founder flag, not allowing xOP command.\"), chan, leveldesc);\n\t\treturn;\n\t}\n\n\t/* ADD */\n\tif (!strcasecmp(\"ADD\", cmd))\n\t{\n\t\tmt = myentity_find_ext(uname);\n\n\t\t/* As in /cs flags, allow founder to do anything */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER)\n\t\t\trestrictflags = ca_all;\n\t\t/* The following is a bit complicated, to allow for\n\t\t * possible future denial of granting +f */\n\t\tif (!(restrictflags & CA_FLAGS))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\tif ((restrictflags & level) != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\tcs_xop_do_add(si, mc, mt, uname, level, leveldesc, restrictflags);\n\t}\n\n\telse if (!strcasecmp(\"DEL\", cmd))\n\t{\n\t\tmt = myentity_find_ext(uname);\n\n\t\t/* As in /cs flags, allow founder to do anything -- fix for #64: allow self removal. */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER || entity(si->smu) == mt)\n\t\t\trestrictflags = ca_all;\n\t\t/* The following is a bit complicated, to allow for\n\t\t * possible future denial of granting +f */\n\t\tif (!(restrictflags & CA_FLAGS))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\tif ((restrictflags & level) != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\tcs_xop_do_del(si, mc, mt, uname, level, leveldesc);\n\t}\n\n\telse if (!strcasecmp(\"LIST\", cmd))\n\t{\n\t\tif (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t\t{\n\t\t\tif (has_priv(si, PRIV_CHAN_AUSPEX))\n\t\t\t\toperoverride = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcs_xop_do_list(si, mc, level, leveldesc, operoverride);\n\t}\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"template.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cs_xop_do_add(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc, unsigned int restrictflags);",
            "static void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc);",
            "static void cs_xop_do_list(sourceinfo_t *si, mychan_t *mc, unsigned int level, const char *leveldesc, bool operoverride);",
            "static void cs_cmd_sop(sourceinfo_t *si, int parc, char *parv[]);",
            "static void cs_cmd_aop(sourceinfo_t *si, int parc, char *parv[]);",
            "static void cs_cmd_hop(sourceinfo_t *si, int parc, char *parv[]);",
            "static void cs_cmd_vop(sourceinfo_t *si, int parc, char *parv[]);",
            "static void cs_cmd_forcexop(sourceinfo_t *si, int parc, char *parv[]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void cs_xop_do_add(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc, unsigned int restrictflags);\nstatic void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc);\nstatic void cs_xop_do_list(sourceinfo_t *si, mychan_t *mc, unsigned int level, const char *leveldesc, bool operoverride);\nstatic void cs_cmd_sop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_aop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_hop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_vop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_forcexop(sourceinfo_t *si, int parc, char *parv[]);\n\nstatic void cs_xop(sourceinfo_t *si, int parc, char *parv[], const char *leveldesc)\n{\n\tmyentity_t *mt;\n\tmychan_t *mc;\n\tbool operoverride = false;\n\tunsigned int restrictflags;\n\tconst char *chan = parv[0];\n\tconst char *cmd = parv[1];\n\tchar *uname = parv[2];\n\tunsigned int level;\n\n\tif (!cmd || !chan)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"xOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: SOP|AOP|HOP|VOP <#channel> ADD|DEL|LIST <nickname>\"));\n\t\treturn;\n\t}\n\n\tif ((strcasecmp(\"LIST\", cmd)) && (!uname))\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"xOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: SOP|AOP|HOP|VOP <#channel> ADD|DEL|LIST <nickname>\"));\n\t\treturn;\n\t}\n\n\t/* make sure they're registered, logged in\n\t * and the founder of the channel before\n\t * we go any further.\n\t */\n\tif (!si->smu)\n\t{\n\t\t/* if they're opers and just want to LIST, they don't have to log in */\n\t\tif (!(has_priv(si, PRIV_CHAN_AUSPEX) && !strcasecmp(\"LIST\", cmd)))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not logged in.\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\") && (!has_priv(si, PRIV_CHAN_AUSPEX) || strcasecmp(\"LIST\", cmd)))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tlevel = get_template_flags(mc, leveldesc);\n\tif (level & CA_FOUNDER)\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 %s template has founder flag, not allowing xOP command.\"), chan, leveldesc);\n\t\treturn;\n\t}\n\n\t/* ADD */\n\tif (!strcasecmp(\"ADD\", cmd))\n\t{\n\t\tmt = myentity_find_ext(uname);\n\n\t\t/* As in /cs flags, allow founder to do anything */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER)\n\t\t\trestrictflags = ca_all;\n\t\t/* The following is a bit complicated, to allow for\n\t\t * possible future denial of granting +f */\n\t\tif (!(restrictflags & CA_FLAGS))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\tif ((restrictflags & level) != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\tcs_xop_do_add(si, mc, mt, uname, level, leveldesc, restrictflags);\n\t}\n\n\telse if (!strcasecmp(\"DEL\", cmd))\n\t{\n\t\tmt = myentity_find_ext(uname);\n\n\t\t/* As in /cs flags, allow founder to do anything -- fix for #64: allow self removal. */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER || entity(si->smu) == mt)\n\t\t\trestrictflags = ca_all;\n\t\t/* The following is a bit complicated, to allow for\n\t\t * possible future denial of granting +f */\n\t\tif (!(restrictflags & CA_FLAGS))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\tif ((restrictflags & level) != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\tcs_xop_do_del(si, mc, mt, uname, level, leveldesc);\n\t}\n\n\telse if (!strcasecmp(\"LIST\", cmd))\n\t{\n\t\tif (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t\t{\n\t\t\tif (has_priv(si, PRIV_CHAN_AUSPEX))\n\t\t\t\toperoverride = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcs_xop_do_list(si, mc, level, leveldesc, operoverride);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void cs_cmd_sop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_aop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_hop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_vop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_forcexop(sourceinfo_t *si, int parc, char *parv[]);\n\nstatic void cs_cmd_aop(sourceinfo_t *si, int parc, char *parv[])\n{\n\tcs_xop(si, parc, parv, \"AOP\");\n}"
  },
  {
    "function_name": "cs_cmd_sop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
    "lines": "185-188",
    "snippet": "static void cs_cmd_sop(sourceinfo_t *si, int parc, char *parv[])\n{\n\tcs_xop(si, parc, parv, \"SOP\");\n}",
    "includes": [
      "#include \"chanserv.h\"",
      "#include \"template.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_cmd_sop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_aop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_hop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_vop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_forcexop(sourceinfo_t *si, int parc, char *parv[]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cs_xop",
          "args": [
            "si",
            "parc",
            "parv",
            "\"SOP\""
          ],
          "line": 187
        },
        "resolved": true,
        "details": {
          "function_name": "cs_xop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
          "lines": "61-183",
          "snippet": "static void cs_xop(sourceinfo_t *si, int parc, char *parv[], const char *leveldesc)\n{\n\tmyentity_t *mt;\n\tmychan_t *mc;\n\tbool operoverride = false;\n\tunsigned int restrictflags;\n\tconst char *chan = parv[0];\n\tconst char *cmd = parv[1];\n\tchar *uname = parv[2];\n\tunsigned int level;\n\n\tif (!cmd || !chan)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"xOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: SOP|AOP|HOP|VOP <#channel> ADD|DEL|LIST <nickname>\"));\n\t\treturn;\n\t}\n\n\tif ((strcasecmp(\"LIST\", cmd)) && (!uname))\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"xOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: SOP|AOP|HOP|VOP <#channel> ADD|DEL|LIST <nickname>\"));\n\t\treturn;\n\t}\n\n\t/* make sure they're registered, logged in\n\t * and the founder of the channel before\n\t * we go any further.\n\t */\n\tif (!si->smu)\n\t{\n\t\t/* if they're opers and just want to LIST, they don't have to log in */\n\t\tif (!(has_priv(si, PRIV_CHAN_AUSPEX) && !strcasecmp(\"LIST\", cmd)))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not logged in.\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\") && (!has_priv(si, PRIV_CHAN_AUSPEX) || strcasecmp(\"LIST\", cmd)))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tlevel = get_template_flags(mc, leveldesc);\n\tif (level & CA_FOUNDER)\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 %s template has founder flag, not allowing xOP command.\"), chan, leveldesc);\n\t\treturn;\n\t}\n\n\t/* ADD */\n\tif (!strcasecmp(\"ADD\", cmd))\n\t{\n\t\tmt = myentity_find_ext(uname);\n\n\t\t/* As in /cs flags, allow founder to do anything */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER)\n\t\t\trestrictflags = ca_all;\n\t\t/* The following is a bit complicated, to allow for\n\t\t * possible future denial of granting +f */\n\t\tif (!(restrictflags & CA_FLAGS))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\tif ((restrictflags & level) != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\tcs_xop_do_add(si, mc, mt, uname, level, leveldesc, restrictflags);\n\t}\n\n\telse if (!strcasecmp(\"DEL\", cmd))\n\t{\n\t\tmt = myentity_find_ext(uname);\n\n\t\t/* As in /cs flags, allow founder to do anything -- fix for #64: allow self removal. */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER || entity(si->smu) == mt)\n\t\t\trestrictflags = ca_all;\n\t\t/* The following is a bit complicated, to allow for\n\t\t * possible future denial of granting +f */\n\t\tif (!(restrictflags & CA_FLAGS))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\tif ((restrictflags & level) != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\tcs_xop_do_del(si, mc, mt, uname, level, leveldesc);\n\t}\n\n\telse if (!strcasecmp(\"LIST\", cmd))\n\t{\n\t\tif (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t\t{\n\t\t\tif (has_priv(si, PRIV_CHAN_AUSPEX))\n\t\t\t\toperoverride = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcs_xop_do_list(si, mc, level, leveldesc, operoverride);\n\t}\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"template.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cs_xop_do_add(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc, unsigned int restrictflags);",
            "static void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc);",
            "static void cs_xop_do_list(sourceinfo_t *si, mychan_t *mc, unsigned int level, const char *leveldesc, bool operoverride);",
            "static void cs_cmd_sop(sourceinfo_t *si, int parc, char *parv[]);",
            "static void cs_cmd_aop(sourceinfo_t *si, int parc, char *parv[]);",
            "static void cs_cmd_hop(sourceinfo_t *si, int parc, char *parv[]);",
            "static void cs_cmd_vop(sourceinfo_t *si, int parc, char *parv[]);",
            "static void cs_cmd_forcexop(sourceinfo_t *si, int parc, char *parv[]);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void cs_xop_do_add(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc, unsigned int restrictflags);\nstatic void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc);\nstatic void cs_xop_do_list(sourceinfo_t *si, mychan_t *mc, unsigned int level, const char *leveldesc, bool operoverride);\nstatic void cs_cmd_sop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_aop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_hop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_vop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_forcexop(sourceinfo_t *si, int parc, char *parv[]);\n\nstatic void cs_xop(sourceinfo_t *si, int parc, char *parv[], const char *leveldesc)\n{\n\tmyentity_t *mt;\n\tmychan_t *mc;\n\tbool operoverride = false;\n\tunsigned int restrictflags;\n\tconst char *chan = parv[0];\n\tconst char *cmd = parv[1];\n\tchar *uname = parv[2];\n\tunsigned int level;\n\n\tif (!cmd || !chan)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"xOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: SOP|AOP|HOP|VOP <#channel> ADD|DEL|LIST <nickname>\"));\n\t\treturn;\n\t}\n\n\tif ((strcasecmp(\"LIST\", cmd)) && (!uname))\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"xOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: SOP|AOP|HOP|VOP <#channel> ADD|DEL|LIST <nickname>\"));\n\t\treturn;\n\t}\n\n\t/* make sure they're registered, logged in\n\t * and the founder of the channel before\n\t * we go any further.\n\t */\n\tif (!si->smu)\n\t{\n\t\t/* if they're opers and just want to LIST, they don't have to log in */\n\t\tif (!(has_priv(si, PRIV_CHAN_AUSPEX) && !strcasecmp(\"LIST\", cmd)))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not logged in.\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\") && (!has_priv(si, PRIV_CHAN_AUSPEX) || strcasecmp(\"LIST\", cmd)))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tlevel = get_template_flags(mc, leveldesc);\n\tif (level & CA_FOUNDER)\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 %s template has founder flag, not allowing xOP command.\"), chan, leveldesc);\n\t\treturn;\n\t}\n\n\t/* ADD */\n\tif (!strcasecmp(\"ADD\", cmd))\n\t{\n\t\tmt = myentity_find_ext(uname);\n\n\t\t/* As in /cs flags, allow founder to do anything */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER)\n\t\t\trestrictflags = ca_all;\n\t\t/* The following is a bit complicated, to allow for\n\t\t * possible future denial of granting +f */\n\t\tif (!(restrictflags & CA_FLAGS))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\tif ((restrictflags & level) != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\tcs_xop_do_add(si, mc, mt, uname, level, leveldesc, restrictflags);\n\t}\n\n\telse if (!strcasecmp(\"DEL\", cmd))\n\t{\n\t\tmt = myentity_find_ext(uname);\n\n\t\t/* As in /cs flags, allow founder to do anything -- fix for #64: allow self removal. */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER || entity(si->smu) == mt)\n\t\t\trestrictflags = ca_all;\n\t\t/* The following is a bit complicated, to allow for\n\t\t * possible future denial of granting +f */\n\t\tif (!(restrictflags & CA_FLAGS))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\tif ((restrictflags & level) != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\tcs_xop_do_del(si, mc, mt, uname, level, leveldesc);\n\t}\n\n\telse if (!strcasecmp(\"LIST\", cmd))\n\t{\n\t\tif (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t\t{\n\t\t\tif (has_priv(si, PRIV_CHAN_AUSPEX))\n\t\t\t\toperoverride = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcs_xop_do_list(si, mc, level, leveldesc, operoverride);\n\t}\n}"
        }
      }
    ],
    "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void cs_cmd_sop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_aop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_hop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_vop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_forcexop(sourceinfo_t *si, int parc, char *parv[]);\n\nstatic void cs_cmd_sop(sourceinfo_t *si, int parc, char *parv[])\n{\n\tcs_xop(si, parc, parv, \"SOP\");\n}"
  },
  {
    "function_name": "cs_xop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
    "lines": "61-183",
    "snippet": "static void cs_xop(sourceinfo_t *si, int parc, char *parv[], const char *leveldesc)\n{\n\tmyentity_t *mt;\n\tmychan_t *mc;\n\tbool operoverride = false;\n\tunsigned int restrictflags;\n\tconst char *chan = parv[0];\n\tconst char *cmd = parv[1];\n\tchar *uname = parv[2];\n\tunsigned int level;\n\n\tif (!cmd || !chan)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"xOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: SOP|AOP|HOP|VOP <#channel> ADD|DEL|LIST <nickname>\"));\n\t\treturn;\n\t}\n\n\tif ((strcasecmp(\"LIST\", cmd)) && (!uname))\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"xOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: SOP|AOP|HOP|VOP <#channel> ADD|DEL|LIST <nickname>\"));\n\t\treturn;\n\t}\n\n\t/* make sure they're registered, logged in\n\t * and the founder of the channel before\n\t * we go any further.\n\t */\n\tif (!si->smu)\n\t{\n\t\t/* if they're opers and just want to LIST, they don't have to log in */\n\t\tif (!(has_priv(si, PRIV_CHAN_AUSPEX) && !strcasecmp(\"LIST\", cmd)))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not logged in.\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\") && (!has_priv(si, PRIV_CHAN_AUSPEX) || strcasecmp(\"LIST\", cmd)))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tlevel = get_template_flags(mc, leveldesc);\n\tif (level & CA_FOUNDER)\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 %s template has founder flag, not allowing xOP command.\"), chan, leveldesc);\n\t\treturn;\n\t}\n\n\t/* ADD */\n\tif (!strcasecmp(\"ADD\", cmd))\n\t{\n\t\tmt = myentity_find_ext(uname);\n\n\t\t/* As in /cs flags, allow founder to do anything */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER)\n\t\t\trestrictflags = ca_all;\n\t\t/* The following is a bit complicated, to allow for\n\t\t * possible future denial of granting +f */\n\t\tif (!(restrictflags & CA_FLAGS))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\tif ((restrictflags & level) != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\tcs_xop_do_add(si, mc, mt, uname, level, leveldesc, restrictflags);\n\t}\n\n\telse if (!strcasecmp(\"DEL\", cmd))\n\t{\n\t\tmt = myentity_find_ext(uname);\n\n\t\t/* As in /cs flags, allow founder to do anything -- fix for #64: allow self removal. */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER || entity(si->smu) == mt)\n\t\t\trestrictflags = ca_all;\n\t\t/* The following is a bit complicated, to allow for\n\t\t * possible future denial of granting +f */\n\t\tif (!(restrictflags & CA_FLAGS))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\tif ((restrictflags & level) != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\tcs_xop_do_del(si, mc, mt, uname, level, leveldesc);\n\t}\n\n\telse if (!strcasecmp(\"LIST\", cmd))\n\t{\n\t\tif (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t\t{\n\t\t\tif (has_priv(si, PRIV_CHAN_AUSPEX))\n\t\t\t\toperoverride = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcs_xop_do_list(si, mc, level, leveldesc, operoverride);\n\t}\n}",
    "includes": [
      "#include \"chanserv.h\"",
      "#include \"template.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_xop_do_add(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc, unsigned int restrictflags);",
      "static void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc);",
      "static void cs_xop_do_list(sourceinfo_t *si, mychan_t *mc, unsigned int level, const char *leveldesc, bool operoverride);",
      "static void cs_cmd_sop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_aop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_hop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_vop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_forcexop(sourceinfo_t *si, int parc, char *parv[]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cs_xop_do_list",
          "args": [
            "si",
            "mc",
            "level",
            "leveldesc",
            "operoverride"
          ],
          "line": 181
        },
        "resolved": true,
        "details": {
          "function_name": "cs_xop_do_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
          "lines": "408-435",
          "snippet": "static void cs_xop_do_list(sourceinfo_t *si, mychan_t *mc, unsigned int level, const char *leveldesc, bool operoverride)\n{\n\tchanacs_t *ca;\n\tint i = 0;\n\tmowgli_node_t *n;\n\n\tcommand_success_nodata(si, _(\"%s list for \\2%s\\2:\"), leveldesc ,mc->name);\n\tMOWGLI_ITER_FOREACH(n, mc->chanacs.head)\n\t{\n\t\tca = (chanacs_t *)n->data;\n\t\tif (ca->level == level)\n\t\t{\n\t\t\tif (ca->entity == NULL)\n\t\t\t\tcommand_success_nodata(si, \"%d: \\2%s\\2\", ++i, ca->host);\n\t\t\telse if (isuser(ca->entity) && MOWGLI_LIST_LENGTH(&user(ca->entity)->logins))\n\t\t\t\tcommand_success_nodata(si, _(\"%d: \\2%s\\2 (logged in)\"), ++i, ca->entity->name);\n\t\t\telse\n\t\t\t\tcommand_success_nodata(si, _(\"%d: \\2%s\\2 (not logged in)\"), ++i, ca->entity->name);\n\t\t}\n\t}\n\t/* XXX */\n\tcommand_success_nodata(si, _(\"Total of \\2%d\\2 %s in %s list of \\2%s\\2.\"), i, (i == 1) ? \"entry\" : \"entries\", leveldesc, mc->name);\n\n\tif (operoverride)\n\t\tlogcommand(si, CMDLOG_ADMIN, \"LIST: \\2%s\\2 \\2%s\\2 (oper override)\", mc->name, leveldesc);\n\telse\n\t\tlogcommand(si, CMDLOG_GET, \"LIST: \\2%s\\2 \\2%s\\2\", mc->name, leveldesc);\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"template.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc);",
            "static void cs_xop_do_list(sourceinfo_t *si, mychan_t *mc, unsigned int level, const char *leveldesc, bool operoverride);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc);\nstatic void cs_xop_do_list(sourceinfo_t *si, mychan_t *mc, unsigned int level, const char *leveldesc, bool operoverride);\n\nstatic void cs_xop_do_list(sourceinfo_t *si, mychan_t *mc, unsigned int level, const char *leveldesc, bool operoverride)\n{\n\tchanacs_t *ca;\n\tint i = 0;\n\tmowgli_node_t *n;\n\n\tcommand_success_nodata(si, _(\"%s list for \\2%s\\2:\"), leveldesc ,mc->name);\n\tMOWGLI_ITER_FOREACH(n, mc->chanacs.head)\n\t{\n\t\tca = (chanacs_t *)n->data;\n\t\tif (ca->level == level)\n\t\t{\n\t\t\tif (ca->entity == NULL)\n\t\t\t\tcommand_success_nodata(si, \"%d: \\2%s\\2\", ++i, ca->host);\n\t\t\telse if (isuser(ca->entity) && MOWGLI_LIST_LENGTH(&user(ca->entity)->logins))\n\t\t\t\tcommand_success_nodata(si, _(\"%d: \\2%s\\2 (logged in)\"), ++i, ca->entity->name);\n\t\t\telse\n\t\t\t\tcommand_success_nodata(si, _(\"%d: \\2%s\\2 (not logged in)\"), ++i, ca->entity->name);\n\t\t}\n\t}\n\t/* XXX */\n\tcommand_success_nodata(si, _(\"Total of \\2%d\\2 %s in %s list of \\2%s\\2.\"), i, (i == 1) ? \"entry\" : \"entries\", leveldesc, mc->name);\n\n\tif (operoverride)\n\t\tlogcommand(si, CMDLOG_ADMIN, \"LIST: \\2%s\\2 \\2%s\\2 (oper override)\", mc->name, leveldesc);\n\telse\n\t\tlogcommand(si, CMDLOG_GET, \"LIST: \\2%s\\2 \\2%s\\2\", mc->name, leveldesc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not authorized to perform this operation.\")"
          ],
          "line": 177
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"You are not authorized to perform this operation.\""
          ],
          "line": 177
        },
        "resolved": true,
        "details": {
          "function_name": "_moddeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
          "lines": "52-59",
          "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_aop);\n\tservice_named_unbind_command(\"chanserv\", &cs_sop);\n\tservice_named_unbind_command(\"chanserv\", &cs_hop);\n\tservice_named_unbind_command(\"chanserv\", &cs_vop);\n\tservice_named_unbind_command(\"chanserv\", &cs_forcexop);\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"template.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "command_t cs_sop = { \"SOP\", N_(\"Manipulates a channel SOP list.\"),\n                        AC_NONE, 3, cs_cmd_sop, { .path = \"cservice/xop\" } };",
            "command_t cs_aop = { \"AOP\", N_(\"Manipulates a channel AOP list.\"),\n                        AC_NONE, 3, cs_cmd_aop, { .path = \"cservice/xop\" } };",
            "command_t cs_hop = { \"HOP\", N_(\"Manipulates a channel HOP list.\"),\n\t\t\tAC_NONE, 3, cs_cmd_hop, { .path = \"cservice/xop\" } };",
            "command_t cs_vop = { \"VOP\", N_(\"Manipulates a channel VOP list.\"),\n                        AC_NONE, 3, cs_cmd_vop, { .path = \"cservice/xop\" } };",
            "command_t cs_forcexop = { \"FORCEXOP\", N_(\"Forces access levels to xOP levels.\"),\n                         AC_NONE, 1, cs_cmd_forcexop, { .path = \"cservice/forcexop\" } };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\ncommand_t cs_sop = { \"SOP\", N_(\"Manipulates a channel SOP list.\"),\n                        AC_NONE, 3, cs_cmd_sop, { .path = \"cservice/xop\" } };\ncommand_t cs_aop = { \"AOP\", N_(\"Manipulates a channel AOP list.\"),\n                        AC_NONE, 3, cs_cmd_aop, { .path = \"cservice/xop\" } };\ncommand_t cs_hop = { \"HOP\", N_(\"Manipulates a channel HOP list.\"),\n\t\t\tAC_NONE, 3, cs_cmd_hop, { .path = \"cservice/xop\" } };\ncommand_t cs_vop = { \"VOP\", N_(\"Manipulates a channel VOP list.\"),\n                        AC_NONE, 3, cs_cmd_vop, { .path = \"cservice/xop\" } };\ncommand_t cs_forcexop = { \"FORCEXOP\", N_(\"Forces access levels to xOP levels.\"),\n                         AC_NONE, 1, cs_cmd_forcexop, { .path = \"cservice/forcexop\" } };\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_aop);\n\tservice_named_unbind_command(\"chanserv\", &cs_sop);\n\tservice_named_unbind_command(\"chanserv\", &cs_hop);\n\tservice_named_unbind_command(\"chanserv\", &cs_vop);\n\tservice_named_unbind_command(\"chanserv\", &cs_forcexop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "has_priv",
          "args": [
            "si",
            "PRIV_CHAN_AUSPEX"
          ],
          "line": 173
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_source_has_flag",
          "args": [
            "mc",
            "si",
            "CA_ACLVIEW"
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "\"LIST\"",
            "cmd"
          ],
          "line": 169
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cs_xop_do_del",
          "args": [
            "si",
            "mc",
            "mt",
            "uname",
            "level",
            "leveldesc"
          ],
          "line": 166
        },
        "resolved": true,
        "details": {
          "function_name": "cs_xop_do_del",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
          "lines": "348-405",
          "snippet": "static void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc)\n{\n\tchanacs_t *ca;\n\thook_channel_acl_req_t req;\n\n\t/* let's finally make this sane.. --w00t */\n\tif (!mt)\n\t{\n\t\t/* we might be deleting a hostmask */\n\t\tif (!validhostmask(target))\n\t\t{\n\t\t\tcommand_fail(si, fault_badparams, _(\"\\2%s\\2 is neither a nickname nor a hostmask.\"), target);\n\t\t\treturn;\n\t\t}\n\n\t\tca = chanacs_find_host_literal(mc, target, level);\n\t\tif (ca == NULL || ca->level != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is not on the %s list for \\2%s\\2.\"), target, leveldesc, mc->name);\n\t\t\treturn;\n\t\t}\n\n\t\treq.ca = ca;\n\t\treq.oldlevel = ca->level;\n\n\t\tca->level = 0;\n\n\t\treq.newlevel = ca->level;\n\n\t\thook_call_channel_acl_change(&req);\n\t\tobject_unref(ca);\n\n\t\tverbose(mc, \"\\2%s\\2 removed \\2%s\\2 from the %s list.\", get_source_name(si), target, leveldesc);\n\t\tlogcommand(si, CMDLOG_SET, \"DEL: \\2%s\\2 \\2%s\\2 from \\2%s\\2\", mc->name, leveldesc, target);\n\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been removed from the %s list for \\2%s\\2.\"), target, leveldesc, mc->name);\n\t\treturn;\n\t}\n\n\tif (!(ca = chanacs_find_literal(mc, mt, level)) || ca->level != level)\n\t{\n\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is not on the %s list for \\2%s\\2.\"), mt->name, leveldesc, mc->name);\n\t\treturn;\n\t}\n\n\treq.ca = ca;\n\treq.oldlevel = ca->level;\n\n\tca->level = 0;\n\n\treq.newlevel = ca->level;\n\n\thook_call_channel_acl_change(&req);\n\tobject_unref(ca);\n\n\tcommand_success_nodata(si, _(\"\\2%s\\2 has been removed from the %s list for \\2%s\\2.\"), mt->name, leveldesc, mc->name);\n\tlogcommand(si, CMDLOG_SET, \"DEL: \\2%s\\2 \\2%s\\2 from \\2%s\\2\", mc->name, leveldesc, mt->name);\n\tverbose(mc, \"\\2%s\\2 removed \\2%s\\2 from the %s list.\", get_source_name(si), mt->name, leveldesc);\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"template.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc);\n\nstatic void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc)\n{\n\tchanacs_t *ca;\n\thook_channel_acl_req_t req;\n\n\t/* let's finally make this sane.. --w00t */\n\tif (!mt)\n\t{\n\t\t/* we might be deleting a hostmask */\n\t\tif (!validhostmask(target))\n\t\t{\n\t\t\tcommand_fail(si, fault_badparams, _(\"\\2%s\\2 is neither a nickname nor a hostmask.\"), target);\n\t\t\treturn;\n\t\t}\n\n\t\tca = chanacs_find_host_literal(mc, target, level);\n\t\tif (ca == NULL || ca->level != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is not on the %s list for \\2%s\\2.\"), target, leveldesc, mc->name);\n\t\t\treturn;\n\t\t}\n\n\t\treq.ca = ca;\n\t\treq.oldlevel = ca->level;\n\n\t\tca->level = 0;\n\n\t\treq.newlevel = ca->level;\n\n\t\thook_call_channel_acl_change(&req);\n\t\tobject_unref(ca);\n\n\t\tverbose(mc, \"\\2%s\\2 removed \\2%s\\2 from the %s list.\", get_source_name(si), target, leveldesc);\n\t\tlogcommand(si, CMDLOG_SET, \"DEL: \\2%s\\2 \\2%s\\2 from \\2%s\\2\", mc->name, leveldesc, target);\n\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been removed from the %s list for \\2%s\\2.\"), target, leveldesc, mc->name);\n\t\treturn;\n\t}\n\n\tif (!(ca = chanacs_find_literal(mc, mt, level)) || ca->level != level)\n\t{\n\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is not on the %s list for \\2%s\\2.\"), mt->name, leveldesc, mc->name);\n\t\treturn;\n\t}\n\n\treq.ca = ca;\n\treq.oldlevel = ca->level;\n\n\tca->level = 0;\n\n\treq.newlevel = ca->level;\n\n\thook_call_channel_acl_change(&req);\n\tobject_unref(ca);\n\n\tcommand_success_nodata(si, _(\"\\2%s\\2 has been removed from the %s list for \\2%s\\2.\"), mt->name, leveldesc, mc->name);\n\tlogcommand(si, CMDLOG_SET, \"DEL: \\2%s\\2 \\2%s\\2 from \\2%s\\2\", mc->name, leveldesc, mt->name);\n\tverbose(mc, \"\\2%s\\2 removed \\2%s\\2 from the %s list.\", get_source_name(si), mt->name, leveldesc);\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not authorized to perform this operation.\")"
          ],
          "line": 163
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_flags",
          "args": [
            "mc",
            "restrictflags"
          ],
          "line": 160
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not authorized to perform this operation.\")"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "entity",
          "args": [
            "si->smu"
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_source_flags",
          "args": [
            "mc",
            "si"
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "myentity_find_ext",
          "args": [
            "uname"
          ],
          "line": 147
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "\"DEL\"",
            "cmd"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "cs_xop_do_add",
          "args": [
            "si",
            "mc",
            "mt",
            "uname",
            "level",
            "leveldesc",
            "restrictflags"
          ],
          "line": 142
        },
        "resolved": true,
        "details": {
          "function_name": "cs_xop_do_add",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
          "lines": "213-346",
          "snippet": "static void cs_xop_do_add(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc, unsigned int restrictflags)\n{\n\tchanacs_t *ca;\n\tunsigned int addflags = level, removeflags = ~level;\n\tbool isnew;\n\thook_channel_acl_req_t req;\n\n\tif (!mt)\n\t{\n\t\t/* we might be adding a hostmask */\n\t\tif (!validhostmask(target))\n\t\t{\n\t\t\tcommand_fail(si, fault_badparams, _(\"\\2%s\\2 is neither a registered account nor a hostmask.\"), target);\n\t\t\treturn;\n\t\t}\n\n\t\ttarget = collapse(target);\n\t\tca = chanacs_open(mc, NULL, target, true, entity(si->smu));\n\t\tif (ca->level == level)\n\t\t{\n\t\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is already on the %s list for \\2%s\\2\"), target, leveldesc, mc->name);\n\t\t\treturn;\n\t\t}\n\t\tisnew = ca->level == 0;\n\n\t\tif (isnew && chanacs_is_table_full(ca))\n\t\t{\n\t\t\tcommand_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);\n\t\t\tchanacs_close(ca);\n\t\t\treturn;\n\t\t}\n\n\t\treq.ca = ca;\n\t\treq.oldlevel = ca->level;\n\n\t\tif (!chanacs_modify(ca, &addflags, &removeflags, restrictflags))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to modify the access entry for \\2%s\\2 on \\2%s\\2.\"), target, mc->name);\n\t\t\tchanacs_close(ca);\n\t\t\treturn;\n\t\t}\n\n\t\treq.newlevel = ca->level;\n\n\t\thook_call_channel_acl_change(&req);\n\n\t\tchanacs_close(ca);\n\n\t\tif (!isnew)\n\t\t{\n\t\t\t/* they have access? change it! */\n\t\t\tlogcommand(si, CMDLOG_SET, \"ADD: \\2%s\\2 \\2%s\\2 on \\2%s\\2 (changed access)\", mc->name, leveldesc, target);\n\t\t\tcommand_success_nodata(si, _(\"\\2%s\\2's access on \\2%s\\2 has been changed to \\2%s\\2.\"), target, mc->name, leveldesc);\n\t\t\tverbose(mc, \"\\2%s\\2 changed \\2%s\\2's access to \\2%s\\2.\", get_source_name(si), target, leveldesc);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogcommand(si, CMDLOG_SET, \"ADD: \\2%s\\2 \\2%s\\2 on \\2%s\\2\", mc->name, leveldesc, target);\n\t\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been added to the %s list for \\2%s\\2.\"), target, leveldesc, mc->name);\n\t\t\tverbose(mc, \"\\2%s\\2 added \\2%s\\2 to the %s list.\", get_source_name(si), target, leveldesc);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tca = chanacs_open(mc, mt, NULL, true, entity(si->smu));\n\n\tif (ca->level & CA_FOUNDER)\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is the founder for \\2%s\\2 and may not be added to the %s list.\"), mt->name, mc->name, leveldesc);\n\t\treturn;\n\t}\n\n\tif (ca->level == level)\n\t{\n\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is already on the %s list for \\2%s\\2.\"), mt->name, leveldesc, mc->name);\n\t\treturn;\n\t}\n\n\t/* NEVEROP logic moved here\n\t * Allow changing access level, but not adding\n\t * -- jilles */\n\tif (isuser(mt) && MU_NEVEROP & user(mt)->flags && (ca->level == 0 || ca->level == CA_AKICK))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 does not wish to be added to channel access lists (NEVEROP set).\"), mt->name);\n\t\tchanacs_close(ca);\n\t\treturn;\n\t}\n\n\t/*\n\t * this is a little more cryptic than it used to be, but much cleaner. Functionally should be\n\t * the same, with the exception that if they had access before, now it doesn't tell what it got\n\t * changed from (I considered the effort to put an extra lookup in not worth it. --w00t\n\t */\n\t/* just assume there's just one entry for that user -- jilles */\n\n\tisnew = ca->level == 0;\n\tif (isnew && chanacs_is_table_full(ca))\n\t{\n\t\tcommand_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);\n\t\tchanacs_close(ca);\n\t\treturn;\n\t}\n\n\treq.ca = ca;\n\treq.oldlevel = ca->level;\n\n\tif (!chanacs_modify(ca, &addflags, &removeflags, restrictflags))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to modify the access entry for \\2%s\\2 on \\2%s\\2.\"), mt->name, mc->name);\n\t\tchanacs_close(ca);\n\t\treturn;\n\t}\n\n\treq.newlevel = ca->level;\n\n\thook_call_channel_acl_change(&req);\n\tchanacs_close(ca);\n\n\tif (!isnew)\n\t{\n\t\t/* they have access? change it! */\n\t\tlogcommand(si, CMDLOG_SET, \"ADD: \\2%s\\2 \\2%s\\2 on \\2%s\\2 (changed access)\", mc->name, leveldesc, mt->name);\n\t\tcommand_success_nodata(si, _(\"\\2%s\\2's access on \\2%s\\2 has been changed to \\2%s\\2.\"), mt->name, mc->name, leveldesc);\n\t\tverbose(mc, \"\\2%s\\2 changed \\2%s\\2's access to \\2%s\\2.\", get_source_name(si), mt->name, leveldesc);\n\t}\n\telse\n\t{\n\t\t/* they have no access, add */\n\t\tlogcommand(si, CMDLOG_SET, \"ADD: \\2%s\\2 \\2%s\\2 on \\2%s\\2\", mc->name, leveldesc, mt->name);\n\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been added to the %s list for \\2%s\\2.\"), mt->name, leveldesc, mc->name);\n\t\tverbose(mc, \"\\2%s\\2 added \\2%s\\2 to the %s list.\", get_source_name(si), mt->name, leveldesc);\n\t}\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"template.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cs_xop_do_add(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc, unsigned int restrictflags);",
            "static void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void cs_xop_do_add(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc, unsigned int restrictflags);\nstatic void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc);\n\nstatic void cs_xop_do_add(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc, unsigned int restrictflags)\n{\n\tchanacs_t *ca;\n\tunsigned int addflags = level, removeflags = ~level;\n\tbool isnew;\n\thook_channel_acl_req_t req;\n\n\tif (!mt)\n\t{\n\t\t/* we might be adding a hostmask */\n\t\tif (!validhostmask(target))\n\t\t{\n\t\t\tcommand_fail(si, fault_badparams, _(\"\\2%s\\2 is neither a registered account nor a hostmask.\"), target);\n\t\t\treturn;\n\t\t}\n\n\t\ttarget = collapse(target);\n\t\tca = chanacs_open(mc, NULL, target, true, entity(si->smu));\n\t\tif (ca->level == level)\n\t\t{\n\t\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is already on the %s list for \\2%s\\2\"), target, leveldesc, mc->name);\n\t\t\treturn;\n\t\t}\n\t\tisnew = ca->level == 0;\n\n\t\tif (isnew && chanacs_is_table_full(ca))\n\t\t{\n\t\t\tcommand_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);\n\t\t\tchanacs_close(ca);\n\t\t\treturn;\n\t\t}\n\n\t\treq.ca = ca;\n\t\treq.oldlevel = ca->level;\n\n\t\tif (!chanacs_modify(ca, &addflags, &removeflags, restrictflags))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to modify the access entry for \\2%s\\2 on \\2%s\\2.\"), target, mc->name);\n\t\t\tchanacs_close(ca);\n\t\t\treturn;\n\t\t}\n\n\t\treq.newlevel = ca->level;\n\n\t\thook_call_channel_acl_change(&req);\n\n\t\tchanacs_close(ca);\n\n\t\tif (!isnew)\n\t\t{\n\t\t\t/* they have access? change it! */\n\t\t\tlogcommand(si, CMDLOG_SET, \"ADD: \\2%s\\2 \\2%s\\2 on \\2%s\\2 (changed access)\", mc->name, leveldesc, target);\n\t\t\tcommand_success_nodata(si, _(\"\\2%s\\2's access on \\2%s\\2 has been changed to \\2%s\\2.\"), target, mc->name, leveldesc);\n\t\t\tverbose(mc, \"\\2%s\\2 changed \\2%s\\2's access to \\2%s\\2.\", get_source_name(si), target, leveldesc);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tlogcommand(si, CMDLOG_SET, \"ADD: \\2%s\\2 \\2%s\\2 on \\2%s\\2\", mc->name, leveldesc, target);\n\t\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been added to the %s list for \\2%s\\2.\"), target, leveldesc, mc->name);\n\t\t\tverbose(mc, \"\\2%s\\2 added \\2%s\\2 to the %s list.\", get_source_name(si), target, leveldesc);\n\t\t}\n\n\t\treturn;\n\t}\n\n\tca = chanacs_open(mc, mt, NULL, true, entity(si->smu));\n\n\tif (ca->level & CA_FOUNDER)\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is the founder for \\2%s\\2 and may not be added to the %s list.\"), mt->name, mc->name, leveldesc);\n\t\treturn;\n\t}\n\n\tif (ca->level == level)\n\t{\n\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is already on the %s list for \\2%s\\2.\"), mt->name, leveldesc, mc->name);\n\t\treturn;\n\t}\n\n\t/* NEVEROP logic moved here\n\t * Allow changing access level, but not adding\n\t * -- jilles */\n\tif (isuser(mt) && MU_NEVEROP & user(mt)->flags && (ca->level == 0 || ca->level == CA_AKICK))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 does not wish to be added to channel access lists (NEVEROP set).\"), mt->name);\n\t\tchanacs_close(ca);\n\t\treturn;\n\t}\n\n\t/*\n\t * this is a little more cryptic than it used to be, but much cleaner. Functionally should be\n\t * the same, with the exception that if they had access before, now it doesn't tell what it got\n\t * changed from (I considered the effort to put an extra lookup in not worth it. --w00t\n\t */\n\t/* just assume there's just one entry for that user -- jilles */\n\n\tisnew = ca->level == 0;\n\tif (isnew && chanacs_is_table_full(ca))\n\t{\n\t\tcommand_fail(si, fault_toomany, _(\"Channel %s access list is full.\"), mc->name);\n\t\tchanacs_close(ca);\n\t\treturn;\n\t}\n\n\treq.ca = ca;\n\treq.oldlevel = ca->level;\n\n\tif (!chanacs_modify(ca, &addflags, &removeflags, restrictflags))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to modify the access entry for \\2%s\\2 on \\2%s\\2.\"), mt->name, mc->name);\n\t\tchanacs_close(ca);\n\t\treturn;\n\t}\n\n\treq.newlevel = ca->level;\n\n\thook_call_channel_acl_change(&req);\n\tchanacs_close(ca);\n\n\tif (!isnew)\n\t{\n\t\t/* they have access? change it! */\n\t\tlogcommand(si, CMDLOG_SET, \"ADD: \\2%s\\2 \\2%s\\2 on \\2%s\\2 (changed access)\", mc->name, leveldesc, mt->name);\n\t\tcommand_success_nodata(si, _(\"\\2%s\\2's access on \\2%s\\2 has been changed to \\2%s\\2.\"), mt->name, mc->name, leveldesc);\n\t\tverbose(mc, \"\\2%s\\2 changed \\2%s\\2's access to \\2%s\\2.\", get_source_name(si), mt->name, leveldesc);\n\t}\n\telse\n\t{\n\t\t/* they have no access, add */\n\t\tlogcommand(si, CMDLOG_SET, \"ADD: \\2%s\\2 \\2%s\\2 on \\2%s\\2\", mc->name, leveldesc, mt->name);\n\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been added to the %s list for \\2%s\\2.\"), mt->name, leveldesc, mc->name);\n\t\tverbose(mc, \"\\2%s\\2 added \\2%s\\2 to the %s list.\", get_source_name(si), mt->name, leveldesc);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not authorized to perform this operation.\")"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "allow_flags",
          "args": [
            "mc",
            "restrictflags"
          ],
          "line": 136
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not authorized to perform this operation.\")"
          ],
          "line": 133
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_source_flags",
          "args": [
            "mc",
            "si"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "myentity_find_ext",
          "args": [
            "uname"
          ],
          "line": 123
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "\"ADD\"",
            "cmd"
          ],
          "line": 121
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"\\2%s\\2 %s template has founder flag, not allowing xOP command.\")",
            "chan",
            "leveldesc"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_template_flags",
          "args": [
            "mc",
            "leveldesc"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"\\2%s\\2 is closed.\")",
            "chan"
          ],
          "line": 109
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "\"LIST\"",
            "cmd"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_priv",
          "args": [
            "si",
            "PRIV_CHAN_AUSPEX"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:close:closer\""
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_target",
            "_(\"Channel \\2%s\\2 is not registered.\")",
            "chan"
          ],
          "line": 103
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_find",
          "args": [
            "chan"
          ],
          "line": 100
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not logged in.\")"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "\"LIST\"",
            "cmd"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "has_priv",
          "args": [
            "si",
            "PRIV_CHAN_AUSPEX"
          ],
          "line": 93
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "_(\"Syntax: SOP|AOP|HOP|VOP <#channel> ADD|DEL|LIST <nickname>\")"
          ],
          "line": 82
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "STR_INSUFFICIENT_PARAMS",
            "\"xOP\""
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "\"LIST\"",
            "cmd"
          ],
          "line": 79
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "_(\"Syntax: SOP|AOP|HOP|VOP <#channel> ADD|DEL|LIST <nickname>\")"
          ],
          "line": 75
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "STR_INSUFFICIENT_PARAMS",
            "\"xOP\""
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void cs_xop_do_add(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc, unsigned int restrictflags);\nstatic void cs_xop_do_del(sourceinfo_t *si, mychan_t *mc, myentity_t *mt, char *target, unsigned int level, const char *leveldesc);\nstatic void cs_xop_do_list(sourceinfo_t *si, mychan_t *mc, unsigned int level, const char *leveldesc, bool operoverride);\nstatic void cs_cmd_sop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_aop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_hop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_vop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_forcexop(sourceinfo_t *si, int parc, char *parv[]);\n\nstatic void cs_xop(sourceinfo_t *si, int parc, char *parv[], const char *leveldesc)\n{\n\tmyentity_t *mt;\n\tmychan_t *mc;\n\tbool operoverride = false;\n\tunsigned int restrictflags;\n\tconst char *chan = parv[0];\n\tconst char *cmd = parv[1];\n\tchar *uname = parv[2];\n\tunsigned int level;\n\n\tif (!cmd || !chan)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"xOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: SOP|AOP|HOP|VOP <#channel> ADD|DEL|LIST <nickname>\"));\n\t\treturn;\n\t}\n\n\tif ((strcasecmp(\"LIST\", cmd)) && (!uname))\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"xOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: SOP|AOP|HOP|VOP <#channel> ADD|DEL|LIST <nickname>\"));\n\t\treturn;\n\t}\n\n\t/* make sure they're registered, logged in\n\t * and the founder of the channel before\n\t * we go any further.\n\t */\n\tif (!si->smu)\n\t{\n\t\t/* if they're opers and just want to LIST, they don't have to log in */\n\t\tif (!(has_priv(si, PRIV_CHAN_AUSPEX) && !strcasecmp(\"LIST\", cmd)))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not logged in.\"));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\") && (!has_priv(si, PRIV_CHAN_AUSPEX) || strcasecmp(\"LIST\", cmd)))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tlevel = get_template_flags(mc, leveldesc);\n\tif (level & CA_FOUNDER)\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 %s template has founder flag, not allowing xOP command.\"), chan, leveldesc);\n\t\treturn;\n\t}\n\n\t/* ADD */\n\tif (!strcasecmp(\"ADD\", cmd))\n\t{\n\t\tmt = myentity_find_ext(uname);\n\n\t\t/* As in /cs flags, allow founder to do anything */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER)\n\t\t\trestrictflags = ca_all;\n\t\t/* The following is a bit complicated, to allow for\n\t\t * possible future denial of granting +f */\n\t\tif (!(restrictflags & CA_FLAGS))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\tif ((restrictflags & level) != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\tcs_xop_do_add(si, mc, mt, uname, level, leveldesc, restrictflags);\n\t}\n\n\telse if (!strcasecmp(\"DEL\", cmd))\n\t{\n\t\tmt = myentity_find_ext(uname);\n\n\t\t/* As in /cs flags, allow founder to do anything -- fix for #64: allow self removal. */\n\t\trestrictflags = chanacs_source_flags(mc, si);\n\t\tif (restrictflags & CA_FOUNDER || entity(si->smu) == mt)\n\t\t\trestrictflags = ca_all;\n\t\t/* The following is a bit complicated, to allow for\n\t\t * possible future denial of granting +f */\n\t\tif (!(restrictflags & CA_FLAGS))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\trestrictflags = allow_flags(mc, restrictflags);\n\t\tif ((restrictflags & level) != level)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\treturn;\n\t\t}\n\t\tcs_xop_do_del(si, mc, mt, uname, level, leveldesc);\n\t}\n\n\telse if (!strcasecmp(\"LIST\", cmd))\n\t{\n\t\tif (!(mc->flags & MC_PUBACL) && !chanacs_source_has_flag(mc, si, CA_ACLVIEW))\n\t\t{\n\t\t\tif (has_priv(si, PRIV_CHAN_AUSPEX))\n\t\t\t\toperoverride = true;\n\t\t\telse\n\t\t\t{\n\t\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\tcs_xop_do_list(si, mc, level, leveldesc, operoverride);\n\t}\n}"
  },
  {
    "function_name": "_moddeinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
    "lines": "52-59",
    "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_aop);\n\tservice_named_unbind_command(\"chanserv\", &cs_sop);\n\tservice_named_unbind_command(\"chanserv\", &cs_hop);\n\tservice_named_unbind_command(\"chanserv\", &cs_vop);\n\tservice_named_unbind_command(\"chanserv\", &cs_forcexop);\n}",
    "includes": [
      "#include \"chanserv.h\"",
      "#include \"template.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "command_t cs_sop = { \"SOP\", N_(\"Manipulates a channel SOP list.\"),\n                        AC_NONE, 3, cs_cmd_sop, { .path = \"cservice/xop\" } };",
      "command_t cs_aop = { \"AOP\", N_(\"Manipulates a channel AOP list.\"),\n                        AC_NONE, 3, cs_cmd_aop, { .path = \"cservice/xop\" } };",
      "command_t cs_hop = { \"HOP\", N_(\"Manipulates a channel HOP list.\"),\n\t\t\tAC_NONE, 3, cs_cmd_hop, { .path = \"cservice/xop\" } };",
      "command_t cs_vop = { \"VOP\", N_(\"Manipulates a channel VOP list.\"),\n                        AC_NONE, 3, cs_cmd_vop, { .path = \"cservice/xop\" } };",
      "command_t cs_forcexop = { \"FORCEXOP\", N_(\"Forces access levels to xOP levels.\"),\n                         AC_NONE, 1, cs_cmd_forcexop, { .path = \"cservice/forcexop\" } };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "service_named_unbind_command",
          "args": [
            "\"chanserv\"",
            "&cs_forcexop"
          ],
          "line": 58
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_named_unbind_command",
          "args": [
            "\"chanserv\"",
            "&cs_vop"
          ],
          "line": 57
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_named_unbind_command",
          "args": [
            "\"chanserv\"",
            "&cs_hop"
          ],
          "line": 56
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_named_unbind_command",
          "args": [
            "\"chanserv\"",
            "&cs_sop"
          ],
          "line": 55
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_named_unbind_command",
          "args": [
            "\"chanserv\"",
            "&cs_aop"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\ncommand_t cs_sop = { \"SOP\", N_(\"Manipulates a channel SOP list.\"),\n                        AC_NONE, 3, cs_cmd_sop, { .path = \"cservice/xop\" } };\ncommand_t cs_aop = { \"AOP\", N_(\"Manipulates a channel AOP list.\"),\n                        AC_NONE, 3, cs_cmd_aop, { .path = \"cservice/xop\" } };\ncommand_t cs_hop = { \"HOP\", N_(\"Manipulates a channel HOP list.\"),\n\t\t\tAC_NONE, 3, cs_cmd_hop, { .path = \"cservice/xop\" } };\ncommand_t cs_vop = { \"VOP\", N_(\"Manipulates a channel VOP list.\"),\n                        AC_NONE, 3, cs_cmd_vop, { .path = \"cservice/xop\" } };\ncommand_t cs_forcexop = { \"FORCEXOP\", N_(\"Forces access levels to xOP levels.\"),\n                         AC_NONE, 1, cs_cmd_forcexop, { .path = \"cservice/forcexop\" } };\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_aop);\n\tservice_named_unbind_command(\"chanserv\", &cs_sop);\n\tservice_named_unbind_command(\"chanserv\", &cs_hop);\n\tservice_named_unbind_command(\"chanserv\", &cs_vop);\n\tservice_named_unbind_command(\"chanserv\", &cs_forcexop);\n}"
  },
  {
    "function_name": "_modinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/xop.c",
    "lines": "42-50",
    "snippet": "void _modinit(module_t *m)\n{\n\tservice_named_bind_command(\"chanserv\", &cs_aop);\n\tservice_named_bind_command(\"chanserv\", &cs_sop);\n\tif (ircd != NULL && ircd->uses_halfops)\n\t\tservice_named_bind_command(\"chanserv\", &cs_hop);\n\tservice_named_bind_command(\"chanserv\", &cs_vop);\n\tservice_named_bind_command(\"chanserv\", &cs_forcexop);\n}",
    "includes": [
      "#include \"chanserv.h\"",
      "#include \"template.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "command_t cs_sop = { \"SOP\", N_(\"Manipulates a channel SOP list.\"),\n                        AC_NONE, 3, cs_cmd_sop, { .path = \"cservice/xop\" } };",
      "command_t cs_aop = { \"AOP\", N_(\"Manipulates a channel AOP list.\"),\n                        AC_NONE, 3, cs_cmd_aop, { .path = \"cservice/xop\" } };",
      "command_t cs_hop = { \"HOP\", N_(\"Manipulates a channel HOP list.\"),\n\t\t\tAC_NONE, 3, cs_cmd_hop, { .path = \"cservice/xop\" } };",
      "command_t cs_vop = { \"VOP\", N_(\"Manipulates a channel VOP list.\"),\n                        AC_NONE, 3, cs_cmd_vop, { .path = \"cservice/xop\" } };",
      "command_t cs_forcexop = { \"FORCEXOP\", N_(\"Forces access levels to xOP levels.\"),\n                         AC_NONE, 1, cs_cmd_forcexop, { .path = \"cservice/forcexop\" } };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "service_named_bind_command",
          "args": [
            "\"chanserv\"",
            "&cs_forcexop"
          ],
          "line": 49
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_named_bind_command",
          "args": [
            "\"chanserv\"",
            "&cs_vop"
          ],
          "line": 48
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_named_bind_command",
          "args": [
            "\"chanserv\"",
            "&cs_hop"
          ],
          "line": 47
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_named_bind_command",
          "args": [
            "\"chanserv\"",
            "&cs_sop"
          ],
          "line": 45
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_named_bind_command",
          "args": [
            "\"chanserv\"",
            "&cs_aop"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"chanserv.h\"\n#include \"template.h\"\n#include \"atheme.h\"\n\ncommand_t cs_sop = { \"SOP\", N_(\"Manipulates a channel SOP list.\"),\n                        AC_NONE, 3, cs_cmd_sop, { .path = \"cservice/xop\" } };\ncommand_t cs_aop = { \"AOP\", N_(\"Manipulates a channel AOP list.\"),\n                        AC_NONE, 3, cs_cmd_aop, { .path = \"cservice/xop\" } };\ncommand_t cs_hop = { \"HOP\", N_(\"Manipulates a channel HOP list.\"),\n\t\t\tAC_NONE, 3, cs_cmd_hop, { .path = \"cservice/xop\" } };\ncommand_t cs_vop = { \"VOP\", N_(\"Manipulates a channel VOP list.\"),\n                        AC_NONE, 3, cs_cmd_vop, { .path = \"cservice/xop\" } };\ncommand_t cs_forcexop = { \"FORCEXOP\", N_(\"Forces access levels to xOP levels.\"),\n                         AC_NONE, 1, cs_cmd_forcexop, { .path = \"cservice/forcexop\" } };\n\nvoid _modinit(module_t *m)\n{\n\tservice_named_bind_command(\"chanserv\", &cs_aop);\n\tservice_named_bind_command(\"chanserv\", &cs_sop);\n\tif (ircd != NULL && ircd->uses_halfops)\n\t\tservice_named_bind_command(\"chanserv\", &cs_hop);\n\tservice_named_bind_command(\"chanserv\", &cs_vop);\n\tservice_named_bind_command(\"chanserv\", &cs_forcexop);\n}"
  }
]