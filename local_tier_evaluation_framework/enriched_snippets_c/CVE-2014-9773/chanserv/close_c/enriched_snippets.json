[
  {
    "function_name": "cs_cmd_close",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/close.c",
    "lines": "68-174",
    "snippet": "static void cs_cmd_close(sourceinfo_t *si, int parc, char *parv[])\n{\n\tchar *target = parv[0];\n\tchar *action = parv[1];\n\tchar *reason = parv[2];\n\tmychan_t *mc;\n\tchannel_t *c;\n\tchanuser_t *cu;\n\tmowgli_node_t *n, *tn;\n\n\tif (!target || !action)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"CLOSE\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Usage: CLOSE <#channel> <ON|OFF> [reason]\"));\n\t\treturn;\n\t}\n\n\tif (!(mc = mychan_find(target)))\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), target);\n\t\treturn;\n\t}\n\n\tif (!strcasecmp(action, \"ON\"))\n\t{\n\t\tif (!reason)\n\t\t{\n\t\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"CLOSE\");\n\t\t\tcommand_fail(si, fault_needmoreparams, _(\"Usage: CLOSE <#channel> ON <reason>\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (mc->flags & CHAN_LOG)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 cannot be closed.\"), target);\n\t\t\treturn;\n\t\t}\n\n\t\tif (metadata_find(mc, \"private:close:closer\"))\n\t\t{\n\t\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is already closed.\"), target);\n\t\t\treturn;\n\t\t}\n\n\t\tmetadata_add(mc, \"private:close:closer\", get_oper_name(si));\n\t\tmetadata_add(mc, \"private:close:reason\", reason);\n\t\tmetadata_add(mc, \"private:close:timestamp\", number_to_string(CURRTIME));\n\n\t\tif ((c = channel_find(target)))\n\t\t{\n\t\t\tif (!chanuser_find(c, user_find_named(chansvs.nick)))\n\t\t\t\tjoin(target, chansvs.nick);\n\n\t\t\t/* stay for a bit to stop rejoin floods */\n\t\t\tmc->flags |= MC_INHABIT;\n\n\t\t\t/* lock it down */\n\t\t\tchannel_mode_va(chansvs.me->me, c, 3, \"+isbl\", \"*!*@*\", \"1\");\n\n\t\t\t/* clear the channel */\n\t\t\tMOWGLI_ITER_FOREACH_SAFE(n, tn, c->members.head)\n\t\t\t{\n\t\t\t\tcu = (chanuser_t *)n->data;\n\n\t\t\t\tif (!is_internal_client(cu->user))\n\t\t\t\t\tkick(chansvs.me->me, c, cu->user, \"This channel has been closed\");\n\t\t\t}\n\t\t}\n\n\t\twallops(\"%s closed the channel \\2%s\\2 (%s).\", get_oper_name(si), target, reason);\n\t\tlogcommand(si, CMDLOG_ADMIN, \"CLOSE:ON: \\2%s\\2 (reason: \\2%s\\2)\", target, reason);\n\t\tcommand_success_nodata(si, _(\"\\2%s\\2 is now closed.\"), target);\n\t}\n\telse if (!strcasecmp(action, \"OFF\"))\n\t{\n\t\tif (!metadata_find(mc, \"private:close:closer\"))\n\t\t{\n\t\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is not closed.\"), target);\n\t\t\treturn;\n\t\t}\n\n\t\tmetadata_delete(mc, \"private:close:closer\");\n\t\tmetadata_delete(mc, \"private:close:reason\");\n\t\tmetadata_delete(mc, \"private:close:timestamp\");\n\t\tmc->flags &= ~MC_INHABIT;\n\t\tc = channel_find(target);\n\t\tif (c != NULL)\n\t\t\tif (chanuser_find(c, user_find_named(chansvs.nick)))\n\t\t\t\tpart(c->name, chansvs.nick);\n\t\tc = channel_find(target);\n\t\tif (c != NULL)\n\t\t{\n\t\t\t/* hmm, channel still exists, probably permanent? */\n\t\t\tchannel_mode_va(chansvs.me->me, c, 2, \"-isbl\", \"*!*@*\");\n\t\t\tcheck_modes(mc, true);\n\t\t}\n\n\t\twallops(\"%s reopened the channel \\2%s\\2.\", get_oper_name(si), target);\n\t\tlogcommand(si, CMDLOG_ADMIN, \"CLOSE:OFF: \\2%s\\2\", target);\n\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been reopened.\"), target);\n\t}\n\telse\n\t{\n\t\tcommand_fail(si, fault_badparams, STR_INVALID_PARAMS, \"CLOSE\");\n\t\tcommand_fail(si, fault_badparams, _(\"Usage: CLOSE <#channel> <ON|OFF> [reason]\"));\n\t}\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_cmd_close(sourceinfo_t *si, int parc, char *parv[]);",
      "static void close_check_join(hook_channel_joinpart_t *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_badparams",
            "_(\"Usage: CLOSE <#channel> <ON|OFF> [reason]\")"
          ],
          "line": 172
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Usage: CLOSE <#channel> <ON|OFF> [reason]\""
          ],
          "line": 172
        },
        "resolved": true,
        "details": {
          "function_name": "close_check_join",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/close.c",
          "lines": "39-66",
          "snippet": "static void close_check_join(hook_channel_joinpart_t *data)\n{\n\tmychan_t *mc;\n\tchanuser_t *cu = data->cu;\n\n\tif (cu == NULL || is_internal_client(cu->user))\n\t\treturn;\n\tmc = mychan_find(cu->chan->name);\n\tif (mc == NULL)\n\t\treturn;\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\t/* don't join if we're already in there */\n\t\tif (!chanuser_find(cu->chan, user_find_named(chansvs.nick)))\n\t\t\tjoin(cu->chan->name, chansvs.nick);\n\n\t\t/* stay for a bit to stop rejoin floods */\n\t\tmc->flags |= MC_INHABIT;\n\n\t\t/* lock it down */\n\t\tchannel_mode_va(chansvs.me->me, cu->chan, 3, \"+isbl\", \"*!*@*\", \"1\");\n\n\t\t/* clear the channel */\n\t\tkick(chansvs.me->me, cu->chan, cu->user, \"This channel has been closed\");\n\t\tdata->cu = NULL;\n\t}\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void close_check_join(hook_channel_joinpart_t *data);"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nstatic void close_check_join(hook_channel_joinpart_t *data);\n\nstatic void close_check_join(hook_channel_joinpart_t *data)\n{\n\tmychan_t *mc;\n\tchanuser_t *cu = data->cu;\n\n\tif (cu == NULL || is_internal_client(cu->user))\n\t\treturn;\n\tmc = mychan_find(cu->chan->name);\n\tif (mc == NULL)\n\t\treturn;\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\t/* don't join if we're already in there */\n\t\tif (!chanuser_find(cu->chan, user_find_named(chansvs.nick)))\n\t\t\tjoin(cu->chan->name, chansvs.nick);\n\n\t\t/* stay for a bit to stop rejoin floods */\n\t\tmc->flags |= MC_INHABIT;\n\n\t\t/* lock it down */\n\t\tchannel_mode_va(chansvs.me->me, cu->chan, 3, \"+isbl\", \"*!*@*\", \"1\");\n\n\t\t/* clear the channel */\n\t\tkick(chansvs.me->me, cu->chan, cu->user, \"This channel has been closed\");\n\t\tdata->cu = NULL;\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_badparams",
            "STR_INVALID_PARAMS",
            "\"CLOSE\""
          ],
          "line": 171
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"\\2%s\\2 has been reopened.\")",
            "target"
          ],
          "line": 167
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_ADMIN",
            "\"CLOSE:OFF: \\2%s\\2\"",
            "target"
          ],
          "line": 166
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wallops",
          "args": [
            "\"%s reopened the channel \\2%s\\2.\"",
            "get_oper_name(si)",
            "target"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_oper_name",
          "args": [
            "si"
          ],
          "line": 165
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "check_modes",
          "args": [
            "mc",
            "true"
          ],
          "line": 162
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_mode_va",
          "args": [
            "chansvs.me->me",
            "c",
            "2",
            "\"-isbl\"",
            "\"*!*@*\""
          ],
          "line": 161
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_find",
          "args": [
            "target"
          ],
          "line": 157
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "part",
          "args": [
            "c->name",
            "chansvs.nick"
          ],
          "line": 156
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanuser_find",
          "args": [
            "c",
            "user_find_named(chansvs.nick)"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_find_named",
          "args": [
            "chansvs.nick"
          ],
          "line": 155
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_find",
          "args": [
            "target"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_delete",
          "args": [
            "mc",
            "\"private:close:timestamp\""
          ],
          "line": 151
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_delete",
          "args": [
            "mc",
            "\"private:close:reason\""
          ],
          "line": 150
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_delete",
          "args": [
            "mc",
            "\"private:close:closer\""
          ],
          "line": 149
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nochange",
            "_(\"\\2%s\\2 is not closed.\")",
            "target"
          ],
          "line": 145
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:close:closer\""
          ],
          "line": 143
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "action",
            "\"OFF\""
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"\\2%s\\2 is now closed.\")",
            "target"
          ],
          "line": 139
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_ADMIN",
            "\"CLOSE:ON: \\2%s\\2 (reason: \\2%s\\2)\"",
            "target",
            "reason"
          ],
          "line": 138
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "wallops",
          "args": [
            "\"%s closed the channel \\2%s\\2 (%s).\"",
            "get_oper_name(si)",
            "target",
            "reason"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_oper_name",
          "args": [
            "si"
          ],
          "line": 137
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "kick",
          "args": [
            "chansvs.me->me",
            "c",
            "cu->user",
            "\"This channel has been closed\""
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "akick_add_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/akick.c",
          "lines": "726-753",
          "snippet": "static akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson)\n{\n\tmowgli_node_t *n;\n\takick_timeout_t *timeout, *timeout2;\n\n\ttimeout = mowgli_heap_alloc(akick_timeout_heap);\n\n\ttimeout->entity = mt;\n\ttimeout->chan = mc;\n\ttimeout->expiration = expireson;\n\n\tmowgli_strlcpy(timeout->host, host, sizeof timeout->host);\n\n\tMOWGLI_ITER_FOREACH_PREV(n, akickdel_list.tail)\n\t{\n\t\ttimeout2 = n->data;\n\t\tif (timeout2->expiration <= timeout->expiration)\n\t\t\tbreak;\n\t}\n\tif (n == NULL)\n\t\tmowgli_node_add_head(timeout, &timeout->node, &akickdel_list);\n\telse if (n->next == NULL)\n\t\tmowgli_node_add(timeout, &timeout->node, &akickdel_list);\n\telse\n\t\tmowgli_node_add_before(timeout, &timeout->node, &akickdel_list, n->next);\n\n\treturn timeout;\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "mowgli_list_t akickdel_list;",
            "static akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson);",
            "mowgli_heap_t *akick_timeout_heap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nmowgli_list_t akickdel_list;\nstatic akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson);\nmowgli_heap_t *akick_timeout_heap;\n\nstatic akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson)\n{\n\tmowgli_node_t *n;\n\takick_timeout_t *timeout, *timeout2;\n\n\ttimeout = mowgli_heap_alloc(akick_timeout_heap);\n\n\ttimeout->entity = mt;\n\ttimeout->chan = mc;\n\ttimeout->expiration = expireson;\n\n\tmowgli_strlcpy(timeout->host, host, sizeof timeout->host);\n\n\tMOWGLI_ITER_FOREACH_PREV(n, akickdel_list.tail)\n\t{\n\t\ttimeout2 = n->data;\n\t\tif (timeout2->expiration <= timeout->expiration)\n\t\t\tbreak;\n\t}\n\tif (n == NULL)\n\t\tmowgli_node_add_head(timeout, &timeout->node, &akickdel_list);\n\telse if (n->next == NULL)\n\t\tmowgli_node_add(timeout, &timeout->node, &akickdel_list);\n\telse\n\t\tmowgli_node_add_before(timeout, &timeout->node, &akickdel_list, n->next);\n\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "is_internal_client",
          "args": [
            "cu->user"
          ],
          "line": 132
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_ITER_FOREACH_SAFE",
          "args": [
            "n",
            "tn",
            "c->members.head"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_mode_va",
          "args": [
            "chansvs.me->me",
            "c",
            "3",
            "\"+isbl\"",
            "\"*!*@*\"",
            "\"1\""
          ],
          "line": 125
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "join",
          "args": [
            "target",
            "chansvs.nick"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanuser_find",
          "args": [
            "c",
            "user_find_named(chansvs.nick)"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_find_named",
          "args": [
            "chansvs.nick"
          ],
          "line": 118
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "channel_find",
          "args": [
            "target"
          ],
          "line": 116
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_add",
          "args": [
            "mc",
            "\"private:close:timestamp\"",
            "number_to_string(CURRTIME)"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "number_to_string",
          "args": [
            "CURRTIME"
          ],
          "line": 114
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_add",
          "args": [
            "mc",
            "\"private:close:reason\"",
            "reason"
          ],
          "line": 113
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_add",
          "args": [
            "mc",
            "\"private:close:closer\"",
            "get_oper_name(si)"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_oper_name",
          "args": [
            "si"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nochange",
            "_(\"\\2%s\\2 is already closed.\")",
            "target"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:close:closer\""
          ],
          "line": 106
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"\\2%s\\2 cannot be closed.\")",
            "target"
          ],
          "line": 102
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "_(\"Usage: CLOSE <#channel> ON <reason>\")"
          ],
          "line": 96
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "STR_INSUFFICIENT_PARAMS",
            "\"CLOSE\""
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strcasecmp",
          "args": [
            "action",
            "\"ON\""
          ],
          "line": 91
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_target",
            "_(\"Channel \\2%s\\2 is not registered.\")",
            "target"
          ],
          "line": 87
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_find",
          "args": [
            "target"
          ],
          "line": 85
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "_(\"Usage: CLOSE <#channel> <ON|OFF> [reason]\")"
          ],
          "line": 81
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "STR_INSUFFICIENT_PARAMS",
            "\"CLOSE\""
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic void cs_cmd_close(sourceinfo_t *si, int parc, char *parv[]);\nstatic void close_check_join(hook_channel_joinpart_t *data);\n\nstatic void cs_cmd_close(sourceinfo_t *si, int parc, char *parv[])\n{\n\tchar *target = parv[0];\n\tchar *action = parv[1];\n\tchar *reason = parv[2];\n\tmychan_t *mc;\n\tchannel_t *c;\n\tchanuser_t *cu;\n\tmowgli_node_t *n, *tn;\n\n\tif (!target || !action)\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"CLOSE\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Usage: CLOSE <#channel> <ON|OFF> [reason]\"));\n\t\treturn;\n\t}\n\n\tif (!(mc = mychan_find(target)))\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), target);\n\t\treturn;\n\t}\n\n\tif (!strcasecmp(action, \"ON\"))\n\t{\n\t\tif (!reason)\n\t\t{\n\t\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"CLOSE\");\n\t\t\tcommand_fail(si, fault_needmoreparams, _(\"Usage: CLOSE <#channel> ON <reason>\"));\n\t\t\treturn;\n\t\t}\n\n\t\tif (mc->flags & CHAN_LOG)\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 cannot be closed.\"), target);\n\t\t\treturn;\n\t\t}\n\n\t\tif (metadata_find(mc, \"private:close:closer\"))\n\t\t{\n\t\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is already closed.\"), target);\n\t\t\treturn;\n\t\t}\n\n\t\tmetadata_add(mc, \"private:close:closer\", get_oper_name(si));\n\t\tmetadata_add(mc, \"private:close:reason\", reason);\n\t\tmetadata_add(mc, \"private:close:timestamp\", number_to_string(CURRTIME));\n\n\t\tif ((c = channel_find(target)))\n\t\t{\n\t\t\tif (!chanuser_find(c, user_find_named(chansvs.nick)))\n\t\t\t\tjoin(target, chansvs.nick);\n\n\t\t\t/* stay for a bit to stop rejoin floods */\n\t\t\tmc->flags |= MC_INHABIT;\n\n\t\t\t/* lock it down */\n\t\t\tchannel_mode_va(chansvs.me->me, c, 3, \"+isbl\", \"*!*@*\", \"1\");\n\n\t\t\t/* clear the channel */\n\t\t\tMOWGLI_ITER_FOREACH_SAFE(n, tn, c->members.head)\n\t\t\t{\n\t\t\t\tcu = (chanuser_t *)n->data;\n\n\t\t\t\tif (!is_internal_client(cu->user))\n\t\t\t\t\tkick(chansvs.me->me, c, cu->user, \"This channel has been closed\");\n\t\t\t}\n\t\t}\n\n\t\twallops(\"%s closed the channel \\2%s\\2 (%s).\", get_oper_name(si), target, reason);\n\t\tlogcommand(si, CMDLOG_ADMIN, \"CLOSE:ON: \\2%s\\2 (reason: \\2%s\\2)\", target, reason);\n\t\tcommand_success_nodata(si, _(\"\\2%s\\2 is now closed.\"), target);\n\t}\n\telse if (!strcasecmp(action, \"OFF\"))\n\t{\n\t\tif (!metadata_find(mc, \"private:close:closer\"))\n\t\t{\n\t\t\tcommand_fail(si, fault_nochange, _(\"\\2%s\\2 is not closed.\"), target);\n\t\t\treturn;\n\t\t}\n\n\t\tmetadata_delete(mc, \"private:close:closer\");\n\t\tmetadata_delete(mc, \"private:close:reason\");\n\t\tmetadata_delete(mc, \"private:close:timestamp\");\n\t\tmc->flags &= ~MC_INHABIT;\n\t\tc = channel_find(target);\n\t\tif (c != NULL)\n\t\t\tif (chanuser_find(c, user_find_named(chansvs.nick)))\n\t\t\t\tpart(c->name, chansvs.nick);\n\t\tc = channel_find(target);\n\t\tif (c != NULL)\n\t\t{\n\t\t\t/* hmm, channel still exists, probably permanent? */\n\t\t\tchannel_mode_va(chansvs.me->me, c, 2, \"-isbl\", \"*!*@*\");\n\t\t\tcheck_modes(mc, true);\n\t\t}\n\n\t\twallops(\"%s reopened the channel \\2%s\\2.\", get_oper_name(si), target);\n\t\tlogcommand(si, CMDLOG_ADMIN, \"CLOSE:OFF: \\2%s\\2\", target);\n\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been reopened.\"), target);\n\t}\n\telse\n\t{\n\t\tcommand_fail(si, fault_badparams, STR_INVALID_PARAMS, \"CLOSE\");\n\t\tcommand_fail(si, fault_badparams, _(\"Usage: CLOSE <#channel> <ON|OFF> [reason]\"));\n\t}\n}"
  },
  {
    "function_name": "close_check_join",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/close.c",
    "lines": "39-66",
    "snippet": "static void close_check_join(hook_channel_joinpart_t *data)\n{\n\tmychan_t *mc;\n\tchanuser_t *cu = data->cu;\n\n\tif (cu == NULL || is_internal_client(cu->user))\n\t\treturn;\n\tmc = mychan_find(cu->chan->name);\n\tif (mc == NULL)\n\t\treturn;\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\t/* don't join if we're already in there */\n\t\tif (!chanuser_find(cu->chan, user_find_named(chansvs.nick)))\n\t\t\tjoin(cu->chan->name, chansvs.nick);\n\n\t\t/* stay for a bit to stop rejoin floods */\n\t\tmc->flags |= MC_INHABIT;\n\n\t\t/* lock it down */\n\t\tchannel_mode_va(chansvs.me->me, cu->chan, 3, \"+isbl\", \"*!*@*\", \"1\");\n\n\t\t/* clear the channel */\n\t\tkick(chansvs.me->me, cu->chan, cu->user, \"This channel has been closed\");\n\t\tdata->cu = NULL;\n\t}\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void close_check_join(hook_channel_joinpart_t *data);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "kick",
          "args": [
            "chansvs.me->me",
            "cu->chan",
            "cu->user",
            "\"This channel has been closed\""
          ],
          "line": 63
        },
        "resolved": true,
        "details": {
          "function_name": "akick_add_timeout",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/akick.c",
          "lines": "726-753",
          "snippet": "static akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson)\n{\n\tmowgli_node_t *n;\n\takick_timeout_t *timeout, *timeout2;\n\n\ttimeout = mowgli_heap_alloc(akick_timeout_heap);\n\n\ttimeout->entity = mt;\n\ttimeout->chan = mc;\n\ttimeout->expiration = expireson;\n\n\tmowgli_strlcpy(timeout->host, host, sizeof timeout->host);\n\n\tMOWGLI_ITER_FOREACH_PREV(n, akickdel_list.tail)\n\t{\n\t\ttimeout2 = n->data;\n\t\tif (timeout2->expiration <= timeout->expiration)\n\t\t\tbreak;\n\t}\n\tif (n == NULL)\n\t\tmowgli_node_add_head(timeout, &timeout->node, &akickdel_list);\n\telse if (n->next == NULL)\n\t\tmowgli_node_add(timeout, &timeout->node, &akickdel_list);\n\telse\n\t\tmowgli_node_add_before(timeout, &timeout->node, &akickdel_list, n->next);\n\n\treturn timeout;\n}",
          "includes": [
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "mowgli_list_t akickdel_list;",
            "static akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson);",
            "mowgli_heap_t *akick_timeout_heap;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"atheme.h\"\n\nmowgli_list_t akickdel_list;\nstatic akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson);\nmowgli_heap_t *akick_timeout_heap;\n\nstatic akick_timeout_t *akick_add_timeout(mychan_t *mc, myentity_t *mt, const char *host, time_t expireson)\n{\n\tmowgli_node_t *n;\n\takick_timeout_t *timeout, *timeout2;\n\n\ttimeout = mowgli_heap_alloc(akick_timeout_heap);\n\n\ttimeout->entity = mt;\n\ttimeout->chan = mc;\n\ttimeout->expiration = expireson;\n\n\tmowgli_strlcpy(timeout->host, host, sizeof timeout->host);\n\n\tMOWGLI_ITER_FOREACH_PREV(n, akickdel_list.tail)\n\t{\n\t\ttimeout2 = n->data;\n\t\tif (timeout2->expiration <= timeout->expiration)\n\t\t\tbreak;\n\t}\n\tif (n == NULL)\n\t\tmowgli_node_add_head(timeout, &timeout->node, &akickdel_list);\n\telse if (n->next == NULL)\n\t\tmowgli_node_add(timeout, &timeout->node, &akickdel_list);\n\telse\n\t\tmowgli_node_add_before(timeout, &timeout->node, &akickdel_list, n->next);\n\n\treturn timeout;\n}"
        }
      },
      {
        "call_info": {
          "callee": "channel_mode_va",
          "args": [
            "chansvs.me->me",
            "cu->chan",
            "3",
            "\"+isbl\"",
            "\"*!*@*\"",
            "\"1\""
          ],
          "line": 60
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "join",
          "args": [
            "cu->chan->name",
            "chansvs.nick"
          ],
          "line": 54
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanuser_find",
          "args": [
            "cu->chan",
            "user_find_named(chansvs.nick)"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_find_named",
          "args": [
            "chansvs.nick"
          ],
          "line": 53
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:close:closer\""
          ],
          "line": 50
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_find",
          "args": [
            "cu->chan->name"
          ],
          "line": 46
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_internal_client",
          "args": [
            "cu->user"
          ],
          "line": 44
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\nstatic void close_check_join(hook_channel_joinpart_t *data);\n\nstatic void close_check_join(hook_channel_joinpart_t *data)\n{\n\tmychan_t *mc;\n\tchanuser_t *cu = data->cu;\n\n\tif (cu == NULL || is_internal_client(cu->user))\n\t\treturn;\n\tmc = mychan_find(cu->chan->name);\n\tif (mc == NULL)\n\t\treturn;\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\t/* don't join if we're already in there */\n\t\tif (!chanuser_find(cu->chan, user_find_named(chansvs.nick)))\n\t\t\tjoin(cu->chan->name, chansvs.nick);\n\n\t\t/* stay for a bit to stop rejoin floods */\n\t\tmc->flags |= MC_INHABIT;\n\n\t\t/* lock it down */\n\t\tchannel_mode_va(chansvs.me->me, cu->chan, 3, \"+isbl\", \"*!*@*\", \"1\");\n\n\t\t/* clear the channel */\n\t\tkick(chansvs.me->me, cu->chan, cu->user, \"This channel has been closed\");\n\t\tdata->cu = NULL;\n\t}\n}"
  },
  {
    "function_name": "_moddeinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/close.c",
    "lines": "33-37",
    "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_close);\n\thook_del_channel_join(close_check_join);\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "command_t cs_close = { \"CLOSE\", N_(\"Closes a channel.\"),\n\t\t\tPRIV_CHAN_ADMIN, 3, cs_cmd_close , { .path = \"cservice/close\" }};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hook_del_channel_join",
          "args": [
            "close_check_join"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_named_unbind_command",
          "args": [
            "\"chanserv\"",
            "&cs_close"
          ],
          "line": 35
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\ncommand_t cs_close = { \"CLOSE\", N_(\"Closes a channel.\"),\n\t\t\tPRIV_CHAN_ADMIN, 3, cs_cmd_close , { .path = \"cservice/close\" }};\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_close);\n\thook_del_channel_join(close_check_join);\n}"
  },
  {
    "function_name": "_modinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/close.c",
    "lines": "26-31",
    "snippet": "void _modinit(module_t *m)\n{\n\tservice_named_bind_command(\"chanserv\", &cs_close);\n\thook_add_event(\"channel_join\");\n\thook_add_first_channel_join(close_check_join);\n}",
    "includes": [
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "command_t cs_close = { \"CLOSE\", N_(\"Closes a channel.\"),\n\t\t\tPRIV_CHAN_ADMIN, 3, cs_cmd_close , { .path = \"cservice/close\" }};"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "hook_add_first_channel_join",
          "args": [
            "close_check_join"
          ],
          "line": 30
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "hook_add_event",
          "args": [
            "\"channel_join\""
          ],
          "line": 29
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_named_bind_command",
          "args": [
            "\"chanserv\"",
            "&cs_close"
          ],
          "line": 28
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"atheme.h\"\n\ncommand_t cs_close = { \"CLOSE\", N_(\"Closes a channel.\"),\n\t\t\tPRIV_CHAN_ADMIN, 3, cs_cmd_close , { .path = \"cservice/close\" }};\n\nvoid _modinit(module_t *m)\n{\n\tservice_named_bind_command(\"chanserv\", &cs_close);\n\thook_add_event(\"channel_join\");\n\thook_add_first_channel_join(close_check_join);\n}"
  }
]