[
  {
    "function_name": "cs_cmd_dehalfop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/halfop.c",
    "lines": "148-158",
    "snippet": "static void cs_cmd_dehalfop(sourceinfo_t *si, int parc, char *parv[])\n{\n\tif (!parv[0])\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"DEHALFOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: DEHALFOP <#channel> [nickname] [...]\"));\n\t\treturn;\n\t}\n\n\tcmd_halfop(si, false, parc, parv);\n}",
    "includes": [
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_cmd_halfop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_dehalfop(sourceinfo_t *si, int parc, char *parv[]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmd_halfop",
          "args": [
            "si",
            "false",
            "parc",
            "parv"
          ],
          "line": 157
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_halfop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/halfop.c",
          "lines": "48-134",
          "snippet": "static void cmd_halfop(sourceinfo_t *si, bool halfopping, int parc, char *parv[])\n{\n\tchar *chan = parv[0];\n\tchar *nick = parv[1];\n\tmychan_t *mc;\n\tuser_t *tu;\n\tchanuser_t *cu;\n\tchar *nicks;\n\tbool halfop;\n\tmowgli_node_t *n;\n\n\tif (!ircd->uses_halfops)\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"Your IRC server does not support halfops.\"));\n\t\treturn;\n\t}\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (!chanacs_source_has_flag(mc, si, CA_HALFOP))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tnicks = (!nick ? strdup(si->su->nick) : strdup(nick));\n\tprefix_action_set_all(&halfop_actions, halfopping, nicks);\n\tfree(nicks);\n\n\tMOWGLI_LIST_FOREACH(n, halfop_actions.head)\n\t{\n\t\tstruct prefix_action *act = n->data;\n\t\tnick = act->nick;\n\t\thalfop = act->en;\n\n\t\t/* figure out who we're going to halfop */\n\t\tif (!(tu = user_find_named(nick)))\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not online.\"), nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is_internal_client(tu))\n\t\t\tcontinue;\n\n\t\t/* SECURE check; we can skip this if deopping or sender == target, because we already verified */\n\t\tif (halfop && (si->su != tu) && (mc->flags & MC_SECURE) && !chanacs_user_has_flag(mc, tu, CA_HALFOP) && !chanacs_user_has_flag(mc, tu, CA_AUTOHALFOP))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 has the SECURE option enabled, and \\2%s\\2 does not have appropriate access.\"), mc->name, tu->nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcu = chanuser_find(mc->chan, tu);\n\t\tif (!cu)\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not on \\2%s\\2.\"), tu->nick, mc->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmodestack_mode_param(chansvs.nick, mc->chan, halfop ? MTYPE_ADD : MTYPE_DEL, 'h', CLIENT_NAME(tu));\n\t\tif (halfop)\n\t\t\tcu->modes |= ircd->halfops_mode;\n\t\telse\n\t\t\tcu->modes &= ~ircd->halfops_mode;\n\n\t\tif (si->c == NULL && tu != si->su)\n\t\t\tchange_notify(chansvs.nick, tu, \"You have been %shalfopped on %s by %s\", halfop ? \"\" : \"de\", mc->name, get_source_name(si));\n\n\t\tlogcommand(si, CMDLOG_DO, \"%sHALFOP: \\2%s!%s@%s\\2 on \\2%s\\2\", halfop ? \"\" : \"DE\", tu->nick, tu->user, tu->vhost, mc->name);\n\t\tif (si->su == NULL || !chanuser_find(mc->chan, si->su))\n\t\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been %shalfopped on \\2%s\\2.\"), tu->nick, halfop ? \"\" : \"de\", mc->name);\n\t}\n\n\tprefix_action_clear(&halfop_actions);\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cs_cmd_halfop(sourceinfo_t *si, int parc, char *parv[]);",
            "static void cs_cmd_dehalfop(sourceinfo_t *si, int parc, char *parv[]);",
            "static mowgli_list_t halfop_actions;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_cmd_halfop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_dehalfop(sourceinfo_t *si, int parc, char *parv[]);\nstatic mowgli_list_t halfop_actions;\n\nstatic void cmd_halfop(sourceinfo_t *si, bool halfopping, int parc, char *parv[])\n{\n\tchar *chan = parv[0];\n\tchar *nick = parv[1];\n\tmychan_t *mc;\n\tuser_t *tu;\n\tchanuser_t *cu;\n\tchar *nicks;\n\tbool halfop;\n\tmowgli_node_t *n;\n\n\tif (!ircd->uses_halfops)\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"Your IRC server does not support halfops.\"));\n\t\treturn;\n\t}\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (!chanacs_source_has_flag(mc, si, CA_HALFOP))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tnicks = (!nick ? strdup(si->su->nick) : strdup(nick));\n\tprefix_action_set_all(&halfop_actions, halfopping, nicks);\n\tfree(nicks);\n\n\tMOWGLI_LIST_FOREACH(n, halfop_actions.head)\n\t{\n\t\tstruct prefix_action *act = n->data;\n\t\tnick = act->nick;\n\t\thalfop = act->en;\n\n\t\t/* figure out who we're going to halfop */\n\t\tif (!(tu = user_find_named(nick)))\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not online.\"), nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is_internal_client(tu))\n\t\t\tcontinue;\n\n\t\t/* SECURE check; we can skip this if deopping or sender == target, because we already verified */\n\t\tif (halfop && (si->su != tu) && (mc->flags & MC_SECURE) && !chanacs_user_has_flag(mc, tu, CA_HALFOP) && !chanacs_user_has_flag(mc, tu, CA_AUTOHALFOP))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 has the SECURE option enabled, and \\2%s\\2 does not have appropriate access.\"), mc->name, tu->nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcu = chanuser_find(mc->chan, tu);\n\t\tif (!cu)\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not on \\2%s\\2.\"), tu->nick, mc->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmodestack_mode_param(chansvs.nick, mc->chan, halfop ? MTYPE_ADD : MTYPE_DEL, 'h', CLIENT_NAME(tu));\n\t\tif (halfop)\n\t\t\tcu->modes |= ircd->halfops_mode;\n\t\telse\n\t\t\tcu->modes &= ~ircd->halfops_mode;\n\n\t\tif (si->c == NULL && tu != si->su)\n\t\t\tchange_notify(chansvs.nick, tu, \"You have been %shalfopped on %s by %s\", halfop ? \"\" : \"de\", mc->name, get_source_name(si));\n\n\t\tlogcommand(si, CMDLOG_DO, \"%sHALFOP: \\2%s!%s@%s\\2 on \\2%s\\2\", halfop ? \"\" : \"DE\", tu->nick, tu->user, tu->vhost, mc->name);\n\t\tif (si->su == NULL || !chanuser_find(mc->chan, si->su))\n\t\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been %shalfopped on \\2%s\\2.\"), tu->nick, halfop ? \"\" : \"de\", mc->name);\n\t}\n\n\tprefix_action_clear(&halfop_actions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "_(\"Syntax: DEHALFOP <#channel> [nickname] [...]\")"
          ],
          "line": 153
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Syntax: DEHALFOP <#channel> [nickname] [...]\""
          ],
          "line": 153
        },
        "resolved": true,
        "details": {
          "function_name": "_moddeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/halfop.c",
          "lines": "40-44",
          "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_halfop);\n\tservice_named_unbind_command(\"chanserv\", &cs_dehalfop);\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "command_t cs_halfop = { \"HALFOP\", N_(\"Gives channel halfops to a user.\"),\n                        AC_NONE, 2, cs_cmd_halfop, { .path = \"cservice/halfop\" } };",
            "command_t cs_dehalfop = { \"DEHALFOP\", N_(\"Removes channel halfops from a user.\"),\n                        AC_NONE, 2, cs_cmd_dehalfop, { .path = \"cservice/halfop\" } };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"atheme.h\"\n\ncommand_t cs_halfop = { \"HALFOP\", N_(\"Gives channel halfops to a user.\"),\n                        AC_NONE, 2, cs_cmd_halfop, { .path = \"cservice/halfop\" } };\ncommand_t cs_dehalfop = { \"DEHALFOP\", N_(\"Removes channel halfops from a user.\"),\n                        AC_NONE, 2, cs_cmd_dehalfop, { .path = \"cservice/halfop\" } };\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_halfop);\n\tservice_named_unbind_command(\"chanserv\", &cs_dehalfop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "STR_INSUFFICIENT_PARAMS",
            "\"DEHALFOP\""
          ],
          "line": 152
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_cmd_halfop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_dehalfop(sourceinfo_t *si, int parc, char *parv[]);\n\nstatic void cs_cmd_dehalfop(sourceinfo_t *si, int parc, char *parv[])\n{\n\tif (!parv[0])\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"DEHALFOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: DEHALFOP <#channel> [nickname] [...]\"));\n\t\treturn;\n\t}\n\n\tcmd_halfop(si, false, parc, parv);\n}"
  },
  {
    "function_name": "cs_cmd_halfop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/halfop.c",
    "lines": "136-146",
    "snippet": "static void cs_cmd_halfop(sourceinfo_t *si, int parc, char *parv[])\n{\n\tif (!parv[0])\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"HALFOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: HALFOP <#channel> [nickname] [...]\"));\n\t\treturn;\n\t}\n\n\tcmd_halfop(si, true, parc, parv);\n}",
    "includes": [
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_cmd_halfop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_dehalfop(sourceinfo_t *si, int parc, char *parv[]);"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "cmd_halfop",
          "args": [
            "si",
            "true",
            "parc",
            "parv"
          ],
          "line": 145
        },
        "resolved": true,
        "details": {
          "function_name": "cmd_halfop",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/halfop.c",
          "lines": "48-134",
          "snippet": "static void cmd_halfop(sourceinfo_t *si, bool halfopping, int parc, char *parv[])\n{\n\tchar *chan = parv[0];\n\tchar *nick = parv[1];\n\tmychan_t *mc;\n\tuser_t *tu;\n\tchanuser_t *cu;\n\tchar *nicks;\n\tbool halfop;\n\tmowgli_node_t *n;\n\n\tif (!ircd->uses_halfops)\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"Your IRC server does not support halfops.\"));\n\t\treturn;\n\t}\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (!chanacs_source_has_flag(mc, si, CA_HALFOP))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tnicks = (!nick ? strdup(si->su->nick) : strdup(nick));\n\tprefix_action_set_all(&halfop_actions, halfopping, nicks);\n\tfree(nicks);\n\n\tMOWGLI_LIST_FOREACH(n, halfop_actions.head)\n\t{\n\t\tstruct prefix_action *act = n->data;\n\t\tnick = act->nick;\n\t\thalfop = act->en;\n\n\t\t/* figure out who we're going to halfop */\n\t\tif (!(tu = user_find_named(nick)))\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not online.\"), nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is_internal_client(tu))\n\t\t\tcontinue;\n\n\t\t/* SECURE check; we can skip this if deopping or sender == target, because we already verified */\n\t\tif (halfop && (si->su != tu) && (mc->flags & MC_SECURE) && !chanacs_user_has_flag(mc, tu, CA_HALFOP) && !chanacs_user_has_flag(mc, tu, CA_AUTOHALFOP))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 has the SECURE option enabled, and \\2%s\\2 does not have appropriate access.\"), mc->name, tu->nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcu = chanuser_find(mc->chan, tu);\n\t\tif (!cu)\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not on \\2%s\\2.\"), tu->nick, mc->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmodestack_mode_param(chansvs.nick, mc->chan, halfop ? MTYPE_ADD : MTYPE_DEL, 'h', CLIENT_NAME(tu));\n\t\tif (halfop)\n\t\t\tcu->modes |= ircd->halfops_mode;\n\t\telse\n\t\t\tcu->modes &= ~ircd->halfops_mode;\n\n\t\tif (si->c == NULL && tu != si->su)\n\t\t\tchange_notify(chansvs.nick, tu, \"You have been %shalfopped on %s by %s\", halfop ? \"\" : \"de\", mc->name, get_source_name(si));\n\n\t\tlogcommand(si, CMDLOG_DO, \"%sHALFOP: \\2%s!%s@%s\\2 on \\2%s\\2\", halfop ? \"\" : \"DE\", tu->nick, tu->user, tu->vhost, mc->name);\n\t\tif (si->su == NULL || !chanuser_find(mc->chan, si->su))\n\t\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been %shalfopped on \\2%s\\2.\"), tu->nick, halfop ? \"\" : \"de\", mc->name);\n\t}\n\n\tprefix_action_clear(&halfop_actions);\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "static void cs_cmd_halfop(sourceinfo_t *si, int parc, char *parv[]);",
            "static void cs_cmd_dehalfop(sourceinfo_t *si, int parc, char *parv[]);",
            "static mowgli_list_t halfop_actions;"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_cmd_halfop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_dehalfop(sourceinfo_t *si, int parc, char *parv[]);\nstatic mowgli_list_t halfop_actions;\n\nstatic void cmd_halfop(sourceinfo_t *si, bool halfopping, int parc, char *parv[])\n{\n\tchar *chan = parv[0];\n\tchar *nick = parv[1];\n\tmychan_t *mc;\n\tuser_t *tu;\n\tchanuser_t *cu;\n\tchar *nicks;\n\tbool halfop;\n\tmowgli_node_t *n;\n\n\tif (!ircd->uses_halfops)\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"Your IRC server does not support halfops.\"));\n\t\treturn;\n\t}\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (!chanacs_source_has_flag(mc, si, CA_HALFOP))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tnicks = (!nick ? strdup(si->su->nick) : strdup(nick));\n\tprefix_action_set_all(&halfop_actions, halfopping, nicks);\n\tfree(nicks);\n\n\tMOWGLI_LIST_FOREACH(n, halfop_actions.head)\n\t{\n\t\tstruct prefix_action *act = n->data;\n\t\tnick = act->nick;\n\t\thalfop = act->en;\n\n\t\t/* figure out who we're going to halfop */\n\t\tif (!(tu = user_find_named(nick)))\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not online.\"), nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is_internal_client(tu))\n\t\t\tcontinue;\n\n\t\t/* SECURE check; we can skip this if deopping or sender == target, because we already verified */\n\t\tif (halfop && (si->su != tu) && (mc->flags & MC_SECURE) && !chanacs_user_has_flag(mc, tu, CA_HALFOP) && !chanacs_user_has_flag(mc, tu, CA_AUTOHALFOP))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 has the SECURE option enabled, and \\2%s\\2 does not have appropriate access.\"), mc->name, tu->nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcu = chanuser_find(mc->chan, tu);\n\t\tif (!cu)\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not on \\2%s\\2.\"), tu->nick, mc->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmodestack_mode_param(chansvs.nick, mc->chan, halfop ? MTYPE_ADD : MTYPE_DEL, 'h', CLIENT_NAME(tu));\n\t\tif (halfop)\n\t\t\tcu->modes |= ircd->halfops_mode;\n\t\telse\n\t\t\tcu->modes &= ~ircd->halfops_mode;\n\n\t\tif (si->c == NULL && tu != si->su)\n\t\t\tchange_notify(chansvs.nick, tu, \"You have been %shalfopped on %s by %s\", halfop ? \"\" : \"de\", mc->name, get_source_name(si));\n\n\t\tlogcommand(si, CMDLOG_DO, \"%sHALFOP: \\2%s!%s@%s\\2 on \\2%s\\2\", halfop ? \"\" : \"DE\", tu->nick, tu->user, tu->vhost, mc->name);\n\t\tif (si->su == NULL || !chanuser_find(mc->chan, si->su))\n\t\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been %shalfopped on \\2%s\\2.\"), tu->nick, halfop ? \"\" : \"de\", mc->name);\n\t}\n\n\tprefix_action_clear(&halfop_actions);\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "_(\"Syntax: HALFOP <#channel> [nickname] [...]\")"
          ],
          "line": 141
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"Syntax: HALFOP <#channel> [nickname] [...]\""
          ],
          "line": 141
        },
        "resolved": true,
        "details": {
          "function_name": "_moddeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/halfop.c",
          "lines": "40-44",
          "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_halfop);\n\tservice_named_unbind_command(\"chanserv\", &cs_dehalfop);\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "command_t cs_halfop = { \"HALFOP\", N_(\"Gives channel halfops to a user.\"),\n                        AC_NONE, 2, cs_cmd_halfop, { .path = \"cservice/halfop\" } };",
            "command_t cs_dehalfop = { \"DEHALFOP\", N_(\"Removes channel halfops from a user.\"),\n                        AC_NONE, 2, cs_cmd_dehalfop, { .path = \"cservice/halfop\" } };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"atheme.h\"\n\ncommand_t cs_halfop = { \"HALFOP\", N_(\"Gives channel halfops to a user.\"),\n                        AC_NONE, 2, cs_cmd_halfop, { .path = \"cservice/halfop\" } };\ncommand_t cs_dehalfop = { \"DEHALFOP\", N_(\"Removes channel halfops from a user.\"),\n                        AC_NONE, 2, cs_cmd_dehalfop, { .path = \"cservice/halfop\" } };\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_halfop);\n\tservice_named_unbind_command(\"chanserv\", &cs_dehalfop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_needmoreparams",
            "STR_INSUFFICIENT_PARAMS",
            "\"HALFOP\""
          ],
          "line": 140
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_cmd_halfop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_dehalfop(sourceinfo_t *si, int parc, char *parv[]);\n\nstatic void cs_cmd_halfop(sourceinfo_t *si, int parc, char *parv[])\n{\n\tif (!parv[0])\n\t{\n\t\tcommand_fail(si, fault_needmoreparams, STR_INSUFFICIENT_PARAMS, \"HALFOP\");\n\t\tcommand_fail(si, fault_needmoreparams, _(\"Syntax: HALFOP <#channel> [nickname] [...]\"));\n\t\treturn;\n\t}\n\n\tcmd_halfop(si, true, parc, parv);\n}"
  },
  {
    "function_name": "cmd_halfop",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/halfop.c",
    "lines": "48-134",
    "snippet": "static void cmd_halfop(sourceinfo_t *si, bool halfopping, int parc, char *parv[])\n{\n\tchar *chan = parv[0];\n\tchar *nick = parv[1];\n\tmychan_t *mc;\n\tuser_t *tu;\n\tchanuser_t *cu;\n\tchar *nicks;\n\tbool halfop;\n\tmowgli_node_t *n;\n\n\tif (!ircd->uses_halfops)\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"Your IRC server does not support halfops.\"));\n\t\treturn;\n\t}\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (!chanacs_source_has_flag(mc, si, CA_HALFOP))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tnicks = (!nick ? strdup(si->su->nick) : strdup(nick));\n\tprefix_action_set_all(&halfop_actions, halfopping, nicks);\n\tfree(nicks);\n\n\tMOWGLI_LIST_FOREACH(n, halfop_actions.head)\n\t{\n\t\tstruct prefix_action *act = n->data;\n\t\tnick = act->nick;\n\t\thalfop = act->en;\n\n\t\t/* figure out who we're going to halfop */\n\t\tif (!(tu = user_find_named(nick)))\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not online.\"), nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is_internal_client(tu))\n\t\t\tcontinue;\n\n\t\t/* SECURE check; we can skip this if deopping or sender == target, because we already verified */\n\t\tif (halfop && (si->su != tu) && (mc->flags & MC_SECURE) && !chanacs_user_has_flag(mc, tu, CA_HALFOP) && !chanacs_user_has_flag(mc, tu, CA_AUTOHALFOP))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 has the SECURE option enabled, and \\2%s\\2 does not have appropriate access.\"), mc->name, tu->nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcu = chanuser_find(mc->chan, tu);\n\t\tif (!cu)\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not on \\2%s\\2.\"), tu->nick, mc->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmodestack_mode_param(chansvs.nick, mc->chan, halfop ? MTYPE_ADD : MTYPE_DEL, 'h', CLIENT_NAME(tu));\n\t\tif (halfop)\n\t\t\tcu->modes |= ircd->halfops_mode;\n\t\telse\n\t\t\tcu->modes &= ~ircd->halfops_mode;\n\n\t\tif (si->c == NULL && tu != si->su)\n\t\t\tchange_notify(chansvs.nick, tu, \"You have been %shalfopped on %s by %s\", halfop ? \"\" : \"de\", mc->name, get_source_name(si));\n\n\t\tlogcommand(si, CMDLOG_DO, \"%sHALFOP: \\2%s!%s@%s\\2 on \\2%s\\2\", halfop ? \"\" : \"DE\", tu->nick, tu->user, tu->vhost, mc->name);\n\t\tif (si->su == NULL || !chanuser_find(mc->chan, si->su))\n\t\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been %shalfopped on \\2%s\\2.\"), tu->nick, halfop ? \"\" : \"de\", mc->name);\n\t}\n\n\tprefix_action_clear(&halfop_actions);\n}",
    "includes": [
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "static void cs_cmd_halfop(sourceinfo_t *si, int parc, char *parv[]);",
      "static void cs_cmd_dehalfop(sourceinfo_t *si, int parc, char *parv[]);",
      "static mowgli_list_t halfop_actions;"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "prefix_action_clear",
          "args": [
            "&halfop_actions"
          ],
          "line": 133
        },
        "resolved": true,
        "details": {
          "function_name": "prefix_action_clear",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/chanserv.h",
          "lines": "72-82",
          "snippet": "static inline void prefix_action_clear(mowgli_list_t *actions)\n{\n\tmowgli_node_t *n, *tn;\n\n\tMOWGLI_LIST_FOREACH_SAFE(n, tn, actions->head)\n\t{\n\t\tfree(n->data);\n\t\tmowgli_node_delete(n, actions);\n\t\tmowgli_node_free(n);\n\t}\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void prefix_action_clear(mowgli_list_t *actions)\n{\n\tmowgli_node_t *n, *tn;\n\n\tMOWGLI_LIST_FOREACH_SAFE(n, tn, actions->head)\n\t{\n\t\tfree(n->data);\n\t\tmowgli_node_delete(n, actions);\n\t\tmowgli_node_free(n);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "command_success_nodata",
          "args": [
            "si",
            "_(\"\\2%s\\2 has been %shalfopped on \\2%s\\2.\")",
            "tu->nick",
            "halfop ? \"\" : \"de\"",
            "mc->name"
          ],
          "line": 130
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "_",
          "args": [
            "\"\\2%s\\2 has been %shalfopped on \\2%s\\2.\""
          ],
          "line": 130
        },
        "resolved": true,
        "details": {
          "function_name": "_moddeinit",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/halfop.c",
          "lines": "40-44",
          "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_halfop);\n\tservice_named_unbind_command(\"chanserv\", &cs_dehalfop);\n}",
          "includes": [
            "#include \"chanserv.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [
            "command_t cs_halfop = { \"HALFOP\", N_(\"Gives channel halfops to a user.\"),\n                        AC_NONE, 2, cs_cmd_halfop, { .path = \"cservice/halfop\" } };",
            "command_t cs_dehalfop = { \"DEHALFOP\", N_(\"Removes channel halfops from a user.\"),\n                        AC_NONE, 2, cs_cmd_dehalfop, { .path = \"cservice/halfop\" } };"
          ],
          "called_functions": [],
          "contextual_snippet": "#include \"chanserv.h\"\n#include \"atheme.h\"\n\ncommand_t cs_halfop = { \"HALFOP\", N_(\"Gives channel halfops to a user.\"),\n                        AC_NONE, 2, cs_cmd_halfop, { .path = \"cservice/halfop\" } };\ncommand_t cs_dehalfop = { \"DEHALFOP\", N_(\"Removes channel halfops from a user.\"),\n                        AC_NONE, 2, cs_cmd_dehalfop, { .path = \"cservice/halfop\" } };\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_halfop);\n\tservice_named_unbind_command(\"chanserv\", &cs_dehalfop);\n}"
        }
      },
      {
        "call_info": {
          "callee": "chanuser_find",
          "args": [
            "mc->chan",
            "si->su"
          ],
          "line": 129
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "logcommand",
          "args": [
            "si",
            "CMDLOG_DO",
            "\"%sHALFOP: \\2%s!%s@%s\\2 on \\2%s\\2\"",
            "halfop ? \"\" : \"DE\"",
            "tu->nick",
            "tu->user",
            "tu->vhost",
            "mc->name"
          ],
          "line": 128
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "change_notify",
          "args": [
            "chansvs.nick",
            "tu",
            "\"You have been %shalfopped on %s by %s\"",
            "halfop ? \"\" : \"de\"",
            "mc->name",
            "get_source_name(si)"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "get_source_name",
          "args": [
            "si"
          ],
          "line": 126
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "modestack_mode_param",
          "args": [
            "chansvs.nick",
            "mc->chan",
            "halfop ? MTYPE_ADD : MTYPE_DEL",
            "'h'",
            "CLIENT_NAME(tu)"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "CLIENT_NAME",
          "args": [
            "tu"
          ],
          "line": 119
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_target",
            "_(\"\\2%s\\2 is not on \\2%s\\2.\")",
            "tu->nick",
            "mc->name"
          ],
          "line": 115
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanuser_find",
          "args": [
            "mc->chan",
            "tu"
          ],
          "line": 112
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"\\2%s\\2 has the SECURE option enabled, and \\2%s\\2 does not have appropriate access.\")",
            "mc->name",
            "tu->nick"
          ],
          "line": 108
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not authorized to perform this operation.\")"
          ],
          "line": 107
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_user_has_flag",
          "args": [
            "mc",
            "tu",
            "CA_AUTOHALFOP"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_user_has_flag",
          "args": [
            "mc",
            "tu",
            "CA_HALFOP"
          ],
          "line": 105
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "is_internal_client",
          "args": [
            "tu"
          ],
          "line": 101
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_target",
            "_(\"\\2%s\\2 is not online.\")",
            "nick"
          ],
          "line": 97
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "user_find_named",
          "args": [
            "nick"
          ],
          "line": 95
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "MOWGLI_LIST_FOREACH",
          "args": [
            "n",
            "halfop_actions.head"
          ],
          "line": 88
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "free",
          "args": [
            "nicks"
          ],
          "line": 86
        },
        "resolved": true,
        "details": {
          "function_name": "free_template_list",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/access.c",
          "lines": "358-371",
          "snippet": "static void free_template_list(mowgli_list_t *l)\n{\n\tmowgli_node_t *n, *tn;\n\n\treturn_if_fail(l != NULL);\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, l->head)\n\t{\n\t\ttemplate_t *t = n->data;\n\n\t\tmowgli_node_delete(&t->node, l);\n\t\tfree(t);\n\t}\n}",
          "includes": [
            "#include \"template.h\"",
            "#include \"atheme.h\""
          ],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "#include \"template.h\"\n#include \"atheme.h\"\n\nstatic void free_template_list(mowgli_list_t *l)\n{\n\tmowgli_node_t *n, *tn;\n\n\treturn_if_fail(l != NULL);\n\n\tMOWGLI_ITER_FOREACH_SAFE(n, tn, l->head)\n\t{\n\t\ttemplate_t *t = n->data;\n\n\t\tmowgli_node_delete(&t->node, l);\n\t\tfree(t);\n\t}\n}"
        }
      },
      {
        "call_info": {
          "callee": "prefix_action_set_all",
          "args": [
            "&halfop_actions",
            "halfopping",
            "nicks"
          ],
          "line": 85
        },
        "resolved": true,
        "details": {
          "function_name": "prefix_action_set_all",
          "container": null,
          "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/chanserv.h",
          "lines": "43-70",
          "snippet": "static inline void prefix_action_set_all(mowgli_list_t *actions, bool dfl, char *nicks)\n{\n\tchar *nick, *strtokctx = NULL;\n\tbool en;\n\n\tnick = strtok_r(nicks, \" \", &strtokctx);\n\tdo\n\t{\n\t\tswitch (*nick)\n\t\t{\n\t\tcase '-':\n\t\t\ten = false;\n\t\t\tnick++;\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\ten = true;\n\t\t\tnick++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ten = dfl;\n\t\t}\n\n\t\tif (!strcmp(nick, \"\"))\n\t\t\tcontinue;\n\n\t\tprefix_action_set(actions, nick, en);\n\t} while ((nick = strtok_r(NULL, \" \", &strtokctx)) != NULL);\n}",
          "includes": [],
          "macros_used": [],
          "globals_used": [],
          "called_functions": [],
          "contextual_snippet": "static inline void prefix_action_set_all(mowgli_list_t *actions, bool dfl, char *nicks)\n{\n\tchar *nick, *strtokctx = NULL;\n\tbool en;\n\n\tnick = strtok_r(nicks, \" \", &strtokctx);\n\tdo\n\t{\n\t\tswitch (*nick)\n\t\t{\n\t\tcase '-':\n\t\t\ten = false;\n\t\t\tnick++;\n\t\t\tbreak;\n\t\tcase '+':\n\t\t\ten = true;\n\t\t\tnick++;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\ten = dfl;\n\t\t}\n\n\t\tif (!strcmp(nick, \"\"))\n\t\t\tcontinue;\n\n\t\tprefix_action_set(actions, nick, en);\n\t} while ((nick = strtok_r(NULL, \" \", &strtokctx)) != NULL);\n}"
        }
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "nick"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "strdup",
          "args": [
            "si->su->nick"
          ],
          "line": 84
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"\\2%s\\2 is closed.\")",
            "chan"
          ],
          "line": 80
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "metadata_find",
          "args": [
            "mc",
            "\"private:close:closer\""
          ],
          "line": 78
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"You are not authorized to perform this operation.\")"
          ],
          "line": 74
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "chanacs_source_has_flag",
          "args": [
            "mc",
            "si",
            "CA_HALFOP"
          ],
          "line": 72
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_nosuch_target",
            "_(\"Channel \\2%s\\2 is not registered.\")",
            "chan"
          ],
          "line": 68
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "mychan_find",
          "args": [
            "chan"
          ],
          "line": 65
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "command_fail",
          "args": [
            "si",
            "fault_noprivs",
            "_(\"Your IRC server does not support halfops.\")"
          ],
          "line": 61
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"chanserv.h\"\n#include \"atheme.h\"\n\nstatic void cs_cmd_halfop(sourceinfo_t *si, int parc, char *parv[]);\nstatic void cs_cmd_dehalfop(sourceinfo_t *si, int parc, char *parv[]);\nstatic mowgli_list_t halfop_actions;\n\nstatic void cmd_halfop(sourceinfo_t *si, bool halfopping, int parc, char *parv[])\n{\n\tchar *chan = parv[0];\n\tchar *nick = parv[1];\n\tmychan_t *mc;\n\tuser_t *tu;\n\tchanuser_t *cu;\n\tchar *nicks;\n\tbool halfop;\n\tmowgli_node_t *n;\n\n\tif (!ircd->uses_halfops)\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"Your IRC server does not support halfops.\"));\n\t\treturn;\n\t}\n\n\tmc = mychan_find(chan);\n\tif (!mc)\n\t{\n\t\tcommand_fail(si, fault_nosuch_target, _(\"Channel \\2%s\\2 is not registered.\"), chan);\n\t\treturn;\n\t}\n\n\tif (!chanacs_source_has_flag(mc, si, CA_HALFOP))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\treturn;\n\t}\n\n\tif (metadata_find(mc, \"private:close:closer\"))\n\t{\n\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 is closed.\"), chan);\n\t\treturn;\n\t}\n\n\tnicks = (!nick ? strdup(si->su->nick) : strdup(nick));\n\tprefix_action_set_all(&halfop_actions, halfopping, nicks);\n\tfree(nicks);\n\n\tMOWGLI_LIST_FOREACH(n, halfop_actions.head)\n\t{\n\t\tstruct prefix_action *act = n->data;\n\t\tnick = act->nick;\n\t\thalfop = act->en;\n\n\t\t/* figure out who we're going to halfop */\n\t\tif (!(tu = user_find_named(nick)))\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not online.\"), nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (is_internal_client(tu))\n\t\t\tcontinue;\n\n\t\t/* SECURE check; we can skip this if deopping or sender == target, because we already verified */\n\t\tif (halfop && (si->su != tu) && (mc->flags & MC_SECURE) && !chanacs_user_has_flag(mc, tu, CA_HALFOP) && !chanacs_user_has_flag(mc, tu, CA_AUTOHALFOP))\n\t\t{\n\t\t\tcommand_fail(si, fault_noprivs, _(\"You are not authorized to perform this operation.\"));\n\t\t\tcommand_fail(si, fault_noprivs, _(\"\\2%s\\2 has the SECURE option enabled, and \\2%s\\2 does not have appropriate access.\"), mc->name, tu->nick);\n\t\t\tcontinue;\n\t\t}\n\n\t\tcu = chanuser_find(mc->chan, tu);\n\t\tif (!cu)\n\t\t{\n\t\t\tcommand_fail(si, fault_nosuch_target, _(\"\\2%s\\2 is not on \\2%s\\2.\"), tu->nick, mc->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tmodestack_mode_param(chansvs.nick, mc->chan, halfop ? MTYPE_ADD : MTYPE_DEL, 'h', CLIENT_NAME(tu));\n\t\tif (halfop)\n\t\t\tcu->modes |= ircd->halfops_mode;\n\t\telse\n\t\t\tcu->modes &= ~ircd->halfops_mode;\n\n\t\tif (si->c == NULL && tu != si->su)\n\t\t\tchange_notify(chansvs.nick, tu, \"You have been %shalfopped on %s by %s\", halfop ? \"\" : \"de\", mc->name, get_source_name(si));\n\n\t\tlogcommand(si, CMDLOG_DO, \"%sHALFOP: \\2%s!%s@%s\\2 on \\2%s\\2\", halfop ? \"\" : \"DE\", tu->nick, tu->user, tu->vhost, mc->name);\n\t\tif (si->su == NULL || !chanuser_find(mc->chan, si->su))\n\t\t\tcommand_success_nodata(si, _(\"\\2%s\\2 has been %shalfopped on \\2%s\\2.\"), tu->nick, halfop ? \"\" : \"de\", mc->name);\n\t}\n\n\tprefix_action_clear(&halfop_actions);\n}"
  },
  {
    "function_name": "_moddeinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/halfop.c",
    "lines": "40-44",
    "snippet": "void _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_halfop);\n\tservice_named_unbind_command(\"chanserv\", &cs_dehalfop);\n}",
    "includes": [
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "command_t cs_halfop = { \"HALFOP\", N_(\"Gives channel halfops to a user.\"),\n                        AC_NONE, 2, cs_cmd_halfop, { .path = \"cservice/halfop\" } };",
      "command_t cs_dehalfop = { \"DEHALFOP\", N_(\"Removes channel halfops from a user.\"),\n                        AC_NONE, 2, cs_cmd_dehalfop, { .path = \"cservice/halfop\" } };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "service_named_unbind_command",
          "args": [
            "\"chanserv\"",
            "&cs_dehalfop"
          ],
          "line": 43
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_named_unbind_command",
          "args": [
            "\"chanserv\"",
            "&cs_halfop"
          ],
          "line": 42
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"chanserv.h\"\n#include \"atheme.h\"\n\ncommand_t cs_halfop = { \"HALFOP\", N_(\"Gives channel halfops to a user.\"),\n                        AC_NONE, 2, cs_cmd_halfop, { .path = \"cservice/halfop\" } };\ncommand_t cs_dehalfop = { \"DEHALFOP\", N_(\"Removes channel halfops from a user.\"),\n                        AC_NONE, 2, cs_cmd_dehalfop, { .path = \"cservice/halfop\" } };\n\nvoid _moddeinit(module_unload_intent_t intent)\n{\n\tservice_named_unbind_command(\"chanserv\", &cs_halfop);\n\tservice_named_unbind_command(\"chanserv\", &cs_dehalfop);\n}"
  },
  {
    "function_name": "_modinit",
    "container": null,
    "file": "/home/michele/Desktop/ricerca/output_repos_c/CVE-2014-9773/repo/modules/chanserv/halfop.c",
    "lines": "27-38",
    "snippet": "void _modinit(module_t *m)\n{\n\tif (ircd != NULL && !ircd->uses_halfops)\n\t{\n\t\tslog(LG_INFO, \"Module %s requires halfop support, refusing to load.\", m->name);\n\t\tm->mflags = MODTYPE_FAIL;\n\t\treturn;\n\t}\n\n        service_named_bind_command(\"chanserv\", &cs_halfop);\n        service_named_bind_command(\"chanserv\", &cs_dehalfop);\n}",
    "includes": [
      "#include \"chanserv.h\"",
      "#include \"atheme.h\""
    ],
    "macros_used": [],
    "globals_used": [
      "command_t cs_halfop = { \"HALFOP\", N_(\"Gives channel halfops to a user.\"),\n                        AC_NONE, 2, cs_cmd_halfop, { .path = \"cservice/halfop\" } };",
      "command_t cs_dehalfop = { \"DEHALFOP\", N_(\"Removes channel halfops from a user.\"),\n                        AC_NONE, 2, cs_cmd_dehalfop, { .path = \"cservice/halfop\" } };"
    ],
    "called_functions": [
      {
        "call_info": {
          "callee": "service_named_bind_command",
          "args": [
            "\"chanserv\"",
            "&cs_dehalfop"
          ],
          "line": 37
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "service_named_bind_command",
          "args": [
            "\"chanserv\"",
            "&cs_halfop"
          ],
          "line": 36
        },
        "resolved": false,
        "reason": "library_or_external"
      },
      {
        "call_info": {
          "callee": "slog",
          "args": [
            "LG_INFO",
            "\"Module %s requires halfop support, refusing to load.\"",
            "m->name"
          ],
          "line": 31
        },
        "resolved": false,
        "reason": "library_or_external"
      }
    ],
    "contextual_snippet": "#include \"chanserv.h\"\n#include \"atheme.h\"\n\ncommand_t cs_halfop = { \"HALFOP\", N_(\"Gives channel halfops to a user.\"),\n                        AC_NONE, 2, cs_cmd_halfop, { .path = \"cservice/halfop\" } };\ncommand_t cs_dehalfop = { \"DEHALFOP\", N_(\"Removes channel halfops from a user.\"),\n                        AC_NONE, 2, cs_cmd_dehalfop, { .path = \"cservice/halfop\" } };\n\nvoid _modinit(module_t *m)\n{\n\tif (ircd != NULL && !ircd->uses_halfops)\n\t{\n\t\tslog(LG_INFO, \"Module %s requires halfop support, refusing to load.\", m->name);\n\t\tm->mflags = MODTYPE_FAIL;\n\t\treturn;\n\t}\n\n        service_named_bind_command(\"chanserv\", &cs_halfop);\n        service_named_bind_command(\"chanserv\", &cs_dehalfop);\n}"
  }
]