[
  {
    "target_function": "IOCallback::writeFully",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/IOCallback.cpp",
    "lines": "46-63",
    "num_chains": 6,
    "chains": [
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlUnicodeString::RenderData",
          "IOCallback::writeFully"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::RenderData",
            "snippet": "filepos_t EbmlUnicodeString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  uint32 Result = Value.GetUTF8().length();\n\n  if (Result != 0) {\n    output.writeFully(Value.GetUTF8().c_str(), Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "279-300"
          },
          {
            "qualified_name": "IOCallback::writeFully",
            "snippet": "START_LIBEBML_NAMESPACE\n\nvoid IOCallback::writeFully(const void*Buffer,size_t Size)\n{\n  if (Size == 0)\n    return;\n\n  if (Buffer == NULL)\n    throw;\n\n  if(write(Buffer,Size) != Size) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"EOF in writeFully(\"<<Buffer<<\",\"<<Size<<\")\";\n    throw runtime_error(Msg.str());\n#endif // GCC2\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/IOCallback.cpp",
            "lines": "46-63"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlUnicodeString::RenderData",
          "IOCallback::writeFully"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::RenderData",
            "snippet": "filepos_t EbmlUnicodeString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  uint32 Result = Value.GetUTF8().length();\n\n  if (Result != 0) {\n    output.writeFully(Value.GetUTF8().c_str(), Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "279-300"
          },
          {
            "qualified_name": "IOCallback::writeFully",
            "snippet": "START_LIBEBML_NAMESPACE\n\nvoid IOCallback::writeFully(const void*Buffer,size_t Size)\n{\n  if (Size == 0)\n    return;\n\n  if (Buffer == NULL)\n    throw;\n\n  if(write(Buffer,Size) != Size) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"EOF in writeFully(\"<<Buffer<<\",\"<<Size<<\")\";\n    throw runtime_error(Msg.str());\n#endif // GCC2\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/IOCallback.cpp",
            "lines": "46-63"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlUnicodeString::RenderData",
          "IOCallback::writeFully"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::RenderData",
            "snippet": "filepos_t EbmlUnicodeString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  uint32 Result = Value.GetUTF8().length();\n\n  if (Result != 0) {\n    output.writeFully(Value.GetUTF8().c_str(), Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "279-300"
          },
          {
            "qualified_name": "IOCallback::writeFully",
            "snippet": "START_LIBEBML_NAMESPACE\n\nvoid IOCallback::writeFully(const void*Buffer,size_t Size)\n{\n  if (Size == 0)\n    return;\n\n  if (Buffer == NULL)\n    throw;\n\n  if(write(Buffer,Size) != Size) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"EOF in writeFully(\"<<Buffer<<\",\"<<Size<<\")\";\n    throw runtime_error(Msg.str());\n#endif // GCC2\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/IOCallback.cpp",
            "lines": "46-63"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlElement::OverwriteHead",
          "EbmlElement::MakeRenderHead",
          "IOCallback::writeFully"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlElement::OverwriteHead",
            "snippet": "filepos_t EbmlElement::OverwriteHead(IOCallback & output, bool bKeepPosition)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n  output.setFilePointer(GetElementPosition());\n  filepos_t Result = MakeRenderHead(output, bKeepPosition);\n  output.setFilePointer(CurrentPosition);\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "681-692"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          },
          {
            "qualified_name": "IOCallback::writeFully",
            "snippet": "START_LIBEBML_NAMESPACE\n\nvoid IOCallback::writeFully(const void*Buffer,size_t Size)\n{\n  if (Size == 0)\n    return;\n\n  if (Buffer == NULL)\n    throw;\n\n  if(write(Buffer,Size) != Size) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"EOF in writeFully(\"<<Buffer<<\",\"<<Size<<\")\";\n    throw runtime_error(Msg.str());\n#endif // GCC2\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/IOCallback.cpp",
            "lines": "46-63"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlMaster::WriteHead",
          "EbmlElement::RenderHead",
          "EbmlElement::MakeRenderHead",
          "IOCallback::writeFully"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::WriteHead",
            "snippet": "filepos_t EbmlMaster::WriteHead(IOCallback & output, int nSizeLength, bool bWithDefault)\n{\n  SetSizeLength(nSizeLength);\n  return RenderHead(output, false, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "161-165"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          },
          {
            "qualified_name": "IOCallback::writeFully",
            "snippet": "START_LIBEBML_NAMESPACE\n\nvoid IOCallback::writeFully(const void*Buffer,size_t Size)\n{\n  if (Size == 0)\n    return;\n\n  if (Buffer == NULL)\n    throw;\n\n  if(write(Buffer,Size) != Size) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"EOF in writeFully(\"<<Buffer<<\",\"<<Size<<\")\";\n    throw runtime_error(Msg.str());\n#endif // GCC2\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/IOCallback.cpp",
            "lines": "46-63"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::RenderHead",
          "EbmlElement::MakeRenderHead",
          "IOCallback::writeFully"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          },
          {
            "qualified_name": "IOCallback::writeFully",
            "snippet": "START_LIBEBML_NAMESPACE\n\nvoid IOCallback::writeFully(const void*Buffer,size_t Size)\n{\n  if (Size == 0)\n    return;\n\n  if (Buffer == NULL)\n    throw;\n\n  if(write(Buffer,Size) != Size) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"EOF in writeFully(\"<<Buffer<<\",\"<<Size<<\")\";\n    throw runtime_error(Msg.str());\n#endif // GCC2\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/IOCallback.cpp",
            "lines": "46-63"
          }
        ]
      }
    ]
  },
  {
    "target_function": "StdIOCallback::close",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
    "lines": "177-191",
    "num_chains": 2,
    "chains": [
      {
        "call_sequence": [
          "StdIOCallback::~StdIOCallback",
          "StdIOCallback::close"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "StdIOCallback::~StdIOCallback",
            "snippet": "StdIOCallback::~StdIOCallback()throw()\n{\n  close();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "97-100"
          },
          {
            "qualified_name": "StdIOCallback::close",
            "snippet": "void StdIOCallback::close()\n{\n  if(File==0)\n    return;\n\n  if(fclose(File)!=0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"Can't close file \"<<File;\n    throw CRTError(Msg.str());\n#endif // GCC2\n  }\n\n  File=0;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "177-191"
          }
        ]
      },
      {
        "call_sequence": [
          "WinIOCallback::~WinIOCallback",
          "StdIOCallback::close"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "WinIOCallback::~WinIOCallback",
            "snippet": "WinIOCallback::~WinIOCallback()\n{\n  close();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "61-64"
          },
          {
            "qualified_name": "StdIOCallback::close",
            "snippet": "void StdIOCallback::close()\n{\n  if(File==0)\n    return;\n\n  if(fclose(File)!=0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"Can't close file \"<<File;\n    throw CRTError(Msg.str());\n#endif // GCC2\n  }\n\n  File=0;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "177-191"
          }
        ]
      }
    ]
  },
  {
    "target_function": "StdIOCallback::getFilePointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
    "lines": "159-175",
    "num_chains": 11,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::OverwriteHead",
          "StdIOCallback::getFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlElement::OverwriteHead",
            "snippet": "filepos_t EbmlElement::OverwriteHead(IOCallback & output, bool bKeepPosition)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n  output.setFilePointer(GetElementPosition());\n  filepos_t Result = MakeRenderHead(output, bKeepPosition);\n  output.setFilePointer(CurrentPosition);\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "681-692"
          },
          {
            "qualified_name": "StdIOCallback::getFilePointer",
            "snippet": "uint64 StdIOCallback::getFilePointer()\n{\n  assert(File!=0);\n\n#if 0\n  long Result=ftell(File);\n  if(Result<0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"Can't tell the current file pointer position for \"<<File;\n    throw CRTError(Msg.str());\n#endif // GCC2\n  }\n#endif\n\n  return mCurrentPosition;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "159-175"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlElement::OverwriteHead",
          "EbmlElement::MakeRenderHead",
          "StdIOCallback::getFilePointer"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlElement::OverwriteHead",
            "snippet": "filepos_t EbmlElement::OverwriteHead(IOCallback & output, bool bKeepPosition)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n  output.setFilePointer(GetElementPosition());\n  filepos_t Result = MakeRenderHead(output, bKeepPosition);\n  output.setFilePointer(CurrentPosition);\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "681-692"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          },
          {
            "qualified_name": "StdIOCallback::getFilePointer",
            "snippet": "uint64 StdIOCallback::getFilePointer()\n{\n  assert(File!=0);\n\n#if 0\n  long Result=ftell(File);\n  if(Result<0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"Can't tell the current file pointer position for \"<<File;\n    throw CRTError(Msg.str());\n#endif // GCC2\n  }\n#endif\n\n  return mCurrentPosition;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "159-175"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlMaster::WriteHead",
          "EbmlElement::RenderHead",
          "EbmlElement::MakeRenderHead",
          "StdIOCallback::getFilePointer"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::WriteHead",
            "snippet": "filepos_t EbmlMaster::WriteHead(IOCallback & output, int nSizeLength, bool bWithDefault)\n{\n  SetSizeLength(nSizeLength);\n  return RenderHead(output, false, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "161-165"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          },
          {
            "qualified_name": "StdIOCallback::getFilePointer",
            "snippet": "uint64 StdIOCallback::getFilePointer()\n{\n  assert(File!=0);\n\n#if 0\n  long Result=ftell(File);\n  if(Result<0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"Can't tell the current file pointer position for \"<<File;\n    throw CRTError(Msg.str());\n#endif // GCC2\n  }\n#endif\n\n  return mCurrentPosition;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "159-175"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::RenderHead",
          "EbmlElement::MakeRenderHead",
          "StdIOCallback::getFilePointer"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          },
          {
            "qualified_name": "StdIOCallback::getFilePointer",
            "snippet": "uint64 StdIOCallback::getFilePointer()\n{\n  assert(File!=0);\n\n#if 0\n  long Result=ftell(File);\n  if(Result<0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"Can't tell the current file pointer position for \"<<File;\n    throw CRTError(Msg.str());\n#endif // GCC2\n  }\n#endif\n\n  return mCurrentPosition;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "159-175"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::Seek",
          "StdIOCallback::getFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::Seek",
            "snippet": "void\nSafeReadIOCallback::Seek(size_t Offset) {\n  mIO->setFilePointer(Offset);\n  uint64 ActualPosition = mIO->getFilePointer();\n  if (ActualPosition != Offset)\n    throw EndOfStreamX(ActualPosition - Offset);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "158-164"
          },
          {
            "qualified_name": "StdIOCallback::getFilePointer",
            "snippet": "uint64 StdIOCallback::getFilePointer()\n{\n  assert(File!=0);\n\n#if 0\n  long Result=ftell(File);\n  if(Result<0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"Can't tell the current file pointer position for \"<<File;\n    throw CRTError(Msg.str());\n#endif // GCC2\n  }\n#endif\n\n  return mCurrentPosition;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "159-175"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::Skip",
          "StdIOCallback::getFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::Skip",
            "snippet": "void\nSafeReadIOCallback::Skip(size_t Count) {\n  int64 PrevPosition     = mIO->getFilePointer();\n  int64 ExpectedPosition = PrevPosition + Count;\n  mIO->setFilePointer(Count, seek_current);\n  int64 ActualPosition   = mIO->getFilePointer();\n\n  if (ActualPosition != ExpectedPosition)\n    throw SafeReadIOCallback::EndOfStreamX(ExpectedPosition - ActualPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "147-156"
          },
          {
            "qualified_name": "StdIOCallback::getFilePointer",
            "snippet": "uint64 StdIOCallback::getFilePointer()\n{\n  assert(File!=0);\n\n#if 0\n  long Result=ftell(File);\n  if(Result<0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"Can't tell the current file pointer position for \"<<File;\n    throw CRTError(Msg.str());\n#endif // GCC2\n  }\n#endif\n\n  return mCurrentPosition;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "159-175"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::IsEmpty",
          "SafeReadIOCallback::GetRemainingBytes",
          "SafeReadIOCallback::GetPosition",
          "StdIOCallback::getFilePointer"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::IsEmpty",
            "snippet": "bool\nSafeReadIOCallback::IsEmpty()\n  const {\n  return !GetRemainingBytes();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "100-104"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetRemainingBytes",
            "snippet": "size_t\nSafeReadIOCallback::GetRemainingBytes()\n  const {\n  return GetSize() - GetPosition();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "94-98"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetPosition",
            "snippet": "size_t\nSafeReadIOCallback::GetPosition()\n  const {\n  return mIO->getFilePointer();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "82-86"
          },
          {
            "qualified_name": "StdIOCallback::getFilePointer",
            "snippet": "uint64 StdIOCallback::getFilePointer()\n{\n  assert(File!=0);\n\n#if 0\n  long Result=ftell(File);\n  if(Result<0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"Can't tell the current file pointer position for \"<<File;\n    throw CRTError(Msg.str());\n#endif // GCC2\n  }\n#endif\n\n  return mCurrentPosition;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "159-175"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::SafeReadIOCallback",
          "SafeReadIOCallback::Init",
          "StdIOCallback::getFilePointer"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::SafeReadIOCallback",
            "snippet": "SafeReadIOCallback::SafeReadIOCallback(IOCallback *IO,\n                                       bool DeleteIO) {\n  Init(IO, DeleteIO);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "52-55"
          },
          {
            "qualified_name": "SafeReadIOCallback::Init",
            "snippet": "void\nSafeReadIOCallback::Init(IOCallback *IO,\n                         bool DeleteIO) {\n  mIO                = IO;\n  mDeleteIO          = DeleteIO;\n  int64 PrevPosition = IO->getFilePointer();\n  IO->setFilePointer(0, seek_end);\n  mSize              = IO->getFilePointer();\n  IO->setFilePointer(PrevPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "71-80"
          },
          {
            "qualified_name": "StdIOCallback::getFilePointer",
            "snippet": "uint64 StdIOCallback::getFilePointer()\n{\n  assert(File!=0);\n\n#if 0\n  long Result=ftell(File);\n  if(Result<0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"Can't tell the current file pointer position for \"<<File;\n    throw CRTError(Msg.str());\n#endif // GCC2\n  }\n#endif\n\n  return mCurrentPosition;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "159-175"
          }
        ]
      },
      {
        "call_sequence": [
          "MemReadIOCallback::MemReadIOCallback",
          "SafeReadIOCallback::Init",
          "StdIOCallback::getFilePointer"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "MemReadIOCallback::MemReadIOCallback",
            "snippet": "START_LIBEBML_NAMESPACE\n\nMemReadIOCallback::MemReadIOCallback(void const *Ptr,\n                                     size_t Size) {\n  Init(Ptr, Size);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "42-47"
          },
          {
            "qualified_name": "SafeReadIOCallback::Init",
            "snippet": "void\nSafeReadIOCallback::Init(IOCallback *IO,\n                         bool DeleteIO) {\n  mIO                = IO;\n  mDeleteIO          = DeleteIO;\n  int64 PrevPosition = IO->getFilePointer();\n  IO->setFilePointer(0, seek_end);\n  mSize              = IO->getFilePointer();\n  IO->setFilePointer(PrevPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "71-80"
          },
          {
            "qualified_name": "StdIOCallback::getFilePointer",
            "snippet": "uint64 StdIOCallback::getFilePointer()\n{\n  assert(File!=0);\n\n#if 0\n  long Result=ftell(File);\n  if(Result<0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"Can't tell the current file pointer position for \"<<File;\n    throw CRTError(Msg.str());\n#endif // GCC2\n  }\n#endif\n\n  return mCurrentPosition;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "159-175"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlElement::VoidMe",
          "EbmlVoid::Overwrite",
          "StdIOCallback::getFilePointer"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlElement::VoidMe",
            "snippet": "uint64 EbmlElement::VoidMe(IOCallback & output, bool bWithDefault)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  EbmlVoid Dummy;\n  return Dummy.Overwrite(*this, output, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "694-702"
          },
          {
            "qualified_name": "EbmlVoid::Overwrite",
            "snippet": "uint64 EbmlVoid::Overwrite(const EbmlElement & EltToVoid, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  //  EltToVoid.UpdateSize(bWithDefault);\n  if (EltToVoid.GetElementPosition() == 0) {\n    // this element has never been written\n    return 0;\n  }\n  if (EltToVoid.GetSize() + EltToVoid.HeadSize() <2) {\n    // the element can't be written here !\n    return 0;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePointer(EltToVoid.GetElementPosition());\n\n  // compute the size of the voided data based on the original one\n  SetSize(EltToVoid.GetSize() + E",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "99-135"
          },
          {
            "qualified_name": "StdIOCallback::getFilePointer",
            "snippet": "uint64 StdIOCallback::getFilePointer()\n{\n  assert(File!=0);\n\n#if 0\n  long Result=ftell(File);\n  if(Result<0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"Can't tell the current file pointer position for \"<<File;\n    throw CRTError(Msg.str());\n#endif // GCC2\n  }\n#endif\n\n  return mCurrentPosition;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "159-175"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "StdIOCallback::getFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "StdIOCallback::getFilePointer",
            "snippet": "uint64 StdIOCallback::getFilePointer()\n{\n  assert(File!=0);\n\n#if 0\n  long Result=ftell(File);\n  if(Result<0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"Can't tell the current file pointer position for \"<<File;\n    throw CRTError(Msg.str());\n#endif // GCC2\n  }\n#endif\n\n  return mCurrentPosition;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "159-175"
          }
        ]
      }
    ]
  },
  {
    "target_function": "StdIOCallback::write",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
    "lines": "151-157",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::OverwriteHead",
          "EbmlElement::MakeRenderHead",
          "IOCallback::writeFully",
          "StdIOCallback::write"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlElement::OverwriteHead",
            "snippet": "filepos_t EbmlElement::OverwriteHead(IOCallback & output, bool bKeepPosition)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n  output.setFilePointer(GetElementPosition());\n  filepos_t Result = MakeRenderHead(output, bKeepPosition);\n  output.setFilePointer(CurrentPosition);\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "681-692"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          },
          {
            "qualified_name": "IOCallback::writeFully",
            "snippet": "START_LIBEBML_NAMESPACE\n\nvoid IOCallback::writeFully(const void*Buffer,size_t Size)\n{\n  if (Size == 0)\n    return;\n\n  if (Buffer == NULL)\n    throw;\n\n  if(write(Buffer,Size) != Size) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"EOF in writeFully(\"<<Buffer<<\",\"<<Size<<\")\";\n    throw runtime_error(Msg.str());\n#endif // GCC2\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/IOCallback.cpp",
            "lines": "46-63"
          },
          {
            "qualified_name": "StdIOCallback::write",
            "snippet": "size_t StdIOCallback::write(const void*Buffer,size_t Size)\n{\n  assert(File!=0);\n  uint32 Result = fwrite(Buffer,1,Size,File);\n  mCurrentPosition += Result;\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "151-157"
          }
        ]
      }
    ]
  },
  {
    "target_function": "StdIOCallback::setFilePointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
    "lines": "113-149",
    "num_chains": 7,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::OverwriteHead",
          "StdIOCallback::setFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlElement::OverwriteHead",
            "snippet": "filepos_t EbmlElement::OverwriteHead(IOCallback & output, bool bKeepPosition)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n  output.setFilePointer(GetElementPosition());\n  filepos_t Result = MakeRenderHead(output, bKeepPosition);\n  output.setFilePointer(CurrentPosition);\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "681-692"
          },
          {
            "qualified_name": "StdIOCallback::setFilePointer",
            "snippet": "void StdIOCallback::setFilePointer(int64 Offset,seek_mode Mode)\n{\n  assert(File!=0);\n\n  // There is a numeric cast in the boost library, which would be quite nice for this checking\n  /*\n    SL : replaced because unknown class in cygwin\n    assert(Offset <= numeric_limits<long>::max());\n    assert(Offset >= numeric_limits<long>::min());\n  */\n\n  assert(Offset <= LONG_MAX);\n  assert(Offset >= LONG_MIN);\n\n  assert(Mode==SEEK_CUR||Mode==SEEK_END||Mode==SEEK_SET);\n\n  if(fseek(File,Offset,Mode)!=0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    ostringstream Msg;\n    Msg<<\"Failed to seek file \"<<File",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "113-149"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::Seek",
          "StdIOCallback::setFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::Seek",
            "snippet": "void\nSafeReadIOCallback::Seek(size_t Offset) {\n  mIO->setFilePointer(Offset);\n  uint64 ActualPosition = mIO->getFilePointer();\n  if (ActualPosition != Offset)\n    throw EndOfStreamX(ActualPosition - Offset);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "158-164"
          },
          {
            "qualified_name": "StdIOCallback::setFilePointer",
            "snippet": "void StdIOCallback::setFilePointer(int64 Offset,seek_mode Mode)\n{\n  assert(File!=0);\n\n  // There is a numeric cast in the boost library, which would be quite nice for this checking\n  /*\n    SL : replaced because unknown class in cygwin\n    assert(Offset <= numeric_limits<long>::max());\n    assert(Offset >= numeric_limits<long>::min());\n  */\n\n  assert(Offset <= LONG_MAX);\n  assert(Offset >= LONG_MIN);\n\n  assert(Mode==SEEK_CUR||Mode==SEEK_END||Mode==SEEK_SET);\n\n  if(fseek(File,Offset,Mode)!=0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    ostringstream Msg;\n    Msg<<\"Failed to seek file \"<<File",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "113-149"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::Skip",
          "StdIOCallback::setFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::Skip",
            "snippet": "void\nSafeReadIOCallback::Skip(size_t Count) {\n  int64 PrevPosition     = mIO->getFilePointer();\n  int64 ExpectedPosition = PrevPosition + Count;\n  mIO->setFilePointer(Count, seek_current);\n  int64 ActualPosition   = mIO->getFilePointer();\n\n  if (ActualPosition != ExpectedPosition)\n    throw SafeReadIOCallback::EndOfStreamX(ExpectedPosition - ActualPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "147-156"
          },
          {
            "qualified_name": "StdIOCallback::setFilePointer",
            "snippet": "void StdIOCallback::setFilePointer(int64 Offset,seek_mode Mode)\n{\n  assert(File!=0);\n\n  // There is a numeric cast in the boost library, which would be quite nice for this checking\n  /*\n    SL : replaced because unknown class in cygwin\n    assert(Offset <= numeric_limits<long>::max());\n    assert(Offset >= numeric_limits<long>::min());\n  */\n\n  assert(Offset <= LONG_MAX);\n  assert(Offset >= LONG_MIN);\n\n  assert(Mode==SEEK_CUR||Mode==SEEK_END||Mode==SEEK_SET);\n\n  if(fseek(File,Offset,Mode)!=0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    ostringstream Msg;\n    Msg<<\"Failed to seek file \"<<File",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "113-149"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::SafeReadIOCallback",
          "SafeReadIOCallback::Init",
          "StdIOCallback::setFilePointer"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::SafeReadIOCallback",
            "snippet": "SafeReadIOCallback::SafeReadIOCallback(IOCallback *IO,\n                                       bool DeleteIO) {\n  Init(IO, DeleteIO);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "52-55"
          },
          {
            "qualified_name": "SafeReadIOCallback::Init",
            "snippet": "void\nSafeReadIOCallback::Init(IOCallback *IO,\n                         bool DeleteIO) {\n  mIO                = IO;\n  mDeleteIO          = DeleteIO;\n  int64 PrevPosition = IO->getFilePointer();\n  IO->setFilePointer(0, seek_end);\n  mSize              = IO->getFilePointer();\n  IO->setFilePointer(PrevPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "71-80"
          },
          {
            "qualified_name": "StdIOCallback::setFilePointer",
            "snippet": "void StdIOCallback::setFilePointer(int64 Offset,seek_mode Mode)\n{\n  assert(File!=0);\n\n  // There is a numeric cast in the boost library, which would be quite nice for this checking\n  /*\n    SL : replaced because unknown class in cygwin\n    assert(Offset <= numeric_limits<long>::max());\n    assert(Offset >= numeric_limits<long>::min());\n  */\n\n  assert(Offset <= LONG_MAX);\n  assert(Offset >= LONG_MIN);\n\n  assert(Mode==SEEK_CUR||Mode==SEEK_END||Mode==SEEK_SET);\n\n  if(fseek(File,Offset,Mode)!=0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    ostringstream Msg;\n    Msg<<\"Failed to seek file \"<<File",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "113-149"
          }
        ]
      },
      {
        "call_sequence": [
          "MemReadIOCallback::MemReadIOCallback",
          "SafeReadIOCallback::Init",
          "StdIOCallback::setFilePointer"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "MemReadIOCallback::MemReadIOCallback",
            "snippet": "START_LIBEBML_NAMESPACE\n\nMemReadIOCallback::MemReadIOCallback(void const *Ptr,\n                                     size_t Size) {\n  Init(Ptr, Size);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "42-47"
          },
          {
            "qualified_name": "SafeReadIOCallback::Init",
            "snippet": "void\nSafeReadIOCallback::Init(IOCallback *IO,\n                         bool DeleteIO) {\n  mIO                = IO;\n  mDeleteIO          = DeleteIO;\n  int64 PrevPosition = IO->getFilePointer();\n  IO->setFilePointer(0, seek_end);\n  mSize              = IO->getFilePointer();\n  IO->setFilePointer(PrevPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "71-80"
          },
          {
            "qualified_name": "StdIOCallback::setFilePointer",
            "snippet": "void StdIOCallback::setFilePointer(int64 Offset,seek_mode Mode)\n{\n  assert(File!=0);\n\n  // There is a numeric cast in the boost library, which would be quite nice for this checking\n  /*\n    SL : replaced because unknown class in cygwin\n    assert(Offset <= numeric_limits<long>::max());\n    assert(Offset >= numeric_limits<long>::min());\n  */\n\n  assert(Offset <= LONG_MAX);\n  assert(Offset >= LONG_MIN);\n\n  assert(Mode==SEEK_CUR||Mode==SEEK_END||Mode==SEEK_SET);\n\n  if(fseek(File,Offset,Mode)!=0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    ostringstream Msg;\n    Msg<<\"Failed to seek file \"<<File",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "113-149"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlElement::VoidMe",
          "EbmlVoid::Overwrite",
          "StdIOCallback::setFilePointer"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlElement::VoidMe",
            "snippet": "uint64 EbmlElement::VoidMe(IOCallback & output, bool bWithDefault)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  EbmlVoid Dummy;\n  return Dummy.Overwrite(*this, output, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "694-702"
          },
          {
            "qualified_name": "EbmlVoid::Overwrite",
            "snippet": "uint64 EbmlVoid::Overwrite(const EbmlElement & EltToVoid, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  //  EltToVoid.UpdateSize(bWithDefault);\n  if (EltToVoid.GetElementPosition() == 0) {\n    // this element has never been written\n    return 0;\n  }\n  if (EltToVoid.GetSize() + EltToVoid.HeadSize() <2) {\n    // the element can't be written here !\n    return 0;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePointer(EltToVoid.GetElementPosition());\n\n  // compute the size of the voided data based on the original one\n  SetSize(EltToVoid.GetSize() + E",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "99-135"
          },
          {
            "qualified_name": "StdIOCallback::setFilePointer",
            "snippet": "void StdIOCallback::setFilePointer(int64 Offset,seek_mode Mode)\n{\n  assert(File!=0);\n\n  // There is a numeric cast in the boost library, which would be quite nice for this checking\n  /*\n    SL : replaced because unknown class in cygwin\n    assert(Offset <= numeric_limits<long>::max());\n    assert(Offset >= numeric_limits<long>::min());\n  */\n\n  assert(Offset <= LONG_MAX);\n  assert(Offset >= LONG_MIN);\n\n  assert(Mode==SEEK_CUR||Mode==SEEK_END||Mode==SEEK_SET);\n\n  if(fseek(File,Offset,Mode)!=0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    ostringstream Msg;\n    Msg<<\"Failed to seek file \"<<File",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "113-149"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "StdIOCallback::setFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "StdIOCallback::setFilePointer",
            "snippet": "void StdIOCallback::setFilePointer(int64 Offset,seek_mode Mode)\n{\n  assert(File!=0);\n\n  // There is a numeric cast in the boost library, which would be quite nice for this checking\n  /*\n    SL : replaced because unknown class in cygwin\n    assert(Offset <= numeric_limits<long>::max());\n    assert(Offset >= numeric_limits<long>::min());\n  */\n\n  assert(Offset <= LONG_MAX);\n  assert(Offset >= LONG_MIN);\n\n  assert(Mode==SEEK_CUR||Mode==SEEK_END||Mode==SEEK_SET);\n\n  if(fseek(File,Offset,Mode)!=0) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    ostringstream Msg;\n    Msg<<\"Failed to seek file \"<<File",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "113-149"
          }
        ]
      }
    ]
  },
  {
    "target_function": "StdIOCallback::read",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
    "lines": "104-111",
    "num_chains": 5,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "StdIOCallback::read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "StdIOCallback::read",
            "snippet": "uint32 StdIOCallback::read(void*Buffer,size_t Size)\n{\n  assert(File!=0);\n\n  size_t result = fread(Buffer, 1, Size, File);\n  mCurrentPosition += result;\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "104-111"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "StdIOCallback::read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "StdIOCallback::read",
            "snippet": "uint32 StdIOCallback::read(void*Buffer,size_t Size)\n{\n  assert(File!=0);\n\n  size_t result = fread(Buffer, 1, Size, File);\n  mCurrentPosition += result;\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "104-111"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "StdIOCallback::read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "StdIOCallback::read",
            "snippet": "uint32 StdIOCallback::read(void*Buffer,size_t Size)\n{\n  assert(File!=0);\n\n  size_t result = fread(Buffer, 1, Size, File);\n  mCurrentPosition += result;\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "104-111"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "StdIOCallback::read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "StdIOCallback::read",
            "snippet": "uint32 StdIOCallback::read(void*Buffer,size_t Size)\n{\n  assert(File!=0);\n\n  size_t result = fread(Buffer, 1, Size, File);\n  mCurrentPosition += result;\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "104-111"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "StdIOCallback::read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "StdIOCallback::read",
            "snippet": "uint32 StdIOCallback::read(void*Buffer,size_t Size)\n{\n  assert(File!=0);\n\n  size_t result = fread(Buffer, 1, Size, File);\n  mCurrentPosition += result;\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "104-111"
          }
        ]
      }
    ]
  },
  {
    "target_function": "StdIOCallback::~StdIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
    "lines": "97-100",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "StdIOCallback::~StdIOCallback"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "StdIOCallback::~StdIOCallback",
            "snippet": "StdIOCallback::~StdIOCallback()throw()\n{\n  close();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "97-100"
          }
        ]
      }
    ]
  },
  {
    "target_function": "StdIOCallback::StdIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
    "lines": "48-94",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "StdIOCallback::StdIOCallback"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "StdIOCallback::StdIOCallback",
            "snippet": "START_LIBEBML_NAMESPACE\n\nCRTError::CRTError(int nError, const std::string & Description)\n  :std::runtime_error(Description+\": \"+strerror(nError))\n  ,Error(nError)\n{\n}\n\nCRTError::CRTError(const std::string & Description,int nError)\n  :std::runtime_error(Description+\": \"+strerror(nError))\n  ,Error(nError)\n{\n}\n\n\nStdIOCallback::StdIOCallback(const char*Path, const open_mode aMode)\n{\n  assert(Path!=0);\n\n  const char *Mode;\n  switch (aMode) {\n    case MODE_READ:\n      Mode = \"rb\";\n      break;\n    case MODE_SAFE:\n      Mode = \"rb+\";\n      break;\n    case MODE_WRITE:\n      Mode = \"wb\";\n      break;\n ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "48-94"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlMaster::InsertElement",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
    "lines": "556-568",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::InsertElement"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::InsertElement",
            "snippet": "bool EbmlMaster::InsertElement(EbmlElement & element, size_t position)\n{\n  std::vector<EbmlElement *>::iterator Itr = ElementList.begin();\n  while (Itr != ElementList.end() && position--)\n  {\n    ++Itr;\n  }\n  if ((Itr == ElementList.end()) && position)\n    return false;\n\n  ElementList.insert(Itr, &element);\n  return true;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "542-554"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlMaster::InsertElement",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
    "lines": "542-554",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::InsertElement"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::InsertElement",
            "snippet": "bool EbmlMaster::InsertElement(EbmlElement & element, size_t position)\n{\n  std::vector<EbmlElement *>::iterator Itr = ElementList.begin();\n  while (Itr != ElementList.end() && position--)\n  {\n    ++Itr;\n  }\n  if ((Itr == ElementList.end()) && position)\n    return false;\n\n  ElementList.insert(Itr, &element);\n  return true;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "542-554"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlMaster::VerifyChecksum",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
    "lines": "526-540",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::VerifyChecksum"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::VerifyChecksum",
            "snippet": "bool EbmlMaster::VerifyChecksum() const\n{\n  if (!bChecksumUsed)\n    return true;\n\n  EbmlCrc32 aChecksum;\n  /// \\todo remove the Checksum if it's in the list\n  /// \\todo find another way when not all default values are saved or (unknown from the reader !!!)\n  MemIOCallback TmpBuf(GetSize() - 6);\n  for (size_t Index = 0; Index < ElementList.size(); Index++) {\n    (ElementList[Index])->Render(TmpBuf, true, false, true);\n  }\n  aChecksum.FillCRC32(TmpBuf.GetDataBuffer(), TmpBuf.GetDataBufferSize());\n  return (aChecksum.GetCrc32() == Checksum.GetCrc32());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "526-540"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlMaster::Remove",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
    "lines": "521-524",
    "num_chains": 5,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::Remove"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::Remove",
            "snippet": "void EbmlMaster::Remove(size_t Index)\n{\n  if (Index < ElementList.size()) {\n    std::vector<EbmlElement *>::iterator Itr = ElementList.begin();\n    while (Index-- > 0) {\n      ++Itr;\n    }\n\n    ElementList.erase(Itr);\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "504-514"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::Remove"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::Remove",
            "snippet": "void EbmlMaster::Remove(size_t Index)\n{\n  if (Index < ElementList.size()) {\n    std::vector<EbmlElement *>::iterator Itr = ElementList.begin();\n    while (Index-- > 0) {\n      ++Itr;\n    }\n\n    ElementList.erase(Itr);\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "504-514"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::Remove"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::Remove",
            "snippet": "void EbmlMaster::Remove(size_t Index)\n{\n  if (Index < ElementList.size()) {\n    std::vector<EbmlElement *>::iterator Itr = ElementList.begin();\n    while (Index-- > 0) {\n      ++Itr;\n    }\n\n    ElementList.erase(Itr);\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "504-514"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::Remove"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::Remove",
            "snippet": "void EbmlMaster::Remove(size_t Index)\n{\n  if (Index < ElementList.size()) {\n    std::vector<EbmlElement *>::iterator Itr = ElementList.begin();\n    while (Index-- > 0) {\n      ++Itr;\n    }\n\n    ElementList.erase(Itr);\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "504-514"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::Remove"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::Remove",
            "snippet": "void EbmlMaster::Remove(size_t Index)\n{\n  if (Index < ElementList.size()) {\n    std::vector<EbmlElement *>::iterator Itr = ElementList.begin();\n    while (Index-- > 0) {\n      ++Itr;\n    }\n\n    ElementList.erase(Itr);\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "504-514"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlMaster::Remove",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
    "lines": "516-519",
    "num_chains": 5,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::Remove"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::Remove",
            "snippet": "void EbmlMaster::Remove(size_t Index)\n{\n  if (Index < ElementList.size()) {\n    std::vector<EbmlElement *>::iterator Itr = ElementList.begin();\n    while (Index-- > 0) {\n      ++Itr;\n    }\n\n    ElementList.erase(Itr);\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "504-514"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::Remove"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::Remove",
            "snippet": "void EbmlMaster::Remove(size_t Index)\n{\n  if (Index < ElementList.size()) {\n    std::vector<EbmlElement *>::iterator Itr = ElementList.begin();\n    while (Index-- > 0) {\n      ++Itr;\n    }\n\n    ElementList.erase(Itr);\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "504-514"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::Remove"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::Remove",
            "snippet": "void EbmlMaster::Remove(size_t Index)\n{\n  if (Index < ElementList.size()) {\n    std::vector<EbmlElement *>::iterator Itr = ElementList.begin();\n    while (Index-- > 0) {\n      ++Itr;\n    }\n\n    ElementList.erase(Itr);\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "504-514"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::Remove"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::Remove",
            "snippet": "void EbmlMaster::Remove(size_t Index)\n{\n  if (Index < ElementList.size()) {\n    std::vector<EbmlElement *>::iterator Itr = ElementList.begin();\n    while (Index-- > 0) {\n      ++Itr;\n    }\n\n    ElementList.erase(Itr);\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "504-514"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::Remove"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::Remove",
            "snippet": "void EbmlMaster::Remove(size_t Index)\n{\n  if (Index < ElementList.size()) {\n    std::vector<EbmlElement *>::iterator Itr = ElementList.begin();\n    while (Index-- > 0) {\n      ++Itr;\n    }\n\n    ElementList.erase(Itr);\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "504-514"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlMaster::Remove",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
    "lines": "504-514",
    "num_chains": 5,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::Remove"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::Remove",
            "snippet": "void EbmlMaster::Remove(size_t Index)\n{\n  if (Index < ElementList.size()) {\n    std::vector<EbmlElement *>::iterator Itr = ElementList.begin();\n    while (Index-- > 0) {\n      ++Itr;\n    }\n\n    ElementList.erase(Itr);\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "504-514"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::Remove"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::Remove",
            "snippet": "void EbmlMaster::Remove(size_t Index)\n{\n  if (Index < ElementList.size()) {\n    std::vector<EbmlElement *>::iterator Itr = ElementList.begin();\n    while (Index-- > 0) {\n      ++Itr;\n    }\n\n    ElementList.erase(Itr);\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "504-514"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::Remove"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::Remove",
            "snippet": "void EbmlMaster::Remove(size_t Index)\n{\n  if (Index < ElementList.size()) {\n    std::vector<EbmlElement *>::iterator Itr = ElementList.begin();\n    while (Index-- > 0) {\n      ++Itr;\n    }\n\n    ElementList.erase(Itr);\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "504-514"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::Remove"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::Remove",
            "snippet": "void EbmlMaster::Remove(size_t Index)\n{\n  if (Index < ElementList.size()) {\n    std::vector<EbmlElement *>::iterator Itr = ElementList.begin();\n    while (Index-- > 0) {\n      ++Itr;\n    }\n\n    ElementList.erase(Itr);\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "504-514"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::Remove"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::Remove",
            "snippet": "void EbmlMaster::Remove(size_t Index)\n{\n  if (Index < ElementList.size()) {\n    std::vector<EbmlElement *>::iterator Itr = ElementList.begin();\n    while (Index-- > 0) {\n      ++Itr;\n    }\n\n    ElementList.erase(Itr);\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "504-514"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlMaster::Read",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
    "lines": "399-502",
    "num_chains": 10,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::Read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::Read",
            "snippet": "void EbmlMaster::Read(EbmlStream & inDataStream, const EbmlSemanticContext & sContext, int & UpperEltFound, EbmlElement * & FoundElt, bool AllowDummyElt, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA)\n  {\n    EbmlElement * ElementLevelA;\n    // remove all existing elements, including the mandatory ones...\n    size_t Index;\n    for (Index=0; Index<ElementList.size(); Index++) {\n      if (!(*ElementList[Index]).IsLocked()) {\n        delete ElementList[Index];\n      }\n    }\n    ElementList.clear();\n    uint64 MaxSizeToRead;\n\n    if (IsFiniteSize())\n      MaxSizeToRead = GetSize();\n    e",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "399-502"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::Read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::Read",
            "snippet": "void EbmlMaster::Read(EbmlStream & inDataStream, const EbmlSemanticContext & sContext, int & UpperEltFound, EbmlElement * & FoundElt, bool AllowDummyElt, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA)\n  {\n    EbmlElement * ElementLevelA;\n    // remove all existing elements, including the mandatory ones...\n    size_t Index;\n    for (Index=0; Index<ElementList.size(); Index++) {\n      if (!(*ElementList[Index]).IsLocked()) {\n        delete ElementList[Index];\n      }\n    }\n    ElementList.clear();\n    uint64 MaxSizeToRead;\n\n    if (IsFiniteSize())\n      MaxSizeToRead = GetSize();\n    e",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "399-502"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::Read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::Read",
            "snippet": "void EbmlMaster::Read(EbmlStream & inDataStream, const EbmlSemanticContext & sContext, int & UpperEltFound, EbmlElement * & FoundElt, bool AllowDummyElt, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA)\n  {\n    EbmlElement * ElementLevelA;\n    // remove all existing elements, including the mandatory ones...\n    size_t Index;\n    for (Index=0; Index<ElementList.size(); Index++) {\n      if (!(*ElementList[Index]).IsLocked()) {\n        delete ElementList[Index];\n      }\n    }\n    ElementList.clear();\n    uint64 MaxSizeToRead;\n\n    if (IsFiniteSize())\n      MaxSizeToRead = GetSize();\n    e",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "399-502"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::Read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::Read",
            "snippet": "void EbmlMaster::Read(EbmlStream & inDataStream, const EbmlSemanticContext & sContext, int & UpperEltFound, EbmlElement * & FoundElt, bool AllowDummyElt, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA)\n  {\n    EbmlElement * ElementLevelA;\n    // remove all existing elements, including the mandatory ones...\n    size_t Index;\n    for (Index=0; Index<ElementList.size(); Index++) {\n      if (!(*ElementList[Index]).IsLocked()) {\n        delete ElementList[Index];\n      }\n    }\n    ElementList.clear();\n    uint64 MaxSizeToRead;\n\n    if (IsFiniteSize())\n      MaxSizeToRead = GetSize();\n    e",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "399-502"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::Read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::Read",
            "snippet": "void EbmlMaster::Read(EbmlStream & inDataStream, const EbmlSemanticContext & sContext, int & UpperEltFound, EbmlElement * & FoundElt, bool AllowDummyElt, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA)\n  {\n    EbmlElement * ElementLevelA;\n    // remove all existing elements, including the mandatory ones...\n    size_t Index;\n    for (Index=0; Index<ElementList.size(); Index++) {\n      if (!(*ElementList[Index]).IsLocked()) {\n        delete ElementList[Index];\n      }\n    }\n    ElementList.clear();\n    uint64 MaxSizeToRead;\n\n    if (IsFiniteSize())\n      MaxSizeToRead = GetSize();\n    e",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "399-502"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE",
          "EbmlMaster::Read"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "EbmlMaster::Read",
            "snippet": "void EbmlMaster::Read(EbmlStream & inDataStream, const EbmlSemanticContext & sContext, int & UpperEltFound, EbmlElement * & FoundElt, bool AllowDummyElt, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA)\n  {\n    EbmlElement * ElementLevelA;\n    // remove all existing elements, including the mandatory ones...\n    size_t Index;\n    for (Index=0; Index<ElementList.size(); Index++) {\n      if (!(*ElementList[Index]).IsLocked()) {\n        delete ElementList[Index];\n      }\n    }\n    ElementList.clear();\n    uint64 MaxSizeToRead;\n\n    if (IsFiniteSize())\n      MaxSizeToRead = GetSize();\n    e",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "399-502"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE",
          "EbmlMaster::Read"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "EbmlMaster::Read",
            "snippet": "void EbmlMaster::Read(EbmlStream & inDataStream, const EbmlSemanticContext & sContext, int & UpperEltFound, EbmlElement * & FoundElt, bool AllowDummyElt, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA)\n  {\n    EbmlElement * ElementLevelA;\n    // remove all existing elements, including the mandatory ones...\n    size_t Index;\n    for (Index=0; Index<ElementList.size(); Index++) {\n      if (!(*ElementList[Index]).IsLocked()) {\n        delete ElementList[Index];\n      }\n    }\n    ElementList.clear();\n    uint64 MaxSizeToRead;\n\n    if (IsFiniteSize())\n      MaxSizeToRead = GetSize();\n    e",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "399-502"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE",
          "EbmlMaster::Read"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "EbmlMaster::Read",
            "snippet": "void EbmlMaster::Read(EbmlStream & inDataStream, const EbmlSemanticContext & sContext, int & UpperEltFound, EbmlElement * & FoundElt, bool AllowDummyElt, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA)\n  {\n    EbmlElement * ElementLevelA;\n    // remove all existing elements, including the mandatory ones...\n    size_t Index;\n    for (Index=0; Index<ElementList.size(); Index++) {\n      if (!(*ElementList[Index]).IsLocked()) {\n        delete ElementList[Index];\n      }\n    }\n    ElementList.clear();\n    uint64 MaxSizeToRead;\n\n    if (IsFiniteSize())\n      MaxSizeToRead = GetSize();\n    e",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "399-502"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE",
          "EbmlMaster::Read"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "EbmlMaster::Read",
            "snippet": "void EbmlMaster::Read(EbmlStream & inDataStream, const EbmlSemanticContext & sContext, int & UpperEltFound, EbmlElement * & FoundElt, bool AllowDummyElt, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA)\n  {\n    EbmlElement * ElementLevelA;\n    // remove all existing elements, including the mandatory ones...\n    size_t Index;\n    for (Index=0; Index<ElementList.size(); Index++) {\n      if (!(*ElementList[Index]).IsLocked()) {\n        delete ElementList[Index];\n      }\n    }\n    ElementList.clear();\n    uint64 MaxSizeToRead;\n\n    if (IsFiniteSize())\n      MaxSizeToRead = GetSize();\n    e",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "399-502"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE",
          "EbmlMaster::Read"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "EbmlMaster::Read",
            "snippet": "void EbmlMaster::Read(EbmlStream & inDataStream, const EbmlSemanticContext & sContext, int & UpperEltFound, EbmlElement * & FoundElt, bool AllowDummyElt, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA)\n  {\n    EbmlElement * ElementLevelA;\n    // remove all existing elements, including the mandatory ones...\n    size_t Index;\n    for (Index=0; Index<ElementList.size(); Index++) {\n      if (!(*ElementList[Index]).IsLocked()) {\n        delete ElementList[Index];\n      }\n    }\n    ElementList.clear();\n    uint64 MaxSizeToRead;\n\n    if (IsFiniteSize())\n      MaxSizeToRead = GetSize();\n    e",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "399-502"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlMaster::Sort",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
    "lines": "389-392",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::Sort"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::Sort",
            "snippet": "void EbmlMaster::Sort()\n{\n  std::sort(ElementList.begin(), ElementList.end(), EbmlElement::CompareElements);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "389-392"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlMaster::CheckMandatory",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
    "lines": "199-217",
    "num_chains": 9,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::WriteHead",
          "EbmlElement::RenderHead",
          "EbmlUnicodeString::UpdateSize",
          "EbmlMaster::CheckMandatory"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::WriteHead",
            "snippet": "filepos_t EbmlMaster::WriteHead(IOCallback & output, int nSizeLength, bool bWithDefault)\n{\n  SetSizeLength(nSizeLength);\n  return RenderHead(output, false, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "161-165"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          },
          {
            "qualified_name": "EbmlMaster::CheckMandatory",
            "snippet": "bool EbmlMaster::CheckMandatory() const\n{\n  assert(Context.GetSize() != 0);\n\n  unsigned int EltIdx;\n  for (EltIdx = 0; EltIdx < EBML_CTX_SIZE(Context); EltIdx++) {\n    if (EBML_CTX_IDX(Context,EltIdx).IsMandatory()) {\n      if (FindElt(EBML_CTX_IDX_INFO(Context,EltIdx)) == NULL) {\n#if defined(LIBEBML_DEBUG)\n        // you are missing this Mandatory element\n//         const char * MissingName = EBML_INFO_NAME(EBML_CTX_IDX_INFO(Context,EltIdx));\n#endif // LIBEBML_DEBUG\n        return false;\n      }\n    }\n  }\n\n  return true;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "199-217"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::RenderHead",
          "EbmlUnicodeString::UpdateSize",
          "EbmlMaster::CheckMandatory"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          },
          {
            "qualified_name": "EbmlMaster::CheckMandatory",
            "snippet": "bool EbmlMaster::CheckMandatory() const\n{\n  assert(Context.GetSize() != 0);\n\n  unsigned int EltIdx;\n  for (EltIdx = 0; EltIdx < EBML_CTX_SIZE(Context); EltIdx++) {\n    if (EBML_CTX_IDX(Context,EltIdx).IsMandatory()) {\n      if (FindElt(EBML_CTX_IDX_INFO(Context,EltIdx)) == NULL) {\n#if defined(LIBEBML_DEBUG)\n        // you are missing this Mandatory element\n//         const char * MissingName = EBML_INFO_NAME(EBML_CTX_IDX_INFO(Context,EltIdx));\n#endif // LIBEBML_DEBUG\n        return false;\n      }\n    }\n  }\n\n  return true;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "199-217"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlUnicodeString::UpdateSize",
          "EbmlMaster::CheckMandatory"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          },
          {
            "qualified_name": "EbmlMaster::CheckMandatory",
            "snippet": "bool EbmlMaster::CheckMandatory() const\n{\n  assert(Context.GetSize() != 0);\n\n  unsigned int EltIdx;\n  for (EltIdx = 0; EltIdx < EBML_CTX_SIZE(Context); EltIdx++) {\n    if (EBML_CTX_IDX(Context,EltIdx).IsMandatory()) {\n      if (FindElt(EBML_CTX_IDX_INFO(Context,EltIdx)) == NULL) {\n#if defined(LIBEBML_DEBUG)\n        // you are missing this Mandatory element\n//         const char * MissingName = EBML_INFO_NAME(EBML_CTX_IDX_INFO(Context,EltIdx));\n#endif // LIBEBML_DEBUG\n        return false;\n      }\n    }\n  }\n\n  return true;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "199-217"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlUnicodeString::UpdateSize",
          "EbmlMaster::CheckMandatory"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          },
          {
            "qualified_name": "EbmlMaster::CheckMandatory",
            "snippet": "bool EbmlMaster::CheckMandatory() const\n{\n  assert(Context.GetSize() != 0);\n\n  unsigned int EltIdx;\n  for (EltIdx = 0; EltIdx < EBML_CTX_SIZE(Context); EltIdx++) {\n    if (EBML_CTX_IDX(Context,EltIdx).IsMandatory()) {\n      if (FindElt(EBML_CTX_IDX_INFO(Context,EltIdx)) == NULL) {\n#if defined(LIBEBML_DEBUG)\n        // you are missing this Mandatory element\n//         const char * MissingName = EBML_INFO_NAME(EBML_CTX_IDX_INFO(Context,EltIdx));\n#endif // LIBEBML_DEBUG\n        return false;\n      }\n    }\n  }\n\n  return true;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "199-217"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlUnicodeString::UpdateSize",
          "EbmlMaster::CheckMandatory"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          },
          {
            "qualified_name": "EbmlMaster::CheckMandatory",
            "snippet": "bool EbmlMaster::CheckMandatory() const\n{\n  assert(Context.GetSize() != 0);\n\n  unsigned int EltIdx;\n  for (EltIdx = 0; EltIdx < EBML_CTX_SIZE(Context); EltIdx++) {\n    if (EBML_CTX_IDX(Context,EltIdx).IsMandatory()) {\n      if (FindElt(EBML_CTX_IDX_INFO(Context,EltIdx)) == NULL) {\n#if defined(LIBEBML_DEBUG)\n        // you are missing this Mandatory element\n//         const char * MissingName = EBML_INFO_NAME(EBML_CTX_IDX_INFO(Context,EltIdx));\n#endif // LIBEBML_DEBUG\n        return false;\n      }\n    }\n  }\n\n  return true;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "199-217"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlUnicodeString::UpdateSize",
          "EbmlMaster::CheckMandatory"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          },
          {
            "qualified_name": "EbmlMaster::CheckMandatory",
            "snippet": "bool EbmlMaster::CheckMandatory() const\n{\n  assert(Context.GetSize() != 0);\n\n  unsigned int EltIdx;\n  for (EltIdx = 0; EltIdx < EBML_CTX_SIZE(Context); EltIdx++) {\n    if (EBML_CTX_IDX(Context,EltIdx).IsMandatory()) {\n      if (FindElt(EBML_CTX_IDX_INFO(Context,EltIdx)) == NULL) {\n#if defined(LIBEBML_DEBUG)\n        // you are missing this Mandatory element\n//         const char * MissingName = EBML_INFO_NAME(EBML_CTX_IDX_INFO(Context,EltIdx));\n#endif // LIBEBML_DEBUG\n        return false;\n      }\n    }\n  }\n\n  return true;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "199-217"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlUnicodeString::RenderData",
          "EbmlMaster::CheckMandatory"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::RenderData",
            "snippet": "filepos_t EbmlUnicodeString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  uint32 Result = Value.GetUTF8().length();\n\n  if (Result != 0) {\n    output.writeFully(Value.GetUTF8().c_str(), Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "279-300"
          },
          {
            "qualified_name": "EbmlMaster::CheckMandatory",
            "snippet": "bool EbmlMaster::CheckMandatory() const\n{\n  assert(Context.GetSize() != 0);\n\n  unsigned int EltIdx;\n  for (EltIdx = 0; EltIdx < EBML_CTX_SIZE(Context); EltIdx++) {\n    if (EBML_CTX_IDX(Context,EltIdx).IsMandatory()) {\n      if (FindElt(EBML_CTX_IDX_INFO(Context,EltIdx)) == NULL) {\n#if defined(LIBEBML_DEBUG)\n        // you are missing this Mandatory element\n//         const char * MissingName = EBML_INFO_NAME(EBML_CTX_IDX_INFO(Context,EltIdx));\n#endif // LIBEBML_DEBUG\n        return false;\n      }\n    }\n  }\n\n  return true;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "199-217"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlUnicodeString::RenderData",
          "EbmlMaster::CheckMandatory"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::RenderData",
            "snippet": "filepos_t EbmlUnicodeString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  uint32 Result = Value.GetUTF8().length();\n\n  if (Result != 0) {\n    output.writeFully(Value.GetUTF8().c_str(), Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "279-300"
          },
          {
            "qualified_name": "EbmlMaster::CheckMandatory",
            "snippet": "bool EbmlMaster::CheckMandatory() const\n{\n  assert(Context.GetSize() != 0);\n\n  unsigned int EltIdx;\n  for (EltIdx = 0; EltIdx < EBML_CTX_SIZE(Context); EltIdx++) {\n    if (EBML_CTX_IDX(Context,EltIdx).IsMandatory()) {\n      if (FindElt(EBML_CTX_IDX_INFO(Context,EltIdx)) == NULL) {\n#if defined(LIBEBML_DEBUG)\n        // you are missing this Mandatory element\n//         const char * MissingName = EBML_INFO_NAME(EBML_CTX_IDX_INFO(Context,EltIdx));\n#endif // LIBEBML_DEBUG\n        return false;\n      }\n    }\n  }\n\n  return true;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "199-217"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlUnicodeString::RenderData",
          "EbmlMaster::CheckMandatory"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::RenderData",
            "snippet": "filepos_t EbmlUnicodeString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  uint32 Result = Value.GetUTF8().length();\n\n  if (Result != 0) {\n    output.writeFully(Value.GetUTF8().c_str(), Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "279-300"
          },
          {
            "qualified_name": "EbmlMaster::CheckMandatory",
            "snippet": "bool EbmlMaster::CheckMandatory() const\n{\n  assert(Context.GetSize() != 0);\n\n  unsigned int EltIdx;\n  for (EltIdx = 0; EltIdx < EBML_CTX_SIZE(Context); EltIdx++) {\n    if (EBML_CTX_IDX(Context,EltIdx).IsMandatory()) {\n      if (FindElt(EBML_CTX_IDX_INFO(Context,EltIdx)) == NULL) {\n#if defined(LIBEBML_DEBUG)\n        // you are missing this Mandatory element\n//         const char * MissingName = EBML_INFO_NAME(EBML_CTX_IDX_INFO(Context,EltIdx));\n#endif // LIBEBML_DEBUG\n        return false;\n      }\n    }\n  }\n\n  return true;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "199-217"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlMaster::ProcessMandatory",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
    "lines": "180-197",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::ProcessMandatory"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::ProcessMandatory",
            "snippet": "bool EbmlMaster::ProcessMandatory()\n{\n  if (EBML_CTX_SIZE(Context) == 0)\n  {\n    return true;\n  }\n\n  assert(Context.GetSize() != 0);\n\n  unsigned int EltIdx;\n  for (EltIdx = 0; EltIdx < EBML_CTX_SIZE(Context); EltIdx++) {\n    if (EBML_CTX_IDX(Context,EltIdx).IsMandatory() && EBML_CTX_IDX(Context,EltIdx).IsUnique()) {\n//      assert(EBML_CTX_IDX(Context,EltIdx).Create != NULL);\n            PushElement(EBML_SEM_CREATE(EBML_CTX_IDX(Context,EltIdx)));\n    }\n  }\n  return true;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "180-197"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlMaster::ReadData",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
    "lines": "170-174",
    "num_chains": 5,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::ReadData",
            "snippet": "filepos_t EbmlMaster::ReadData(IOCallback & input, ScopeMode /* ReadFully */)\n{\n  input.setFilePointer(GetSize(), seek_current);\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "170-174"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::ReadData",
            "snippet": "filepos_t EbmlMaster::ReadData(IOCallback & input, ScopeMode /* ReadFully */)\n{\n  input.setFilePointer(GetSize(), seek_current);\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "170-174"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::ReadData",
            "snippet": "filepos_t EbmlMaster::ReadData(IOCallback & input, ScopeMode /* ReadFully */)\n{\n  input.setFilePointer(GetSize(), seek_current);\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "170-174"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::ReadData",
            "snippet": "filepos_t EbmlMaster::ReadData(IOCallback & input, ScopeMode /* ReadFully */)\n{\n  input.setFilePointer(GetSize(), seek_current);\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "170-174"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlMaster::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlMaster::ReadData",
            "snippet": "filepos_t EbmlMaster::ReadData(IOCallback & input, ScopeMode /* ReadFully */)\n{\n  input.setFilePointer(GetSize(), seek_current);\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "170-174"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlMaster::WriteHead",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
    "lines": "161-165",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::WriteHead"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::WriteHead",
            "snippet": "filepos_t EbmlMaster::WriteHead(IOCallback & output, int nSizeLength, bool bWithDefault)\n{\n  SetSizeLength(nSizeLength);\n  return RenderHead(output, false, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "161-165"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlMaster::UpdateSize",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
    "lines": "130-159",
    "num_chains": 10,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::WriteHead",
          "EbmlElement::RenderHead",
          "EbmlMaster::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::WriteHead",
            "snippet": "filepos_t EbmlMaster::WriteHead(IOCallback & output, int nSizeLength, bool bWithDefault)\n{\n  SetSizeLength(nSizeLength);\n  return RenderHead(output, false, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "161-165"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlMaster::UpdateSize",
            "snippet": "uint64 EbmlMaster::UpdateSize(bool bWithDefault, bool bForceRender)\n{\n  SetSize_(0);\n\n  if (!IsFiniteSize())\n    return (0-1);\n\n  if (!bForceRender) {\n    assert(CheckMandatory());\n    }\n\n  size_t Index;\n\n  for (Index = 0; Index < ElementList.size(); Index++) {\n    if (!bWithDefault && (ElementList[Index])->IsDefaultValue())\n      continue;\n    (ElementList[Index])->UpdateSize(bWithDefault, bForceRender);\n    uint64 SizeToAdd = (ElementList[Index])->ElementSize(bWithDefault);\n#if defined(LIBEBML_DEBUG)\n    if (static_cast<int64>(SizeToAdd) == (0-1))\n      return (0-1);\n#endif // LIBEBML_DEBUG\n",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "130-159"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlMaster::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlMaster::UpdateSize",
            "snippet": "uint64 EbmlMaster::UpdateSize(bool bWithDefault, bool bForceRender)\n{\n  SetSize_(0);\n\n  if (!IsFiniteSize())\n    return (0-1);\n\n  if (!bForceRender) {\n    assert(CheckMandatory());\n    }\n\n  size_t Index;\n\n  for (Index = 0; Index < ElementList.size(); Index++) {\n    if (!bWithDefault && (ElementList[Index])->IsDefaultValue())\n      continue;\n    (ElementList[Index])->UpdateSize(bWithDefault, bForceRender);\n    uint64 SizeToAdd = (ElementList[Index])->ElementSize(bWithDefault);\n#if defined(LIBEBML_DEBUG)\n    if (static_cast<int64>(SizeToAdd) == (0-1))\n      return (0-1);\n#endif // LIBEBML_DEBUG\n",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "130-159"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlMaster::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlMaster::UpdateSize",
            "snippet": "uint64 EbmlMaster::UpdateSize(bool bWithDefault, bool bForceRender)\n{\n  SetSize_(0);\n\n  if (!IsFiniteSize())\n    return (0-1);\n\n  if (!bForceRender) {\n    assert(CheckMandatory());\n    }\n\n  size_t Index;\n\n  for (Index = 0; Index < ElementList.size(); Index++) {\n    if (!bWithDefault && (ElementList[Index])->IsDefaultValue())\n      continue;\n    (ElementList[Index])->UpdateSize(bWithDefault, bForceRender);\n    uint64 SizeToAdd = (ElementList[Index])->ElementSize(bWithDefault);\n#if defined(LIBEBML_DEBUG)\n    if (static_cast<int64>(SizeToAdd) == (0-1))\n      return (0-1);\n#endif // LIBEBML_DEBUG\n",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "130-159"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlMaster::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlMaster::UpdateSize",
            "snippet": "uint64 EbmlMaster::UpdateSize(bool bWithDefault, bool bForceRender)\n{\n  SetSize_(0);\n\n  if (!IsFiniteSize())\n    return (0-1);\n\n  if (!bForceRender) {\n    assert(CheckMandatory());\n    }\n\n  size_t Index;\n\n  for (Index = 0; Index < ElementList.size(); Index++) {\n    if (!bWithDefault && (ElementList[Index])->IsDefaultValue())\n      continue;\n    (ElementList[Index])->UpdateSize(bWithDefault, bForceRender);\n    uint64 SizeToAdd = (ElementList[Index])->ElementSize(bWithDefault);\n#if defined(LIBEBML_DEBUG)\n    if (static_cast<int64>(SizeToAdd) == (0-1))\n      return (0-1);\n#endif // LIBEBML_DEBUG\n",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "130-159"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlElement::VoidMe",
          "EbmlVoid::Overwrite",
          "EbmlElement::RenderHead",
          "EbmlMaster::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlElement::VoidMe",
            "snippet": "uint64 EbmlElement::VoidMe(IOCallback & output, bool bWithDefault)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  EbmlVoid Dummy;\n  return Dummy.Overwrite(*this, output, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "694-702"
          },
          {
            "qualified_name": "EbmlVoid::Overwrite",
            "snippet": "uint64 EbmlVoid::Overwrite(const EbmlElement & EltToVoid, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  //  EltToVoid.UpdateSize(bWithDefault);\n  if (EltToVoid.GetElementPosition() == 0) {\n    // this element has never been written\n    return 0;\n  }\n  if (EltToVoid.GetSize() + EltToVoid.HeadSize() <2) {\n    // the element can't be written here !\n    return 0;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePointer(EltToVoid.GetElementPosition());\n\n  // compute the size of the voided data based on the original one\n  SetSize(EltToVoid.GetSize() + E",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "99-135"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlMaster::UpdateSize",
            "snippet": "uint64 EbmlMaster::UpdateSize(bool bWithDefault, bool bForceRender)\n{\n  SetSize_(0);\n\n  if (!IsFiniteSize())\n    return (0-1);\n\n  if (!bForceRender) {\n    assert(CheckMandatory());\n    }\n\n  size_t Index;\n\n  for (Index = 0; Index < ElementList.size(); Index++) {\n    if (!bWithDefault && (ElementList[Index])->IsDefaultValue())\n      continue;\n    (ElementList[Index])->UpdateSize(bWithDefault, bForceRender);\n    uint64 SizeToAdd = (ElementList[Index])->ElementSize(bWithDefault);\n#if defined(LIBEBML_DEBUG)\n    if (static_cast<int64>(SizeToAdd) == (0-1))\n      return (0-1);\n#endif // LIBEBML_DEBUG\n",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "130-159"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::RenderHead",
          "EbmlMaster::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlMaster::UpdateSize",
            "snippet": "uint64 EbmlMaster::UpdateSize(bool bWithDefault, bool bForceRender)\n{\n  SetSize_(0);\n\n  if (!IsFiniteSize())\n    return (0-1);\n\n  if (!bForceRender) {\n    assert(CheckMandatory());\n    }\n\n  size_t Index;\n\n  for (Index = 0; Index < ElementList.size(); Index++) {\n    if (!bWithDefault && (ElementList[Index])->IsDefaultValue())\n      continue;\n    (ElementList[Index])->UpdateSize(bWithDefault, bForceRender);\n    uint64 SizeToAdd = (ElementList[Index])->ElementSize(bWithDefault);\n#if defined(LIBEBML_DEBUG)\n    if (static_cast<int64>(SizeToAdd) == (0-1))\n      return (0-1);\n#endif // LIBEBML_DEBUG\n",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "130-159"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlMaster::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlMaster::UpdateSize",
            "snippet": "uint64 EbmlMaster::UpdateSize(bool bWithDefault, bool bForceRender)\n{\n  SetSize_(0);\n\n  if (!IsFiniteSize())\n    return (0-1);\n\n  if (!bForceRender) {\n    assert(CheckMandatory());\n    }\n\n  size_t Index;\n\n  for (Index = 0; Index < ElementList.size(); Index++) {\n    if (!bWithDefault && (ElementList[Index])->IsDefaultValue())\n      continue;\n    (ElementList[Index])->UpdateSize(bWithDefault, bForceRender);\n    uint64 SizeToAdd = (ElementList[Index])->ElementSize(bWithDefault);\n#if defined(LIBEBML_DEBUG)\n    if (static_cast<int64>(SizeToAdd) == (0-1))\n      return (0-1);\n#endif // LIBEBML_DEBUG\n",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "130-159"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlMaster::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlMaster::UpdateSize",
            "snippet": "uint64 EbmlMaster::UpdateSize(bool bWithDefault, bool bForceRender)\n{\n  SetSize_(0);\n\n  if (!IsFiniteSize())\n    return (0-1);\n\n  if (!bForceRender) {\n    assert(CheckMandatory());\n    }\n\n  size_t Index;\n\n  for (Index = 0; Index < ElementList.size(); Index++) {\n    if (!bWithDefault && (ElementList[Index])->IsDefaultValue())\n      continue;\n    (ElementList[Index])->UpdateSize(bWithDefault, bForceRender);\n    uint64 SizeToAdd = (ElementList[Index])->ElementSize(bWithDefault);\n#if defined(LIBEBML_DEBUG)\n    if (static_cast<int64>(SizeToAdd) == (0-1))\n      return (0-1);\n#endif // LIBEBML_DEBUG\n",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "130-159"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlMaster::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlMaster::UpdateSize",
            "snippet": "uint64 EbmlMaster::UpdateSize(bool bWithDefault, bool bForceRender)\n{\n  SetSize_(0);\n\n  if (!IsFiniteSize())\n    return (0-1);\n\n  if (!bForceRender) {\n    assert(CheckMandatory());\n    }\n\n  size_t Index;\n\n  for (Index = 0; Index < ElementList.size(); Index++) {\n    if (!bWithDefault && (ElementList[Index])->IsDefaultValue())\n      continue;\n    (ElementList[Index])->UpdateSize(bWithDefault, bForceRender);\n    uint64 SizeToAdd = (ElementList[Index])->ElementSize(bWithDefault);\n#if defined(LIBEBML_DEBUG)\n    if (static_cast<int64>(SizeToAdd) == (0-1))\n      return (0-1);\n#endif // LIBEBML_DEBUG\n",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "130-159"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlMaster::UpdateSize"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlMaster::UpdateSize",
            "snippet": "uint64 EbmlMaster::UpdateSize(bool bWithDefault, bool bForceRender)\n{\n  SetSize_(0);\n\n  if (!IsFiniteSize())\n    return (0-1);\n\n  if (!bForceRender) {\n    assert(CheckMandatory());\n    }\n\n  size_t Index;\n\n  for (Index = 0; Index < ElementList.size(); Index++) {\n    if (!bWithDefault && (ElementList[Index])->IsDefaultValue())\n      continue;\n    (ElementList[Index])->UpdateSize(bWithDefault, bForceRender);\n    uint64 SizeToAdd = (ElementList[Index])->ElementSize(bWithDefault);\n#if defined(LIBEBML_DEBUG)\n    if (static_cast<int64>(SizeToAdd) == (0-1))\n      return (0-1);\n#endif // LIBEBML_DEBUG\n",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "130-159"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlMaster::PushElement",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
    "lines": "124-128",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::ProcessMandatory",
          "EbmlMaster::PushElement"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::ProcessMandatory",
            "snippet": "bool EbmlMaster::ProcessMandatory()\n{\n  if (EBML_CTX_SIZE(Context) == 0)\n  {\n    return true;\n  }\n\n  assert(Context.GetSize() != 0);\n\n  unsigned int EltIdx;\n  for (EltIdx = 0; EltIdx < EBML_CTX_SIZE(Context); EltIdx++) {\n    if (EBML_CTX_IDX(Context,EltIdx).IsMandatory() && EBML_CTX_IDX(Context,EltIdx).IsUnique()) {\n//      assert(EBML_CTX_IDX(Context,EltIdx).Create != NULL);\n            PushElement(EBML_SEM_CREATE(EBML_CTX_IDX(Context,EltIdx)));\n    }\n  }\n  return true;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "180-197"
          },
          {
            "qualified_name": "EbmlMaster::PushElement",
            "snippet": "bool EbmlMaster::PushElement(EbmlElement & element)\n{\n  ElementList.push_back(&element);\n  return true;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "124-128"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlMaster::RenderData",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
    "lines": "90-119",
    "num_chains": 3,
    "chains": [
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlMaster::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlMaster::RenderData",
            "snippet": "filepos_t EbmlMaster::RenderData(IOCallback & output, bool bForceRender, bool bWithDefault)\n{\n  filepos_t Result = 0;\n  size_t Index;\n\n  if (!bForceRender) {\n    assert(CheckMandatory());\n  }\n\n  if (!bChecksumUsed) { // old school\n    for (Index = 0; Index < ElementList.size(); Index++) {\n      if (!bWithDefault && (ElementList[Index])->IsDefaultValue())\n        continue;\n      Result += (ElementList[Index])->Render(output, bWithDefault, false ,bForceRender);\n    }\n  } else { // new school\n    MemIOCallback TmpBuf(GetSize() - 6);\n    for (Index = 0; Index < ElementList.size(); Index++) {\n     ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "90-119"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlMaster::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlMaster::RenderData",
            "snippet": "filepos_t EbmlMaster::RenderData(IOCallback & output, bool bForceRender, bool bWithDefault)\n{\n  filepos_t Result = 0;\n  size_t Index;\n\n  if (!bForceRender) {\n    assert(CheckMandatory());\n  }\n\n  if (!bChecksumUsed) { // old school\n    for (Index = 0; Index < ElementList.size(); Index++) {\n      if (!bWithDefault && (ElementList[Index])->IsDefaultValue())\n        continue;\n      Result += (ElementList[Index])->Render(output, bWithDefault, false ,bForceRender);\n    }\n  } else { // new school\n    MemIOCallback TmpBuf(GetSize() - 6);\n    for (Index = 0; Index < ElementList.size(); Index++) {\n     ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "90-119"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlMaster::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlMaster::RenderData",
            "snippet": "filepos_t EbmlMaster::RenderData(IOCallback & output, bool bForceRender, bool bWithDefault)\n{\n  filepos_t Result = 0;\n  size_t Index;\n\n  if (!bForceRender) {\n    assert(CheckMandatory());\n  }\n\n  if (!bChecksumUsed) { // old school\n    for (Index = 0; Index < ElementList.size(); Index++) {\n      if (!bWithDefault && (ElementList[Index])->IsDefaultValue())\n        continue;\n      Result += (ElementList[Index])->Render(output, bWithDefault, false ,bForceRender);\n    }\n  } else { // new school\n    MemIOCallback TmpBuf(GetSize() - 6);\n    for (Index = 0; Index < ElementList.size(); Index++) {\n     ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "90-119"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlMaster::~EbmlMaster",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
    "lines": "73-84",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::~EbmlMaster"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::~EbmlMaster",
            "snippet": "EbmlMaster::~EbmlMaster()\n{\n  assert(!IsLocked()); // you're trying to delete a locked element !!!\n\n  size_t Index;\n\n  for (Index = 0; Index < ElementList.size(); Index++) {\n    if (!(*ElementList[Index]).IsLocked())  {\n      delete ElementList[Index];\n    }\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "73-84"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlMaster::EbmlMaster",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
    "lines": "55-71",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::EbmlMaster"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::EbmlMaster",
            "snippet": "EbmlMaster::EbmlMaster(const EbmlMaster & ElementToClone)\n :EbmlElement(ElementToClone)\n ,ElementList(ElementToClone.ListSize())\n ,Context(ElementToClone.Context)\n ,bChecksumUsed(ElementToClone.bChecksumUsed)\n ,Checksum(ElementToClone.Checksum)\n{\n  // add a clone of the list\n  std::vector<EbmlElement *>::const_iterator Itr = ElementToClone.ElementList.begin();\n  std::vector<EbmlElement *>::iterator myItr = ElementList.begin();\n  while (Itr != ElementToClone.ElementList.end())\n  {\n    *myItr = (*Itr)->Clone();\n    ++Itr; ++myItr;\n  }\n\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "55-71"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlElement::VoidMe",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
    "lines": "694-702",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::VoidMe"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlElement::VoidMe",
            "snippet": "uint64 EbmlElement::VoidMe(IOCallback & output, bool bWithDefault)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  EbmlVoid Dummy;\n  return Dummy.Overwrite(*this, output, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "694-702"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlElement::OverwriteHead",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
    "lines": "681-692",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::OverwriteHead"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlElement::OverwriteHead",
            "snippet": "filepos_t EbmlElement::OverwriteHead(IOCallback & output, bool bKeepPosition)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n  output.setFilePointer(GetElementPosition());\n  filepos_t Result = MakeRenderHead(output, bKeepPosition);\n  output.setFilePointer(CurrentPosition);\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "681-692"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlElement::ForceSize",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
    "lines": "661-679",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::ForceSize"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlElement::ForceSize",
            "snippet": "bool EbmlElement::ForceSize(uint64 NewSize)\n{\n  if (bSizeIsFinite) {\n    return false;\n  }\n\n  int OldSizeLen = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  uint64 OldSize = Size;\n\n  Size = NewSize;\n\n  if (CodedSizeLength(Size, SizeLength, bSizeIsFinite) == OldSizeLen) {\n    bSizeIsFinite = true;\n    return true;\n  }\n  Size = OldSize;\n\n  return false;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "661-679"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlElement::Read",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
    "lines": "656-659",
    "num_chains": 10,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlElement::Read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlElement::Read",
            "snippet": "void EbmlElement::Read(EbmlStream & inDataStream, const EbmlSemanticContext & /* Context */, int & /* UpperEltFound */, EbmlElement * & /* FoundElt */, bool /* AllowDummyElt */, ScopeMode ReadFully)\n{\n  ReadData(inDataStream.I_O(), ReadFully);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "656-659"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlElement::Read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlElement::Read",
            "snippet": "void EbmlElement::Read(EbmlStream & inDataStream, const EbmlSemanticContext & /* Context */, int & /* UpperEltFound */, EbmlElement * & /* FoundElt */, bool /* AllowDummyElt */, ScopeMode ReadFully)\n{\n  ReadData(inDataStream.I_O(), ReadFully);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "656-659"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlElement::Read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlElement::Read",
            "snippet": "void EbmlElement::Read(EbmlStream & inDataStream, const EbmlSemanticContext & /* Context */, int & /* UpperEltFound */, EbmlElement * & /* FoundElt */, bool /* AllowDummyElt */, ScopeMode ReadFully)\n{\n  ReadData(inDataStream.I_O(), ReadFully);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "656-659"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlElement::Read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlElement::Read",
            "snippet": "void EbmlElement::Read(EbmlStream & inDataStream, const EbmlSemanticContext & /* Context */, int & /* UpperEltFound */, EbmlElement * & /* FoundElt */, bool /* AllowDummyElt */, ScopeMode ReadFully)\n{\n  ReadData(inDataStream.I_O(), ReadFully);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "656-659"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlElement::Read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlElement::Read",
            "snippet": "void EbmlElement::Read(EbmlStream & inDataStream, const EbmlSemanticContext & /* Context */, int & /* UpperEltFound */, EbmlElement * & /* FoundElt */, bool /* AllowDummyElt */, ScopeMode ReadFully)\n{\n  ReadData(inDataStream.I_O(), ReadFully);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "656-659"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE",
          "EbmlElement::Read"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "EbmlElement::Read",
            "snippet": "void EbmlElement::Read(EbmlStream & inDataStream, const EbmlSemanticContext & /* Context */, int & /* UpperEltFound */, EbmlElement * & /* FoundElt */, bool /* AllowDummyElt */, ScopeMode ReadFully)\n{\n  ReadData(inDataStream.I_O(), ReadFully);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "656-659"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE",
          "EbmlElement::Read"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "EbmlElement::Read",
            "snippet": "void EbmlElement::Read(EbmlStream & inDataStream, const EbmlSemanticContext & /* Context */, int & /* UpperEltFound */, EbmlElement * & /* FoundElt */, bool /* AllowDummyElt */, ScopeMode ReadFully)\n{\n  ReadData(inDataStream.I_O(), ReadFully);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "656-659"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE",
          "EbmlElement::Read"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "EbmlElement::Read",
            "snippet": "void EbmlElement::Read(EbmlStream & inDataStream, const EbmlSemanticContext & /* Context */, int & /* UpperEltFound */, EbmlElement * & /* FoundElt */, bool /* AllowDummyElt */, ScopeMode ReadFully)\n{\n  ReadData(inDataStream.I_O(), ReadFully);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "656-659"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE",
          "EbmlElement::Read"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "EbmlElement::Read",
            "snippet": "void EbmlElement::Read(EbmlStream & inDataStream, const EbmlSemanticContext & /* Context */, int & /* UpperEltFound */, EbmlElement * & /* FoundElt */, bool /* AllowDummyElt */, ScopeMode ReadFully)\n{\n  ReadData(inDataStream.I_O(), ReadFully);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "656-659"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE",
          "EbmlElement::Read"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "EbmlElement::Read",
            "snippet": "void EbmlElement::Read(EbmlStream & inDataStream, const EbmlSemanticContext & /* Context */, int & /* UpperEltFound */, EbmlElement * & /* FoundElt */, bool /* AllowDummyElt */, ScopeMode ReadFully)\n{\n  ReadData(inDataStream.I_O(), ReadFully);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "656-659"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlElement::CompareElements",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
    "lines": "648-654",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::CompareElements"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlElement::CompareElements",
            "snippet": "bool EbmlElement::CompareElements(const EbmlElement *A, const EbmlElement *B)\n{\n  if (EbmlId(*A) == EbmlId(*B))\n    return A->IsSmallerThan(B);\n  else\n    return false;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "648-654"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlElement::IsSmallerThan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
    "lines": "643-646",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::CompareElements",
          "EbmlElement::IsSmallerThan"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlElement::CompareElements",
            "snippet": "bool EbmlElement::CompareElements(const EbmlElement *A, const EbmlElement *B)\n{\n  if (EbmlId(*A) == EbmlId(*B))\n    return A->IsSmallerThan(B);\n  else\n    return false;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "648-654"
          },
          {
            "qualified_name": "EbmlElement::IsSmallerThan",
            "snippet": "bool EbmlElement::IsSmallerThan(const EbmlElement *Cmp) const\n{\n  return EbmlId(*this) == EbmlId(*Cmp);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "643-646"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlElement::ElementSize",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
    "lines": "636-641",
    "num_chains": 6,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::WriteHead",
          "EbmlElement::RenderHead",
          "EbmlUnicodeString::UpdateSize",
          "EbmlElement::ElementSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::WriteHead",
            "snippet": "filepos_t EbmlMaster::WriteHead(IOCallback & output, int nSizeLength, bool bWithDefault)\n{\n  SetSizeLength(nSizeLength);\n  return RenderHead(output, false, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "161-165"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          },
          {
            "qualified_name": "EbmlElement::ElementSize",
            "snippet": "uint64 EbmlElement::ElementSize(bool bWithDefault) const\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0; // won't be saved\n  return Size + EBML_ID_LENGTH((const EbmlId&)*this) + CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "636-641"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::RenderHead",
          "EbmlUnicodeString::UpdateSize",
          "EbmlElement::ElementSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          },
          {
            "qualified_name": "EbmlElement::ElementSize",
            "snippet": "uint64 EbmlElement::ElementSize(bool bWithDefault) const\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0; // won't be saved\n  return Size + EBML_ID_LENGTH((const EbmlId&)*this) + CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "636-641"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlUnicodeString::UpdateSize",
          "EbmlElement::ElementSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          },
          {
            "qualified_name": "EbmlElement::ElementSize",
            "snippet": "uint64 EbmlElement::ElementSize(bool bWithDefault) const\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0; // won't be saved\n  return Size + EBML_ID_LENGTH((const EbmlId&)*this) + CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "636-641"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlUnicodeString::UpdateSize",
          "EbmlElement::ElementSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          },
          {
            "qualified_name": "EbmlElement::ElementSize",
            "snippet": "uint64 EbmlElement::ElementSize(bool bWithDefault) const\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0; // won't be saved\n  return Size + EBML_ID_LENGTH((const EbmlId&)*this) + CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "636-641"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlUnicodeString::UpdateSize",
          "EbmlElement::ElementSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          },
          {
            "qualified_name": "EbmlElement::ElementSize",
            "snippet": "uint64 EbmlElement::ElementSize(bool bWithDefault) const\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0; // won't be saved\n  return Size + EBML_ID_LENGTH((const EbmlId&)*this) + CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "636-641"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlUnicodeString::UpdateSize",
          "EbmlElement::ElementSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          },
          {
            "qualified_name": "EbmlElement::ElementSize",
            "snippet": "uint64 EbmlElement::ElementSize(bool bWithDefault) const\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0; // won't be saved\n  return Size + EBML_ID_LENGTH((const EbmlId&)*this) + CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "636-641"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlElement::MakeRenderHead",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
    "lines": "615-634",
    "num_chains": 7,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::OverwriteHead",
          "EbmlElement::MakeRenderHead"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlElement::OverwriteHead",
            "snippet": "filepos_t EbmlElement::OverwriteHead(IOCallback & output, bool bKeepPosition)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n  output.setFilePointer(GetElementPosition());\n  filepos_t Result = MakeRenderHead(output, bKeepPosition);\n  output.setFilePointer(CurrentPosition);\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "681-692"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlMaster::WriteHead",
          "EbmlElement::RenderHead",
          "EbmlElement::MakeRenderHead"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::WriteHead",
            "snippet": "filepos_t EbmlMaster::WriteHead(IOCallback & output, int nSizeLength, bool bWithDefault)\n{\n  SetSizeLength(nSizeLength);\n  return RenderHead(output, false, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "161-165"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlElement::MakeRenderHead"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlElement::MakeRenderHead"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlElement::MakeRenderHead"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlElement::VoidMe",
          "EbmlVoid::Overwrite",
          "EbmlElement::RenderHead",
          "EbmlElement::MakeRenderHead"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlElement::VoidMe",
            "snippet": "uint64 EbmlElement::VoidMe(IOCallback & output, bool bWithDefault)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  EbmlVoid Dummy;\n  return Dummy.Overwrite(*this, output, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "694-702"
          },
          {
            "qualified_name": "EbmlVoid::Overwrite",
            "snippet": "uint64 EbmlVoid::Overwrite(const EbmlElement & EltToVoid, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  //  EltToVoid.UpdateSize(bWithDefault);\n  if (EltToVoid.GetElementPosition() == 0) {\n    // this element has never been written\n    return 0;\n  }\n  if (EltToVoid.GetSize() + EltToVoid.HeadSize() <2) {\n    // the element can't be written here !\n    return 0;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePointer(EltToVoid.GetElementPosition());\n\n  // compute the size of the voided data based on the original one\n  SetSize(EltToVoid.GetSize() + E",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "99-135"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::RenderHead",
          "EbmlElement::MakeRenderHead"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlElement::RenderHead",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
    "lines": "605-613",
    "num_chains": 6,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::WriteHead",
          "EbmlElement::RenderHead"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::WriteHead",
            "snippet": "filepos_t EbmlMaster::WriteHead(IOCallback & output, int nSizeLength, bool bWithDefault)\n{\n  SetSizeLength(nSizeLength);\n  return RenderHead(output, false, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "161-165"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlElement::RenderHead"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlElement::RenderHead"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlElement::RenderHead"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlElement::VoidMe",
          "EbmlVoid::Overwrite",
          "EbmlElement::RenderHead"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlElement::VoidMe",
            "snippet": "uint64 EbmlElement::VoidMe(IOCallback & output, bool bWithDefault)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  EbmlVoid Dummy;\n  return Dummy.Overwrite(*this, output, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "694-702"
          },
          {
            "qualified_name": "EbmlVoid::Overwrite",
            "snippet": "uint64 EbmlVoid::Overwrite(const EbmlElement & EltToVoid, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  //  EltToVoid.UpdateSize(bWithDefault);\n  if (EltToVoid.GetElementPosition() == 0) {\n    // this element has never been written\n    return 0;\n  }\n  if (EltToVoid.GetSize() + EltToVoid.HeadSize() <2) {\n    // the element can't be written here !\n    return 0;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePointer(EltToVoid.GetElementPosition());\n\n  // compute the size of the voided data based on the original one\n  SetSize(EltToVoid.GetSize() + E",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "99-135"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::RenderHead"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlElement::Render",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
    "lines": "580-598",
    "num_chains": 3,
    "chains": [
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlElement::~EbmlElement",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
    "lines": "250-253",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::~EbmlElement"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlElement::~EbmlElement",
            "snippet": "EbmlElement::~EbmlElement()\n{\n  assert(!bLocked);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "250-253"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlElement::EbmlElement",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
    "lines": "237-248",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::EbmlElement"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlElement::EbmlElement",
            "snippet": "EbmlElement::EbmlElement(uint64 aDefaultSize, bool bValueSet)\n  :DefaultSize(aDefaultSize)\n  ,SizeLength(0) ///< write optimal size by default\n  ,bSizeIsFinite(true)\n  ,ElementPosition(0)\n  ,SizePosition(0)\n  ,bValueIsSet(bValueSet)\n  ,DefaultIsSet(false)\n  ,bLocked(false)\n{\n  Size = DefaultSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "224-235"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlElement::EbmlElement",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
    "lines": "224-235",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::EbmlElement"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlElement::EbmlElement",
            "snippet": "EbmlElement::EbmlElement(uint64 aDefaultSize, bool bValueSet)\n  :DefaultSize(aDefaultSize)\n  ,SizeLength(0) ///< write optimal size by default\n  ,bSizeIsFinite(true)\n  ,ElementPosition(0)\n  ,SizePosition(0)\n  ,bValueIsSet(bValueSet)\n  ,DefaultIsSet(false)\n  ,bLocked(false)\n{\n  Size = DefaultSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "224-235"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlCallbacks::EbmlCallbacks",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
    "lines": "205-212",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlCallbacks::EbmlCallbacks"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlCallbacks::EbmlCallbacks",
            "snippet": "EbmlCallbacks::EbmlCallbacks(EbmlElement & (*Creator)(), const EbmlId & aGlobalId, const char * aDebugName, const EbmlSemanticContext & aContext)\n  :Create(Creator)\n  ,GlobalId(aGlobalId)\n  ,DebugName(aDebugName)\n  ,Context(aContext)\n{\n  assert((Create!=NULL) || !strcmp(aDebugName, \"DummyElement\"));\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "205-212"
          }
        ]
      }
    ]
  },
  {
    "target_function": "ReadCodedSizeSignedValue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
    "lines": "180-202",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "ReadCodedSizeSignedValue"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "ReadCodedSizeSignedValue",
            "snippet": "int64 ReadCodedSizeSignedValue(const binary * InBuffer, uint32 & BufferSize, uint64 & SizeUnknown)\n{\n  int64 Result = ReadCodedSizeValue(InBuffer, BufferSize, SizeUnknown);\n\n  if (BufferSize != 0) {\n    switch (BufferSize) {\n      case 1:\n        Result -= 63;\n        break;\n      case 2:\n        Result -= 8191;\n        break;\n      case 3:\n        Result -= 1048575L;\n        break;\n      case 4:\n        Result -= 134217727L;\n        break;\n    }\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "180-202"
          }
        ]
      }
    ]
  },
  {
    "target_function": "ReadCodedSizeValue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
    "lines": "139-178",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "ReadCodedSizeSignedValue",
          "ReadCodedSizeValue"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "ReadCodedSizeSignedValue",
            "snippet": "int64 ReadCodedSizeSignedValue(const binary * InBuffer, uint32 & BufferSize, uint64 & SizeUnknown)\n{\n  int64 Result = ReadCodedSizeValue(InBuffer, BufferSize, SizeUnknown);\n\n  if (BufferSize != 0) {\n    switch (BufferSize) {\n      case 1:\n        Result -= 63;\n        break;\n      case 2:\n        Result -= 8191;\n        break;\n      case 3:\n        Result -= 1048575L;\n        break;\n      case 4:\n        Result -= 134217727L;\n        break;\n    }\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "180-202"
          },
          {
            "qualified_name": "ReadCodedSizeValue",
            "snippet": "uint64 ReadCodedSizeValue(const binary * InBuffer, uint32 & BufferSize, uint64 & SizeUnknown)\n{\n  binary SizeBitMask = 1 << 7;\n  uint64 Result = 0x7F;\n  unsigned int SizeIdx, PossibleSizeLength = 0;\n  binary PossibleSize[8];\n  memset(PossibleSize, 0, 8);\n\n  SizeUnknown = 0x7F; // the last bit is discarded when computing the size\n  for (SizeIdx = 0; SizeIdx < BufferSize && SizeIdx < 8; SizeIdx++) {\n    if (InBuffer[0] & (SizeBitMask >> SizeIdx)) {\n      // ID found\n      PossibleSizeLength = SizeIdx + 1;\n      SizeBitMask >>= SizeIdx;\n      for (SizeIdx = 0; SizeIdx < PossibleSizeLength; SizeId",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "139-178"
          }
        ]
      }
    ]
  },
  {
    "target_function": "CodedValueLengthSigned",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
    "lines": "125-137",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "CodedValueLengthSigned"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "CodedValueLengthSigned",
            "snippet": "int CodedValueLengthSigned(int64 Length, int CodedSize, binary * OutBuffer)\n{\n  if (Length > -64 && Length < 64) // 2^6\n    Length += 63;\n  else if (Length > -8192 && Length < 8192) // 2^13\n    Length += 8191;\n  else if (Length > -1048576L && Length < 1048576L) // 2^20\n    Length += 1048575L;\n  else if (Length > -134217728L && Length < 134217728L) // 2^27\n    Length += 134217727L;\n\n  return CodedValueLength(Length, CodedSize, OutBuffer);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "125-137"
          }
        ]
      }
    ]
  },
  {
    "target_function": "CodedValueLength",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
    "lines": "111-123",
    "num_chains": 4,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::OverwriteHead",
          "EbmlElement::MakeRenderHead",
          "CodedValueLength"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlElement::OverwriteHead",
            "snippet": "filepos_t EbmlElement::OverwriteHead(IOCallback & output, bool bKeepPosition)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n  output.setFilePointer(GetElementPosition());\n  filepos_t Result = MakeRenderHead(output, bKeepPosition);\n  output.setFilePointer(CurrentPosition);\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "681-692"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          },
          {
            "qualified_name": "CodedValueLength",
            "snippet": "int CodedValueLength(uint64 Length, int CodedSize, binary * OutBuffer)\n{\n  int _SizeMask = 0xFF;\n  OutBuffer[0] = 1 << (8 - CodedSize);\n  for (int i=1; i<CodedSize; i++) {\n    OutBuffer[CodedSize-i] = Length & 0xFF;\n    Length >>= 8;\n    _SizeMask >>= 1;\n  }\n  // first one use a OR with the \"EBML size head\"\n  OutBuffer[0] |= Length & 0xFF & _SizeMask;\n  return CodedSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "111-123"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlMaster::WriteHead",
          "EbmlElement::RenderHead",
          "EbmlElement::MakeRenderHead",
          "CodedValueLength"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::WriteHead",
            "snippet": "filepos_t EbmlMaster::WriteHead(IOCallback & output, int nSizeLength, bool bWithDefault)\n{\n  SetSizeLength(nSizeLength);\n  return RenderHead(output, false, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "161-165"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          },
          {
            "qualified_name": "CodedValueLength",
            "snippet": "int CodedValueLength(uint64 Length, int CodedSize, binary * OutBuffer)\n{\n  int _SizeMask = 0xFF;\n  OutBuffer[0] = 1 << (8 - CodedSize);\n  for (int i=1; i<CodedSize; i++) {\n    OutBuffer[CodedSize-i] = Length & 0xFF;\n    Length >>= 8;\n    _SizeMask >>= 1;\n  }\n  // first one use a OR with the \"EBML size head\"\n  OutBuffer[0] |= Length & 0xFF & _SizeMask;\n  return CodedSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "111-123"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::RenderHead",
          "EbmlElement::MakeRenderHead",
          "CodedValueLength"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          },
          {
            "qualified_name": "CodedValueLength",
            "snippet": "int CodedValueLength(uint64 Length, int CodedSize, binary * OutBuffer)\n{\n  int _SizeMask = 0xFF;\n  OutBuffer[0] = 1 << (8 - CodedSize);\n  for (int i=1; i<CodedSize; i++) {\n    OutBuffer[CodedSize-i] = Length & 0xFF;\n    Length >>= 8;\n    _SizeMask >>= 1;\n  }\n  // first one use a OR with the \"EBML size head\"\n  OutBuffer[0] |= Length & 0xFF & _SizeMask;\n  return CodedSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "111-123"
          }
        ]
      },
      {
        "call_sequence": [
          "CodedValueLengthSigned",
          "CodedValueLength"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "CodedValueLengthSigned",
            "snippet": "int CodedValueLengthSigned(int64 Length, int CodedSize, binary * OutBuffer)\n{\n  if (Length > -64 && Length < 64) // 2^6\n    Length += 63;\n  else if (Length > -8192 && Length < 8192) // 2^13\n    Length += 8191;\n  else if (Length > -1048576L && Length < 1048576L) // 2^20\n    Length += 1048575L;\n  else if (Length > -134217728L && Length < 134217728L) // 2^27\n    Length += 134217727L;\n\n  return CodedValueLength(Length, CodedSize, OutBuffer);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "125-137"
          },
          {
            "qualified_name": "CodedValueLength",
            "snippet": "int CodedValueLength(uint64 Length, int CodedSize, binary * OutBuffer)\n{\n  int _SizeMask = 0xFF;\n  OutBuffer[0] = 1 << (8 - CodedSize);\n  for (int i=1; i<CodedSize; i++) {\n    OutBuffer[CodedSize-i] = Length & 0xFF;\n    Length >>= 8;\n    _SizeMask >>= 1;\n  }\n  // first one use a OR with the \"EBML size head\"\n  OutBuffer[0] |= Length & 0xFF & _SizeMask;\n  return CodedSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "111-123"
          }
        ]
      }
    ]
  },
  {
    "target_function": "CodedSizeLengthSigned",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
    "lines": "88-109",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "CodedSizeLengthSigned"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "CodedSizeLengthSigned",
            "snippet": "int CodedSizeLengthSigned(int64 Length, unsigned int SizeLength)\n{\n  unsigned int CodedSize;\n  // prepare the head of the size (000...01xxxxxx)\n  // optimal size\n  if (Length > -64 && Length < 64) // 2^6\n    CodedSize = 1;\n  else if (Length > -8192 && Length < 8192) // 2^13\n    CodedSize = 2;\n  else if (Length > -1048576L && Length < 1048576L) // 2^20\n    CodedSize = 3;\n  else if (Length > -134217728L && Length < 134217728L) // 2^27\n    CodedSize = 4;\n  else CodedSize = 5;\n\n  if (SizeLength > 0 && CodedSize < SizeLength) {\n    // defined size\n    CodedSize = SizeLength;\n  }\n\n  return CodedSize",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "88-109"
          }
        ]
      }
    ]
  },
  {
    "target_function": "CodedSizeLength",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
    "lines": "45-83",
    "num_chains": 7,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::ForceSize",
          "CodedSizeLength"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlElement::ForceSize",
            "snippet": "bool EbmlElement::ForceSize(uint64 NewSize)\n{\n  if (bSizeIsFinite) {\n    return false;\n  }\n\n  int OldSizeLen = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  uint64 OldSize = Size;\n\n  Size = NewSize;\n\n  if (CodedSizeLength(Size, SizeLength, bSizeIsFinite) == OldSizeLen) {\n    bSizeIsFinite = true;\n    return true;\n  }\n  Size = OldSize;\n\n  return false;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "661-679"
          },
          {
            "qualified_name": "CodedSizeLength",
            "snippet": "START_LIBEBML_NAMESPACE\n\n/*!\n  \\todo handle more than CodedSize of 5\n*/\nint CodedSizeLength(uint64 Length, unsigned int SizeLength, bool bSizeFinite)\n{\n  unsigned int CodedSize;\n  if (bSizeFinite) {\n    // prepare the head of the size (000...01xxxxxx)\n    // optimal size\n    if (Length < 127) // 2^7 - 1\n      CodedSize = 1;\n    else if (Length < 16383) // 2^14 - 1\n      CodedSize = 2;\n    else if (Length < 2097151L) // 2^21 - 1\n      CodedSize = 3;\n    else if (Length < 268435455L) // 2^28 - 1\n      CodedSize = 4;\n    else CodedSize = 5;\n  } else {\n    if (Length <= 127) // 2^7 - 1\n      Coded",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "45-83"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlUnicodeString::UpdateSize",
          "EbmlElement::ElementSize",
          "CodedSizeLength"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          },
          {
            "qualified_name": "EbmlElement::ElementSize",
            "snippet": "uint64 EbmlElement::ElementSize(bool bWithDefault) const\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0; // won't be saved\n  return Size + EBML_ID_LENGTH((const EbmlId&)*this) + CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "636-641"
          },
          {
            "qualified_name": "CodedSizeLength",
            "snippet": "START_LIBEBML_NAMESPACE\n\n/*!\n  \\todo handle more than CodedSize of 5\n*/\nint CodedSizeLength(uint64 Length, unsigned int SizeLength, bool bSizeFinite)\n{\n  unsigned int CodedSize;\n  if (bSizeFinite) {\n    // prepare the head of the size (000...01xxxxxx)\n    // optimal size\n    if (Length < 127) // 2^7 - 1\n      CodedSize = 1;\n    else if (Length < 16383) // 2^14 - 1\n      CodedSize = 2;\n    else if (Length < 2097151L) // 2^21 - 1\n      CodedSize = 3;\n    else if (Length < 268435455L) // 2^28 - 1\n      CodedSize = 4;\n    else CodedSize = 5;\n  } else {\n    if (Length <= 127) // 2^7 - 1\n      Coded",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "45-83"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlElement::OverwriteHead",
          "EbmlElement::MakeRenderHead",
          "CodedSizeLength"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlElement::OverwriteHead",
            "snippet": "filepos_t EbmlElement::OverwriteHead(IOCallback & output, bool bKeepPosition)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n  output.setFilePointer(GetElementPosition());\n  filepos_t Result = MakeRenderHead(output, bKeepPosition);\n  output.setFilePointer(CurrentPosition);\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "681-692"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          },
          {
            "qualified_name": "CodedSizeLength",
            "snippet": "START_LIBEBML_NAMESPACE\n\n/*!\n  \\todo handle more than CodedSize of 5\n*/\nint CodedSizeLength(uint64 Length, unsigned int SizeLength, bool bSizeFinite)\n{\n  unsigned int CodedSize;\n  if (bSizeFinite) {\n    // prepare the head of the size (000...01xxxxxx)\n    // optimal size\n    if (Length < 127) // 2^7 - 1\n      CodedSize = 1;\n    else if (Length < 16383) // 2^14 - 1\n      CodedSize = 2;\n    else if (Length < 2097151L) // 2^21 - 1\n      CodedSize = 3;\n    else if (Length < 268435455L) // 2^28 - 1\n      CodedSize = 4;\n    else CodedSize = 5;\n  } else {\n    if (Length <= 127) // 2^7 - 1\n      Coded",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "45-83"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlMaster::WriteHead",
          "EbmlElement::RenderHead",
          "EbmlElement::MakeRenderHead",
          "CodedSizeLength"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::WriteHead",
            "snippet": "filepos_t EbmlMaster::WriteHead(IOCallback & output, int nSizeLength, bool bWithDefault)\n{\n  SetSizeLength(nSizeLength);\n  return RenderHead(output, false, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "161-165"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          },
          {
            "qualified_name": "CodedSizeLength",
            "snippet": "START_LIBEBML_NAMESPACE\n\n/*!\n  \\todo handle more than CodedSize of 5\n*/\nint CodedSizeLength(uint64 Length, unsigned int SizeLength, bool bSizeFinite)\n{\n  unsigned int CodedSize;\n  if (bSizeFinite) {\n    // prepare the head of the size (000...01xxxxxx)\n    // optimal size\n    if (Length < 127) // 2^7 - 1\n      CodedSize = 1;\n    else if (Length < 16383) // 2^14 - 1\n      CodedSize = 2;\n    else if (Length < 2097151L) // 2^21 - 1\n      CodedSize = 3;\n    else if (Length < 268435455L) // 2^28 - 1\n      CodedSize = 4;\n    else CodedSize = 5;\n  } else {\n    if (Length <= 127) // 2^7 - 1\n      Coded",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "45-83"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::RenderHead",
          "EbmlElement::MakeRenderHead",
          "CodedSizeLength"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          },
          {
            "qualified_name": "CodedSizeLength",
            "snippet": "START_LIBEBML_NAMESPACE\n\n/*!\n  \\todo handle more than CodedSize of 5\n*/\nint CodedSizeLength(uint64 Length, unsigned int SizeLength, bool bSizeFinite)\n{\n  unsigned int CodedSize;\n  if (bSizeFinite) {\n    // prepare the head of the size (000...01xxxxxx)\n    // optimal size\n    if (Length < 127) // 2^7 - 1\n      CodedSize = 1;\n    else if (Length < 16383) // 2^14 - 1\n      CodedSize = 2;\n    else if (Length < 2097151L) // 2^21 - 1\n      CodedSize = 3;\n    else if (Length < 268435455L) // 2^28 - 1\n      CodedSize = 4;\n    else CodedSize = 5;\n  } else {\n    if (Length <= 127) // 2^7 - 1\n      Coded",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "45-83"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlElement::VoidMe",
          "EbmlVoid::Overwrite",
          "CodedSizeLength"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlElement::VoidMe",
            "snippet": "uint64 EbmlElement::VoidMe(IOCallback & output, bool bWithDefault)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  EbmlVoid Dummy;\n  return Dummy.Overwrite(*this, output, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "694-702"
          },
          {
            "qualified_name": "EbmlVoid::Overwrite",
            "snippet": "uint64 EbmlVoid::Overwrite(const EbmlElement & EltToVoid, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  //  EltToVoid.UpdateSize(bWithDefault);\n  if (EltToVoid.GetElementPosition() == 0) {\n    // this element has never been written\n    return 0;\n  }\n  if (EltToVoid.GetSize() + EltToVoid.HeadSize() <2) {\n    // the element can't be written here !\n    return 0;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePointer(EltToVoid.GetElementPosition());\n\n  // compute the size of the voided data based on the original one\n  SetSize(EltToVoid.GetSize() + E",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "99-135"
          },
          {
            "qualified_name": "CodedSizeLength",
            "snippet": "START_LIBEBML_NAMESPACE\n\n/*!\n  \\todo handle more than CodedSize of 5\n*/\nint CodedSizeLength(uint64 Length, unsigned int SizeLength, bool bSizeFinite)\n{\n  unsigned int CodedSize;\n  if (bSizeFinite) {\n    // prepare the head of the size (000...01xxxxxx)\n    // optimal size\n    if (Length < 127) // 2^7 - 1\n      CodedSize = 1;\n    else if (Length < 16383) // 2^14 - 1\n      CodedSize = 2;\n    else if (Length < 2097151L) // 2^21 - 1\n      CodedSize = 3;\n    else if (Length < 268435455L) // 2^28 - 1\n      CodedSize = 4;\n    else CodedSize = 5;\n  } else {\n    if (Length <= 127) // 2^7 - 1\n      Coded",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "45-83"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "CodedSizeLength"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "CodedSizeLength",
            "snippet": "START_LIBEBML_NAMESPACE\n\n/*!\n  \\todo handle more than CodedSize of 5\n*/\nint CodedSizeLength(uint64 Length, unsigned int SizeLength, bool bSizeFinite)\n{\n  unsigned int CodedSize;\n  if (bSizeFinite) {\n    // prepare the head of the size (000...01xxxxxx)\n    // optimal size\n    if (Length < 127) // 2^7 - 1\n      CodedSize = 1;\n    else if (Length < 16383) // 2^14 - 1\n      CodedSize = 2;\n    else if (Length < 2097151L) // 2^21 - 1\n      CodedSize = 3;\n    else if (Length < 268435455L) // 2^28 - 1\n      CodedSize = 4;\n    else CodedSize = 5;\n  } else {\n    if (Length <= 127) // 2^7 - 1\n      Coded",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "45-83"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlCrc32::Finalize",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "338-348",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::VerifyChecksum",
          "EbmlCrc32::FillCRC32",
          "EbmlCrc32::Finalize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::VerifyChecksum",
            "snippet": "bool EbmlMaster::VerifyChecksum() const\n{\n  if (!bChecksumUsed)\n    return true;\n\n  EbmlCrc32 aChecksum;\n  /// \\todo remove the Checksum if it's in the list\n  /// \\todo find another way when not all default values are saved or (unknown from the reader !!!)\n  MemIOCallback TmpBuf(GetSize() - 6);\n  for (size_t Index = 0; Index < ElementList.size(); Index++) {\n    (ElementList[Index])->Render(TmpBuf, true, false, true);\n  }\n  aChecksum.FillCRC32(TmpBuf.GetDataBuffer(), TmpBuf.GetDataBufferSize());\n  return (aChecksum.GetCrc32() == Checksum.GetCrc32());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "526-540"
          },
          {
            "qualified_name": "EbmlCrc32::FillCRC32",
            "snippet": "void EbmlCrc32::FillCRC32(const binary *s, uint32 n)\n{\n  ResetCRC();\n  Update(s, n);\n  Finalize();\n\n  /*uint32 crc = CRC32_NEGL;\n\n  for(; !IsAligned<uint32>(s) && n > 0; n--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^ CRC32_SHIFTED(crc);\n\n  while (n >= 4)\n  {\n    crc ^= *(const uint32 *)s;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    n -= 4;\n    s += 4;\n  }\n\n  while (n--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "281-313"
          },
          {
            "qualified_name": "EbmlCrc32::Finalize",
            "snippet": "void EbmlCrc32::Finalize()\n{\n  //Finalize the CRC32\n  m_crc ^= CRC32_NEGL;\n  //Copy it over to completed CRC32 memeber\n  m_crc_final = m_crc;\n  //Reset the holding CRC member (m_crc)\n  ResetCRC();\n  //This EbmlElement has been set\n  SetValueIsSet();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "338-348"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlCrc32::Update",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "315-336",
    "num_chains": 2,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::VerifyChecksum",
          "EbmlCrc32::FillCRC32",
          "EbmlCrc32::Update"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::VerifyChecksum",
            "snippet": "bool EbmlMaster::VerifyChecksum() const\n{\n  if (!bChecksumUsed)\n    return true;\n\n  EbmlCrc32 aChecksum;\n  /// \\todo remove the Checksum if it's in the list\n  /// \\todo find another way when not all default values are saved or (unknown from the reader !!!)\n  MemIOCallback TmpBuf(GetSize() - 6);\n  for (size_t Index = 0; Index < ElementList.size(); Index++) {\n    (ElementList[Index])->Render(TmpBuf, true, false, true);\n  }\n  aChecksum.FillCRC32(TmpBuf.GetDataBuffer(), TmpBuf.GetDataBufferSize());\n  return (aChecksum.GetCrc32() == Checksum.GetCrc32());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "526-540"
          },
          {
            "qualified_name": "EbmlCrc32::FillCRC32",
            "snippet": "void EbmlCrc32::FillCRC32(const binary *s, uint32 n)\n{\n  ResetCRC();\n  Update(s, n);\n  Finalize();\n\n  /*uint32 crc = CRC32_NEGL;\n\n  for(; !IsAligned<uint32>(s) && n > 0; n--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^ CRC32_SHIFTED(crc);\n\n  while (n >= 4)\n  {\n    crc ^= *(const uint32 *)s;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    n -= 4;\n    s += 4;\n  }\n\n  while (n--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "281-313"
          },
          {
            "qualified_name": "EbmlCrc32::Update",
            "snippet": "void EbmlCrc32::Update(const binary *input, uint32 length)\n{\n  uint32 crc = m_crc;\n\n  for(; !IsAligned<uint32>(input) && length > 0; length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  while (length >= 4) {\n    crc ^= *(const uint32 *)input;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    length -= 4;\n    input += 4;\n  }\n\n  while (length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CR",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "315-336"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlCrc32::Update"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlCrc32::Update",
            "snippet": "void EbmlCrc32::Update(const binary *input, uint32 length)\n{\n  uint32 crc = m_crc;\n\n  for(; !IsAligned<uint32>(input) && length > 0; length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  while (length >= 4) {\n    crc ^= *(const uint32 *)input;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    length -= 4;\n    input += 4;\n  }\n\n  while (length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CR",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "315-336"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlCrc32::FillCRC32",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "281-313",
    "num_chains": 4,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::VerifyChecksum",
          "EbmlCrc32::FillCRC32"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::VerifyChecksum",
            "snippet": "bool EbmlMaster::VerifyChecksum() const\n{\n  if (!bChecksumUsed)\n    return true;\n\n  EbmlCrc32 aChecksum;\n  /// \\todo remove the Checksum if it's in the list\n  /// \\todo find another way when not all default values are saved or (unknown from the reader !!!)\n  MemIOCallback TmpBuf(GetSize() - 6);\n  for (size_t Index = 0; Index < ElementList.size(); Index++) {\n    (ElementList[Index])->Render(TmpBuf, true, false, true);\n  }\n  aChecksum.FillCRC32(TmpBuf.GetDataBuffer(), TmpBuf.GetDataBufferSize());\n  return (aChecksum.GetCrc32() == Checksum.GetCrc32());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "526-540"
          },
          {
            "qualified_name": "EbmlCrc32::FillCRC32",
            "snippet": "void EbmlCrc32::FillCRC32(const binary *s, uint32 n)\n{\n  ResetCRC();\n  Update(s, n);\n  Finalize();\n\n  /*uint32 crc = CRC32_NEGL;\n\n  for(; !IsAligned<uint32>(s) && n > 0; n--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^ CRC32_SHIFTED(crc);\n\n  while (n >= 4)\n  {\n    crc ^= *(const uint32 *)s;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    n -= 4;\n    s += 4;\n  }\n\n  while (n--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "281-313"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlUnicodeString::RenderData",
          "EbmlCrc32::FillCRC32"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::RenderData",
            "snippet": "filepos_t EbmlUnicodeString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  uint32 Result = Value.GetUTF8().length();\n\n  if (Result != 0) {\n    output.writeFully(Value.GetUTF8().c_str(), Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "279-300"
          },
          {
            "qualified_name": "EbmlCrc32::FillCRC32",
            "snippet": "void EbmlCrc32::FillCRC32(const binary *s, uint32 n)\n{\n  ResetCRC();\n  Update(s, n);\n  Finalize();\n\n  /*uint32 crc = CRC32_NEGL;\n\n  for(; !IsAligned<uint32>(s) && n > 0; n--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^ CRC32_SHIFTED(crc);\n\n  while (n >= 4)\n  {\n    crc ^= *(const uint32 *)s;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    n -= 4;\n    s += 4;\n  }\n\n  while (n--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "281-313"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlUnicodeString::RenderData",
          "EbmlCrc32::FillCRC32"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::RenderData",
            "snippet": "filepos_t EbmlUnicodeString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  uint32 Result = Value.GetUTF8().length();\n\n  if (Result != 0) {\n    output.writeFully(Value.GetUTF8().c_str(), Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "279-300"
          },
          {
            "qualified_name": "EbmlCrc32::FillCRC32",
            "snippet": "void EbmlCrc32::FillCRC32(const binary *s, uint32 n)\n{\n  ResetCRC();\n  Update(s, n);\n  Finalize();\n\n  /*uint32 crc = CRC32_NEGL;\n\n  for(; !IsAligned<uint32>(s) && n > 0; n--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^ CRC32_SHIFTED(crc);\n\n  while (n >= 4)\n  {\n    crc ^= *(const uint32 *)s;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    n -= 4;\n    s += 4;\n  }\n\n  while (n--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "281-313"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlUnicodeString::RenderData",
          "EbmlCrc32::FillCRC32"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::RenderData",
            "snippet": "filepos_t EbmlUnicodeString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  uint32 Result = Value.GetUTF8().length();\n\n  if (Result != 0) {\n    output.writeFully(Value.GetUTF8().c_str(), Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "279-300"
          },
          {
            "qualified_name": "EbmlCrc32::FillCRC32",
            "snippet": "void EbmlCrc32::FillCRC32(const binary *s, uint32 n)\n{\n  ResetCRC();\n  Update(s, n);\n  Finalize();\n\n  /*uint32 crc = CRC32_NEGL;\n\n  for(; !IsAligned<uint32>(s) && n > 0; n--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^ CRC32_SHIFTED(crc);\n\n  while (n >= 4)\n  {\n    crc ^= *(const uint32 *)s;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    n -= 4;\n    s += 4;\n  }\n\n  while (n--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "281-313"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlCrc32::CheckCRC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "252-279",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlCrc32::CheckCRC"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlCrc32::CheckCRC",
            "snippet": "bool EbmlCrc32::CheckCRC(uint32 inputCRC, const binary *input, uint32 length)\n{\n  uint32 crc = CRC32_NEGL;\n\n  for(; !IsAligned<uint32>(input) && length > 0; length--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *input++] ^ CRC32_SHIFTED(crc);\n\n  while (length >= 4) {\n    crc ^= *(const uint32 *)input;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    length -= 4;\n    input += 4;\n  }\n\n  while (length--)\n    crc = m_tab[CRC32_IND",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "252-279"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlCrc32::ReadData",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "233-250",
    "num_chains": 5,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlCrc32::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlCrc32::ReadData",
            "snippet": "filepos_t EbmlCrc32::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary *Buffer = new (std::nothrow) binary[GetSize()];\n    if (Buffer == NULL) {\n      // impossible to read, skip it\n      input.setFilePointer(GetSize(), seek_current);\n    } else {\n      input.readFully(Buffer, GetSize());\n\n      memcpy((void *)&m_crc_final, Buffer, 4);\n      delete [] Buffer;\n      SetValueIsSet();\n    }\n  }\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "233-250"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlCrc32::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlCrc32::ReadData",
            "snippet": "filepos_t EbmlCrc32::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary *Buffer = new (std::nothrow) binary[GetSize()];\n    if (Buffer == NULL) {\n      // impossible to read, skip it\n      input.setFilePointer(GetSize(), seek_current);\n    } else {\n      input.readFully(Buffer, GetSize());\n\n      memcpy((void *)&m_crc_final, Buffer, 4);\n      delete [] Buffer;\n      SetValueIsSet();\n    }\n  }\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "233-250"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlCrc32::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlCrc32::ReadData",
            "snippet": "filepos_t EbmlCrc32::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary *Buffer = new (std::nothrow) binary[GetSize()];\n    if (Buffer == NULL) {\n      // impossible to read, skip it\n      input.setFilePointer(GetSize(), seek_current);\n    } else {\n      input.readFully(Buffer, GetSize());\n\n      memcpy((void *)&m_crc_final, Buffer, 4);\n      delete [] Buffer;\n      SetValueIsSet();\n    }\n  }\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "233-250"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlCrc32::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlCrc32::ReadData",
            "snippet": "filepos_t EbmlCrc32::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary *Buffer = new (std::nothrow) binary[GetSize()];\n    if (Buffer == NULL) {\n      // impossible to read, skip it\n      input.setFilePointer(GetSize(), seek_current);\n    } else {\n      input.readFully(Buffer, GetSize());\n\n      memcpy((void *)&m_crc_final, Buffer, 4);\n      delete [] Buffer;\n      SetValueIsSet();\n    }\n  }\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "233-250"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlCrc32::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlCrc32::ReadData",
            "snippet": "filepos_t EbmlCrc32::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary *Buffer = new (std::nothrow) binary[GetSize()];\n    if (Buffer == NULL) {\n      // impossible to read, skip it\n      input.setFilePointer(GetSize(), seek_current);\n    } else {\n      input.readFully(Buffer, GetSize());\n\n      memcpy((void *)&m_crc_final, Buffer, 4);\n      delete [] Buffer;\n      SetValueIsSet();\n    }\n  }\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "233-250"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlCrc32::RenderData",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "210-231",
    "num_chains": 3,
    "chains": [
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlCrc32::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlCrc32::RenderData",
            "snippet": "filepos_t EbmlCrc32::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  filepos_t Result = 4;\n\n  if (Result != 0) {\n    output.writeFully(&m_crc_final, Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "210-231"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlCrc32::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlCrc32::RenderData",
            "snippet": "filepos_t EbmlCrc32::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  filepos_t Result = 4;\n\n  if (Result != 0) {\n    output.writeFully(&m_crc_final, Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "210-231"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlCrc32::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlCrc32::RenderData",
            "snippet": "filepos_t EbmlCrc32::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  filepos_t Result = 4;\n\n  if (Result != 0) {\n    output.writeFully(&m_crc_final, Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "210-231"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlCrc32::CheckElementCRC32",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "202-208",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlCrc32::AddElementCRC32",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "192-200",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlCrc32::UpdateByte",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "187-190",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlCrc32::UpdateByte"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::UpdateByte",
            "snippet": "void EbmlCrc32::UpdateByte(binary b)\n{\n  m_crc = m_tab[CRC32_INDEX(m_crc) ^ b] ^ CRC32_SHIFTED(m_crc);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "187-190"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlCrc32::ResetCRC",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "182-185",
    "num_chains": 3,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::VerifyChecksum",
          "EbmlCrc32::FillCRC32",
          "EbmlCrc32::Finalize",
          "EbmlCrc32::ResetCRC"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::VerifyChecksum",
            "snippet": "bool EbmlMaster::VerifyChecksum() const\n{\n  if (!bChecksumUsed)\n    return true;\n\n  EbmlCrc32 aChecksum;\n  /// \\todo remove the Checksum if it's in the list\n  /// \\todo find another way when not all default values are saved or (unknown from the reader !!!)\n  MemIOCallback TmpBuf(GetSize() - 6);\n  for (size_t Index = 0; Index < ElementList.size(); Index++) {\n    (ElementList[Index])->Render(TmpBuf, true, false, true);\n  }\n  aChecksum.FillCRC32(TmpBuf.GetDataBuffer(), TmpBuf.GetDataBufferSize());\n  return (aChecksum.GetCrc32() == Checksum.GetCrc32());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "526-540"
          },
          {
            "qualified_name": "EbmlCrc32::FillCRC32",
            "snippet": "void EbmlCrc32::FillCRC32(const binary *s, uint32 n)\n{\n  ResetCRC();\n  Update(s, n);\n  Finalize();\n\n  /*uint32 crc = CRC32_NEGL;\n\n  for(; !IsAligned<uint32>(s) && n > 0; n--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^ CRC32_SHIFTED(crc);\n\n  while (n >= 4)\n  {\n    crc ^= *(const uint32 *)s;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    n -= 4;\n    s += 4;\n  }\n\n  while (n--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "281-313"
          },
          {
            "qualified_name": "EbmlCrc32::Finalize",
            "snippet": "void EbmlCrc32::Finalize()\n{\n  //Finalize the CRC32\n  m_crc ^= CRC32_NEGL;\n  //Copy it over to completed CRC32 memeber\n  m_crc_final = m_crc;\n  //Reset the holding CRC member (m_crc)\n  ResetCRC();\n  //This EbmlElement has been set\n  SetValueIsSet();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "338-348"
          },
          {
            "qualified_name": "EbmlCrc32::ResetCRC",
            "snippet": "void EbmlCrc32::ResetCRC()\n{\n  m_crc = CRC32_NEGL;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "182-185"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlMaster::VerifyChecksum",
          "EbmlCrc32::FillCRC32",
          "EbmlCrc32::ResetCRC"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::VerifyChecksum",
            "snippet": "bool EbmlMaster::VerifyChecksum() const\n{\n  if (!bChecksumUsed)\n    return true;\n\n  EbmlCrc32 aChecksum;\n  /// \\todo remove the Checksum if it's in the list\n  /// \\todo find another way when not all default values are saved or (unknown from the reader !!!)\n  MemIOCallback TmpBuf(GetSize() - 6);\n  for (size_t Index = 0; Index < ElementList.size(); Index++) {\n    (ElementList[Index])->Render(TmpBuf, true, false, true);\n  }\n  aChecksum.FillCRC32(TmpBuf.GetDataBuffer(), TmpBuf.GetDataBufferSize());\n  return (aChecksum.GetCrc32() == Checksum.GetCrc32());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "526-540"
          },
          {
            "qualified_name": "EbmlCrc32::FillCRC32",
            "snippet": "void EbmlCrc32::FillCRC32(const binary *s, uint32 n)\n{\n  ResetCRC();\n  Update(s, n);\n  Finalize();\n\n  /*uint32 crc = CRC32_NEGL;\n\n  for(; !IsAligned<uint32>(s) && n > 0; n--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^ CRC32_SHIFTED(crc);\n\n  while (n >= 4)\n  {\n    crc ^= *(const uint32 *)s;\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    crc = m_tab[CRC32_INDEX(crc)] ^ CRC32_SHIFTED(crc);\n    n -= 4;\n    s += 4;\n  }\n\n  while (n--)\n    crc = m_tab[CRC32_INDEX(crc) ^ *s++] ^",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "281-313"
          },
          {
            "qualified_name": "EbmlCrc32::ResetCRC",
            "snippet": "void EbmlCrc32::ResetCRC()\n{\n  m_crc = CRC32_NEGL;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "182-185"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::EbmlCrc32",
          "EbmlCrc32::ResetCRC"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::EbmlCrc32",
            "snippet": "EbmlCrc32::EbmlCrc32()\n{\n  ResetCRC();\n  SetDefaultSize(4);\n  m_crc_final = 0;\n  SetSize_(4);\n  //This EbmlElement has been set\n  //  SetValueIsSet();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "165-173"
          },
          {
            "qualified_name": "EbmlCrc32::ResetCRC",
            "snippet": "void EbmlCrc32::ResetCRC()\n{\n  m_crc = CRC32_NEGL;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "182-185"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlCrc32::EbmlCrc32",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "175-180",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlCrc32::EbmlCrc32"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::EbmlCrc32",
            "snippet": "EbmlCrc32::EbmlCrc32()\n{\n  ResetCRC();\n  SetDefaultSize(4);\n  m_crc_final = 0;\n  SetSize_(4);\n  //This EbmlElement has been set\n  //  SetValueIsSet();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "165-173"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlCrc32::EbmlCrc32",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
    "lines": "165-173",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlCrc32::EbmlCrc32"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::EbmlCrc32",
            "snippet": "EbmlCrc32::EbmlCrc32()\n{\n  ResetCRC();\n  SetDefaultSize(4);\n  m_crc_final = 0;\n  SetSize_(4);\n  //This EbmlElement has been set\n  //  SetValueIsSet();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "165-173"
          }
        ]
      }
    ]
  },
  {
    "target_function": "SafeReadIOCallback::Read",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
    "lines": "166-172",
    "num_chains": 5,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          }
        ]
      }
    ]
  },
  {
    "target_function": "SafeReadIOCallback::Seek",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
    "lines": "158-164",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::Seek"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::Seek",
            "snippet": "void\nSafeReadIOCallback::Seek(size_t Offset) {\n  mIO->setFilePointer(Offset);\n  uint64 ActualPosition = mIO->getFilePointer();\n  if (ActualPosition != Offset)\n    throw EndOfStreamX(ActualPosition - Offset);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "158-164"
          }
        ]
      }
    ]
  },
  {
    "target_function": "SafeReadIOCallback::Skip",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
    "lines": "147-156",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::Skip"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::Skip",
            "snippet": "void\nSafeReadIOCallback::Skip(size_t Count) {\n  int64 PrevPosition     = mIO->getFilePointer();\n  int64 ExpectedPosition = PrevPosition + Count;\n  mIO->setFilePointer(Count, seek_current);\n  int64 ActualPosition   = mIO->getFilePointer();\n\n  if (ActualPosition != ExpectedPosition)\n    throw SafeReadIOCallback::EndOfStreamX(ExpectedPosition - ActualPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "147-156"
          }
        ]
      }
    ]
  },
  {
    "target_function": "SafeReadIOCallback::GetUInt64BE",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
    "lines": "142-145",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          }
        ]
      }
    ]
  },
  {
    "target_function": "SafeReadIOCallback::GetUInt32BE",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
    "lines": "137-140",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          }
        ]
      }
    ]
  },
  {
    "target_function": "SafeReadIOCallback::GetUInt24BE",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
    "lines": "132-135",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          }
        ]
      }
    ]
  },
  {
    "target_function": "SafeReadIOCallback::GetUInt16BE",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
    "lines": "127-130",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          }
        ]
      }
    ]
  },
  {
    "target_function": "SafeReadIOCallback::GetUInt8",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
    "lines": "122-125",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          }
        ]
      }
    ]
  },
  {
    "target_function": "SafeReadIOCallback::GetUIntBE",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
    "lines": "106-120",
    "num_chains": 5,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          }
        ]
      }
    ]
  },
  {
    "target_function": "SafeReadIOCallback::IsEmpty",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
    "lines": "100-104",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::IsEmpty"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::IsEmpty",
            "snippet": "bool\nSafeReadIOCallback::IsEmpty()\n  const {\n  return !GetRemainingBytes();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "100-104"
          }
        ]
      }
    ]
  },
  {
    "target_function": "SafeReadIOCallback::GetRemainingBytes",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
    "lines": "94-98",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::IsEmpty",
          "SafeReadIOCallback::GetRemainingBytes"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::IsEmpty",
            "snippet": "bool\nSafeReadIOCallback::IsEmpty()\n  const {\n  return !GetRemainingBytes();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "100-104"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetRemainingBytes",
            "snippet": "size_t\nSafeReadIOCallback::GetRemainingBytes()\n  const {\n  return GetSize() - GetPosition();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "94-98"
          }
        ]
      }
    ]
  },
  {
    "target_function": "SafeReadIOCallback::GetSize",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
    "lines": "88-92",
    "num_chains": 23,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::VerifyChecksum",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::VerifyChecksum",
            "snippet": "bool EbmlMaster::VerifyChecksum() const\n{\n  if (!bChecksumUsed)\n    return true;\n\n  EbmlCrc32 aChecksum;\n  /// \\todo remove the Checksum if it's in the list\n  /// \\todo find another way when not all default values are saved or (unknown from the reader !!!)\n  MemIOCallback TmpBuf(GetSize() - 6);\n  for (size_t Index = 0; Index < ElementList.size(); Index++) {\n    (ElementList[Index])->Render(TmpBuf, true, false, true);\n  }\n  aChecksum.FillCRC32(TmpBuf.GetDataBuffer(), TmpBuf.GetDataBufferSize());\n  return (aChecksum.GetCrc32() == Checksum.GetCrc32());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "526-540"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlUnicodeString::UpdateSize",
          "EbmlMaster::CheckMandatory",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          },
          {
            "qualified_name": "EbmlMaster::CheckMandatory",
            "snippet": "bool EbmlMaster::CheckMandatory() const\n{\n  assert(Context.GetSize() != 0);\n\n  unsigned int EltIdx;\n  for (EltIdx = 0; EltIdx < EBML_CTX_SIZE(Context); EltIdx++) {\n    if (EBML_CTX_IDX(Context,EltIdx).IsMandatory()) {\n      if (FindElt(EBML_CTX_IDX_INFO(Context,EltIdx)) == NULL) {\n#if defined(LIBEBML_DEBUG)\n        // you are missing this Mandatory element\n//         const char * MissingName = EBML_INFO_NAME(EBML_CTX_IDX_INFO(Context,EltIdx));\n#endif // LIBEBML_DEBUG\n        return false;\n      }\n    }\n  }\n\n  return true;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "199-217"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlMaster::ProcessMandatory",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::ProcessMandatory",
            "snippet": "bool EbmlMaster::ProcessMandatory()\n{\n  if (EBML_CTX_SIZE(Context) == 0)\n  {\n    return true;\n  }\n\n  assert(Context.GetSize() != 0);\n\n  unsigned int EltIdx;\n  for (EltIdx = 0; EltIdx < EBML_CTX_SIZE(Context); EltIdx++) {\n    if (EBML_CTX_IDX(Context,EltIdx).IsMandatory() && EBML_CTX_IDX(Context,EltIdx).IsUnique()) {\n//      assert(EBML_CTX_IDX(Context,EltIdx).Create != NULL);\n            PushElement(EBML_SEM_CREATE(EBML_CTX_IDX(Context,EltIdx)));\n    }\n  }\n  return true;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "180-197"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlMaster::WriteHead",
          "EbmlElement::RenderHead",
          "EbmlUnicodeString::UpdateSize",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::WriteHead",
            "snippet": "filepos_t EbmlMaster::WriteHead(IOCallback & output, int nSizeLength, bool bWithDefault)\n{\n  SetSizeLength(nSizeLength);\n  return RenderHead(output, false, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "161-165"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::RenderHead",
          "EbmlUnicodeString::UpdateSize",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlUnicodeString::UpdateSize",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlUnicodeString::UpdateSize",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlUnicodeString::UpdateSize",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlUnicodeString::UpdateSize",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlUnicodeString::RenderData",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::RenderData",
            "snippet": "filepos_t EbmlUnicodeString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  uint32 Result = Value.GetUTF8().length();\n\n  if (Result != 0) {\n    output.writeFully(Value.GetUTF8().c_str(), Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "279-300"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlUnicodeString::RenderData",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::RenderData",
            "snippet": "filepos_t EbmlUnicodeString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  uint32 Result = Value.GetUTF8().length();\n\n  if (Result != 0) {\n    output.writeFully(Value.GetUTF8().c_str(), Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "279-300"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlUnicodeString::RenderData",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::RenderData",
            "snippet": "filepos_t EbmlUnicodeString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  uint32 Result = Value.GetUTF8().length();\n\n  if (Result != 0) {\n    output.writeFully(Value.GetUTF8().c_str(), Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "279-300"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::IsEmpty",
          "SafeReadIOCallback::GetRemainingBytes",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::IsEmpty",
            "snippet": "bool\nSafeReadIOCallback::IsEmpty()\n  const {\n  return !GetRemainingBytes();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "100-104"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetRemainingBytes",
            "snippet": "size_t\nSafeReadIOCallback::GetRemainingBytes()\n  const {\n  return GetSize() - GetPosition();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "94-98"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlElement::VoidMe",
          "EbmlVoid::Overwrite",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlElement::VoidMe",
            "snippet": "uint64 EbmlElement::VoidMe(IOCallback & output, bool bWithDefault)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  EbmlVoid Dummy;\n  return Dummy.Overwrite(*this, output, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "694-702"
          },
          {
            "qualified_name": "EbmlVoid::Overwrite",
            "snippet": "uint64 EbmlVoid::Overwrite(const EbmlElement & EltToVoid, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  //  EltToVoid.UpdateSize(bWithDefault);\n  if (EltToVoid.GetElementPosition() == 0) {\n    // this element has never been written\n    return 0;\n  }\n  if (EltToVoid.GetSize() + EltToVoid.HeadSize() <2) {\n    // the element can't be written here !\n    return 0;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePointer(EltToVoid.GetElementPosition());\n\n  // compute the size of the voided data based on the original one\n  SetSize(EltToVoid.GetSize() + E",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "99-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      },
      {
        "call_sequence": [
          "MemReadIOCallback::MemReadIOCallback",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "MemReadIOCallback::MemReadIOCallback",
            "snippet": "START_LIBEBML_NAMESPACE\n\nMemReadIOCallback::MemReadIOCallback(void const *Ptr,\n                                     size_t Size) {\n  Init(Ptr, Size);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "42-47"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlBinary::operator==",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlBinary::operator==",
            "snippet": "bool EbmlBinary::operator==(const EbmlBinary & ElementToCompare) const\n{\n  return ((GetSize() == ElementToCompare.GetSize()) && !memcmp(Data, ElementToCompare.Data, GetSize()));\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "101-104"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlBinary::EbmlBinary",
          "SafeReadIOCallback::GetSize"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlBinary::EbmlBinary",
            "snippet": "EbmlBinary::EbmlBinary(const EbmlBinary & ElementToClone)\n  :EbmlElement(ElementToClone)\n{\n  if (ElementToClone.Data == NULL)\n    Data = NULL;\n  else {\n    Data = (binary *)malloc(GetSize() * sizeof(binary));\n    assert(Data != NULL);\n    memcpy(Data, ElementToClone.Data, GetSize());\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "49-59"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetSize",
            "snippet": "size_t\nSafeReadIOCallback::GetSize()\n  const {\n  return mSize;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "88-92"
          }
        ]
      }
    ]
  },
  {
    "target_function": "SafeReadIOCallback::GetPosition",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
    "lines": "82-86",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::IsEmpty",
          "SafeReadIOCallback::GetRemainingBytes",
          "SafeReadIOCallback::GetPosition"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::IsEmpty",
            "snippet": "bool\nSafeReadIOCallback::IsEmpty()\n  const {\n  return !GetRemainingBytes();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "100-104"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetRemainingBytes",
            "snippet": "size_t\nSafeReadIOCallback::GetRemainingBytes()\n  const {\n  return GetSize() - GetPosition();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "94-98"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetPosition",
            "snippet": "size_t\nSafeReadIOCallback::GetPosition()\n  const {\n  return mIO->getFilePointer();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "82-86"
          }
        ]
      }
    ]
  },
  {
    "target_function": "SafeReadIOCallback::Init",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
    "lines": "71-80",
    "num_chains": 2,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::SafeReadIOCallback",
          "SafeReadIOCallback::Init"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::SafeReadIOCallback",
            "snippet": "SafeReadIOCallback::SafeReadIOCallback(IOCallback *IO,\n                                       bool DeleteIO) {\n  Init(IO, DeleteIO);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "52-55"
          },
          {
            "qualified_name": "SafeReadIOCallback::Init",
            "snippet": "void\nSafeReadIOCallback::Init(IOCallback *IO,\n                         bool DeleteIO) {\n  mIO                = IO;\n  mDeleteIO          = DeleteIO;\n  int64 PrevPosition = IO->getFilePointer();\n  IO->setFilePointer(0, seek_end);\n  mSize              = IO->getFilePointer();\n  IO->setFilePointer(PrevPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "71-80"
          }
        ]
      },
      {
        "call_sequence": [
          "MemReadIOCallback::MemReadIOCallback",
          "SafeReadIOCallback::Init"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "MemReadIOCallback::MemReadIOCallback",
            "snippet": "START_LIBEBML_NAMESPACE\n\nMemReadIOCallback::MemReadIOCallback(void const *Ptr,\n                                     size_t Size) {\n  Init(Ptr, Size);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "42-47"
          },
          {
            "qualified_name": "SafeReadIOCallback::Init",
            "snippet": "void\nSafeReadIOCallback::Init(IOCallback *IO,\n                         bool DeleteIO) {\n  mIO                = IO;\n  mDeleteIO          = DeleteIO;\n  int64 PrevPosition = IO->getFilePointer();\n  IO->setFilePointer(0, seek_end);\n  mSize              = IO->getFilePointer();\n  IO->setFilePointer(PrevPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "71-80"
          }
        ]
      }
    ]
  },
  {
    "target_function": "SafeReadIOCallback::~SafeReadIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
    "lines": "66-69",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::~SafeReadIOCallback"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::~SafeReadIOCallback",
            "snippet": "SafeReadIOCallback::~SafeReadIOCallback() {\n  if (mDeleteIO)\n    delete mIO;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "66-69"
          }
        ]
      }
    ]
  },
  {
    "target_function": "SafeReadIOCallback::SafeReadIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
    "lines": "62-64",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::SafeReadIOCallback"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::SafeReadIOCallback",
            "snippet": "SafeReadIOCallback::SafeReadIOCallback(IOCallback *IO,\n                                       bool DeleteIO) {\n  Init(IO, DeleteIO);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "52-55"
          }
        ]
      }
    ]
  },
  {
    "target_function": "SafeReadIOCallback::SafeReadIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
    "lines": "57-60",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::SafeReadIOCallback"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::SafeReadIOCallback",
            "snippet": "SafeReadIOCallback::SafeReadIOCallback(IOCallback *IO,\n                                       bool DeleteIO) {\n  Init(IO, DeleteIO);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "52-55"
          }
        ]
      }
    ]
  },
  {
    "target_function": "SafeReadIOCallback::SafeReadIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
    "lines": "52-55",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::SafeReadIOCallback"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::SafeReadIOCallback",
            "snippet": "SafeReadIOCallback::SafeReadIOCallback(IOCallback *IO,\n                                       bool DeleteIO) {\n  Init(IO, DeleteIO);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "52-55"
          }
        ]
      }
    ]
  },
  {
    "target_function": "mMissingBytes",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
    "lines": "43-48",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "mMissingBytes"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "mMissingBytes",
            "snippet": "START_LIBEBML_NAMESPACE\n\nSafeReadIOCallback::EndOfStreamX::EndOfStreamX(size_t MissingBytes)\n  : mMissingBytes(MissingBytes)\n{\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "43-48"
          }
        ]
      }
    ]
  },
  {
    "target_function": "MemIOCallback::write",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
    "lines": "110-119",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::OverwriteHead",
          "EbmlElement::MakeRenderHead",
          "IOCallback::writeFully",
          "MemIOCallback::write"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlElement::OverwriteHead",
            "snippet": "filepos_t EbmlElement::OverwriteHead(IOCallback & output, bool bKeepPosition)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n  output.setFilePointer(GetElementPosition());\n  filepos_t Result = MakeRenderHead(output, bKeepPosition);\n  output.setFilePointer(CurrentPosition);\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "681-692"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          },
          {
            "qualified_name": "IOCallback::writeFully",
            "snippet": "START_LIBEBML_NAMESPACE\n\nvoid IOCallback::writeFully(const void*Buffer,size_t Size)\n{\n  if (Size == 0)\n    return;\n\n  if (Buffer == NULL)\n    throw;\n\n  if(write(Buffer,Size) != Size) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"EOF in writeFully(\"<<Buffer<<\",\"<<Size<<\")\";\n    throw runtime_error(Msg.str());\n#endif // GCC2\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/IOCallback.cpp",
            "lines": "46-63"
          },
          {
            "qualified_name": "MemIOCallback::write",
            "snippet": "size_t MemIOCallback::write(const void *Buffer, size_t Size)\n{\n  if (dataBufferMemorySize < dataBufferPos + Size) {\n    //We need more memory!\n    dataBuffer = (binary *)realloc((void *)dataBuffer, dataBufferPos + Size);\n  }\n  memcpy(dataBuffer+dataBufferPos, Buffer, Size);\n  dataBufferPos += Size;\n  if (dataBufferPos > dataBufferTotalSize)\n    dataBufferTotalSize = dataBufferPos;\n\n  return Size;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
            "lines": "96-108"
          }
        ]
      }
    ]
  },
  {
    "target_function": "MemIOCallback::write",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
    "lines": "96-108",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::OverwriteHead",
          "EbmlElement::MakeRenderHead",
          "IOCallback::writeFully",
          "MemIOCallback::write"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlElement::OverwriteHead",
            "snippet": "filepos_t EbmlElement::OverwriteHead(IOCallback & output, bool bKeepPosition)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n  output.setFilePointer(GetElementPosition());\n  filepos_t Result = MakeRenderHead(output, bKeepPosition);\n  output.setFilePointer(CurrentPosition);\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "681-692"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          },
          {
            "qualified_name": "IOCallback::writeFully",
            "snippet": "START_LIBEBML_NAMESPACE\n\nvoid IOCallback::writeFully(const void*Buffer,size_t Size)\n{\n  if (Size == 0)\n    return;\n\n  if (Buffer == NULL)\n    throw;\n\n  if(write(Buffer,Size) != Size) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"EOF in writeFully(\"<<Buffer<<\",\"<<Size<<\")\";\n    throw runtime_error(Msg.str());\n#endif // GCC2\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/IOCallback.cpp",
            "lines": "46-63"
          },
          {
            "qualified_name": "MemIOCallback::write",
            "snippet": "size_t MemIOCallback::write(const void *Buffer, size_t Size)\n{\n  if (dataBufferMemorySize < dataBufferPos + Size) {\n    //We need more memory!\n    dataBuffer = (binary *)realloc((void *)dataBuffer, dataBufferPos + Size);\n  }\n  memcpy(dataBuffer+dataBufferPos, Buffer, Size);\n  dataBufferPos += Size;\n  if (dataBufferPos > dataBufferTotalSize)\n    dataBufferTotalSize = dataBufferPos;\n\n  return Size;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
            "lines": "96-108"
          }
        ]
      }
    ]
  },
  {
    "target_function": "MemIOCallback::setFilePointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
    "lines": "86-94",
    "num_chains": 7,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::OverwriteHead",
          "MemIOCallback::setFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlElement::OverwriteHead",
            "snippet": "filepos_t EbmlElement::OverwriteHead(IOCallback & output, bool bKeepPosition)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n  output.setFilePointer(GetElementPosition());\n  filepos_t Result = MakeRenderHead(output, bKeepPosition);\n  output.setFilePointer(CurrentPosition);\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "681-692"
          },
          {
            "qualified_name": "MemIOCallback::setFilePointer",
            "snippet": "void MemIOCallback::setFilePointer(int64 Offset, seek_mode Mode)\n{\n  if (Mode == seek_beginning)\n    dataBufferPos = Offset;\n  else if (Mode == seek_current)\n    dataBufferPos = dataBufferPos + Offset;\n  else if (Mode == seek_end)\n    dataBufferPos = dataBufferTotalSize + Offset;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
            "lines": "86-94"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::Seek",
          "MemIOCallback::setFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::Seek",
            "snippet": "void\nSafeReadIOCallback::Seek(size_t Offset) {\n  mIO->setFilePointer(Offset);\n  uint64 ActualPosition = mIO->getFilePointer();\n  if (ActualPosition != Offset)\n    throw EndOfStreamX(ActualPosition - Offset);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "158-164"
          },
          {
            "qualified_name": "MemIOCallback::setFilePointer",
            "snippet": "void MemIOCallback::setFilePointer(int64 Offset, seek_mode Mode)\n{\n  if (Mode == seek_beginning)\n    dataBufferPos = Offset;\n  else if (Mode == seek_current)\n    dataBufferPos = dataBufferPos + Offset;\n  else if (Mode == seek_end)\n    dataBufferPos = dataBufferTotalSize + Offset;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
            "lines": "86-94"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::Skip",
          "MemIOCallback::setFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::Skip",
            "snippet": "void\nSafeReadIOCallback::Skip(size_t Count) {\n  int64 PrevPosition     = mIO->getFilePointer();\n  int64 ExpectedPosition = PrevPosition + Count;\n  mIO->setFilePointer(Count, seek_current);\n  int64 ActualPosition   = mIO->getFilePointer();\n\n  if (ActualPosition != ExpectedPosition)\n    throw SafeReadIOCallback::EndOfStreamX(ExpectedPosition - ActualPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "147-156"
          },
          {
            "qualified_name": "MemIOCallback::setFilePointer",
            "snippet": "void MemIOCallback::setFilePointer(int64 Offset, seek_mode Mode)\n{\n  if (Mode == seek_beginning)\n    dataBufferPos = Offset;\n  else if (Mode == seek_current)\n    dataBufferPos = dataBufferPos + Offset;\n  else if (Mode == seek_end)\n    dataBufferPos = dataBufferTotalSize + Offset;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
            "lines": "86-94"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::SafeReadIOCallback",
          "SafeReadIOCallback::Init",
          "MemIOCallback::setFilePointer"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::SafeReadIOCallback",
            "snippet": "SafeReadIOCallback::SafeReadIOCallback(IOCallback *IO,\n                                       bool DeleteIO) {\n  Init(IO, DeleteIO);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "52-55"
          },
          {
            "qualified_name": "SafeReadIOCallback::Init",
            "snippet": "void\nSafeReadIOCallback::Init(IOCallback *IO,\n                         bool DeleteIO) {\n  mIO                = IO;\n  mDeleteIO          = DeleteIO;\n  int64 PrevPosition = IO->getFilePointer();\n  IO->setFilePointer(0, seek_end);\n  mSize              = IO->getFilePointer();\n  IO->setFilePointer(PrevPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "71-80"
          },
          {
            "qualified_name": "MemIOCallback::setFilePointer",
            "snippet": "void MemIOCallback::setFilePointer(int64 Offset, seek_mode Mode)\n{\n  if (Mode == seek_beginning)\n    dataBufferPos = Offset;\n  else if (Mode == seek_current)\n    dataBufferPos = dataBufferPos + Offset;\n  else if (Mode == seek_end)\n    dataBufferPos = dataBufferTotalSize + Offset;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
            "lines": "86-94"
          }
        ]
      },
      {
        "call_sequence": [
          "MemReadIOCallback::MemReadIOCallback",
          "SafeReadIOCallback::Init",
          "MemIOCallback::setFilePointer"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "MemReadIOCallback::MemReadIOCallback",
            "snippet": "START_LIBEBML_NAMESPACE\n\nMemReadIOCallback::MemReadIOCallback(void const *Ptr,\n                                     size_t Size) {\n  Init(Ptr, Size);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "42-47"
          },
          {
            "qualified_name": "SafeReadIOCallback::Init",
            "snippet": "void\nSafeReadIOCallback::Init(IOCallback *IO,\n                         bool DeleteIO) {\n  mIO                = IO;\n  mDeleteIO          = DeleteIO;\n  int64 PrevPosition = IO->getFilePointer();\n  IO->setFilePointer(0, seek_end);\n  mSize              = IO->getFilePointer();\n  IO->setFilePointer(PrevPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "71-80"
          },
          {
            "qualified_name": "MemIOCallback::setFilePointer",
            "snippet": "void MemIOCallback::setFilePointer(int64 Offset, seek_mode Mode)\n{\n  if (Mode == seek_beginning)\n    dataBufferPos = Offset;\n  else if (Mode == seek_current)\n    dataBufferPos = dataBufferPos + Offset;\n  else if (Mode == seek_end)\n    dataBufferPos = dataBufferTotalSize + Offset;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
            "lines": "86-94"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlElement::VoidMe",
          "EbmlVoid::Overwrite",
          "MemIOCallback::setFilePointer"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlElement::VoidMe",
            "snippet": "uint64 EbmlElement::VoidMe(IOCallback & output, bool bWithDefault)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  EbmlVoid Dummy;\n  return Dummy.Overwrite(*this, output, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "694-702"
          },
          {
            "qualified_name": "EbmlVoid::Overwrite",
            "snippet": "uint64 EbmlVoid::Overwrite(const EbmlElement & EltToVoid, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  //  EltToVoid.UpdateSize(bWithDefault);\n  if (EltToVoid.GetElementPosition() == 0) {\n    // this element has never been written\n    return 0;\n  }\n  if (EltToVoid.GetSize() + EltToVoid.HeadSize() <2) {\n    // the element can't be written here !\n    return 0;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePointer(EltToVoid.GetElementPosition());\n\n  // compute the size of the voided data based on the original one\n  SetSize(EltToVoid.GetSize() + E",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "99-135"
          },
          {
            "qualified_name": "MemIOCallback::setFilePointer",
            "snippet": "void MemIOCallback::setFilePointer(int64 Offset, seek_mode Mode)\n{\n  if (Mode == seek_beginning)\n    dataBufferPos = Offset;\n  else if (Mode == seek_current)\n    dataBufferPos = dataBufferPos + Offset;\n  else if (Mode == seek_end)\n    dataBufferPos = dataBufferTotalSize + Offset;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
            "lines": "86-94"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "MemIOCallback::setFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "MemIOCallback::setFilePointer",
            "snippet": "void MemIOCallback::setFilePointer(int64 Offset, seek_mode Mode)\n{\n  if (Mode == seek_beginning)\n    dataBufferPos = Offset;\n  else if (Mode == seek_current)\n    dataBufferPos = dataBufferPos + Offset;\n  else if (Mode == seek_end)\n    dataBufferPos = dataBufferTotalSize + Offset;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
            "lines": "86-94"
          }
        ]
      }
    ]
  },
  {
    "target_function": "MemIOCallback::read",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
    "lines": "66-84",
    "num_chains": 5,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "MemIOCallback::read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "MemIOCallback::read",
            "snippet": "uint32 MemIOCallback::read(void *Buffer, size_t Size)\n{\n  if (Buffer == NULL || Size < 1)\n    return 0;\n  //If the size is larger than than the amount left in the buffer\n  if (Size + dataBufferPos > dataBufferTotalSize) {\n    //We will only return the remaining data\n    memcpy(Buffer, dataBuffer + dataBufferPos, dataBufferTotalSize - dataBufferPos);\n    uint64 oldDataPos = dataBufferPos;\n    dataBufferPos = dataBufferTotalSize;\n    return dataBufferTotalSize - oldDataPos;\n  }\n\n  //Well... We made it here, so do a quick and simple copy\n  memcpy(Buffer, dataBuffer+dataBufferPos, Size);\n  dataBuf",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
            "lines": "66-84"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "MemIOCallback::read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "MemIOCallback::read",
            "snippet": "uint32 MemIOCallback::read(void *Buffer, size_t Size)\n{\n  if (Buffer == NULL || Size < 1)\n    return 0;\n  //If the size is larger than than the amount left in the buffer\n  if (Size + dataBufferPos > dataBufferTotalSize) {\n    //We will only return the remaining data\n    memcpy(Buffer, dataBuffer + dataBufferPos, dataBufferTotalSize - dataBufferPos);\n    uint64 oldDataPos = dataBufferPos;\n    dataBufferPos = dataBufferTotalSize;\n    return dataBufferTotalSize - oldDataPos;\n  }\n\n  //Well... We made it here, so do a quick and simple copy\n  memcpy(Buffer, dataBuffer+dataBufferPos, Size);\n  dataBuf",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
            "lines": "66-84"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "MemIOCallback::read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "MemIOCallback::read",
            "snippet": "uint32 MemIOCallback::read(void *Buffer, size_t Size)\n{\n  if (Buffer == NULL || Size < 1)\n    return 0;\n  //If the size is larger than than the amount left in the buffer\n  if (Size + dataBufferPos > dataBufferTotalSize) {\n    //We will only return the remaining data\n    memcpy(Buffer, dataBuffer + dataBufferPos, dataBufferTotalSize - dataBufferPos);\n    uint64 oldDataPos = dataBufferPos;\n    dataBufferPos = dataBufferTotalSize;\n    return dataBufferTotalSize - oldDataPos;\n  }\n\n  //Well... We made it here, so do a quick and simple copy\n  memcpy(Buffer, dataBuffer+dataBufferPos, Size);\n  dataBuf",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
            "lines": "66-84"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "MemIOCallback::read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "MemIOCallback::read",
            "snippet": "uint32 MemIOCallback::read(void *Buffer, size_t Size)\n{\n  if (Buffer == NULL || Size < 1)\n    return 0;\n  //If the size is larger than than the amount left in the buffer\n  if (Size + dataBufferPos > dataBufferTotalSize) {\n    //We will only return the remaining data\n    memcpy(Buffer, dataBuffer + dataBufferPos, dataBufferTotalSize - dataBufferPos);\n    uint64 oldDataPos = dataBufferPos;\n    dataBufferPos = dataBufferTotalSize;\n    return dataBufferTotalSize - oldDataPos;\n  }\n\n  //Well... We made it here, so do a quick and simple copy\n  memcpy(Buffer, dataBuffer+dataBufferPos, Size);\n  dataBuf",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
            "lines": "66-84"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "MemIOCallback::read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "MemIOCallback::read",
            "snippet": "uint32 MemIOCallback::read(void *Buffer, size_t Size)\n{\n  if (Buffer == NULL || Size < 1)\n    return 0;\n  //If the size is larger than than the amount left in the buffer\n  if (Size + dataBufferPos > dataBufferTotalSize) {\n    //We will only return the remaining data\n    memcpy(Buffer, dataBuffer + dataBufferPos, dataBufferTotalSize - dataBufferPos);\n    uint64 oldDataPos = dataBufferPos;\n    dataBufferPos = dataBufferTotalSize;\n    return dataBufferTotalSize - oldDataPos;\n  }\n\n  //Well... We made it here, so do a quick and simple copy\n  memcpy(Buffer, dataBuffer+dataBufferPos, Size);\n  dataBuf",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
            "lines": "66-84"
          }
        ]
      }
    ]
  },
  {
    "target_function": "MemIOCallback::~MemIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
    "lines": "60-64",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "MemIOCallback::~MemIOCallback"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "MemIOCallback::~MemIOCallback",
            "snippet": "MemIOCallback::~MemIOCallback()\n{\n  if (dataBuffer != NULL)\n    free(dataBuffer);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
            "lines": "60-64"
          }
        ]
      }
    ]
  },
  {
    "target_function": "MemIOCallback::MemIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
    "lines": "39-58",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "MemIOCallback::MemIOCallback"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "MemIOCallback::MemIOCallback",
            "snippet": "START_LIBEBML_NAMESPACE\n\nMemIOCallback::MemIOCallback(uint64 DefaultSize)\n{\n  //The default size of the buffer is 128 bytes\n  dataBuffer = (binary *)malloc(DefaultSize);\n  if (dataBuffer == NULL) {\n    mOk = false;\n    std::stringstream Msg;\n    Msg << \"Failed to alloc memory block of size \";\n    // not working with VC6    Msg << DefaultSize;\n    mLastErrorStr = Msg.str();\n    return;\n  }\n\n  dataBufferMemorySize = DefaultSize;\n  dataBufferPos = 0;\n  dataBufferTotalSize = 0;\n  mOk = true;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemIOCallback.cpp",
            "lines": "39-58"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlVoid::Overwrite",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
    "lines": "99-135",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::VoidMe",
          "EbmlVoid::Overwrite"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlElement::VoidMe",
            "snippet": "uint64 EbmlElement::VoidMe(IOCallback & output, bool bWithDefault)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  EbmlVoid Dummy;\n  return Dummy.Overwrite(*this, output, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "694-702"
          },
          {
            "qualified_name": "EbmlVoid::Overwrite",
            "snippet": "uint64 EbmlVoid::Overwrite(const EbmlElement & EltToVoid, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  //  EltToVoid.UpdateSize(bWithDefault);\n  if (EltToVoid.GetElementPosition() == 0) {\n    // this element has never been written\n    return 0;\n  }\n  if (EltToVoid.GetSize() + EltToVoid.HeadSize() <2) {\n    // the element can't be written here !\n    return 0;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePointer(EltToVoid.GetElementPosition());\n\n  // compute the size of the voided data based on the original one\n  SetSize(EltToVoid.GetSize() + E",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "99-135"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlVoid::ReplaceWith",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
    "lines": "62-97",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlVoid::RenderData",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
    "lines": "48-60",
    "num_chains": 3,
    "chains": [
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlVoid::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlVoid::RenderData",
            "snippet": "filepos_t EbmlVoid::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  // write dummy data by 4KB chunks\n  static binary DummyBuf[4*1024];\n\n  uint64 SizeToWrite = GetSize();\n  while (SizeToWrite > 4*1024) {\n    output.writeFully(DummyBuf, 4*1024);\n    SizeToWrite -= 4*1024;\n  }\n  output.writeFully(DummyBuf, SizeToWrite);\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "48-60"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlVoid::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlVoid::RenderData",
            "snippet": "filepos_t EbmlVoid::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  // write dummy data by 4KB chunks\n  static binary DummyBuf[4*1024];\n\n  uint64 SizeToWrite = GetSize();\n  while (SizeToWrite > 4*1024) {\n    output.writeFully(DummyBuf, 4*1024);\n    SizeToWrite -= 4*1024;\n  }\n  output.writeFully(DummyBuf, SizeToWrite);\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "48-60"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlVoid::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlVoid::RenderData",
            "snippet": "filepos_t EbmlVoid::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  // write dummy data by 4KB chunks\n  static binary DummyBuf[4*1024];\n\n  uint64 SizeToWrite = GetSize();\n  while (SizeToWrite > 4*1024) {\n    output.writeFully(DummyBuf, 4*1024);\n    SizeToWrite -= 4*1024;\n  }\n  output.writeFully(DummyBuf, SizeToWrite);\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "48-60"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlVoid::EbmlVoid",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
    "lines": "43-46",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlVoid::EbmlVoid"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::EbmlVoid",
            "snippet": "EbmlVoid::EbmlVoid()\n{\n  SetValueIsSet();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "43-46"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlString::ReadData",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
    "lines": "145-169",
    "num_chains": 5,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlString::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlString::ReadData",
            "snippet": "filepos_t EbmlString::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    if (GetSize() == 0) {\n      Value = \"\";\n      SetValueIsSet();\n    } else {\n      char *Buffer = new (std::nothrow) char[GetSize() + 1];\n      if (Buffer == NULL) {\n        // unable to store the data, skip it\n        input.setFilePointer(GetSize(), seek_current);\n      } else {\n        input.readFully(Buffer, GetSize());\n        if (Buffer[GetSize()-1] != '\\0') {\n          Buffer[GetSize()] = '\\0';\n        }\n        Value = Buffer;\n        delete [] Buffer;\n        SetValueIsSet()",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
            "lines": "145-169"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlString::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlString::ReadData",
            "snippet": "filepos_t EbmlString::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    if (GetSize() == 0) {\n      Value = \"\";\n      SetValueIsSet();\n    } else {\n      char *Buffer = new (std::nothrow) char[GetSize() + 1];\n      if (Buffer == NULL) {\n        // unable to store the data, skip it\n        input.setFilePointer(GetSize(), seek_current);\n      } else {\n        input.readFully(Buffer, GetSize());\n        if (Buffer[GetSize()-1] != '\\0') {\n          Buffer[GetSize()] = '\\0';\n        }\n        Value = Buffer;\n        delete [] Buffer;\n        SetValueIsSet()",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
            "lines": "145-169"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlString::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlString::ReadData",
            "snippet": "filepos_t EbmlString::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    if (GetSize() == 0) {\n      Value = \"\";\n      SetValueIsSet();\n    } else {\n      char *Buffer = new (std::nothrow) char[GetSize() + 1];\n      if (Buffer == NULL) {\n        // unable to store the data, skip it\n        input.setFilePointer(GetSize(), seek_current);\n      } else {\n        input.readFully(Buffer, GetSize());\n        if (Buffer[GetSize()-1] != '\\0') {\n          Buffer[GetSize()] = '\\0';\n        }\n        Value = Buffer;\n        delete [] Buffer;\n        SetValueIsSet()",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
            "lines": "145-169"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlString::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlString::ReadData",
            "snippet": "filepos_t EbmlString::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    if (GetSize() == 0) {\n      Value = \"\";\n      SetValueIsSet();\n    } else {\n      char *Buffer = new (std::nothrow) char[GetSize() + 1];\n      if (Buffer == NULL) {\n        // unable to store the data, skip it\n        input.setFilePointer(GetSize(), seek_current);\n      } else {\n        input.readFully(Buffer, GetSize());\n        if (Buffer[GetSize()-1] != '\\0') {\n          Buffer[GetSize()] = '\\0';\n        }\n        Value = Buffer;\n        delete [] Buffer;\n        SetValueIsSet()",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
            "lines": "145-169"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlString::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlString::ReadData",
            "snippet": "filepos_t EbmlString::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    if (GetSize() == 0) {\n      Value = \"\";\n      SetValueIsSet();\n    } else {\n      char *Buffer = new (std::nothrow) char[GetSize() + 1];\n      if (Buffer == NULL) {\n        // unable to store the data, skip it\n        input.setFilePointer(GetSize(), seek_current);\n      } else {\n        input.readFully(Buffer, GetSize());\n        if (Buffer[GetSize()-1] != '\\0') {\n          Buffer[GetSize()] = '\\0';\n        }\n        Value = Buffer;\n        delete [] Buffer;\n        SetValueIsSet()",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
            "lines": "145-169"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlString::UpdateSize",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
    "lines": "132-143",
    "num_chains": 10,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::WriteHead",
          "EbmlElement::RenderHead",
          "EbmlString::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::WriteHead",
            "snippet": "filepos_t EbmlMaster::WriteHead(IOCallback & output, int nSizeLength, bool bWithDefault)\n{\n  SetSizeLength(nSizeLength);\n  return RenderHead(output, false, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "161-165"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlString::UpdateSize",
            "snippet": "uint64 EbmlString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value.length() < GetDefaultSize()) {\n    SetSize_(GetDefaultSize());\n  } else {\n    SetSize_(Value.length());\n  }\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
            "lines": "132-143"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlString::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlString::UpdateSize",
            "snippet": "uint64 EbmlString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value.length() < GetDefaultSize()) {\n    SetSize_(GetDefaultSize());\n  } else {\n    SetSize_(Value.length());\n  }\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
            "lines": "132-143"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlString::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlString::UpdateSize",
            "snippet": "uint64 EbmlString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value.length() < GetDefaultSize()) {\n    SetSize_(GetDefaultSize());\n  } else {\n    SetSize_(Value.length());\n  }\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
            "lines": "132-143"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlString::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlString::UpdateSize",
            "snippet": "uint64 EbmlString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value.length() < GetDefaultSize()) {\n    SetSize_(GetDefaultSize());\n  } else {\n    SetSize_(Value.length());\n  }\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
            "lines": "132-143"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlElement::VoidMe",
          "EbmlVoid::Overwrite",
          "EbmlElement::RenderHead",
          "EbmlString::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlElement::VoidMe",
            "snippet": "uint64 EbmlElement::VoidMe(IOCallback & output, bool bWithDefault)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  EbmlVoid Dummy;\n  return Dummy.Overwrite(*this, output, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "694-702"
          },
          {
            "qualified_name": "EbmlVoid::Overwrite",
            "snippet": "uint64 EbmlVoid::Overwrite(const EbmlElement & EltToVoid, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  //  EltToVoid.UpdateSize(bWithDefault);\n  if (EltToVoid.GetElementPosition() == 0) {\n    // this element has never been written\n    return 0;\n  }\n  if (EltToVoid.GetSize() + EltToVoid.HeadSize() <2) {\n    // the element can't be written here !\n    return 0;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePointer(EltToVoid.GetElementPosition());\n\n  // compute the size of the voided data based on the original one\n  SetSize(EltToVoid.GetSize() + E",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "99-135"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlString::UpdateSize",
            "snippet": "uint64 EbmlString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value.length() < GetDefaultSize()) {\n    SetSize_(GetDefaultSize());\n  } else {\n    SetSize_(Value.length());\n  }\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
            "lines": "132-143"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::RenderHead",
          "EbmlString::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlString::UpdateSize",
            "snippet": "uint64 EbmlString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value.length() < GetDefaultSize()) {\n    SetSize_(GetDefaultSize());\n  } else {\n    SetSize_(Value.length());\n  }\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
            "lines": "132-143"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlString::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlString::UpdateSize",
            "snippet": "uint64 EbmlString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value.length() < GetDefaultSize()) {\n    SetSize_(GetDefaultSize());\n  } else {\n    SetSize_(Value.length());\n  }\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
            "lines": "132-143"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlString::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlString::UpdateSize",
            "snippet": "uint64 EbmlString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value.length() < GetDefaultSize()) {\n    SetSize_(GetDefaultSize());\n  } else {\n    SetSize_(Value.length());\n  }\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
            "lines": "132-143"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlString::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlString::UpdateSize",
            "snippet": "uint64 EbmlString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value.length() < GetDefaultSize()) {\n    SetSize_(GetDefaultSize());\n  } else {\n    SetSize_(Value.length());\n  }\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
            "lines": "132-143"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlString::UpdateSize"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlString::UpdateSize",
            "snippet": "uint64 EbmlString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value.length() < GetDefaultSize()) {\n    SetSize_(GetDefaultSize());\n  } else {\n    SetSize_(Value.length());\n  }\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
            "lines": "132-143"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlString::GetValue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
    "lines": "128-130",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlString::GetValue"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlString::GetValue",
            "snippet": "std::string EbmlString::GetValue() const {\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
            "lines": "128-130"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlString::RenderData",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
    "lines": "90-109",
    "num_chains": 3,
    "chains": [
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlString::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlString::RenderData",
            "snippet": "filepos_t EbmlString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  filepos_t Result;\n  output.writeFully(Value.c_str(), Value.length());\n  Result = Value.length();\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad == NULL) {\n      return Result;\n    }\n    memset(Pad, 0x00, GetDefaultSize() - Result);\n    output.writeFully(Pad, GetDefaultSize() - Result);\n    Result = GetDefaultSize();\n    delete [] Pad;\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
            "lines": "90-109"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlString::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlString::RenderData",
            "snippet": "filepos_t EbmlString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  filepos_t Result;\n  output.writeFully(Value.c_str(), Value.length());\n  Result = Value.length();\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad == NULL) {\n      return Result;\n    }\n    memset(Pad, 0x00, GetDefaultSize() - Result);\n    output.writeFully(Pad, GetDefaultSize() - Result);\n    Result = GetDefaultSize();\n    delete [] Pad;\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
            "lines": "90-109"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlString::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlString::RenderData",
            "snippet": "filepos_t EbmlString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  filepos_t Result;\n  output.writeFully(Value.c_str(), Value.length());\n  Result = Value.length();\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad == NULL) {\n      return Result;\n    }\n    memset(Pad, 0x00, GetDefaultSize() - Result);\n    output.writeFully(Pad, GetDefaultSize() - Result);\n    Result = GetDefaultSize();\n    delete [] Pad;\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
            "lines": "90-109"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlString::SetDefaultValue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
    "lines": "73-78",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlString::SetDefaultValue"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlString::SetDefaultValue",
            "snippet": "void EbmlString::SetDefaultValue(std::string & aValue)\n{\n  assert(!DefaultISset());\n  DefaultValue = aValue;\n  SetDefaultIsSet();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
            "lines": "73-78"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlString::EbmlString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
    "lines": "66-71",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlString::EbmlString"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlString::EbmlString",
            "snippet": "EbmlString::EbmlString(const std::string & aDefaultValue)\n  :EbmlElement(0, true), Value(aDefaultValue), DefaultValue(aDefaultValue)\n{\n  SetDefaultSize(0);\n  SetDefaultIsSet();\n/* done automatically\n  SetSize_(Value.length());\n  if (GetDefaultSize() > GetSize())\n    SetSize_(GetDefaultSize());*/\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
            "lines": "52-61"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlString::EbmlString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
    "lines": "52-61",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlString::EbmlString"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlString::EbmlString",
            "snippet": "EbmlString::EbmlString(const std::string & aDefaultValue)\n  :EbmlElement(0, true), Value(aDefaultValue), DefaultValue(aDefaultValue)\n{\n  SetDefaultSize(0);\n  SetDefaultIsSet();\n/* done automatically\n  SetSize_(Value.length());\n  if (GetDefaultSize() > GetSize())\n    SetSize_(GetDefaultSize());*/\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlString.cpp",
            "lines": "52-61"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlDate::IsSmallerThan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlDate.cpp",
    "lines": "78-84",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::CompareElements",
          "EbmlDate::IsSmallerThan"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlElement::CompareElements",
            "snippet": "bool EbmlElement::CompareElements(const EbmlElement *A, const EbmlElement *B)\n{\n  if (EbmlId(*A) == EbmlId(*B))\n    return A->IsSmallerThan(B);\n  else\n    return false;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "648-654"
          },
          {
            "qualified_name": "EbmlDate::IsSmallerThan",
            "snippet": "bool EbmlDate::IsSmallerThan(const EbmlElement *Cmp) const\n{\n  if (EbmlId(*this) == EbmlId(*Cmp))\n    return this->myDate < static_cast<const EbmlDate *>(Cmp)->myDate;\n  else\n    return false;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlDate.cpp",
            "lines": "78-84"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlDate::RenderData",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlDate.cpp",
    "lines": "66-76",
    "num_chains": 3,
    "chains": [
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlDate::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlDate::RenderData",
            "snippet": "filepos_t EbmlDate::RenderData(IOCallback & output, bool /* bForceRender */, bool  /* bWithDefault */)\n{\n  if (GetSize() != 0) {\n    assert(GetSize() == 8);\n    big_int64 b64(myDate);\n\n    output.writeFully(&b64.endian(),GetSize());\n  }\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlDate.cpp",
            "lines": "66-76"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlDate::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlDate::RenderData",
            "snippet": "filepos_t EbmlDate::RenderData(IOCallback & output, bool /* bForceRender */, bool  /* bWithDefault */)\n{\n  if (GetSize() != 0) {\n    assert(GetSize() == 8);\n    big_int64 b64(myDate);\n\n    output.writeFully(&b64.endian(),GetSize());\n  }\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlDate.cpp",
            "lines": "66-76"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlDate::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlDate::RenderData",
            "snippet": "filepos_t EbmlDate::RenderData(IOCallback & output, bool /* bForceRender */, bool  /* bWithDefault */)\n{\n  if (GetSize() != 0) {\n    assert(GetSize() == 8);\n    big_int64 b64(myDate);\n\n    output.writeFully(&b64.endian(),GetSize());\n  }\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlDate.cpp",
            "lines": "66-76"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlDate::ReadData",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlDate.cpp",
    "lines": "48-64",
    "num_chains": 5,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlDate::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlDate::ReadData",
            "snippet": "filepos_t EbmlDate::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if ((ReadFully == SCOPE_NO_DATA) || (GetSize() == 0))\n    return GetSize();\n\n  assert(GetSize() == 8);\n  binary Buffer[8];\n  input.readFully(Buffer, GetSize());\n\n  big_int64 b64;\n  b64.Eval(Buffer);\n\n  myDate = b64;\n  SetValueIsSet();\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlDate.cpp",
            "lines": "48-64"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlDate::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlDate::ReadData",
            "snippet": "filepos_t EbmlDate::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if ((ReadFully == SCOPE_NO_DATA) || (GetSize() == 0))\n    return GetSize();\n\n  assert(GetSize() == 8);\n  binary Buffer[8];\n  input.readFully(Buffer, GetSize());\n\n  big_int64 b64;\n  b64.Eval(Buffer);\n\n  myDate = b64;\n  SetValueIsSet();\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlDate.cpp",
            "lines": "48-64"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlDate::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlDate::ReadData",
            "snippet": "filepos_t EbmlDate::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if ((ReadFully == SCOPE_NO_DATA) || (GetSize() == 0))\n    return GetSize();\n\n  assert(GetSize() == 8);\n  binary Buffer[8];\n  input.readFully(Buffer, GetSize());\n\n  big_int64 b64;\n  b64.Eval(Buffer);\n\n  myDate = b64;\n  SetValueIsSet();\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlDate.cpp",
            "lines": "48-64"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlDate::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlDate::ReadData",
            "snippet": "filepos_t EbmlDate::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if ((ReadFully == SCOPE_NO_DATA) || (GetSize() == 0))\n    return GetSize();\n\n  assert(GetSize() == 8);\n  binary Buffer[8];\n  input.readFully(Buffer, GetSize());\n\n  big_int64 b64;\n  b64.Eval(Buffer);\n\n  myDate = b64;\n  SetValueIsSet();\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlDate.cpp",
            "lines": "48-64"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlDate::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlDate::ReadData",
            "snippet": "filepos_t EbmlDate::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if ((ReadFully == SCOPE_NO_DATA) || (GetSize() == 0))\n    return GetSize();\n\n  assert(GetSize() == 8);\n  binary Buffer[8];\n  input.readFully(Buffer, GetSize());\n\n  big_int64 b64;\n  b64.Eval(Buffer);\n\n  myDate = b64;\n  SetValueIsSet();\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlDate.cpp",
            "lines": "48-64"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlDate::EbmlDate",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlDate.cpp",
    "lines": "42-46",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlDate::EbmlDate"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlDate::EbmlDate",
            "snippet": "EbmlDate::EbmlDate(const EbmlDate & ElementToClone)\n:EbmlElement(ElementToClone)\n{\n  myDate = ElementToClone.myDate;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlDate.cpp",
            "lines": "42-46"
          }
        ]
      }
    ]
  },
  {
    "target_function": "ADbg::unsetDebugFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
    "lines": "220-236",
    "num_chains": 2,
    "chains": [
      {
        "call_sequence": [
          "ADbg::setDebugFile",
          "ADbg::unsetDebugFile"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "ADbg::setDebugFile",
            "snippet": "bool ADbg::setDebugFile(const char * NewFilename) {\n  bool result;\n  result = unsetDebugFile();\n\n  if (!result)\n    return false;\n\n  result = false;\n\n#ifdef WIN32\n  hFile = CreateFileA(NewFilename, GENERIC_WRITE, FILE_SHARE_WRITE|FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );\n\n  if (hFile != INVALID_HANDLE_VALUE) {\n    SetFilePointer( hFile, 0, 0, FILE_END );\n\n    result = true;\n  }\n#else\n  hFile = fopen(NewFilename, \"w+\");\n  if (hFile != NULL) {\n    fseek(hFile, 0, SEEK_END);\n    result = true;\n  }\n#endif\n  if (result)\n    OutPut(-1,\"Debug hFile Opening succeeded\");\n\n  els",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "187-218"
          },
          {
            "qualified_name": "ADbg::unsetDebugFile",
            "snippet": "bool ADbg::unsetDebugFile() {\n  bool result = (hFile == NULL);\n  if (result)\n    return true;\n\n#ifdef WIN32\n  result = (CloseHandle(hFile) != 0);\n#else\n  result = (fclose(hFile) == 0);\n#endif\n\n  if (result) {\n    OutPut(-1,\"Debug hFile Closing succeeded\");\n    hFile = NULL;\n  }\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "220-236"
          }
        ]
      },
      {
        "call_sequence": [
          "ADbg::~ADbg",
          "ADbg::unsetDebugFile"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "ADbg::~ADbg",
            "snippet": "ADbg::~ADbg()\n{\n  unsetDebugFile();\n  OutPut(-1,\"ADbg Deletion (0x%08X)\",this);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "69-73"
          },
          {
            "qualified_name": "ADbg::unsetDebugFile",
            "snippet": "bool ADbg::unsetDebugFile() {\n  bool result = (hFile == NULL);\n  if (result)\n    return true;\n\n#ifdef WIN32\n  result = (CloseHandle(hFile) != 0);\n#else\n  result = (fclose(hFile) == 0);\n#endif\n\n  if (result) {\n    OutPut(-1,\"Debug hFile Closing succeeded\");\n    hFile = NULL;\n  }\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "220-236"
          }
        ]
      }
    ]
  },
  {
    "target_function": "ADbg::setDebugFile",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
    "lines": "187-218",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "ADbg::setDebugFile"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "ADbg::setDebugFile",
            "snippet": "bool ADbg::setDebugFile(const char * NewFilename) {\n  bool result;\n  result = unsetDebugFile();\n\n  if (!result)\n    return false;\n\n  result = false;\n\n#ifdef WIN32\n  hFile = CreateFileA(NewFilename, GENERIC_WRITE, FILE_SHARE_WRITE|FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );\n\n  if (hFile != INVALID_HANDLE_VALUE) {\n    SetFilePointer( hFile, 0, 0, FILE_END );\n\n    result = true;\n  }\n#else\n  hFile = fopen(NewFilename, \"w+\");\n  if (hFile != NULL) {\n    fseek(hFile, 0, SEEK_END);\n    result = true;\n  }\n#endif\n  if (result)\n    OutPut(-1,\"Debug hFile Opening succeeded\");\n\n  els",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "187-218"
          }
        ]
      }
    ]
  },
  {
    "target_function": "ADbg::OutPut",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
    "lines": "178-185",
    "num_chains": 5,
    "chains": [
      {
        "call_sequence": [
          "ADbg::setDebugFile",
          "ADbg::unsetDebugFile",
          "ADbg::OutPut"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "ADbg::setDebugFile",
            "snippet": "bool ADbg::setDebugFile(const char * NewFilename) {\n  bool result;\n  result = unsetDebugFile();\n\n  if (!result)\n    return false;\n\n  result = false;\n\n#ifdef WIN32\n  hFile = CreateFileA(NewFilename, GENERIC_WRITE, FILE_SHARE_WRITE|FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );\n\n  if (hFile != INVALID_HANDLE_VALUE) {\n    SetFilePointer( hFile, 0, 0, FILE_END );\n\n    result = true;\n  }\n#else\n  hFile = fopen(NewFilename, \"w+\");\n  if (hFile != NULL) {\n    fseek(hFile, 0, SEEK_END);\n    result = true;\n  }\n#endif\n  if (result)\n    OutPut(-1,\"Debug hFile Opening succeeded\");\n\n  els",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "187-218"
          },
          {
            "qualified_name": "ADbg::unsetDebugFile",
            "snippet": "bool ADbg::unsetDebugFile() {\n  bool result = (hFile == NULL);\n  if (result)\n    return true;\n\n#ifdef WIN32\n  result = (CloseHandle(hFile) != 0);\n#else\n  result = (fclose(hFile) == 0);\n#endif\n\n  if (result) {\n    OutPut(-1,\"Debug hFile Closing succeeded\");\n    hFile = NULL;\n  }\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "220-236"
          },
          {
            "qualified_name": "ADbg::OutPut",
            "snippet": "int ADbg::OutPut(int forLevel, const char * format,...) const\n{\n  int result=0;\n\n  if (forLevel >= my_level) {\n    va_list tstlist;\n\n    va_start(tstlist, format);\n\n    result = _OutPut(format,tstlist);\n\n  }\n\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "162-176"
          }
        ]
      },
      {
        "call_sequence": [
          "ADbg::~ADbg",
          "ADbg::unsetDebugFile",
          "ADbg::OutPut"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "ADbg::~ADbg",
            "snippet": "ADbg::~ADbg()\n{\n  unsetDebugFile();\n  OutPut(-1,\"ADbg Deletion (0x%08X)\",this);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "69-73"
          },
          {
            "qualified_name": "ADbg::unsetDebugFile",
            "snippet": "bool ADbg::unsetDebugFile() {\n  bool result = (hFile == NULL);\n  if (result)\n    return true;\n\n#ifdef WIN32\n  result = (CloseHandle(hFile) != 0);\n#else\n  result = (fclose(hFile) == 0);\n#endif\n\n  if (result) {\n    OutPut(-1,\"Debug hFile Closing succeeded\");\n    hFile = NULL;\n  }\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "220-236"
          },
          {
            "qualified_name": "ADbg::OutPut",
            "snippet": "int ADbg::OutPut(int forLevel, const char * format,...) const\n{\n  int result=0;\n\n  if (forLevel >= my_level) {\n    va_list tstlist;\n\n    va_start(tstlist, format);\n\n    result = _OutPut(format,tstlist);\n\n  }\n\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "162-176"
          }
        ]
      },
      {
        "call_sequence": [
          "ADbg::setDebugFile",
          "ADbg::OutPut"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "ADbg::setDebugFile",
            "snippet": "bool ADbg::setDebugFile(const char * NewFilename) {\n  bool result;\n  result = unsetDebugFile();\n\n  if (!result)\n    return false;\n\n  result = false;\n\n#ifdef WIN32\n  hFile = CreateFileA(NewFilename, GENERIC_WRITE, FILE_SHARE_WRITE|FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );\n\n  if (hFile != INVALID_HANDLE_VALUE) {\n    SetFilePointer( hFile, 0, 0, FILE_END );\n\n    result = true;\n  }\n#else\n  hFile = fopen(NewFilename, \"w+\");\n  if (hFile != NULL) {\n    fseek(hFile, 0, SEEK_END);\n    result = true;\n  }\n#endif\n  if (result)\n    OutPut(-1,\"Debug hFile Opening succeeded\");\n\n  els",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "187-218"
          },
          {
            "qualified_name": "ADbg::OutPut",
            "snippet": "int ADbg::OutPut(int forLevel, const char * format,...) const\n{\n  int result=0;\n\n  if (forLevel >= my_level) {\n    va_list tstlist;\n\n    va_start(tstlist, format);\n\n    result = _OutPut(format,tstlist);\n\n  }\n\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "162-176"
          }
        ]
      },
      {
        "call_sequence": [
          "ADbg::~ADbg",
          "ADbg::OutPut"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "ADbg::~ADbg",
            "snippet": "ADbg::~ADbg()\n{\n  unsetDebugFile();\n  OutPut(-1,\"ADbg Deletion (0x%08X)\",this);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "69-73"
          },
          {
            "qualified_name": "ADbg::OutPut",
            "snippet": "int ADbg::OutPut(int forLevel, const char * format,...) const\n{\n  int result=0;\n\n  if (forLevel >= my_level) {\n    va_list tstlist;\n\n    va_start(tstlist, format);\n\n    result = _OutPut(format,tstlist);\n\n  }\n\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "162-176"
          }
        ]
      },
      {
        "call_sequence": [
          "ADbg::ADbg",
          "ADbg::OutPut"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "ADbg::ADbg",
            "snippet": "ADbg::ADbg(int level)\n  :my_level(level)\n  ,my_time_included(false)\n  ,my_use_file(false)\n  ,my_debug_output(true)\n  ,hFile(NULL)\n{\n  prefix[0] = '\\0';\n  OutPut(-1,\"ADbg Creation at debug level = %d (0x%08X)\",my_level,this);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "58-67"
          },
          {
            "qualified_name": "ADbg::OutPut",
            "snippet": "int ADbg::OutPut(int forLevel, const char * format,...) const\n{\n  int result=0;\n\n  if (forLevel >= my_level) {\n    va_list tstlist;\n\n    va_start(tstlist, format);\n\n    result = _OutPut(format,tstlist);\n\n  }\n\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "162-176"
          }
        ]
      }
    ]
  },
  {
    "target_function": "ADbg::OutPut",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
    "lines": "162-176",
    "num_chains": 5,
    "chains": [
      {
        "call_sequence": [
          "ADbg::setDebugFile",
          "ADbg::unsetDebugFile",
          "ADbg::OutPut"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "ADbg::setDebugFile",
            "snippet": "bool ADbg::setDebugFile(const char * NewFilename) {\n  bool result;\n  result = unsetDebugFile();\n\n  if (!result)\n    return false;\n\n  result = false;\n\n#ifdef WIN32\n  hFile = CreateFileA(NewFilename, GENERIC_WRITE, FILE_SHARE_WRITE|FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );\n\n  if (hFile != INVALID_HANDLE_VALUE) {\n    SetFilePointer( hFile, 0, 0, FILE_END );\n\n    result = true;\n  }\n#else\n  hFile = fopen(NewFilename, \"w+\");\n  if (hFile != NULL) {\n    fseek(hFile, 0, SEEK_END);\n    result = true;\n  }\n#endif\n  if (result)\n    OutPut(-1,\"Debug hFile Opening succeeded\");\n\n  els",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "187-218"
          },
          {
            "qualified_name": "ADbg::unsetDebugFile",
            "snippet": "bool ADbg::unsetDebugFile() {\n  bool result = (hFile == NULL);\n  if (result)\n    return true;\n\n#ifdef WIN32\n  result = (CloseHandle(hFile) != 0);\n#else\n  result = (fclose(hFile) == 0);\n#endif\n\n  if (result) {\n    OutPut(-1,\"Debug hFile Closing succeeded\");\n    hFile = NULL;\n  }\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "220-236"
          },
          {
            "qualified_name": "ADbg::OutPut",
            "snippet": "int ADbg::OutPut(int forLevel, const char * format,...) const\n{\n  int result=0;\n\n  if (forLevel >= my_level) {\n    va_list tstlist;\n\n    va_start(tstlist, format);\n\n    result = _OutPut(format,tstlist);\n\n  }\n\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "162-176"
          }
        ]
      },
      {
        "call_sequence": [
          "ADbg::~ADbg",
          "ADbg::unsetDebugFile",
          "ADbg::OutPut"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "ADbg::~ADbg",
            "snippet": "ADbg::~ADbg()\n{\n  unsetDebugFile();\n  OutPut(-1,\"ADbg Deletion (0x%08X)\",this);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "69-73"
          },
          {
            "qualified_name": "ADbg::unsetDebugFile",
            "snippet": "bool ADbg::unsetDebugFile() {\n  bool result = (hFile == NULL);\n  if (result)\n    return true;\n\n#ifdef WIN32\n  result = (CloseHandle(hFile) != 0);\n#else\n  result = (fclose(hFile) == 0);\n#endif\n\n  if (result) {\n    OutPut(-1,\"Debug hFile Closing succeeded\");\n    hFile = NULL;\n  }\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "220-236"
          },
          {
            "qualified_name": "ADbg::OutPut",
            "snippet": "int ADbg::OutPut(int forLevel, const char * format,...) const\n{\n  int result=0;\n\n  if (forLevel >= my_level) {\n    va_list tstlist;\n\n    va_start(tstlist, format);\n\n    result = _OutPut(format,tstlist);\n\n  }\n\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "162-176"
          }
        ]
      },
      {
        "call_sequence": [
          "ADbg::setDebugFile",
          "ADbg::OutPut"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "ADbg::setDebugFile",
            "snippet": "bool ADbg::setDebugFile(const char * NewFilename) {\n  bool result;\n  result = unsetDebugFile();\n\n  if (!result)\n    return false;\n\n  result = false;\n\n#ifdef WIN32\n  hFile = CreateFileA(NewFilename, GENERIC_WRITE, FILE_SHARE_WRITE|FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );\n\n  if (hFile != INVALID_HANDLE_VALUE) {\n    SetFilePointer( hFile, 0, 0, FILE_END );\n\n    result = true;\n  }\n#else\n  hFile = fopen(NewFilename, \"w+\");\n  if (hFile != NULL) {\n    fseek(hFile, 0, SEEK_END);\n    result = true;\n  }\n#endif\n  if (result)\n    OutPut(-1,\"Debug hFile Opening succeeded\");\n\n  els",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "187-218"
          },
          {
            "qualified_name": "ADbg::OutPut",
            "snippet": "int ADbg::OutPut(int forLevel, const char * format,...) const\n{\n  int result=0;\n\n  if (forLevel >= my_level) {\n    va_list tstlist;\n\n    va_start(tstlist, format);\n\n    result = _OutPut(format,tstlist);\n\n  }\n\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "162-176"
          }
        ]
      },
      {
        "call_sequence": [
          "ADbg::~ADbg",
          "ADbg::OutPut"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "ADbg::~ADbg",
            "snippet": "ADbg::~ADbg()\n{\n  unsetDebugFile();\n  OutPut(-1,\"ADbg Deletion (0x%08X)\",this);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "69-73"
          },
          {
            "qualified_name": "ADbg::OutPut",
            "snippet": "int ADbg::OutPut(int forLevel, const char * format,...) const\n{\n  int result=0;\n\n  if (forLevel >= my_level) {\n    va_list tstlist;\n\n    va_start(tstlist, format);\n\n    result = _OutPut(format,tstlist);\n\n  }\n\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "162-176"
          }
        ]
      },
      {
        "call_sequence": [
          "ADbg::ADbg",
          "ADbg::OutPut"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "ADbg::ADbg",
            "snippet": "ADbg::ADbg(int level)\n  :my_level(level)\n  ,my_time_included(false)\n  ,my_use_file(false)\n  ,my_debug_output(true)\n  ,hFile(NULL)\n{\n  prefix[0] = '\\0';\n  OutPut(-1,\"ADbg Creation at debug level = %d (0x%08X)\",my_level,this);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "58-67"
          },
          {
            "qualified_name": "ADbg::OutPut",
            "snippet": "int ADbg::OutPut(int forLevel, const char * format,...) const\n{\n  int result=0;\n\n  if (forLevel >= my_level) {\n    va_list tstlist;\n\n    va_start(tstlist, format);\n\n    result = _OutPut(format,tstlist);\n\n  }\n\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "162-176"
          }
        ]
      }
    ]
  },
  {
    "target_function": "ADbg::_OutPut",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
    "lines": "75-160",
    "num_chains": 5,
    "chains": [
      {
        "call_sequence": [
          "ADbg::setDebugFile",
          "ADbg::unsetDebugFile",
          "ADbg::OutPut",
          "ADbg::_OutPut"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "ADbg::setDebugFile",
            "snippet": "bool ADbg::setDebugFile(const char * NewFilename) {\n  bool result;\n  result = unsetDebugFile();\n\n  if (!result)\n    return false;\n\n  result = false;\n\n#ifdef WIN32\n  hFile = CreateFileA(NewFilename, GENERIC_WRITE, FILE_SHARE_WRITE|FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );\n\n  if (hFile != INVALID_HANDLE_VALUE) {\n    SetFilePointer( hFile, 0, 0, FILE_END );\n\n    result = true;\n  }\n#else\n  hFile = fopen(NewFilename, \"w+\");\n  if (hFile != NULL) {\n    fseek(hFile, 0, SEEK_END);\n    result = true;\n  }\n#endif\n  if (result)\n    OutPut(-1,\"Debug hFile Opening succeeded\");\n\n  els",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "187-218"
          },
          {
            "qualified_name": "ADbg::unsetDebugFile",
            "snippet": "bool ADbg::unsetDebugFile() {\n  bool result = (hFile == NULL);\n  if (result)\n    return true;\n\n#ifdef WIN32\n  result = (CloseHandle(hFile) != 0);\n#else\n  result = (fclose(hFile) == 0);\n#endif\n\n  if (result) {\n    OutPut(-1,\"Debug hFile Closing succeeded\");\n    hFile = NULL;\n  }\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "220-236"
          },
          {
            "qualified_name": "ADbg::OutPut",
            "snippet": "int ADbg::OutPut(int forLevel, const char * format,...) const\n{\n  int result=0;\n\n  if (forLevel >= my_level) {\n    va_list tstlist;\n\n    va_start(tstlist, format);\n\n    result = _OutPut(format,tstlist);\n\n  }\n\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "162-176"
          },
          {
            "qualified_name": "ADbg::_OutPut",
            "snippet": "inline int ADbg::_OutPut(const char * format,va_list params) const\n{\n  int result;\n\n  char tst[1000];\n  char myformat[256];\n\n#ifdef WIN32\n  if (my_time_included) {\n    SYSTEMTIME time;\n    GetSystemTime(&time);\n    if (prefix[0] == '\\0')\n      wsprintfA(myformat,\"%04d/%02d/%02d %02d:%02d:%02d.%03d UTC : %s\\r\\n\",\n                time.wYear,\n                time.wMonth,\n                time.wDay,\n                time.wHour,\n                time.wMinute,\n                time.wSecond,\n                time.wMilliseconds,\n                format);\n    else\n      wsprintfA(myformat,\"%04d/%02d/%02d %02",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "75-160"
          }
        ]
      },
      {
        "call_sequence": [
          "ADbg::~ADbg",
          "ADbg::unsetDebugFile",
          "ADbg::OutPut",
          "ADbg::_OutPut"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "ADbg::~ADbg",
            "snippet": "ADbg::~ADbg()\n{\n  unsetDebugFile();\n  OutPut(-1,\"ADbg Deletion (0x%08X)\",this);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "69-73"
          },
          {
            "qualified_name": "ADbg::unsetDebugFile",
            "snippet": "bool ADbg::unsetDebugFile() {\n  bool result = (hFile == NULL);\n  if (result)\n    return true;\n\n#ifdef WIN32\n  result = (CloseHandle(hFile) != 0);\n#else\n  result = (fclose(hFile) == 0);\n#endif\n\n  if (result) {\n    OutPut(-1,\"Debug hFile Closing succeeded\");\n    hFile = NULL;\n  }\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "220-236"
          },
          {
            "qualified_name": "ADbg::OutPut",
            "snippet": "int ADbg::OutPut(int forLevel, const char * format,...) const\n{\n  int result=0;\n\n  if (forLevel >= my_level) {\n    va_list tstlist;\n\n    va_start(tstlist, format);\n\n    result = _OutPut(format,tstlist);\n\n  }\n\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "162-176"
          },
          {
            "qualified_name": "ADbg::_OutPut",
            "snippet": "inline int ADbg::_OutPut(const char * format,va_list params) const\n{\n  int result;\n\n  char tst[1000];\n  char myformat[256];\n\n#ifdef WIN32\n  if (my_time_included) {\n    SYSTEMTIME time;\n    GetSystemTime(&time);\n    if (prefix[0] == '\\0')\n      wsprintfA(myformat,\"%04d/%02d/%02d %02d:%02d:%02d.%03d UTC : %s\\r\\n\",\n                time.wYear,\n                time.wMonth,\n                time.wDay,\n                time.wHour,\n                time.wMinute,\n                time.wSecond,\n                time.wMilliseconds,\n                format);\n    else\n      wsprintfA(myformat,\"%04d/%02d/%02d %02",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "75-160"
          }
        ]
      },
      {
        "call_sequence": [
          "ADbg::setDebugFile",
          "ADbg::OutPut",
          "ADbg::_OutPut"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "ADbg::setDebugFile",
            "snippet": "bool ADbg::setDebugFile(const char * NewFilename) {\n  bool result;\n  result = unsetDebugFile();\n\n  if (!result)\n    return false;\n\n  result = false;\n\n#ifdef WIN32\n  hFile = CreateFileA(NewFilename, GENERIC_WRITE, FILE_SHARE_WRITE|FILE_SHARE_READ, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );\n\n  if (hFile != INVALID_HANDLE_VALUE) {\n    SetFilePointer( hFile, 0, 0, FILE_END );\n\n    result = true;\n  }\n#else\n  hFile = fopen(NewFilename, \"w+\");\n  if (hFile != NULL) {\n    fseek(hFile, 0, SEEK_END);\n    result = true;\n  }\n#endif\n  if (result)\n    OutPut(-1,\"Debug hFile Opening succeeded\");\n\n  els",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "187-218"
          },
          {
            "qualified_name": "ADbg::OutPut",
            "snippet": "int ADbg::OutPut(int forLevel, const char * format,...) const\n{\n  int result=0;\n\n  if (forLevel >= my_level) {\n    va_list tstlist;\n\n    va_start(tstlist, format);\n\n    result = _OutPut(format,tstlist);\n\n  }\n\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "162-176"
          },
          {
            "qualified_name": "ADbg::_OutPut",
            "snippet": "inline int ADbg::_OutPut(const char * format,va_list params) const\n{\n  int result;\n\n  char tst[1000];\n  char myformat[256];\n\n#ifdef WIN32\n  if (my_time_included) {\n    SYSTEMTIME time;\n    GetSystemTime(&time);\n    if (prefix[0] == '\\0')\n      wsprintfA(myformat,\"%04d/%02d/%02d %02d:%02d:%02d.%03d UTC : %s\\r\\n\",\n                time.wYear,\n                time.wMonth,\n                time.wDay,\n                time.wHour,\n                time.wMinute,\n                time.wSecond,\n                time.wMilliseconds,\n                format);\n    else\n      wsprintfA(myformat,\"%04d/%02d/%02d %02",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "75-160"
          }
        ]
      },
      {
        "call_sequence": [
          "ADbg::~ADbg",
          "ADbg::OutPut",
          "ADbg::_OutPut"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "ADbg::~ADbg",
            "snippet": "ADbg::~ADbg()\n{\n  unsetDebugFile();\n  OutPut(-1,\"ADbg Deletion (0x%08X)\",this);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "69-73"
          },
          {
            "qualified_name": "ADbg::OutPut",
            "snippet": "int ADbg::OutPut(int forLevel, const char * format,...) const\n{\n  int result=0;\n\n  if (forLevel >= my_level) {\n    va_list tstlist;\n\n    va_start(tstlist, format);\n\n    result = _OutPut(format,tstlist);\n\n  }\n\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "162-176"
          },
          {
            "qualified_name": "ADbg::_OutPut",
            "snippet": "inline int ADbg::_OutPut(const char * format,va_list params) const\n{\n  int result;\n\n  char tst[1000];\n  char myformat[256];\n\n#ifdef WIN32\n  if (my_time_included) {\n    SYSTEMTIME time;\n    GetSystemTime(&time);\n    if (prefix[0] == '\\0')\n      wsprintfA(myformat,\"%04d/%02d/%02d %02d:%02d:%02d.%03d UTC : %s\\r\\n\",\n                time.wYear,\n                time.wMonth,\n                time.wDay,\n                time.wHour,\n                time.wMinute,\n                time.wSecond,\n                time.wMilliseconds,\n                format);\n    else\n      wsprintfA(myformat,\"%04d/%02d/%02d %02",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "75-160"
          }
        ]
      },
      {
        "call_sequence": [
          "ADbg::ADbg",
          "ADbg::OutPut",
          "ADbg::_OutPut"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "ADbg::ADbg",
            "snippet": "ADbg::ADbg(int level)\n  :my_level(level)\n  ,my_time_included(false)\n  ,my_use_file(false)\n  ,my_debug_output(true)\n  ,hFile(NULL)\n{\n  prefix[0] = '\\0';\n  OutPut(-1,\"ADbg Creation at debug level = %d (0x%08X)\",my_level,this);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "58-67"
          },
          {
            "qualified_name": "ADbg::OutPut",
            "snippet": "int ADbg::OutPut(int forLevel, const char * format,...) const\n{\n  int result=0;\n\n  if (forLevel >= my_level) {\n    va_list tstlist;\n\n    va_start(tstlist, format);\n\n    result = _OutPut(format,tstlist);\n\n  }\n\n  return result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "162-176"
          },
          {
            "qualified_name": "ADbg::_OutPut",
            "snippet": "inline int ADbg::_OutPut(const char * format,va_list params) const\n{\n  int result;\n\n  char tst[1000];\n  char myformat[256];\n\n#ifdef WIN32\n  if (my_time_included) {\n    SYSTEMTIME time;\n    GetSystemTime(&time);\n    if (prefix[0] == '\\0')\n      wsprintfA(myformat,\"%04d/%02d/%02d %02d:%02d:%02d.%03d UTC : %s\\r\\n\",\n                time.wYear,\n                time.wMonth,\n                time.wDay,\n                time.wHour,\n                time.wMinute,\n                time.wSecond,\n                time.wMilliseconds,\n                format);\n    else\n      wsprintfA(myformat,\"%04d/%02d/%02d %02",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "75-160"
          }
        ]
      }
    ]
  },
  {
    "target_function": "ADbg::~ADbg",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
    "lines": "69-73",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "ADbg::~ADbg"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "ADbg::~ADbg",
            "snippet": "ADbg::~ADbg()\n{\n  unsetDebugFile();\n  OutPut(-1,\"ADbg Deletion (0x%08X)\",this);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "69-73"
          }
        ]
      }
    ]
  },
  {
    "target_function": "ADbg::ADbg",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
    "lines": "58-67",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "ADbg::ADbg"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "ADbg::ADbg",
            "snippet": "ADbg::ADbg(int level)\n  :my_level(level)\n  ,my_time_included(false)\n  ,my_use_file(false)\n  ,my_debug_output(true)\n  ,hFile(NULL)\n{\n  prefix[0] = '\\0';\n  OutPut(-1,\"ADbg Creation at debug level = %d (0x%08X)\",my_level,this);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/Debug.cpp",
            "lines": "58-67"
          }
        ]
      }
    ]
  },
  {
    "target_function": "MemReadIOCallback::setFilePointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
    "lines": "81-90",
    "num_chains": 7,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::OverwriteHead",
          "MemReadIOCallback::setFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlElement::OverwriteHead",
            "snippet": "filepos_t EbmlElement::OverwriteHead(IOCallback & output, bool bKeepPosition)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n  output.setFilePointer(GetElementPosition());\n  filepos_t Result = MakeRenderHead(output, bKeepPosition);\n  output.setFilePointer(CurrentPosition);\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "681-692"
          },
          {
            "qualified_name": "MemReadIOCallback::setFilePointer",
            "snippet": "void\nMemReadIOCallback::setFilePointer(int64 Offset,\n                                  seek_mode Mode) {\n  int64 NewPosition = Mode == seek_beginning ? Offset\n                    : Mode == seek_end       ? static_cast<int64>(mEnd - mStart) + Offset\n                    :                          static_cast<int64>(mPtr - mStart) + Offset;\n\n  NewPosition = std::min<int64>(std::max<int64>(NewPosition, 0), mEnd - mStart);\n  mPtr = mStart + NewPosition;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "81-90"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::Seek",
          "MemReadIOCallback::setFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::Seek",
            "snippet": "void\nSafeReadIOCallback::Seek(size_t Offset) {\n  mIO->setFilePointer(Offset);\n  uint64 ActualPosition = mIO->getFilePointer();\n  if (ActualPosition != Offset)\n    throw EndOfStreamX(ActualPosition - Offset);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "158-164"
          },
          {
            "qualified_name": "MemReadIOCallback::setFilePointer",
            "snippet": "void\nMemReadIOCallback::setFilePointer(int64 Offset,\n                                  seek_mode Mode) {\n  int64 NewPosition = Mode == seek_beginning ? Offset\n                    : Mode == seek_end       ? static_cast<int64>(mEnd - mStart) + Offset\n                    :                          static_cast<int64>(mPtr - mStart) + Offset;\n\n  NewPosition = std::min<int64>(std::max<int64>(NewPosition, 0), mEnd - mStart);\n  mPtr = mStart + NewPosition;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "81-90"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::Skip",
          "MemReadIOCallback::setFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::Skip",
            "snippet": "void\nSafeReadIOCallback::Skip(size_t Count) {\n  int64 PrevPosition     = mIO->getFilePointer();\n  int64 ExpectedPosition = PrevPosition + Count;\n  mIO->setFilePointer(Count, seek_current);\n  int64 ActualPosition   = mIO->getFilePointer();\n\n  if (ActualPosition != ExpectedPosition)\n    throw SafeReadIOCallback::EndOfStreamX(ExpectedPosition - ActualPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "147-156"
          },
          {
            "qualified_name": "MemReadIOCallback::setFilePointer",
            "snippet": "void\nMemReadIOCallback::setFilePointer(int64 Offset,\n                                  seek_mode Mode) {\n  int64 NewPosition = Mode == seek_beginning ? Offset\n                    : Mode == seek_end       ? static_cast<int64>(mEnd - mStart) + Offset\n                    :                          static_cast<int64>(mPtr - mStart) + Offset;\n\n  NewPosition = std::min<int64>(std::max<int64>(NewPosition, 0), mEnd - mStart);\n  mPtr = mStart + NewPosition;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "81-90"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::SafeReadIOCallback",
          "SafeReadIOCallback::Init",
          "MemReadIOCallback::setFilePointer"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::SafeReadIOCallback",
            "snippet": "SafeReadIOCallback::SafeReadIOCallback(IOCallback *IO,\n                                       bool DeleteIO) {\n  Init(IO, DeleteIO);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "52-55"
          },
          {
            "qualified_name": "SafeReadIOCallback::Init",
            "snippet": "void\nSafeReadIOCallback::Init(IOCallback *IO,\n                         bool DeleteIO) {\n  mIO                = IO;\n  mDeleteIO          = DeleteIO;\n  int64 PrevPosition = IO->getFilePointer();\n  IO->setFilePointer(0, seek_end);\n  mSize              = IO->getFilePointer();\n  IO->setFilePointer(PrevPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "71-80"
          },
          {
            "qualified_name": "MemReadIOCallback::setFilePointer",
            "snippet": "void\nMemReadIOCallback::setFilePointer(int64 Offset,\n                                  seek_mode Mode) {\n  int64 NewPosition = Mode == seek_beginning ? Offset\n                    : Mode == seek_end       ? static_cast<int64>(mEnd - mStart) + Offset\n                    :                          static_cast<int64>(mPtr - mStart) + Offset;\n\n  NewPosition = std::min<int64>(std::max<int64>(NewPosition, 0), mEnd - mStart);\n  mPtr = mStart + NewPosition;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "81-90"
          }
        ]
      },
      {
        "call_sequence": [
          "MemReadIOCallback::MemReadIOCallback",
          "SafeReadIOCallback::Init",
          "MemReadIOCallback::setFilePointer"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "MemReadIOCallback::MemReadIOCallback",
            "snippet": "START_LIBEBML_NAMESPACE\n\nMemReadIOCallback::MemReadIOCallback(void const *Ptr,\n                                     size_t Size) {\n  Init(Ptr, Size);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "42-47"
          },
          {
            "qualified_name": "SafeReadIOCallback::Init",
            "snippet": "void\nSafeReadIOCallback::Init(IOCallback *IO,\n                         bool DeleteIO) {\n  mIO                = IO;\n  mDeleteIO          = DeleteIO;\n  int64 PrevPosition = IO->getFilePointer();\n  IO->setFilePointer(0, seek_end);\n  mSize              = IO->getFilePointer();\n  IO->setFilePointer(PrevPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "71-80"
          },
          {
            "qualified_name": "MemReadIOCallback::setFilePointer",
            "snippet": "void\nMemReadIOCallback::setFilePointer(int64 Offset,\n                                  seek_mode Mode) {\n  int64 NewPosition = Mode == seek_beginning ? Offset\n                    : Mode == seek_end       ? static_cast<int64>(mEnd - mStart) + Offset\n                    :                          static_cast<int64>(mPtr - mStart) + Offset;\n\n  NewPosition = std::min<int64>(std::max<int64>(NewPosition, 0), mEnd - mStart);\n  mPtr = mStart + NewPosition;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "81-90"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlElement::VoidMe",
          "EbmlVoid::Overwrite",
          "MemReadIOCallback::setFilePointer"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlElement::VoidMe",
            "snippet": "uint64 EbmlElement::VoidMe(IOCallback & output, bool bWithDefault)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  EbmlVoid Dummy;\n  return Dummy.Overwrite(*this, output, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "694-702"
          },
          {
            "qualified_name": "EbmlVoid::Overwrite",
            "snippet": "uint64 EbmlVoid::Overwrite(const EbmlElement & EltToVoid, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  //  EltToVoid.UpdateSize(bWithDefault);\n  if (EltToVoid.GetElementPosition() == 0) {\n    // this element has never been written\n    return 0;\n  }\n  if (EltToVoid.GetSize() + EltToVoid.HeadSize() <2) {\n    // the element can't be written here !\n    return 0;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePointer(EltToVoid.GetElementPosition());\n\n  // compute the size of the voided data based on the original one\n  SetSize(EltToVoid.GetSize() + E",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "99-135"
          },
          {
            "qualified_name": "MemReadIOCallback::setFilePointer",
            "snippet": "void\nMemReadIOCallback::setFilePointer(int64 Offset,\n                                  seek_mode Mode) {\n  int64 NewPosition = Mode == seek_beginning ? Offset\n                    : Mode == seek_end       ? static_cast<int64>(mEnd - mStart) + Offset\n                    :                          static_cast<int64>(mPtr - mStart) + Offset;\n\n  NewPosition = std::min<int64>(std::max<int64>(NewPosition, 0), mEnd - mStart);\n  mPtr = mStart + NewPosition;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "81-90"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "MemReadIOCallback::setFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "MemReadIOCallback::setFilePointer",
            "snippet": "void\nMemReadIOCallback::setFilePointer(int64 Offset,\n                                  seek_mode Mode) {\n  int64 NewPosition = Mode == seek_beginning ? Offset\n                    : Mode == seek_end       ? static_cast<int64>(mEnd - mStart) + Offset\n                    :                          static_cast<int64>(mPtr - mStart) + Offset;\n\n  NewPosition = std::min<int64>(std::max<int64>(NewPosition, 0), mEnd - mStart);\n  mPtr = mStart + NewPosition;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "81-90"
          }
        ]
      }
    ]
  },
  {
    "target_function": "MemReadIOCallback::read",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
    "lines": "68-79",
    "num_chains": 5,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "MemReadIOCallback::read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "MemReadIOCallback::read",
            "snippet": "uint32\nMemReadIOCallback::read(void *Buffer,\n                        size_t Size) {\n  size_t RemainingBytes = mEnd - mPtr;\n  if (RemainingBytes < Size)\n    Size = RemainingBytes;\n\n  std::memcpy(Buffer, mPtr, Size);\n  mPtr += Size;\n\n  return Size;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "68-79"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "MemReadIOCallback::read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "MemReadIOCallback::read",
            "snippet": "uint32\nMemReadIOCallback::read(void *Buffer,\n                        size_t Size) {\n  size_t RemainingBytes = mEnd - mPtr;\n  if (RemainingBytes < Size)\n    Size = RemainingBytes;\n\n  std::memcpy(Buffer, mPtr, Size);\n  mPtr += Size;\n\n  return Size;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "68-79"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "MemReadIOCallback::read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "MemReadIOCallback::read",
            "snippet": "uint32\nMemReadIOCallback::read(void *Buffer,\n                        size_t Size) {\n  size_t RemainingBytes = mEnd - mPtr;\n  if (RemainingBytes < Size)\n    Size = RemainingBytes;\n\n  std::memcpy(Buffer, mPtr, Size);\n  mPtr += Size;\n\n  return Size;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "68-79"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "MemReadIOCallback::read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "MemReadIOCallback::read",
            "snippet": "uint32\nMemReadIOCallback::read(void *Buffer,\n                        size_t Size) {\n  size_t RemainingBytes = mEnd - mPtr;\n  if (RemainingBytes < Size)\n    Size = RemainingBytes;\n\n  std::memcpy(Buffer, mPtr, Size);\n  mPtr += Size;\n\n  return Size;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "68-79"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "MemReadIOCallback::read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "MemReadIOCallback::read",
            "snippet": "uint32\nMemReadIOCallback::read(void *Buffer,\n                        size_t Size) {\n  size_t RemainingBytes = mEnd - mPtr;\n  if (RemainingBytes < Size)\n    Size = RemainingBytes;\n\n  std::memcpy(Buffer, mPtr, Size);\n  mPtr += Size;\n\n  return Size;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "68-79"
          }
        ]
      }
    ]
  },
  {
    "target_function": "MemReadIOCallback::Init",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
    "lines": "60-66",
    "num_chains": 2,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::SafeReadIOCallback",
          "MemReadIOCallback::Init"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::SafeReadIOCallback",
            "snippet": "SafeReadIOCallback::SafeReadIOCallback(IOCallback *IO,\n                                       bool DeleteIO) {\n  Init(IO, DeleteIO);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "52-55"
          },
          {
            "qualified_name": "MemReadIOCallback::Init",
            "snippet": "void\nMemReadIOCallback::Init(void const *Ptr,\n                        size_t Size) {\n  mStart = reinterpret_cast<uint8 const *>(Ptr);\n  mEnd   = mStart + Size;\n  mPtr   = mStart;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "60-66"
          }
        ]
      },
      {
        "call_sequence": [
          "MemReadIOCallback::MemReadIOCallback",
          "MemReadIOCallback::Init"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "MemReadIOCallback::MemReadIOCallback",
            "snippet": "START_LIBEBML_NAMESPACE\n\nMemReadIOCallback::MemReadIOCallback(void const *Ptr,\n                                     size_t Size) {\n  Init(Ptr, Size);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "42-47"
          },
          {
            "qualified_name": "MemReadIOCallback::Init",
            "snippet": "void\nMemReadIOCallback::Init(void const *Ptr,\n                        size_t Size) {\n  mStart = reinterpret_cast<uint8 const *>(Ptr);\n  mEnd   = mStart + Size;\n  mPtr   = mStart;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "60-66"
          }
        ]
      }
    ]
  },
  {
    "target_function": "MemReadIOCallback::~MemReadIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
    "lines": "57-58",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "MemReadIOCallback::~MemReadIOCallback"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "MemReadIOCallback::~MemReadIOCallback",
            "snippet": "MemReadIOCallback::~MemReadIOCallback() {\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "57-58"
          }
        ]
      }
    ]
  },
  {
    "target_function": "MemReadIOCallback::MemReadIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
    "lines": "53-55",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "MemReadIOCallback::MemReadIOCallback"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "MemReadIOCallback::MemReadIOCallback",
            "snippet": "START_LIBEBML_NAMESPACE\n\nMemReadIOCallback::MemReadIOCallback(void const *Ptr,\n                                     size_t Size) {\n  Init(Ptr, Size);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "42-47"
          }
        ]
      }
    ]
  },
  {
    "target_function": "MemReadIOCallback::MemReadIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
    "lines": "49-51",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "MemReadIOCallback::MemReadIOCallback"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "MemReadIOCallback::MemReadIOCallback",
            "snippet": "START_LIBEBML_NAMESPACE\n\nMemReadIOCallback::MemReadIOCallback(void const *Ptr,\n                                     size_t Size) {\n  Init(Ptr, Size);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "42-47"
          }
        ]
      }
    ]
  },
  {
    "target_function": "MemReadIOCallback::MemReadIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
    "lines": "42-47",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "MemReadIOCallback::MemReadIOCallback"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "MemReadIOCallback::MemReadIOCallback",
            "snippet": "START_LIBEBML_NAMESPACE\n\nMemReadIOCallback::MemReadIOCallback(void const *Ptr,\n                                     size_t Size) {\n  Init(Ptr, Size);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "42-47"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlBinary::operator==",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
    "lines": "101-104",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlBinary::operator=="
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlBinary::operator==",
            "snippet": "bool EbmlBinary::operator==(const EbmlBinary & ElementToCompare) const\n{\n  return ((GetSize() == ElementToCompare.GetSize()) && !memcmp(Data, ElementToCompare.Data, GetSize()));\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "101-104"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlBinary::ReadData",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
    "lines": "84-99",
    "num_chains": 5,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlBinary::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlBinary::ReadData",
            "snippet": "filepos_t EbmlBinary::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (Data != NULL)\n    free(Data);\n\n  if (ReadFully == SCOPE_NO_DATA || !GetSize()) {\n    Data = NULL;\n    return GetSize();\n  }\n\n  Data = (binary *)malloc(GetSize());\n  if (Data == NULL)\n    throw CRTError(std::string(\"Error allocating data\"));\n  SetValueIsSet();\n  return input.read(Data, GetSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "84-99"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlBinary::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlBinary::ReadData",
            "snippet": "filepos_t EbmlBinary::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (Data != NULL)\n    free(Data);\n\n  if (ReadFully == SCOPE_NO_DATA || !GetSize()) {\n    Data = NULL;\n    return GetSize();\n  }\n\n  Data = (binary *)malloc(GetSize());\n  if (Data == NULL)\n    throw CRTError(std::string(\"Error allocating data\"));\n  SetValueIsSet();\n  return input.read(Data, GetSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "84-99"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlBinary::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlBinary::ReadData",
            "snippet": "filepos_t EbmlBinary::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (Data != NULL)\n    free(Data);\n\n  if (ReadFully == SCOPE_NO_DATA || !GetSize()) {\n    Data = NULL;\n    return GetSize();\n  }\n\n  Data = (binary *)malloc(GetSize());\n  if (Data == NULL)\n    throw CRTError(std::string(\"Error allocating data\"));\n  SetValueIsSet();\n  return input.read(Data, GetSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "84-99"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlBinary::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlBinary::ReadData",
            "snippet": "filepos_t EbmlBinary::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (Data != NULL)\n    free(Data);\n\n  if (ReadFully == SCOPE_NO_DATA || !GetSize()) {\n    Data = NULL;\n    return GetSize();\n  }\n\n  Data = (binary *)malloc(GetSize());\n  if (Data == NULL)\n    throw CRTError(std::string(\"Error allocating data\"));\n  SetValueIsSet();\n  return input.read(Data, GetSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "84-99"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlBinary::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlBinary::ReadData",
            "snippet": "filepos_t EbmlBinary::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (Data != NULL)\n    free(Data);\n\n  if (ReadFully == SCOPE_NO_DATA || !GetSize()) {\n    Data = NULL;\n    return GetSize();\n  }\n\n  Data = (binary *)malloc(GetSize());\n  if (Data == NULL)\n    throw CRTError(std::string(\"Error allocating data\"));\n  SetValueIsSet();\n  return input.read(Data, GetSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "84-99"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlBinary::UpdateSize",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
    "lines": "79-82",
    "num_chains": 10,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::WriteHead",
          "EbmlElement::RenderHead",
          "EbmlBinary::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::WriteHead",
            "snippet": "filepos_t EbmlMaster::WriteHead(IOCallback & output, int nSizeLength, bool bWithDefault)\n{\n  SetSizeLength(nSizeLength);\n  return RenderHead(output, false, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "161-165"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlBinary::UpdateSize",
            "snippet": "uint64 EbmlBinary::UpdateSize(bool /* bWithDefault */, bool /* bForceRender */)\n{\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "79-82"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlBinary::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlBinary::UpdateSize",
            "snippet": "uint64 EbmlBinary::UpdateSize(bool /* bWithDefault */, bool /* bForceRender */)\n{\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "79-82"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlBinary::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlBinary::UpdateSize",
            "snippet": "uint64 EbmlBinary::UpdateSize(bool /* bWithDefault */, bool /* bForceRender */)\n{\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "79-82"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlBinary::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlBinary::UpdateSize",
            "snippet": "uint64 EbmlBinary::UpdateSize(bool /* bWithDefault */, bool /* bForceRender */)\n{\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "79-82"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlElement::VoidMe",
          "EbmlVoid::Overwrite",
          "EbmlElement::RenderHead",
          "EbmlBinary::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlElement::VoidMe",
            "snippet": "uint64 EbmlElement::VoidMe(IOCallback & output, bool bWithDefault)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  EbmlVoid Dummy;\n  return Dummy.Overwrite(*this, output, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "694-702"
          },
          {
            "qualified_name": "EbmlVoid::Overwrite",
            "snippet": "uint64 EbmlVoid::Overwrite(const EbmlElement & EltToVoid, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  //  EltToVoid.UpdateSize(bWithDefault);\n  if (EltToVoid.GetElementPosition() == 0) {\n    // this element has never been written\n    return 0;\n  }\n  if (EltToVoid.GetSize() + EltToVoid.HeadSize() <2) {\n    // the element can't be written here !\n    return 0;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePointer(EltToVoid.GetElementPosition());\n\n  // compute the size of the voided data based on the original one\n  SetSize(EltToVoid.GetSize() + E",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "99-135"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlBinary::UpdateSize",
            "snippet": "uint64 EbmlBinary::UpdateSize(bool /* bWithDefault */, bool /* bForceRender */)\n{\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "79-82"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::RenderHead",
          "EbmlBinary::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlBinary::UpdateSize",
            "snippet": "uint64 EbmlBinary::UpdateSize(bool /* bWithDefault */, bool /* bForceRender */)\n{\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "79-82"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlBinary::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlBinary::UpdateSize",
            "snippet": "uint64 EbmlBinary::UpdateSize(bool /* bWithDefault */, bool /* bForceRender */)\n{\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "79-82"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlBinary::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlBinary::UpdateSize",
            "snippet": "uint64 EbmlBinary::UpdateSize(bool /* bWithDefault */, bool /* bForceRender */)\n{\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "79-82"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlBinary::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlBinary::UpdateSize",
            "snippet": "uint64 EbmlBinary::UpdateSize(bool /* bWithDefault */, bool /* bForceRender */)\n{\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "79-82"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlBinary::UpdateSize"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlBinary::UpdateSize",
            "snippet": "uint64 EbmlBinary::UpdateSize(bool /* bWithDefault */, bool /* bForceRender */)\n{\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "79-82"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlBinary::RenderData",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
    "lines": "69-74",
    "num_chains": 3,
    "chains": [
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlBinary::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlBinary::RenderData",
            "snippet": "filepos_t EbmlBinary::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  output.writeFully(Data,GetSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "69-74"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlBinary::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlBinary::RenderData",
            "snippet": "filepos_t EbmlBinary::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  output.writeFully(Data,GetSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "69-74"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlBinary::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlBinary::RenderData",
            "snippet": "filepos_t EbmlBinary::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  output.writeFully(Data,GetSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "69-74"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlBinary::~EbmlBinary",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
    "lines": "61-64",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlBinary::~EbmlBinary"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlBinary::~EbmlBinary",
            "snippet": "EbmlBinary::~EbmlBinary(void) {\n  if(Data)\n    free(Data);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "61-64"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlBinary::EbmlBinary",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
    "lines": "49-59",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlBinary::EbmlBinary"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlBinary::EbmlBinary",
            "snippet": "EbmlBinary::EbmlBinary(const EbmlBinary & ElementToClone)\n  :EbmlElement(ElementToClone)\n{\n  if (ElementToClone.Data == NULL)\n    Data = NULL;\n  else {\n    Data = (binary *)malloc(GetSize() * sizeof(binary));\n    assert(Data != NULL);\n    memcpy(Data, ElementToClone.Data, GetSize());\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "49-59"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlFloat::IsSmallerThan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
    "lines": "149-155",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::CompareElements",
          "EbmlFloat::IsSmallerThan"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlElement::CompareElements",
            "snippet": "bool EbmlElement::CompareElements(const EbmlElement *A, const EbmlElement *B)\n{\n  if (EbmlId(*A) == EbmlId(*B))\n    return A->IsSmallerThan(B);\n  else\n    return false;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "648-654"
          },
          {
            "qualified_name": "EbmlFloat::IsSmallerThan",
            "snippet": "bool EbmlFloat::IsSmallerThan(const EbmlElement *Cmp) const\n{\n  if (EbmlId(*this) == EbmlId(*Cmp))\n    return this->Value < static_cast<const EbmlFloat *>(Cmp)->Value;\n  else\n    return false;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "149-155"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlFloat::ReadData",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
    "lines": "120-147",
    "num_chains": 5,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlFloat::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlFloat::ReadData",
            "snippet": "filepos_t EbmlFloat::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary Buffer[20];\n    assert(GetSize() <= 20);\n    input.readFully(Buffer, GetSize());\n\n    if (GetSize() == 4) {\n      big_int32 TmpRead;\n      TmpRead.Eval(Buffer);\n      int32 tmpp = int32(TmpRead);\n      float val;\n      memcpy(&val, &tmpp, 4);\n      Value = val;\n      SetValueIsSet();\n    } else if (GetSize() == 8) {\n      big_int64 TmpRead;\n      TmpRead.Eval(Buffer);\n      int64 tmpp = int64(TmpRead);\n      double val;\n      memcpy(&val, &tmpp, 8);\n      Value = val;\n      S",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "120-147"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlFloat::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlFloat::ReadData",
            "snippet": "filepos_t EbmlFloat::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary Buffer[20];\n    assert(GetSize() <= 20);\n    input.readFully(Buffer, GetSize());\n\n    if (GetSize() == 4) {\n      big_int32 TmpRead;\n      TmpRead.Eval(Buffer);\n      int32 tmpp = int32(TmpRead);\n      float val;\n      memcpy(&val, &tmpp, 4);\n      Value = val;\n      SetValueIsSet();\n    } else if (GetSize() == 8) {\n      big_int64 TmpRead;\n      TmpRead.Eval(Buffer);\n      int64 tmpp = int64(TmpRead);\n      double val;\n      memcpy(&val, &tmpp, 8);\n      Value = val;\n      S",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "120-147"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlFloat::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlFloat::ReadData",
            "snippet": "filepos_t EbmlFloat::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary Buffer[20];\n    assert(GetSize() <= 20);\n    input.readFully(Buffer, GetSize());\n\n    if (GetSize() == 4) {\n      big_int32 TmpRead;\n      TmpRead.Eval(Buffer);\n      int32 tmpp = int32(TmpRead);\n      float val;\n      memcpy(&val, &tmpp, 4);\n      Value = val;\n      SetValueIsSet();\n    } else if (GetSize() == 8) {\n      big_int64 TmpRead;\n      TmpRead.Eval(Buffer);\n      int64 tmpp = int64(TmpRead);\n      double val;\n      memcpy(&val, &tmpp, 8);\n      Value = val;\n      S",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "120-147"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlFloat::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlFloat::ReadData",
            "snippet": "filepos_t EbmlFloat::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary Buffer[20];\n    assert(GetSize() <= 20);\n    input.readFully(Buffer, GetSize());\n\n    if (GetSize() == 4) {\n      big_int32 TmpRead;\n      TmpRead.Eval(Buffer);\n      int32 tmpp = int32(TmpRead);\n      float val;\n      memcpy(&val, &tmpp, 4);\n      Value = val;\n      SetValueIsSet();\n    } else if (GetSize() == 8) {\n      big_int64 TmpRead;\n      TmpRead.Eval(Buffer);\n      int64 tmpp = int64(TmpRead);\n      double val;\n      memcpy(&val, &tmpp, 8);\n      Value = val;\n      S",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "120-147"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlFloat::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlFloat::ReadData",
            "snippet": "filepos_t EbmlFloat::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary Buffer[20];\n    assert(GetSize() <= 20);\n    input.readFully(Buffer, GetSize());\n\n    if (GetSize() == 4) {\n      big_int32 TmpRead;\n      TmpRead.Eval(Buffer);\n      int32 tmpp = int32(TmpRead);\n      float val;\n      memcpy(&val, &tmpp, 4);\n      Value = val;\n      SetValueIsSet();\n    } else if (GetSize() == 8) {\n      big_int64 TmpRead;\n      TmpRead.Eval(Buffer);\n      int64 tmpp = int64(TmpRead);\n      double val;\n      memcpy(&val, &tmpp, 8);\n      Value = val;\n      S",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "120-147"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlFloat::UpdateSize",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
    "lines": "110-115",
    "num_chains": 10,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::WriteHead",
          "EbmlElement::RenderHead",
          "EbmlFloat::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::WriteHead",
            "snippet": "filepos_t EbmlMaster::WriteHead(IOCallback & output, int nSizeLength, bool bWithDefault)\n{\n  SetSizeLength(nSizeLength);\n  return RenderHead(output, false, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "161-165"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlFloat::UpdateSize",
            "snippet": "uint64 EbmlFloat::UpdateSize(bool bWithDefault, bool  /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "110-115"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlFloat::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlFloat::UpdateSize",
            "snippet": "uint64 EbmlFloat::UpdateSize(bool bWithDefault, bool  /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "110-115"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlFloat::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlFloat::UpdateSize",
            "snippet": "uint64 EbmlFloat::UpdateSize(bool bWithDefault, bool  /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "110-115"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlFloat::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlFloat::UpdateSize",
            "snippet": "uint64 EbmlFloat::UpdateSize(bool bWithDefault, bool  /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "110-115"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlElement::VoidMe",
          "EbmlVoid::Overwrite",
          "EbmlElement::RenderHead",
          "EbmlFloat::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlElement::VoidMe",
            "snippet": "uint64 EbmlElement::VoidMe(IOCallback & output, bool bWithDefault)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  EbmlVoid Dummy;\n  return Dummy.Overwrite(*this, output, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "694-702"
          },
          {
            "qualified_name": "EbmlVoid::Overwrite",
            "snippet": "uint64 EbmlVoid::Overwrite(const EbmlElement & EltToVoid, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  //  EltToVoid.UpdateSize(bWithDefault);\n  if (EltToVoid.GetElementPosition() == 0) {\n    // this element has never been written\n    return 0;\n  }\n  if (EltToVoid.GetSize() + EltToVoid.HeadSize() <2) {\n    // the element can't be written here !\n    return 0;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePointer(EltToVoid.GetElementPosition());\n\n  // compute the size of the voided data based on the original one\n  SetSize(EltToVoid.GetSize() + E",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "99-135"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlFloat::UpdateSize",
            "snippet": "uint64 EbmlFloat::UpdateSize(bool bWithDefault, bool  /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "110-115"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::RenderHead",
          "EbmlFloat::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlFloat::UpdateSize",
            "snippet": "uint64 EbmlFloat::UpdateSize(bool bWithDefault, bool  /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "110-115"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlFloat::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlFloat::UpdateSize",
            "snippet": "uint64 EbmlFloat::UpdateSize(bool bWithDefault, bool  /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "110-115"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlFloat::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlFloat::UpdateSize",
            "snippet": "uint64 EbmlFloat::UpdateSize(bool bWithDefault, bool  /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "110-115"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlFloat::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlFloat::UpdateSize",
            "snippet": "uint64 EbmlFloat::UpdateSize(bool bWithDefault, bool  /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "110-115"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlFloat::UpdateSize"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlFloat::UpdateSize",
            "snippet": "uint64 EbmlFloat::UpdateSize(bool bWithDefault, bool  /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "110-115"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlFloat::RenderData",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
    "lines": "89-108",
    "num_chains": 3,
    "chains": [
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlFloat::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlFloat::RenderData",
            "snippet": "filepos_t EbmlFloat::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  assert(GetSize() == 4 || GetSize() == 8);\n\n  if (GetSize() == 4) {\n    float val = Value;\n    int Tmp;\n    memcpy(&Tmp, &val, 4);\n    big_int32 TmpToWrite(Tmp);\n    output.writeFully(&TmpToWrite.endian(), GetSize());\n  } else if (GetSize() == 8) {\n    double val = Value;\n    int64 Tmp;\n    memcpy(&Tmp, &val, 8);\n    big_int64 TmpToWrite(Tmp);\n    output.writeFully(&TmpToWrite.endian(), GetSize());\n  }\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "89-108"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlFloat::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlFloat::RenderData",
            "snippet": "filepos_t EbmlFloat::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  assert(GetSize() == 4 || GetSize() == 8);\n\n  if (GetSize() == 4) {\n    float val = Value;\n    int Tmp;\n    memcpy(&Tmp, &val, 4);\n    big_int32 TmpToWrite(Tmp);\n    output.writeFully(&TmpToWrite.endian(), GetSize());\n  } else if (GetSize() == 8) {\n    double val = Value;\n    int64 Tmp;\n    memcpy(&Tmp, &val, 8);\n    big_int64 TmpToWrite(Tmp);\n    output.writeFully(&TmpToWrite.endian(), GetSize());\n  }\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "89-108"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlFloat::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlFloat::RenderData",
            "snippet": "filepos_t EbmlFloat::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  assert(GetSize() == 4 || GetSize() == 8);\n\n  if (GetSize() == 4) {\n    float val = Value;\n    int Tmp;\n    memcpy(&Tmp, &val, 4);\n    big_int32 TmpToWrite(Tmp);\n    output.writeFully(&TmpToWrite.endian(), GetSize());\n  } else if (GetSize() == 8) {\n    double val = Value;\n    int64 Tmp;\n    memcpy(&Tmp, &val, 8);\n    big_int64 TmpToWrite(Tmp);\n    output.writeFully(&TmpToWrite.endian(), GetSize());\n  }\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "89-108"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlFloat::GetValue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
    "lines": "79-79",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlFloat::GetValue"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlFloat::GetValue",
            "snippet": "double EbmlFloat::GetValue() const {return Value;}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "79-79"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlFloat::DefaultVal",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
    "lines": "70-74",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlFloat::DefaultVal"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlFloat::DefaultVal",
            "snippet": "double EbmlFloat::DefaultVal() const\n{\n  assert(DefaultISset());\n  return DefaultValue;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "70-74"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlFloat::SetDefaultValue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
    "lines": "63-68",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlFloat::SetDefaultValue"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlFloat::SetDefaultValue",
            "snippet": "void EbmlFloat::SetDefaultValue(double aValue)\n{\n  assert(!DefaultISset());\n  DefaultValue = aValue;\n  SetDefaultIsSet();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "63-68"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlFloat::EbmlFloat",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
    "lines": "56-61",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlFloat::EbmlFloat"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlFloat::EbmlFloat",
            "snippet": "EbmlFloat::EbmlFloat(const double aDefaultValue, const EbmlFloat::Precision prec)\n  :EbmlElement(0, true), Value(aDefaultValue), DefaultValue(aDefaultValue)\n{\n  SetDefaultIsSet();\n  SetPrecision(prec);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "49-54"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlFloat::EbmlFloat",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
    "lines": "49-54",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlFloat::EbmlFloat"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlFloat::EbmlFloat",
            "snippet": "EbmlFloat::EbmlFloat(const double aDefaultValue, const EbmlFloat::Precision prec)\n  :EbmlElement(0, true), Value(aDefaultValue), DefaultValue(aDefaultValue)\n{\n  SetDefaultIsSet();\n  SetPrecision(prec);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlFloat.cpp",
            "lines": "49-54"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlUInteger::IsSmallerThan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
    "lines": "152-158",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::CompareElements",
          "EbmlUInteger::IsSmallerThan"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlElement::CompareElements",
            "snippet": "bool EbmlElement::CompareElements(const EbmlElement *A, const EbmlElement *B)\n{\n  if (EbmlId(*A) == EbmlId(*B))\n    return A->IsSmallerThan(B);\n  else\n    return false;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "648-654"
          },
          {
            "qualified_name": "EbmlUInteger::IsSmallerThan",
            "snippet": "bool EbmlUInteger::IsSmallerThan(const EbmlElement *Cmp) const\n{\n  if (EbmlId(*this) == EbmlId(*Cmp))\n    return this->Value < static_cast<const EbmlUInteger *>(Cmp)->Value;\n  else\n    return false;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "152-158"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlUInteger::ReadData",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
    "lines": "135-150",
    "num_chains": 5,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlUInteger::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlUInteger::ReadData",
            "snippet": "filepos_t EbmlUInteger::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary Buffer[8];\n    input.readFully(Buffer, GetSize());\n    Value = 0;\n\n    for (unsigned int i=0; i<GetSize(); i++) {\n      Value <<= 8;\n      Value |= Buffer[i];\n    }\n    SetValueIsSet();\n  }\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "135-150"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlUInteger::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlUInteger::ReadData",
            "snippet": "filepos_t EbmlUInteger::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary Buffer[8];\n    input.readFully(Buffer, GetSize());\n    Value = 0;\n\n    for (unsigned int i=0; i<GetSize(); i++) {\n      Value <<= 8;\n      Value |= Buffer[i];\n    }\n    SetValueIsSet();\n  }\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "135-150"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlUInteger::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlUInteger::ReadData",
            "snippet": "filepos_t EbmlUInteger::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary Buffer[8];\n    input.readFully(Buffer, GetSize());\n    Value = 0;\n\n    for (unsigned int i=0; i<GetSize(); i++) {\n      Value <<= 8;\n      Value |= Buffer[i];\n    }\n    SetValueIsSet();\n  }\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "135-150"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlUInteger::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlUInteger::ReadData",
            "snippet": "filepos_t EbmlUInteger::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary Buffer[8];\n    input.readFully(Buffer, GetSize());\n    Value = 0;\n\n    for (unsigned int i=0; i<GetSize(); i++) {\n      Value <<= 8;\n      Value |= Buffer[i];\n    }\n    SetValueIsSet();\n  }\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "135-150"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlUInteger::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlUInteger::ReadData",
            "snippet": "filepos_t EbmlUInteger::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary Buffer[8];\n    input.readFully(Buffer, GetSize());\n    Value = 0;\n\n    for (unsigned int i=0; i<GetSize(); i++) {\n      Value <<= 8;\n      Value |= Buffer[i];\n    }\n    SetValueIsSet();\n  }\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "135-150"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlUInteger::UpdateSize",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
    "lines": "105-133",
    "num_chains": 10,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::WriteHead",
          "EbmlElement::RenderHead",
          "EbmlUInteger::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::WriteHead",
            "snippet": "filepos_t EbmlMaster::WriteHead(IOCallback & output, int nSizeLength, bool bWithDefault)\n{\n  SetSizeLength(nSizeLength);\n  return RenderHead(output, false, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "161-165"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlUInteger::UpdateSize",
            "snippet": "uint64 EbmlUInteger::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value <= 0xFF) {\n    SetSize_(1);\n  } else if (Value <= 0xFFFF) {\n    SetSize_(2);\n  } else if (Value <= 0xFFFFFF) {\n    SetSize_(3);\n  } else if (Value <= 0xFFFFFFFF) {\n    SetSize_(4);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFF)) {\n    SetSize_(5);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFFFF)) {\n    SetSize_(6);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFFFFFF)) {\n    SetSize_(7);\n  } else {\n    SetSize_(8);\n  }\n\n  if (Get",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "105-133"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlUInteger::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlUInteger::UpdateSize",
            "snippet": "uint64 EbmlUInteger::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value <= 0xFF) {\n    SetSize_(1);\n  } else if (Value <= 0xFFFF) {\n    SetSize_(2);\n  } else if (Value <= 0xFFFFFF) {\n    SetSize_(3);\n  } else if (Value <= 0xFFFFFFFF) {\n    SetSize_(4);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFF)) {\n    SetSize_(5);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFFFF)) {\n    SetSize_(6);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFFFFFF)) {\n    SetSize_(7);\n  } else {\n    SetSize_(8);\n  }\n\n  if (Get",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "105-133"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlUInteger::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlUInteger::UpdateSize",
            "snippet": "uint64 EbmlUInteger::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value <= 0xFF) {\n    SetSize_(1);\n  } else if (Value <= 0xFFFF) {\n    SetSize_(2);\n  } else if (Value <= 0xFFFFFF) {\n    SetSize_(3);\n  } else if (Value <= 0xFFFFFFFF) {\n    SetSize_(4);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFF)) {\n    SetSize_(5);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFFFF)) {\n    SetSize_(6);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFFFFFF)) {\n    SetSize_(7);\n  } else {\n    SetSize_(8);\n  }\n\n  if (Get",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "105-133"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlUInteger::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlUInteger::UpdateSize",
            "snippet": "uint64 EbmlUInteger::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value <= 0xFF) {\n    SetSize_(1);\n  } else if (Value <= 0xFFFF) {\n    SetSize_(2);\n  } else if (Value <= 0xFFFFFF) {\n    SetSize_(3);\n  } else if (Value <= 0xFFFFFFFF) {\n    SetSize_(4);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFF)) {\n    SetSize_(5);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFFFF)) {\n    SetSize_(6);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFFFFFF)) {\n    SetSize_(7);\n  } else {\n    SetSize_(8);\n  }\n\n  if (Get",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "105-133"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlElement::VoidMe",
          "EbmlVoid::Overwrite",
          "EbmlElement::RenderHead",
          "EbmlUInteger::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlElement::VoidMe",
            "snippet": "uint64 EbmlElement::VoidMe(IOCallback & output, bool bWithDefault)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  EbmlVoid Dummy;\n  return Dummy.Overwrite(*this, output, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "694-702"
          },
          {
            "qualified_name": "EbmlVoid::Overwrite",
            "snippet": "uint64 EbmlVoid::Overwrite(const EbmlElement & EltToVoid, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  //  EltToVoid.UpdateSize(bWithDefault);\n  if (EltToVoid.GetElementPosition() == 0) {\n    // this element has never been written\n    return 0;\n  }\n  if (EltToVoid.GetSize() + EltToVoid.HeadSize() <2) {\n    // the element can't be written here !\n    return 0;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePointer(EltToVoid.GetElementPosition());\n\n  // compute the size of the voided data based on the original one\n  SetSize(EltToVoid.GetSize() + E",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "99-135"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlUInteger::UpdateSize",
            "snippet": "uint64 EbmlUInteger::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value <= 0xFF) {\n    SetSize_(1);\n  } else if (Value <= 0xFFFF) {\n    SetSize_(2);\n  } else if (Value <= 0xFFFFFF) {\n    SetSize_(3);\n  } else if (Value <= 0xFFFFFFFF) {\n    SetSize_(4);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFF)) {\n    SetSize_(5);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFFFF)) {\n    SetSize_(6);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFFFFFF)) {\n    SetSize_(7);\n  } else {\n    SetSize_(8);\n  }\n\n  if (Get",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "105-133"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::RenderHead",
          "EbmlUInteger::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlUInteger::UpdateSize",
            "snippet": "uint64 EbmlUInteger::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value <= 0xFF) {\n    SetSize_(1);\n  } else if (Value <= 0xFFFF) {\n    SetSize_(2);\n  } else if (Value <= 0xFFFFFF) {\n    SetSize_(3);\n  } else if (Value <= 0xFFFFFFFF) {\n    SetSize_(4);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFF)) {\n    SetSize_(5);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFFFF)) {\n    SetSize_(6);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFFFFFF)) {\n    SetSize_(7);\n  } else {\n    SetSize_(8);\n  }\n\n  if (Get",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "105-133"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlUInteger::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUInteger::UpdateSize",
            "snippet": "uint64 EbmlUInteger::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value <= 0xFF) {\n    SetSize_(1);\n  } else if (Value <= 0xFFFF) {\n    SetSize_(2);\n  } else if (Value <= 0xFFFFFF) {\n    SetSize_(3);\n  } else if (Value <= 0xFFFFFFFF) {\n    SetSize_(4);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFF)) {\n    SetSize_(5);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFFFF)) {\n    SetSize_(6);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFFFFFF)) {\n    SetSize_(7);\n  } else {\n    SetSize_(8);\n  }\n\n  if (Get",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "105-133"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlUInteger::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUInteger::UpdateSize",
            "snippet": "uint64 EbmlUInteger::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value <= 0xFF) {\n    SetSize_(1);\n  } else if (Value <= 0xFFFF) {\n    SetSize_(2);\n  } else if (Value <= 0xFFFFFF) {\n    SetSize_(3);\n  } else if (Value <= 0xFFFFFFFF) {\n    SetSize_(4);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFF)) {\n    SetSize_(5);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFFFF)) {\n    SetSize_(6);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFFFFFF)) {\n    SetSize_(7);\n  } else {\n    SetSize_(8);\n  }\n\n  if (Get",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "105-133"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlUInteger::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUInteger::UpdateSize",
            "snippet": "uint64 EbmlUInteger::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value <= 0xFF) {\n    SetSize_(1);\n  } else if (Value <= 0xFFFF) {\n    SetSize_(2);\n  } else if (Value <= 0xFFFFFF) {\n    SetSize_(3);\n  } else if (Value <= 0xFFFFFFFF) {\n    SetSize_(4);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFF)) {\n    SetSize_(5);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFFFF)) {\n    SetSize_(6);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFFFFFF)) {\n    SetSize_(7);\n  } else {\n    SetSize_(8);\n  }\n\n  if (Get",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "105-133"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlUInteger::UpdateSize"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlUInteger::UpdateSize",
            "snippet": "uint64 EbmlUInteger::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value <= 0xFF) {\n    SetSize_(1);\n  } else if (Value <= 0xFFFF) {\n    SetSize_(2);\n  } else if (Value <= 0xFFFFFF) {\n    SetSize_(3);\n  } else if (Value <= 0xFFFFFFFF) {\n    SetSize_(4);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFF)) {\n    SetSize_(5);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFFFF)) {\n    SetSize_(6);\n  } else if (Value <= EBML_PRETTYLONGINT(0xFFFFFFFFFFFFFF)) {\n    SetSize_(7);\n  } else {\n    SetSize_(8);\n  }\n\n  if (Get",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "105-133"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlUInteger::RenderData",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
    "lines": "87-103",
    "num_chains": 3,
    "chains": [
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlUInteger::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUInteger::RenderData",
            "snippet": "filepos_t EbmlUInteger::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  binary FinalData[8]; // we don't handle more than 64 bits integers\n\n  if (GetSizeLength() > 8)\n    return 0; // integer bigger coded on more than 64 bits are not supported\n\n  uint64 TempValue = Value;\n  for (unsigned int i=0; i<GetSize();i++) {\n    FinalData[GetSize()-i-1] = TempValue & 0xFF;\n    TempValue >>= 8;\n  }\n\n  output.writeFully(FinalData,GetSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "87-103"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlUInteger::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUInteger::RenderData",
            "snippet": "filepos_t EbmlUInteger::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  binary FinalData[8]; // we don't handle more than 64 bits integers\n\n  if (GetSizeLength() > 8)\n    return 0; // integer bigger coded on more than 64 bits are not supported\n\n  uint64 TempValue = Value;\n  for (unsigned int i=0; i<GetSize();i++) {\n    FinalData[GetSize()-i-1] = TempValue & 0xFF;\n    TempValue >>= 8;\n  }\n\n  output.writeFully(FinalData,GetSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "87-103"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlUInteger::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUInteger::RenderData",
            "snippet": "filepos_t EbmlUInteger::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  binary FinalData[8]; // we don't handle more than 64 bits integers\n\n  if (GetSizeLength() > 8)\n    return 0; // integer bigger coded on more than 64 bits are not supported\n\n  uint64 TempValue = Value;\n  for (unsigned int i=0; i<GetSize();i++) {\n    FinalData[GetSize()-i-1] = TempValue & 0xFF;\n    TempValue >>= 8;\n  }\n\n  output.writeFully(FinalData,GetSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "87-103"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlUInteger::GetValue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
    "lines": "78-78",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlUInteger::GetValue"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlUInteger::GetValue",
            "snippet": "uint64 EbmlUInteger::GetValue() const {return Value;}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "78-78"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlUInteger::DefaultVal",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
    "lines": "67-71",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlUInteger::DefaultVal"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlUInteger::DefaultVal",
            "snippet": "uint64 EbmlUInteger::DefaultVal() const\n{\n  assert(DefaultISset());\n  return DefaultValue;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "67-71"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlUInteger::SetDefaultValue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
    "lines": "60-65",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlUInteger::SetDefaultValue"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlUInteger::SetDefaultValue",
            "snippet": "void EbmlUInteger::SetDefaultValue(uint64 aValue)\n{\n  assert(!DefaultISset());\n  DefaultValue = aValue;\n  SetDefaultIsSet();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "60-65"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlUInteger::EbmlUInteger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
    "lines": "53-58",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlUInteger::EbmlUInteger"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlUInteger::EbmlUInteger",
            "snippet": "EbmlUInteger::EbmlUInteger(uint64 aDefaultValue)\n  :EbmlElement(DEFAULT_UINT_SIZE, true), Value(aDefaultValue), DefaultValue(aDefaultValue)\n{\n  SetDefaultIsSet();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "47-51"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlUInteger::EbmlUInteger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
    "lines": "47-51",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlUInteger::EbmlUInteger"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlUInteger::EbmlUInteger",
            "snippet": "EbmlUInteger::EbmlUInteger(uint64 aDefaultValue)\n  :EbmlElement(DEFAULT_UINT_SIZE, true), Value(aDefaultValue), DefaultValue(aDefaultValue)\n{\n  SetDefaultIsSet();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
            "lines": "47-51"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlElement",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUInteger.cpp",
    "lines": "41-45",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlElement",
            "snippet": "START_LIBEBML_NAMESPACE\n\nEbmlSInteger::EbmlSInteger()\n  :EbmlElement(DEFAULT_INT_SIZE, false)\n{}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "39-43"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlStream::~EbmlStream",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlStream.cpp",
    "lines": "44-45",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlStream::~EbmlStream"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlStream::~EbmlStream",
            "snippet": "EbmlStream::~EbmlStream()\n{}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlStream.cpp",
            "lines": "44-45"
          }
        ]
      }
    ]
  },
  {
    "target_function": "Stream",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlStream.cpp",
    "lines": "38-42",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "Stream"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "Stream",
            "snippet": "START_LIBEBML_NAMESPACE\n\nEbmlStream::EbmlStream(IOCallback & DataStream)\n  :Stream(DataStream)\n{}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlStream.cpp",
            "lines": "38-42"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlUnicodeString::ReadData",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "347-372",
    "num_chains": 5,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlUnicodeString::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlUnicodeString::ReadData",
            "snippet": "filepos_t EbmlUnicodeString::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    if (GetSize() == 0) {\n      Value = UTFstring::value_type(0);\n      SetValueIsSet();\n    } else {\n      char *Buffer = new (std::nothrow) char[GetSize()+1];\n      if (Buffer == NULL) {\n        // impossible to read, skip it\n        input.setFilePointer(GetSize(), seek_current);\n      } else {\n        input.readFully(Buffer, GetSize());\n        if (Buffer[GetSize()-1] != 0) {\n          Buffer[GetSize()] = 0;\n        }\n\n        Value.SetUTF8(Buffer); // implicit conversion to ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "347-372"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlUnicodeString::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlUnicodeString::ReadData",
            "snippet": "filepos_t EbmlUnicodeString::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    if (GetSize() == 0) {\n      Value = UTFstring::value_type(0);\n      SetValueIsSet();\n    } else {\n      char *Buffer = new (std::nothrow) char[GetSize()+1];\n      if (Buffer == NULL) {\n        // impossible to read, skip it\n        input.setFilePointer(GetSize(), seek_current);\n      } else {\n        input.readFully(Buffer, GetSize());\n        if (Buffer[GetSize()-1] != 0) {\n          Buffer[GetSize()] = 0;\n        }\n\n        Value.SetUTF8(Buffer); // implicit conversion to ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "347-372"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlUnicodeString::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlUnicodeString::ReadData",
            "snippet": "filepos_t EbmlUnicodeString::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    if (GetSize() == 0) {\n      Value = UTFstring::value_type(0);\n      SetValueIsSet();\n    } else {\n      char *Buffer = new (std::nothrow) char[GetSize()+1];\n      if (Buffer == NULL) {\n        // impossible to read, skip it\n        input.setFilePointer(GetSize(), seek_current);\n      } else {\n        input.readFully(Buffer, GetSize());\n        if (Buffer[GetSize()-1] != 0) {\n          Buffer[GetSize()] = 0;\n        }\n\n        Value.SetUTF8(Buffer); // implicit conversion to ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "347-372"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlUnicodeString::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlUnicodeString::ReadData",
            "snippet": "filepos_t EbmlUnicodeString::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    if (GetSize() == 0) {\n      Value = UTFstring::value_type(0);\n      SetValueIsSet();\n    } else {\n      char *Buffer = new (std::nothrow) char[GetSize()+1];\n      if (Buffer == NULL) {\n        // impossible to read, skip it\n        input.setFilePointer(GetSize(), seek_current);\n      } else {\n        input.readFully(Buffer, GetSize());\n        if (Buffer[GetSize()-1] != 0) {\n          Buffer[GetSize()] = 0;\n        }\n\n        Value.SetUTF8(Buffer); // implicit conversion to ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "347-372"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlUnicodeString::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlUnicodeString::ReadData",
            "snippet": "filepos_t EbmlUnicodeString::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    if (GetSize() == 0) {\n      Value = UTFstring::value_type(0);\n      SetValueIsSet();\n    } else {\n      char *Buffer = new (std::nothrow) char[GetSize()+1];\n      if (Buffer == NULL) {\n        // impossible to read, skip it\n        input.setFilePointer(GetSize(), seek_current);\n      } else {\n        input.readFully(Buffer, GetSize());\n        if (Buffer[GetSize()-1] != 0) {\n          Buffer[GetSize()] = 0;\n        }\n\n        Value.SetUTF8(Buffer); // implicit conversion to ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "347-372"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlUnicodeString::UpdateSize",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "332-342",
    "num_chains": 10,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::WriteHead",
          "EbmlElement::RenderHead",
          "EbmlUnicodeString::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::WriteHead",
            "snippet": "filepos_t EbmlMaster::WriteHead(IOCallback & output, int nSizeLength, bool bWithDefault)\n{\n  SetSizeLength(nSizeLength);\n  return RenderHead(output, false, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "161-165"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlUnicodeString::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlUnicodeString::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlUnicodeString::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlElement::VoidMe",
          "EbmlVoid::Overwrite",
          "EbmlElement::RenderHead",
          "EbmlUnicodeString::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlElement::VoidMe",
            "snippet": "uint64 EbmlElement::VoidMe(IOCallback & output, bool bWithDefault)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  EbmlVoid Dummy;\n  return Dummy.Overwrite(*this, output, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "694-702"
          },
          {
            "qualified_name": "EbmlVoid::Overwrite",
            "snippet": "uint64 EbmlVoid::Overwrite(const EbmlElement & EltToVoid, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  //  EltToVoid.UpdateSize(bWithDefault);\n  if (EltToVoid.GetElementPosition() == 0) {\n    // this element has never been written\n    return 0;\n  }\n  if (EltToVoid.GetSize() + EltToVoid.HeadSize() <2) {\n    // the element can't be written here !\n    return 0;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePointer(EltToVoid.GetElementPosition());\n\n  // compute the size of the voided data based on the original one\n  SetSize(EltToVoid.GetSize() + E",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "99-135"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::RenderHead",
          "EbmlUnicodeString::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlUnicodeString::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlUnicodeString::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlUnicodeString::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlUnicodeString::UpdateSize"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlUnicodeString::UpdateSize",
            "snippet": "uint64 EbmlUnicodeString::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  SetSize_(Value.GetUTF8().length());\n  if (GetSize() < GetDefaultSize())\n    SetSize_(GetDefaultSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "332-342"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlUnicodeString::GetValueUTF8",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "325-327",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlUnicodeString::GetValueUTF8"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlUnicodeString::GetValueUTF8",
            "snippet": "std::string EbmlUnicodeString::GetValueUTF8() const {\n  return Value.GetUTF8();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "325-327"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlUnicodeString::GetValue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "321-323",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlUnicodeString::GetValue"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlUnicodeString::GetValue",
            "snippet": "UTFstring EbmlUnicodeString::GetValue() const {\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "321-323"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlUnicodeString::RenderData",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "279-300",
    "num_chains": 3,
    "chains": [
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlUnicodeString::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::RenderData",
            "snippet": "filepos_t EbmlUnicodeString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  uint32 Result = Value.GetUTF8().length();\n\n  if (Result != 0) {\n    output.writeFully(Value.GetUTF8().c_str(), Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "279-300"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlUnicodeString::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::RenderData",
            "snippet": "filepos_t EbmlUnicodeString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  uint32 Result = Value.GetUTF8().length();\n\n  if (Result != 0) {\n    output.writeFully(Value.GetUTF8().c_str(), Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "279-300"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlUnicodeString::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlUnicodeString::RenderData",
            "snippet": "filepos_t EbmlUnicodeString::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  uint32 Result = Value.GetUTF8().length();\n\n  if (Result != 0) {\n    output.writeFully(Value.GetUTF8().c_str(), Result);\n  }\n\n  if (Result < GetDefaultSize()) {\n    // pad the rest with 0\n    binary *Pad = new (std::nothrow) binary[GetDefaultSize() - Result];\n    if (Pad != NULL) {\n      memset(Pad, 0x00, GetDefaultSize() - Result);\n      output.writeFully(Pad, GetDefaultSize() - Result);\n\n      Result = GetDefaultSize();\n      delete [] Pad;\n    }\n  }\n\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "279-300"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlUnicodeString::SetDefaultValue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "261-266",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlUnicodeString::SetDefaultValue"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlUnicodeString::SetDefaultValue",
            "snippet": "void EbmlUnicodeString::SetDefaultValue(UTFstring & aValue)\n{\n  assert(!DefaultISset());\n  DefaultValue = aValue;\n  SetDefaultIsSet();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "261-266"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlUnicodeString::EbmlUnicodeString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "254-259",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlUnicodeString::EbmlUnicodeString"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlUnicodeString::EbmlUnicodeString",
            "snippet": "EbmlUnicodeString::EbmlUnicodeString()\n  :EbmlElement(0, false)\n{\n  SetDefaultSize(0);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "241-245"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlUnicodeString::EbmlUnicodeString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "247-252",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlUnicodeString::EbmlUnicodeString"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlUnicodeString::EbmlUnicodeString",
            "snippet": "EbmlUnicodeString::EbmlUnicodeString()\n  :EbmlElement(0, false)\n{\n  SetDefaultSize(0);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "241-245"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlUnicodeString::EbmlUnicodeString",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "241-245",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlUnicodeString::EbmlUnicodeString"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlUnicodeString::EbmlUnicodeString",
            "snippet": "EbmlUnicodeString::EbmlUnicodeString()\n  :EbmlElement(0, false)\n{\n  SetDefaultSize(0);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "241-245"
          }
        ]
      }
    ]
  },
  {
    "target_function": "UTFstring::wcscmp_internal",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "230-237",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlBinary::operator==",
          "UTFstring::wcscmp_internal"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlBinary::operator==",
            "snippet": "bool EbmlBinary::operator==(const EbmlBinary & ElementToCompare) const\n{\n  return ((GetSize() == ElementToCompare.GetSize()) && !memcmp(Data, ElementToCompare.Data, GetSize()));\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlBinary.cpp",
            "lines": "101-104"
          },
          {
            "qualified_name": "UTFstring::wcscmp_internal",
            "snippet": "bool UTFstring::wcscmp_internal(const wchar_t *str1, const wchar_t *str2)\n{\n  size_t Index=0;\n  while (str1[Index] == str2[Index] && str1[Index] != 0) {\n    Index++;\n  }\n  return (str1[Index] == str2[Index]);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "230-237"
          }
        ]
      }
    ]
  },
  {
    "target_function": "UTFstring::UpdateFromUCS2",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "198-228",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "UTFstring::UpdateFromUCS2"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "UTFstring::UpdateFromUCS2",
            "snippet": "void UTFstring::UpdateFromUCS2()\n{\n  // find the size of the final UTF-8 string\n  size_t i,Size=0;\n  for (i=0; i<_Length; i++) {\n    if (_Data[i] < 0x80) {\n      Size++;\n    } else if (_Data[i] < 0x800) {\n      Size += 2;\n    } else {\n      Size += 3;\n    }\n  }\n  std::string::value_type *tmpStr = new std::string::value_type[Size+1];\n  for (i=0, Size=0; i<_Length; i++) {\n    if (_Data[i] < 0x80) {\n      tmpStr[Size++] = _Data[i];\n    } else if (_Data[i] < 0x800) {\n      tmpStr[Size++] = 0xC0 | (_Data[i] >> 6);\n      tmpStr[Size++] = 0x80 | (_Data[i] & 0x3F);\n    } else {\n      tmpStr[Size++] = ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "198-228"
          }
        ]
      }
    ]
  },
  {
    "target_function": "UTFstring::operator==",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "138-145",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "UTFstring::operator=="
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "UTFstring::operator==",
            "snippet": "bool UTFstring::operator==(const UTFstring& _aStr) const\n{\n  if ((_Data == NULL) && (_aStr._Data == NULL))\n    return true;\n  if ((_Data == NULL) || (_aStr._Data == NULL))\n    return false;\n  return wcscmp_internal(_Data, _aStr._Data);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "138-145"
          }
        ]
      }
    ]
  },
  {
    "target_function": "UTFstring::UTFstring",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "89-94",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "UTFstring::UTFstring"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "UTFstring::UTFstring",
            "snippet": "UTFstring::UTFstring()\n  :_Length(0)\n  ,_Data(NULL)\n{}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "65-68"
          }
        ]
      }
    ]
  },
  {
    "target_function": "UTFstring::~UTFstring",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "84-87",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "UTFstring::~UTFstring"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "UTFstring::~UTFstring",
            "snippet": "UTFstring::~UTFstring()\n{\n  delete [] _Data;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "84-87"
          }
        ]
      }
    ]
  },
  {
    "target_function": "UTFstring::UTFstring",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "77-82",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "UTFstring::UTFstring"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "UTFstring::UTFstring",
            "snippet": "UTFstring::UTFstring()\n  :_Length(0)\n  ,_Data(NULL)\n{}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "65-68"
          }
        ]
      }
    ]
  },
  {
    "target_function": "UTFstring::UTFstring",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "70-75",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "UTFstring::UTFstring"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "UTFstring::UTFstring",
            "snippet": "UTFstring::UTFstring()\n  :_Length(0)\n  ,_Data(NULL)\n{}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "65-68"
          }
        ]
      }
    ]
  },
  {
    "target_function": "UTFstring::UTFstring",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
    "lines": "65-68",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "UTFstring::UTFstring"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "UTFstring::UTFstring",
            "snippet": "UTFstring::UTFstring()\n  :_Length(0)\n  ,_Data(NULL)\n{}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlUnicodeString.cpp",
            "lines": "65-68"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlSInteger::IsSmallerThan",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
    "lines": "145-151",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::CompareElements",
          "EbmlSInteger::IsSmallerThan"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlElement::CompareElements",
            "snippet": "bool EbmlElement::CompareElements(const EbmlElement *A, const EbmlElement *B)\n{\n  if (EbmlId(*A) == EbmlId(*B))\n    return A->IsSmallerThan(B);\n  else\n    return false;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "648-654"
          },
          {
            "qualified_name": "EbmlSInteger::IsSmallerThan",
            "snippet": "bool EbmlSInteger::IsSmallerThan(const EbmlElement *Cmp) const\n{\n  if (EbmlId(*this) == EbmlId(*Cmp))\n    return this->Value < static_cast<const EbmlSInteger *>(Cmp)->Value;\n  else\n    return false;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "145-151"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlSInteger::ReadData",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
    "lines": "124-143",
    "num_chains": 5,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlSInteger::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlSInteger::ReadData",
            "snippet": "filepos_t EbmlSInteger::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary Buffer[8];\n    input.readFully(Buffer, GetSize());\n\n    if (Buffer[0] & 0x80)\n      Value = -1; // this is a negative value\n    else\n      Value = 0; // this is a positive value\n\n    for (unsigned int i=0; i<GetSize(); i++) {\n      Value <<= 8;\n      Value |= Buffer[i];\n    }\n    SetValueIsSet();\n  }\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "124-143"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlSInteger::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlSInteger::ReadData",
            "snippet": "filepos_t EbmlSInteger::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary Buffer[8];\n    input.readFully(Buffer, GetSize());\n\n    if (Buffer[0] & 0x80)\n      Value = -1; // this is a negative value\n    else\n      Value = 0; // this is a positive value\n\n    for (unsigned int i=0; i<GetSize(); i++) {\n      Value <<= 8;\n      Value |= Buffer[i];\n    }\n    SetValueIsSet();\n  }\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "124-143"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlSInteger::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlSInteger::ReadData",
            "snippet": "filepos_t EbmlSInteger::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary Buffer[8];\n    input.readFully(Buffer, GetSize());\n\n    if (Buffer[0] & 0x80)\n      Value = -1; // this is a negative value\n    else\n      Value = 0; // this is a positive value\n\n    for (unsigned int i=0; i<GetSize(); i++) {\n      Value <<= 8;\n      Value |= Buffer[i];\n    }\n    SetValueIsSet();\n  }\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "124-143"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlSInteger::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlSInteger::ReadData",
            "snippet": "filepos_t EbmlSInteger::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary Buffer[8];\n    input.readFully(Buffer, GetSize());\n\n    if (Buffer[0] & 0x80)\n      Value = -1; // this is a negative value\n    else\n      Value = 0; // this is a positive value\n\n    for (unsigned int i=0; i<GetSize(); i++) {\n      Value <<= 8;\n      Value |= Buffer[i];\n    }\n    SetValueIsSet();\n  }\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "124-143"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "EbmlSInteger::ReadData"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "EbmlSInteger::ReadData",
            "snippet": "filepos_t EbmlSInteger::ReadData(IOCallback & input, ScopeMode ReadFully)\n{\n  if (ReadFully != SCOPE_NO_DATA) {\n    binary Buffer[8];\n    input.readFully(Buffer, GetSize());\n\n    if (Buffer[0] & 0x80)\n      Value = -1; // this is a negative value\n    else\n      Value = 0; // this is a positive value\n\n    for (unsigned int i=0; i<GetSize(); i++) {\n      Value <<= 8;\n      Value |= Buffer[i];\n    }\n    SetValueIsSet();\n  }\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "124-143"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlSInteger::UpdateSize",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
    "lines": "91-122",
    "num_chains": 10,
    "chains": [
      {
        "call_sequence": [
          "EbmlMaster::WriteHead",
          "EbmlElement::RenderHead",
          "EbmlSInteger::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::WriteHead",
            "snippet": "filepos_t EbmlMaster::WriteHead(IOCallback & output, int nSizeLength, bool bWithDefault)\n{\n  SetSizeLength(nSizeLength);\n  return RenderHead(output, false, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "161-165"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlSInteger::UpdateSize",
            "snippet": "uint64 EbmlSInteger::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value <= 0x7F && Value >= (-0x80)) {\n    SetSize_(1);\n  } else if (Value <= 0x7FFF && Value >= (-0x8000)) {\n    SetSize_(2);\n  } else if (Value <= 0x7FFFFF && Value >= (-0x800000)) {\n    SetSize_(3);\n  } else if (Value <= EBML_PRETTYLONGINT(0x7FFFFFFF) && Value >= (EBML_PRETTYLONGINT(-0x80000000))) {\n    SetSize_(4);\n  } else if (Value <= EBML_PRETTYLONGINT(0x7FFFFFFFFF) &&\n             Value >= EBML_PRETTYLONGINT(-0x8000000000)) {\n    SetSize_(5);\n  } els",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "91-122"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlSInteger::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlSInteger::UpdateSize",
            "snippet": "uint64 EbmlSInteger::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value <= 0x7F && Value >= (-0x80)) {\n    SetSize_(1);\n  } else if (Value <= 0x7FFF && Value >= (-0x8000)) {\n    SetSize_(2);\n  } else if (Value <= 0x7FFFFF && Value >= (-0x800000)) {\n    SetSize_(3);\n  } else if (Value <= EBML_PRETTYLONGINT(0x7FFFFFFF) && Value >= (EBML_PRETTYLONGINT(-0x80000000))) {\n    SetSize_(4);\n  } else if (Value <= EBML_PRETTYLONGINT(0x7FFFFFFFFF) &&\n             Value >= EBML_PRETTYLONGINT(-0x8000000000)) {\n    SetSize_(5);\n  } els",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "91-122"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlSInteger::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlSInteger::UpdateSize",
            "snippet": "uint64 EbmlSInteger::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value <= 0x7F && Value >= (-0x80)) {\n    SetSize_(1);\n  } else if (Value <= 0x7FFF && Value >= (-0x8000)) {\n    SetSize_(2);\n  } else if (Value <= 0x7FFFFF && Value >= (-0x800000)) {\n    SetSize_(3);\n  } else if (Value <= EBML_PRETTYLONGINT(0x7FFFFFFF) && Value >= (EBML_PRETTYLONGINT(-0x80000000))) {\n    SetSize_(4);\n  } else if (Value <= EBML_PRETTYLONGINT(0x7FFFFFFFFF) &&\n             Value >= EBML_PRETTYLONGINT(-0x8000000000)) {\n    SetSize_(5);\n  } els",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "91-122"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlElement::RenderHead",
          "EbmlSInteger::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlSInteger::UpdateSize",
            "snippet": "uint64 EbmlSInteger::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value <= 0x7F && Value >= (-0x80)) {\n    SetSize_(1);\n  } else if (Value <= 0x7FFF && Value >= (-0x8000)) {\n    SetSize_(2);\n  } else if (Value <= 0x7FFFFF && Value >= (-0x800000)) {\n    SetSize_(3);\n  } else if (Value <= EBML_PRETTYLONGINT(0x7FFFFFFF) && Value >= (EBML_PRETTYLONGINT(-0x80000000))) {\n    SetSize_(4);\n  } else if (Value <= EBML_PRETTYLONGINT(0x7FFFFFFFFF) &&\n             Value >= EBML_PRETTYLONGINT(-0x8000000000)) {\n    SetSize_(5);\n  } els",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "91-122"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlElement::VoidMe",
          "EbmlVoid::Overwrite",
          "EbmlElement::RenderHead",
          "EbmlSInteger::UpdateSize"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlElement::VoidMe",
            "snippet": "uint64 EbmlElement::VoidMe(IOCallback & output, bool bWithDefault)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  EbmlVoid Dummy;\n  return Dummy.Overwrite(*this, output, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "694-702"
          },
          {
            "qualified_name": "EbmlVoid::Overwrite",
            "snippet": "uint64 EbmlVoid::Overwrite(const EbmlElement & EltToVoid, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  //  EltToVoid.UpdateSize(bWithDefault);\n  if (EltToVoid.GetElementPosition() == 0) {\n    // this element has never been written\n    return 0;\n  }\n  if (EltToVoid.GetSize() + EltToVoid.HeadSize() <2) {\n    // the element can't be written here !\n    return 0;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePointer(EltToVoid.GetElementPosition());\n\n  // compute the size of the voided data based on the original one\n  SetSize(EltToVoid.GetSize() + E",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "99-135"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlSInteger::UpdateSize",
            "snippet": "uint64 EbmlSInteger::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value <= 0x7F && Value >= (-0x80)) {\n    SetSize_(1);\n  } else if (Value <= 0x7FFF && Value >= (-0x8000)) {\n    SetSize_(2);\n  } else if (Value <= 0x7FFFFF && Value >= (-0x800000)) {\n    SetSize_(3);\n  } else if (Value <= EBML_PRETTYLONGINT(0x7FFFFFFF) && Value >= (EBML_PRETTYLONGINT(-0x80000000))) {\n    SetSize_(4);\n  } else if (Value <= EBML_PRETTYLONGINT(0x7FFFFFFFFF) &&\n             Value >= EBML_PRETTYLONGINT(-0x8000000000)) {\n    SetSize_(5);\n  } els",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "91-122"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::RenderHead",
          "EbmlSInteger::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlSInteger::UpdateSize",
            "snippet": "uint64 EbmlSInteger::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value <= 0x7F && Value >= (-0x80)) {\n    SetSize_(1);\n  } else if (Value <= 0x7FFF && Value >= (-0x8000)) {\n    SetSize_(2);\n  } else if (Value <= 0x7FFFFF && Value >= (-0x800000)) {\n    SetSize_(3);\n  } else if (Value <= EBML_PRETTYLONGINT(0x7FFFFFFF) && Value >= (EBML_PRETTYLONGINT(-0x80000000))) {\n    SetSize_(4);\n  } else if (Value <= EBML_PRETTYLONGINT(0x7FFFFFFFFF) &&\n             Value >= EBML_PRETTYLONGINT(-0x8000000000)) {\n    SetSize_(5);\n  } els",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "91-122"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlSInteger::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlSInteger::UpdateSize",
            "snippet": "uint64 EbmlSInteger::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value <= 0x7F && Value >= (-0x80)) {\n    SetSize_(1);\n  } else if (Value <= 0x7FFF && Value >= (-0x8000)) {\n    SetSize_(2);\n  } else if (Value <= 0x7FFFFF && Value >= (-0x800000)) {\n    SetSize_(3);\n  } else if (Value <= EBML_PRETTYLONGINT(0x7FFFFFFF) && Value >= (EBML_PRETTYLONGINT(-0x80000000))) {\n    SetSize_(4);\n  } else if (Value <= EBML_PRETTYLONGINT(0x7FFFFFFFFF) &&\n             Value >= EBML_PRETTYLONGINT(-0x8000000000)) {\n    SetSize_(5);\n  } els",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "91-122"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlSInteger::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlSInteger::UpdateSize",
            "snippet": "uint64 EbmlSInteger::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value <= 0x7F && Value >= (-0x80)) {\n    SetSize_(1);\n  } else if (Value <= 0x7FFF && Value >= (-0x8000)) {\n    SetSize_(2);\n  } else if (Value <= 0x7FFFFF && Value >= (-0x800000)) {\n    SetSize_(3);\n  } else if (Value <= EBML_PRETTYLONGINT(0x7FFFFFFF) && Value >= (EBML_PRETTYLONGINT(-0x80000000))) {\n    SetSize_(4);\n  } else if (Value <= EBML_PRETTYLONGINT(0x7FFFFFFFFF) &&\n             Value >= EBML_PRETTYLONGINT(-0x8000000000)) {\n    SetSize_(5);\n  } els",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "91-122"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlSInteger::UpdateSize"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlSInteger::UpdateSize",
            "snippet": "uint64 EbmlSInteger::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value <= 0x7F && Value >= (-0x80)) {\n    SetSize_(1);\n  } else if (Value <= 0x7FFF && Value >= (-0x8000)) {\n    SetSize_(2);\n  } else if (Value <= 0x7FFFFF && Value >= (-0x800000)) {\n    SetSize_(3);\n  } else if (Value <= EBML_PRETTYLONGINT(0x7FFFFFFF) && Value >= (EBML_PRETTYLONGINT(-0x80000000))) {\n    SetSize_(4);\n  } else if (Value <= EBML_PRETTYLONGINT(0x7FFFFFFFFF) &&\n             Value >= EBML_PRETTYLONGINT(-0x8000000000)) {\n    SetSize_(5);\n  } els",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "91-122"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlSInteger::UpdateSize"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlSInteger::UpdateSize",
            "snippet": "uint64 EbmlSInteger::UpdateSize(bool bWithDefault, bool /* bForceRender */)\n{\n  if (!bWithDefault && IsDefaultValue())\n    return 0;\n\n  if (Value <= 0x7F && Value >= (-0x80)) {\n    SetSize_(1);\n  } else if (Value <= 0x7FFF && Value >= (-0x8000)) {\n    SetSize_(2);\n  } else if (Value <= 0x7FFFFF && Value >= (-0x800000)) {\n    SetSize_(3);\n  } else if (Value <= EBML_PRETTYLONGINT(0x7FFFFFFF) && Value >= (EBML_PRETTYLONGINT(-0x80000000))) {\n    SetSize_(4);\n  } else if (Value <= EBML_PRETTYLONGINT(0x7FFFFFFFFF) &&\n             Value >= EBML_PRETTYLONGINT(-0x8000000000)) {\n    SetSize_(5);\n  } els",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "91-122"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlSInteger::RenderData",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
    "lines": "72-89",
    "num_chains": 3,
    "chains": [
      {
        "call_sequence": [
          "EbmlCrc32::CheckElementCRC32",
          "EbmlElement::Render",
          "EbmlSInteger::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::CheckElementCRC32",
            "snippet": "bool EbmlCrc32::CheckElementCRC32(EbmlElement &ElementToCRC)\n{\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer);\n\n  return CheckCRC(m_crc_final, memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "202-208"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlSInteger::RenderData",
            "snippet": "filepos_t EbmlSInteger::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  binary FinalData[8]; // we don't handle more than 64 bits integers\n  unsigned int i;\n\n  if (GetSizeLength() > 8)\n    return 0; // integer bigger coded on more than 64 bits are not supported\n\n  int64 TempValue = Value;\n  for (i=0; i<GetSize();i++) {\n    FinalData[GetSize()-i-1] = binary(TempValue & 0xFF);\n    TempValue >>= 8;\n  }\n\n  output.writeFully(FinalData,GetSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "72-89"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlCrc32::AddElementCRC32",
          "EbmlElement::Render",
          "EbmlSInteger::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlCrc32::AddElementCRC32",
            "snippet": "void EbmlCrc32::AddElementCRC32(EbmlElement &ElementToCRC)\n{\n  // Use a special IOCallback class that Render's to memory instead of to disk\n  MemIOCallback memoryBuffer;\n  ElementToCRC.Render(memoryBuffer, true, true);\n\n  Update(memoryBuffer.GetDataBuffer(), memoryBuffer.GetDataBufferSize());\n  //  Finalize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlCrc32.cpp",
            "lines": "192-200"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlSInteger::RenderData",
            "snippet": "filepos_t EbmlSInteger::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  binary FinalData[8]; // we don't handle more than 64 bits integers\n  unsigned int i;\n\n  if (GetSizeLength() > 8)\n    return 0; // integer bigger coded on more than 64 bits are not supported\n\n  int64 TempValue = Value;\n  for (i=0; i<GetSize();i++) {\n    FinalData[GetSize()-i-1] = binary(TempValue & 0xFF);\n    TempValue >>= 8;\n  }\n\n  output.writeFully(FinalData,GetSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "72-89"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::Render",
          "EbmlSInteger::RenderData"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::Render",
            "snippet": "filepos_t EbmlElement::Render(IOCallback & output, bool bWithDefault, bool bKeepPosition, bool bForceRender)\n{\n  assert(bValueIsSet || (bWithDefault && DefaultISset())); // an element is been rendered without a value set !!!\n  // it may be a mandatory element without a default value\n  if (!bWithDefault && IsDefaultValue()) {\n    return 0;\n  }\n#if defined(LIBEBML_DEBUG)\n  uint64 SupposedSize = UpdateSize(bWithDefault, bForceRender);\n#endif // LIBEBML_DEBUG\n  filepos_t result = RenderHead(output, bForceRender, bWithDefault, bKeepPosition);\n  uint64 WrittenSize = RenderData(output, bForceRender, ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "580-598"
          },
          {
            "qualified_name": "EbmlSInteger::RenderData",
            "snippet": "filepos_t EbmlSInteger::RenderData(IOCallback & output, bool /* bForceRender */, bool /* bWithDefault */)\n{\n  binary FinalData[8]; // we don't handle more than 64 bits integers\n  unsigned int i;\n\n  if (GetSizeLength() > 8)\n    return 0; // integer bigger coded on more than 64 bits are not supported\n\n  int64 TempValue = Value;\n  for (i=0; i<GetSize();i++) {\n    FinalData[GetSize()-i-1] = binary(TempValue & 0xFF);\n    TempValue >>= 8;\n  }\n\n  output.writeFully(FinalData,GetSize());\n\n  return GetSize();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "72-89"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlSInteger::GetValue",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
    "lines": "63-63",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlSInteger::GetValue"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlSInteger::GetValue",
            "snippet": "int64 EbmlSInteger::GetValue() const {return Value;}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "63-63"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlSInteger::EbmlSInteger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
    "lines": "51-56",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlSInteger::EbmlSInteger"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlSInteger::EbmlSInteger",
            "snippet": "EbmlSInteger::EbmlSInteger(int64 aDefaultValue)\n  :EbmlElement(DEFAULT_INT_SIZE, true), Value(aDefaultValue)\n{\n  SetDefaultIsSet();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "45-49"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlSInteger::EbmlSInteger",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
    "lines": "45-49",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlSInteger::EbmlSInteger"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlSInteger::EbmlSInteger",
            "snippet": "EbmlSInteger::EbmlSInteger(int64 aDefaultValue)\n  :EbmlElement(DEFAULT_INT_SIZE, true), Value(aDefaultValue)\n{\n  SetDefaultIsSet();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "45-49"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlElement",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
    "lines": "39-43",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlElement",
            "snippet": "START_LIBEBML_NAMESPACE\n\nEbmlSInteger::EbmlSInteger()\n  :EbmlElement(DEFAULT_INT_SIZE, false)\n{}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlSInteger.cpp",
            "lines": "39-43"
          }
        ]
      }
    ]
  },
  {
    "target_function": "EbmlHead::EbmlHead",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlHead.cpp",
    "lines": "54-56",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlHead::EbmlHead"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "EbmlHead::EbmlHead",
            "snippet": "EbmlHead::EbmlHead()\n  :EbmlMaster(EbmlHead_Context)\n{}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlHead.cpp",
            "lines": "54-56"
          }
        ]
      }
    ]
  },
  {
    "target_function": "WinIOCallback::SetEOF",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
    "lines": "271-274",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "WinIOCallback::SetEOF"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "WinIOCallback::SetEOF",
            "snippet": "bool WinIOCallback::SetEOF()\n{\n  return SetEndOfFile(mFile) != 0;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "271-274"
          }
        ]
      }
    ]
  },
  {
    "target_function": "WinIOCallback::write",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
    "lines": "261-269",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::OverwriteHead",
          "EbmlElement::MakeRenderHead",
          "IOCallback::writeFully",
          "WinIOCallback::write"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlElement::OverwriteHead",
            "snippet": "filepos_t EbmlElement::OverwriteHead(IOCallback & output, bool bKeepPosition)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n  output.setFilePointer(GetElementPosition());\n  filepos_t Result = MakeRenderHead(output, bKeepPosition);\n  output.setFilePointer(CurrentPosition);\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "681-692"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          },
          {
            "qualified_name": "IOCallback::writeFully",
            "snippet": "START_LIBEBML_NAMESPACE\n\nvoid IOCallback::writeFully(const void*Buffer,size_t Size)\n{\n  if (Size == 0)\n    return;\n\n  if (Buffer == NULL)\n    throw;\n\n  if(write(Buffer,Size) != Size) {\n#if !defined(__GNUC__) || (__GNUC__ > 2)\n    stringstream Msg;\n    Msg<<\"EOF in writeFully(\"<<Buffer<<\",\"<<Size<<\")\";\n    throw runtime_error(Msg.str());\n#endif // GCC2\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/IOCallback.cpp",
            "lines": "46-63"
          },
          {
            "qualified_name": "WinIOCallback::write",
            "snippet": "size_t WinIOCallback::write(const void*Buffer,size_t Size)\n{\n  DWORD BytesWriten;\n  if (!WriteFile(mFile, Buffer, Size, &BytesWriten, NULL)) {\n    return 0;\n  }\n  mCurrentPosition += BytesWriten;\n  return BytesWriten;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "261-269"
          }
        ]
      }
    ]
  },
  {
    "target_function": "WinIOCallback::read",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
    "lines": "251-259",
    "num_chains": 5,
    "chains": [
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt64BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "WinIOCallback::read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt64BE",
            "snippet": "uint64\nSafeReadIOCallback::GetUInt64BE() {\n  return GetUIntBE(8);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "142-145"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "WinIOCallback::read",
            "snippet": "uint32 WinIOCallback::read(void*Buffer,size_t Size)\n{\n  DWORD BytesRead;\n  if (!ReadFile(mFile, Buffer, Size, &BytesRead, NULL)) {\n    return 0;\n  }\n  mCurrentPosition += BytesRead;\n  return BytesRead;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "251-259"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt32BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "WinIOCallback::read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt32BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt32BE() {\n  return GetUIntBE(4);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "137-140"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "WinIOCallback::read",
            "snippet": "uint32 WinIOCallback::read(void*Buffer,size_t Size)\n{\n  DWORD BytesRead;\n  if (!ReadFile(mFile, Buffer, Size, &BytesRead, NULL)) {\n    return 0;\n  }\n  mCurrentPosition += BytesRead;\n  return BytesRead;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "251-259"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt24BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "WinIOCallback::read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt24BE",
            "snippet": "uint32\nSafeReadIOCallback::GetUInt24BE() {\n  return GetUIntBE(3);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "132-135"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "WinIOCallback::read",
            "snippet": "uint32 WinIOCallback::read(void*Buffer,size_t Size)\n{\n  DWORD BytesRead;\n  if (!ReadFile(mFile, Buffer, Size, &BytesRead, NULL)) {\n    return 0;\n  }\n  mCurrentPosition += BytesRead;\n  return BytesRead;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "251-259"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt16BE",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "WinIOCallback::read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt16BE",
            "snippet": "uint16\nSafeReadIOCallback::GetUInt16BE() {\n  return GetUIntBE(2);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "127-130"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "WinIOCallback::read",
            "snippet": "uint32 WinIOCallback::read(void*Buffer,size_t Size)\n{\n  DWORD BytesRead;\n  if (!ReadFile(mFile, Buffer, Size, &BytesRead, NULL)) {\n    return 0;\n  }\n  mCurrentPosition += BytesRead;\n  return BytesRead;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "251-259"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::GetUInt8",
          "SafeReadIOCallback::GetUIntBE",
          "SafeReadIOCallback::Read",
          "WinIOCallback::read"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::GetUInt8",
            "snippet": "uint8\nSafeReadIOCallback::GetUInt8() {\n  return GetUIntBE(1);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "122-125"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetUIntBE",
            "snippet": "uint64\nSafeReadIOCallback::GetUIntBE(size_t NumBytes) {\n  uint8 Buffer[8];\n\n  NumBytes     = std::min<size_t>(std::max<size_t>(1, NumBytes), 8);\n  uint64 Value = 0;\n  uint8* Ptr   = &Buffer[0];\n\n  Read(Buffer, NumBytes);\n\n  for (size_t i = 0; NumBytes > i; ++i, ++Ptr)\n    Value = (Value << 8) + *Ptr;\n\n  return Value;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "106-120"
          },
          {
            "qualified_name": "SafeReadIOCallback::Read",
            "snippet": "void\nSafeReadIOCallback::Read(void *Dst,\n                       size_t Count) {\n  uint64 NumRead = mIO->read(Dst, Count);\n  if (NumRead != Count)\n    throw SafeReadIOCallback::EndOfStreamX(Count - NumRead);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "166-172"
          },
          {
            "qualified_name": "WinIOCallback::read",
            "snippet": "uint32 WinIOCallback::read(void*Buffer,size_t Size)\n{\n  DWORD BytesRead;\n  if (!ReadFile(mFile, Buffer, Size, &BytesRead, NULL)) {\n    return 0;\n  }\n  mCurrentPosition += BytesRead;\n  return BytesRead;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "251-259"
          }
        ]
      }
    ]
  },
  {
    "target_function": "WinIOCallback::setFilePointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
    "lines": "222-249",
    "num_chains": 7,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::OverwriteHead",
          "WinIOCallback::setFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlElement::OverwriteHead",
            "snippet": "filepos_t EbmlElement::OverwriteHead(IOCallback & output, bool bKeepPosition)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n  output.setFilePointer(GetElementPosition());\n  filepos_t Result = MakeRenderHead(output, bKeepPosition);\n  output.setFilePointer(CurrentPosition);\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "681-692"
          },
          {
            "qualified_name": "WinIOCallback::setFilePointer",
            "snippet": "void WinIOCallback::setFilePointer(int64 Offset, seek_mode Mode)\n{\n  DWORD Method;\n  switch(Mode) {\n    case seek_beginning:\n      Method=FILE_BEGIN;\n      break;\n    case seek_current:\n      Method=FILE_CURRENT;\n      break;\n    case seek_end:\n      Method=FILE_END;\n      break;\n    default:\n      assert(false);\n      break;\n  }\n\n  LONG High = LONG(Offset>>32);\n  mCurrentPosition = SetFilePointer(mFile, LONG(Offset & 0xffffffff), &High, Method);\n  if ( mCurrentPosition == INVALID_SET_FILE_POINTER ) {\n    High = 0;\n    DWORD Low = SetFilePointer(mFile, 0, &High, FILE_CURRENT);\n    mCurrentPosi",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "222-249"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::Seek",
          "WinIOCallback::setFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::Seek",
            "snippet": "void\nSafeReadIOCallback::Seek(size_t Offset) {\n  mIO->setFilePointer(Offset);\n  uint64 ActualPosition = mIO->getFilePointer();\n  if (ActualPosition != Offset)\n    throw EndOfStreamX(ActualPosition - Offset);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "158-164"
          },
          {
            "qualified_name": "WinIOCallback::setFilePointer",
            "snippet": "void WinIOCallback::setFilePointer(int64 Offset, seek_mode Mode)\n{\n  DWORD Method;\n  switch(Mode) {\n    case seek_beginning:\n      Method=FILE_BEGIN;\n      break;\n    case seek_current:\n      Method=FILE_CURRENT;\n      break;\n    case seek_end:\n      Method=FILE_END;\n      break;\n    default:\n      assert(false);\n      break;\n  }\n\n  LONG High = LONG(Offset>>32);\n  mCurrentPosition = SetFilePointer(mFile, LONG(Offset & 0xffffffff), &High, Method);\n  if ( mCurrentPosition == INVALID_SET_FILE_POINTER ) {\n    High = 0;\n    DWORD Low = SetFilePointer(mFile, 0, &High, FILE_CURRENT);\n    mCurrentPosi",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "222-249"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::Skip",
          "WinIOCallback::setFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::Skip",
            "snippet": "void\nSafeReadIOCallback::Skip(size_t Count) {\n  int64 PrevPosition     = mIO->getFilePointer();\n  int64 ExpectedPosition = PrevPosition + Count;\n  mIO->setFilePointer(Count, seek_current);\n  int64 ActualPosition   = mIO->getFilePointer();\n\n  if (ActualPosition != ExpectedPosition)\n    throw SafeReadIOCallback::EndOfStreamX(ExpectedPosition - ActualPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "147-156"
          },
          {
            "qualified_name": "WinIOCallback::setFilePointer",
            "snippet": "void WinIOCallback::setFilePointer(int64 Offset, seek_mode Mode)\n{\n  DWORD Method;\n  switch(Mode) {\n    case seek_beginning:\n      Method=FILE_BEGIN;\n      break;\n    case seek_current:\n      Method=FILE_CURRENT;\n      break;\n    case seek_end:\n      Method=FILE_END;\n      break;\n    default:\n      assert(false);\n      break;\n  }\n\n  LONG High = LONG(Offset>>32);\n  mCurrentPosition = SetFilePointer(mFile, LONG(Offset & 0xffffffff), &High, Method);\n  if ( mCurrentPosition == INVALID_SET_FILE_POINTER ) {\n    High = 0;\n    DWORD Low = SetFilePointer(mFile, 0, &High, FILE_CURRENT);\n    mCurrentPosi",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "222-249"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::SafeReadIOCallback",
          "SafeReadIOCallback::Init",
          "WinIOCallback::setFilePointer"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::SafeReadIOCallback",
            "snippet": "SafeReadIOCallback::SafeReadIOCallback(IOCallback *IO,\n                                       bool DeleteIO) {\n  Init(IO, DeleteIO);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "52-55"
          },
          {
            "qualified_name": "SafeReadIOCallback::Init",
            "snippet": "void\nSafeReadIOCallback::Init(IOCallback *IO,\n                         bool DeleteIO) {\n  mIO                = IO;\n  mDeleteIO          = DeleteIO;\n  int64 PrevPosition = IO->getFilePointer();\n  IO->setFilePointer(0, seek_end);\n  mSize              = IO->getFilePointer();\n  IO->setFilePointer(PrevPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "71-80"
          },
          {
            "qualified_name": "WinIOCallback::setFilePointer",
            "snippet": "void WinIOCallback::setFilePointer(int64 Offset, seek_mode Mode)\n{\n  DWORD Method;\n  switch(Mode) {\n    case seek_beginning:\n      Method=FILE_BEGIN;\n      break;\n    case seek_current:\n      Method=FILE_CURRENT;\n      break;\n    case seek_end:\n      Method=FILE_END;\n      break;\n    default:\n      assert(false);\n      break;\n  }\n\n  LONG High = LONG(Offset>>32);\n  mCurrentPosition = SetFilePointer(mFile, LONG(Offset & 0xffffffff), &High, Method);\n  if ( mCurrentPosition == INVALID_SET_FILE_POINTER ) {\n    High = 0;\n    DWORD Low = SetFilePointer(mFile, 0, &High, FILE_CURRENT);\n    mCurrentPosi",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "222-249"
          }
        ]
      },
      {
        "call_sequence": [
          "MemReadIOCallback::MemReadIOCallback",
          "SafeReadIOCallback::Init",
          "WinIOCallback::setFilePointer"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "MemReadIOCallback::MemReadIOCallback",
            "snippet": "START_LIBEBML_NAMESPACE\n\nMemReadIOCallback::MemReadIOCallback(void const *Ptr,\n                                     size_t Size) {\n  Init(Ptr, Size);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "42-47"
          },
          {
            "qualified_name": "SafeReadIOCallback::Init",
            "snippet": "void\nSafeReadIOCallback::Init(IOCallback *IO,\n                         bool DeleteIO) {\n  mIO                = IO;\n  mDeleteIO          = DeleteIO;\n  int64 PrevPosition = IO->getFilePointer();\n  IO->setFilePointer(0, seek_end);\n  mSize              = IO->getFilePointer();\n  IO->setFilePointer(PrevPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "71-80"
          },
          {
            "qualified_name": "WinIOCallback::setFilePointer",
            "snippet": "void WinIOCallback::setFilePointer(int64 Offset, seek_mode Mode)\n{\n  DWORD Method;\n  switch(Mode) {\n    case seek_beginning:\n      Method=FILE_BEGIN;\n      break;\n    case seek_current:\n      Method=FILE_CURRENT;\n      break;\n    case seek_end:\n      Method=FILE_END;\n      break;\n    default:\n      assert(false);\n      break;\n  }\n\n  LONG High = LONG(Offset>>32);\n  mCurrentPosition = SetFilePointer(mFile, LONG(Offset & 0xffffffff), &High, Method);\n  if ( mCurrentPosition == INVALID_SET_FILE_POINTER ) {\n    High = 0;\n    DWORD Low = SetFilePointer(mFile, 0, &High, FILE_CURRENT);\n    mCurrentPosi",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "222-249"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlElement::VoidMe",
          "EbmlVoid::Overwrite",
          "WinIOCallback::setFilePointer"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlElement::VoidMe",
            "snippet": "uint64 EbmlElement::VoidMe(IOCallback & output, bool bWithDefault)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  EbmlVoid Dummy;\n  return Dummy.Overwrite(*this, output, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "694-702"
          },
          {
            "qualified_name": "EbmlVoid::Overwrite",
            "snippet": "uint64 EbmlVoid::Overwrite(const EbmlElement & EltToVoid, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  //  EltToVoid.UpdateSize(bWithDefault);\n  if (EltToVoid.GetElementPosition() == 0) {\n    // this element has never been written\n    return 0;\n  }\n  if (EltToVoid.GetSize() + EltToVoid.HeadSize() <2) {\n    // the element can't be written here !\n    return 0;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePointer(EltToVoid.GetElementPosition());\n\n  // compute the size of the voided data based on the original one\n  SetSize(EltToVoid.GetSize() + E",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "99-135"
          },
          {
            "qualified_name": "WinIOCallback::setFilePointer",
            "snippet": "void WinIOCallback::setFilePointer(int64 Offset, seek_mode Mode)\n{\n  DWORD Method;\n  switch(Mode) {\n    case seek_beginning:\n      Method=FILE_BEGIN;\n      break;\n    case seek_current:\n      Method=FILE_CURRENT;\n      break;\n    case seek_end:\n      Method=FILE_END;\n      break;\n    default:\n      assert(false);\n      break;\n  }\n\n  LONG High = LONG(Offset>>32);\n  mCurrentPosition = SetFilePointer(mFile, LONG(Offset & 0xffffffff), &High, Method);\n  if ( mCurrentPosition == INVALID_SET_FILE_POINTER ) {\n    High = 0;\n    DWORD Low = SetFilePointer(mFile, 0, &High, FILE_CURRENT);\n    mCurrentPosi",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "222-249"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "WinIOCallback::setFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "WinIOCallback::setFilePointer",
            "snippet": "void WinIOCallback::setFilePointer(int64 Offset, seek_mode Mode)\n{\n  DWORD Method;\n  switch(Mode) {\n    case seek_beginning:\n      Method=FILE_BEGIN;\n      break;\n    case seek_current:\n      Method=FILE_CURRENT;\n      break;\n    case seek_end:\n      Method=FILE_END;\n      break;\n    default:\n      assert(false);\n      break;\n  }\n\n  LONG High = LONG(Offset>>32);\n  mCurrentPosition = SetFilePointer(mFile, LONG(Offset & 0xffffffff), &High, Method);\n  if ( mCurrentPosition == INVALID_SET_FILE_POINTER ) {\n    High = 0;\n    DWORD Low = SetFilePointer(mFile, 0, &High, FILE_CURRENT);\n    mCurrentPosi",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "222-249"
          }
        ]
      }
    ]
  },
  {
    "target_function": "WinIOCallback::getFilePointer",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
    "lines": "206-220",
    "num_chains": 11,
    "chains": [
      {
        "call_sequence": [
          "EbmlElement::OverwriteHead",
          "WinIOCallback::getFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlElement::OverwriteHead",
            "snippet": "filepos_t EbmlElement::OverwriteHead(IOCallback & output, bool bKeepPosition)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n  output.setFilePointer(GetElementPosition());\n  filepos_t Result = MakeRenderHead(output, bKeepPosition);\n  output.setFilePointer(CurrentPosition);\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "681-692"
          },
          {
            "qualified_name": "WinIOCallback::getFilePointer",
            "snippet": "uint64 WinIOCallback::getFilePointer()\n{\n  if (!mFile) {\n    return 0;\n  }\n\n  return mCurrentPosition;\n#if 0\n  LONG High = 0;\n  DWORD Low = SetFilePointer(mFile, 0, &High, FILE_CURRENT);\n  if ( (Low==INVALID_SET_FILE_POINTER) && (GetLastError()!=NO_ERROR) )\n    return static_cast<uint64>(-1);\n  return ((uint64(High)<<32) | Low);\n#endif\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "206-220"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlElement::OverwriteHead",
          "EbmlElement::MakeRenderHead",
          "WinIOCallback::getFilePointer"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlElement::OverwriteHead",
            "snippet": "filepos_t EbmlElement::OverwriteHead(IOCallback & output, bool bKeepPosition)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n  output.setFilePointer(GetElementPosition());\n  filepos_t Result = MakeRenderHead(output, bKeepPosition);\n  output.setFilePointer(CurrentPosition);\n  return Result;\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "681-692"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          },
          {
            "qualified_name": "WinIOCallback::getFilePointer",
            "snippet": "uint64 WinIOCallback::getFilePointer()\n{\n  if (!mFile) {\n    return 0;\n  }\n\n  return mCurrentPosition;\n#if 0\n  LONG High = 0;\n  DWORD Low = SetFilePointer(mFile, 0, &High, FILE_CURRENT);\n  if ( (Low==INVALID_SET_FILE_POINTER) && (GetLastError()!=NO_ERROR) )\n    return static_cast<uint64>(-1);\n  return ((uint64(High)<<32) | Low);\n#endif\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "206-220"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlMaster::WriteHead",
          "EbmlElement::RenderHead",
          "EbmlElement::MakeRenderHead",
          "WinIOCallback::getFilePointer"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlMaster::WriteHead",
            "snippet": "filepos_t EbmlMaster::WriteHead(IOCallback & output, int nSizeLength, bool bWithDefault)\n{\n  SetSizeLength(nSizeLength);\n  return RenderHead(output, false, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlMaster.cpp",
            "lines": "161-165"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          },
          {
            "qualified_name": "WinIOCallback::getFilePointer",
            "snippet": "uint64 WinIOCallback::getFilePointer()\n{\n  if (!mFile) {\n    return 0;\n  }\n\n  return mCurrentPosition;\n#if 0\n  LONG High = 0;\n  DWORD Low = SetFilePointer(mFile, 0, &High, FILE_CURRENT);\n  if ( (Low==INVALID_SET_FILE_POINTER) && (GetLastError()!=NO_ERROR) )\n    return static_cast<uint64>(-1);\n  return ((uint64(High)<<32) | Low);\n#endif\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "206-220"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "EbmlElement::RenderHead",
          "EbmlElement::MakeRenderHead",
          "WinIOCallback::getFilePointer"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "EbmlElement::RenderHead",
            "snippet": "filepos_t EbmlElement::RenderHead(IOCallback & output, bool bForceRender, bool bWithDefault, bool bKeepPosition)\n{\n  if (EBML_ID_LENGTH((const EbmlId&)*this) <= 0 || EBML_ID_LENGTH((const EbmlId&)*this) > 4)\n    return 0;\n\n  UpdateSize(bWithDefault, bForceRender);\n\n  return MakeRenderHead(output, bKeepPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "605-613"
          },
          {
            "qualified_name": "EbmlElement::MakeRenderHead",
            "snippet": "filepos_t EbmlElement::MakeRenderHead(IOCallback & output, bool bKeepPosition)\n{\n  binary FinalHead[4+8]; // Class D + 64 bits coded size\n  unsigned int FinalHeadSize;\n\n  FinalHeadSize = EBML_ID_LENGTH((const EbmlId&)*this);\n  EbmlId(*this).Fill(FinalHead);\n\n  int CodedSize = CodedSizeLength(Size, SizeLength, bSizeIsFinite);\n  CodedValueLength(Size, CodedSize, &FinalHead[FinalHeadSize]);\n  FinalHeadSize += CodedSize;\n\n  output.writeFully(FinalHead, FinalHeadSize);\n  if (!bKeepPosition) {\n    ElementPosition = output.getFilePointer() - FinalHeadSize;\n    SizePosition = ElementPosition + EBML_ID",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "615-634"
          },
          {
            "qualified_name": "WinIOCallback::getFilePointer",
            "snippet": "uint64 WinIOCallback::getFilePointer()\n{\n  if (!mFile) {\n    return 0;\n  }\n\n  return mCurrentPosition;\n#if 0\n  LONG High = 0;\n  DWORD Low = SetFilePointer(mFile, 0, &High, FILE_CURRENT);\n  if ( (Low==INVALID_SET_FILE_POINTER) && (GetLastError()!=NO_ERROR) )\n    return static_cast<uint64>(-1);\n  return ((uint64(High)<<32) | Low);\n#endif\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "206-220"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::Seek",
          "WinIOCallback::getFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::Seek",
            "snippet": "void\nSafeReadIOCallback::Seek(size_t Offset) {\n  mIO->setFilePointer(Offset);\n  uint64 ActualPosition = mIO->getFilePointer();\n  if (ActualPosition != Offset)\n    throw EndOfStreamX(ActualPosition - Offset);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "158-164"
          },
          {
            "qualified_name": "WinIOCallback::getFilePointer",
            "snippet": "uint64 WinIOCallback::getFilePointer()\n{\n  if (!mFile) {\n    return 0;\n  }\n\n  return mCurrentPosition;\n#if 0\n  LONG High = 0;\n  DWORD Low = SetFilePointer(mFile, 0, &High, FILE_CURRENT);\n  if ( (Low==INVALID_SET_FILE_POINTER) && (GetLastError()!=NO_ERROR) )\n    return static_cast<uint64>(-1);\n  return ((uint64(High)<<32) | Low);\n#endif\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "206-220"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::Skip",
          "WinIOCallback::getFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::Skip",
            "snippet": "void\nSafeReadIOCallback::Skip(size_t Count) {\n  int64 PrevPosition     = mIO->getFilePointer();\n  int64 ExpectedPosition = PrevPosition + Count;\n  mIO->setFilePointer(Count, seek_current);\n  int64 ActualPosition   = mIO->getFilePointer();\n\n  if (ActualPosition != ExpectedPosition)\n    throw SafeReadIOCallback::EndOfStreamX(ExpectedPosition - ActualPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "147-156"
          },
          {
            "qualified_name": "WinIOCallback::getFilePointer",
            "snippet": "uint64 WinIOCallback::getFilePointer()\n{\n  if (!mFile) {\n    return 0;\n  }\n\n  return mCurrentPosition;\n#if 0\n  LONG High = 0;\n  DWORD Low = SetFilePointer(mFile, 0, &High, FILE_CURRENT);\n  if ( (Low==INVALID_SET_FILE_POINTER) && (GetLastError()!=NO_ERROR) )\n    return static_cast<uint64>(-1);\n  return ((uint64(High)<<32) | Low);\n#endif\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "206-220"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::IsEmpty",
          "SafeReadIOCallback::GetRemainingBytes",
          "SafeReadIOCallback::GetPosition",
          "WinIOCallback::getFilePointer"
        ],
        "length": 4,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::IsEmpty",
            "snippet": "bool\nSafeReadIOCallback::IsEmpty()\n  const {\n  return !GetRemainingBytes();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "100-104"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetRemainingBytes",
            "snippet": "size_t\nSafeReadIOCallback::GetRemainingBytes()\n  const {\n  return GetSize() - GetPosition();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "94-98"
          },
          {
            "qualified_name": "SafeReadIOCallback::GetPosition",
            "snippet": "size_t\nSafeReadIOCallback::GetPosition()\n  const {\n  return mIO->getFilePointer();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "82-86"
          },
          {
            "qualified_name": "WinIOCallback::getFilePointer",
            "snippet": "uint64 WinIOCallback::getFilePointer()\n{\n  if (!mFile) {\n    return 0;\n  }\n\n  return mCurrentPosition;\n#if 0\n  LONG High = 0;\n  DWORD Low = SetFilePointer(mFile, 0, &High, FILE_CURRENT);\n  if ( (Low==INVALID_SET_FILE_POINTER) && (GetLastError()!=NO_ERROR) )\n    return static_cast<uint64>(-1);\n  return ((uint64(High)<<32) | Low);\n#endif\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "206-220"
          }
        ]
      },
      {
        "call_sequence": [
          "SafeReadIOCallback::SafeReadIOCallback",
          "SafeReadIOCallback::Init",
          "WinIOCallback::getFilePointer"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "SafeReadIOCallback::SafeReadIOCallback",
            "snippet": "SafeReadIOCallback::SafeReadIOCallback(IOCallback *IO,\n                                       bool DeleteIO) {\n  Init(IO, DeleteIO);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "52-55"
          },
          {
            "qualified_name": "SafeReadIOCallback::Init",
            "snippet": "void\nSafeReadIOCallback::Init(IOCallback *IO,\n                         bool DeleteIO) {\n  mIO                = IO;\n  mDeleteIO          = DeleteIO;\n  int64 PrevPosition = IO->getFilePointer();\n  IO->setFilePointer(0, seek_end);\n  mSize              = IO->getFilePointer();\n  IO->setFilePointer(PrevPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "71-80"
          },
          {
            "qualified_name": "WinIOCallback::getFilePointer",
            "snippet": "uint64 WinIOCallback::getFilePointer()\n{\n  if (!mFile) {\n    return 0;\n  }\n\n  return mCurrentPosition;\n#if 0\n  LONG High = 0;\n  DWORD Low = SetFilePointer(mFile, 0, &High, FILE_CURRENT);\n  if ( (Low==INVALID_SET_FILE_POINTER) && (GetLastError()!=NO_ERROR) )\n    return static_cast<uint64>(-1);\n  return ((uint64(High)<<32) | Low);\n#endif\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "206-220"
          }
        ]
      },
      {
        "call_sequence": [
          "MemReadIOCallback::MemReadIOCallback",
          "SafeReadIOCallback::Init",
          "WinIOCallback::getFilePointer"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "MemReadIOCallback::MemReadIOCallback",
            "snippet": "START_LIBEBML_NAMESPACE\n\nMemReadIOCallback::MemReadIOCallback(void const *Ptr,\n                                     size_t Size) {\n  Init(Ptr, Size);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/MemReadIOCallback.cpp",
            "lines": "42-47"
          },
          {
            "qualified_name": "SafeReadIOCallback::Init",
            "snippet": "void\nSafeReadIOCallback::Init(IOCallback *IO,\n                         bool DeleteIO) {\n  mIO                = IO;\n  mDeleteIO          = DeleteIO;\n  int64 PrevPosition = IO->getFilePointer();\n  IO->setFilePointer(0, seek_end);\n  mSize              = IO->getFilePointer();\n  IO->setFilePointer(PrevPosition);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/SafeReadIOCallback.cpp",
            "lines": "71-80"
          },
          {
            "qualified_name": "WinIOCallback::getFilePointer",
            "snippet": "uint64 WinIOCallback::getFilePointer()\n{\n  if (!mFile) {\n    return 0;\n  }\n\n  return mCurrentPosition;\n#if 0\n  LONG High = 0;\n  DWORD Low = SetFilePointer(mFile, 0, &High, FILE_CURRENT);\n  if ( (Low==INVALID_SET_FILE_POINTER) && (GetLastError()!=NO_ERROR) )\n    return static_cast<uint64>(-1);\n  return ((uint64(High)<<32) | Low);\n#endif\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "206-220"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlElement::VoidMe",
          "EbmlVoid::Overwrite",
          "WinIOCallback::getFilePointer"
        ],
        "length": 3,
        "snippets": [
          {
            "qualified_name": "EbmlElement::VoidMe",
            "snippet": "uint64 EbmlElement::VoidMe(IOCallback & output, bool bWithDefault)\n{\n  if (ElementPosition == 0) {\n    return 0; // the element has not been written\n  }\n\n  EbmlVoid Dummy;\n  return Dummy.Overwrite(*this, output, bWithDefault);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlElement.cpp",
            "lines": "694-702"
          },
          {
            "qualified_name": "EbmlVoid::Overwrite",
            "snippet": "uint64 EbmlVoid::Overwrite(const EbmlElement & EltToVoid, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  //  EltToVoid.UpdateSize(bWithDefault);\n  if (EltToVoid.GetElementPosition() == 0) {\n    // this element has never been written\n    return 0;\n  }\n  if (EltToVoid.GetSize() + EltToVoid.HeadSize() <2) {\n    // the element can't be written here !\n    return 0;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePointer(EltToVoid.GetElementPosition());\n\n  // compute the size of the voided data based on the original one\n  SetSize(EltToVoid.GetSize() + E",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "99-135"
          },
          {
            "qualified_name": "WinIOCallback::getFilePointer",
            "snippet": "uint64 WinIOCallback::getFilePointer()\n{\n  if (!mFile) {\n    return 0;\n  }\n\n  return mCurrentPosition;\n#if 0\n  LONG High = 0;\n  DWORD Low = SetFilePointer(mFile, 0, &High, FILE_CURRENT);\n  if ( (Low==INVALID_SET_FILE_POINTER) && (GetLastError()!=NO_ERROR) )\n    return static_cast<uint64>(-1);\n  return ((uint64(High)<<32) | Low);\n#endif\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "206-220"
          }
        ]
      },
      {
        "call_sequence": [
          "EbmlVoid::ReplaceWith",
          "WinIOCallback::getFilePointer"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "EbmlVoid::ReplaceWith",
            "snippet": "uint64 EbmlVoid::ReplaceWith(EbmlElement & EltToReplaceWith, IOCallback & output, bool ComeBackAfterward, bool bWithDefault)\n{\n  EltToReplaceWith.UpdateSize(bWithDefault);\n  if (HeadSize() + GetSize() < EltToReplaceWith.GetSize() + EltToReplaceWith.HeadSize()) {\n    // the element can't be written here !\n    return INVALID_FILEPOS_T;\n  }\n  if (HeadSize() + GetSize() - EltToReplaceWith.GetSize() - EltToReplaceWith.HeadSize() == 1) {\n    // there is not enough space to put a filling element\n    return INVALID_FILEPOS_T;\n  }\n\n  uint64 CurrentPosition = output.getFilePointer();\n\n  output.setFilePo",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/EbmlVoid.cpp",
            "lines": "62-97"
          },
          {
            "qualified_name": "WinIOCallback::getFilePointer",
            "snippet": "uint64 WinIOCallback::getFilePointer()\n{\n  if (!mFile) {\n    return 0;\n  }\n\n  return mCurrentPosition;\n#if 0\n  LONG High = 0;\n  DWORD Low = SetFilePointer(mFile, 0, &High, FILE_CURRENT);\n  if ( (Low==INVALID_SET_FILE_POINTER) && (GetLastError()!=NO_ERROR) )\n    return static_cast<uint64>(-1);\n  return ((uint64(High)<<32) | Low);\n#endif\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "206-220"
          }
        ]
      }
    ]
  },
  {
    "target_function": "WinIOCallback::close",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
    "lines": "198-204",
    "num_chains": 2,
    "chains": [
      {
        "call_sequence": [
          "StdIOCallback::~StdIOCallback",
          "WinIOCallback::close"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "StdIOCallback::~StdIOCallback",
            "snippet": "StdIOCallback::~StdIOCallback()throw()\n{\n  close();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/StdIOCallback.cpp",
            "lines": "97-100"
          },
          {
            "qualified_name": "WinIOCallback::close",
            "snippet": "void WinIOCallback::close()\n{\n  if (mFile) {\n    CloseHandle(mFile);\n    mFile = NULL;\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "198-204"
          }
        ]
      },
      {
        "call_sequence": [
          "WinIOCallback::~WinIOCallback",
          "WinIOCallback::close"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "WinIOCallback::~WinIOCallback",
            "snippet": "WinIOCallback::~WinIOCallback()\n{\n  close();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "61-64"
          },
          {
            "qualified_name": "WinIOCallback::close",
            "snippet": "void WinIOCallback::close()\n{\n  if (mFile) {\n    CloseHandle(mFile);\n    mFile = NULL;\n  }\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "198-204"
          }
        ]
      }
    ]
  },
  {
    "target_function": "WinIOCallback::open",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
    "lines": "118-196",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "WinIOCallback::WinIOCallback",
          "WinIOCallback::open"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "WinIOCallback::WinIOCallback",
            "snippet": "WinIOCallback::WinIOCallback(const wchar_t* Path, const open_mode aMode, DWORD dwFlags)\n  :mFile(NULL), mOk(false)\n{\n  mOk = open(Path, aMode, dwFlags);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "55-59"
          },
          {
            "qualified_name": "WinIOCallback::open",
            "snippet": "bool WinIOCallback::open(const char* Path, const open_mode aMode, DWORD dwFlags)\n{\n  assert(Path!=0);\n\n  DWORD AccessMode, ShareMode, Disposition;\n\n  switch (aMode) {\n    case MODE_READ:\n      AccessMode = GENERIC_READ;\n      ShareMode = FILE_SHARE_READ|FILE_SHARE_WRITE;\n      Disposition = OPEN_EXISTING;\n      break;\n    case MODE_WRITE:\n      AccessMode = GENERIC_WRITE;\n      ShareMode = 0;\n      Disposition = OPEN_ALWAYS;\n      break;\n    case MODE_SAFE:\n      AccessMode = GENERIC_WRITE|GENERIC_READ;\n      ShareMode = FILE_SHARE_READ|FILE_SHARE_WRITE;\n      Disposition = OPEN_ALWAYS;\n      ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "66-116"
          }
        ]
      }
    ]
  },
  {
    "target_function": "WinIOCallback::open",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
    "lines": "66-116",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "WinIOCallback::WinIOCallback",
          "WinIOCallback::open"
        ],
        "length": 2,
        "snippets": [
          {
            "qualified_name": "WinIOCallback::WinIOCallback",
            "snippet": "WinIOCallback::WinIOCallback(const wchar_t* Path, const open_mode aMode, DWORD dwFlags)\n  :mFile(NULL), mOk(false)\n{\n  mOk = open(Path, aMode, dwFlags);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "55-59"
          },
          {
            "qualified_name": "WinIOCallback::open",
            "snippet": "bool WinIOCallback::open(const char* Path, const open_mode aMode, DWORD dwFlags)\n{\n  assert(Path!=0);\n\n  DWORD AccessMode, ShareMode, Disposition;\n\n  switch (aMode) {\n    case MODE_READ:\n      AccessMode = GENERIC_READ;\n      ShareMode = FILE_SHARE_READ|FILE_SHARE_WRITE;\n      Disposition = OPEN_EXISTING;\n      break;\n    case MODE_WRITE:\n      AccessMode = GENERIC_WRITE;\n      ShareMode = 0;\n      Disposition = OPEN_ALWAYS;\n      break;\n    case MODE_SAFE:\n      AccessMode = GENERIC_WRITE|GENERIC_READ;\n      ShareMode = FILE_SHARE_READ|FILE_SHARE_WRITE;\n      Disposition = OPEN_ALWAYS;\n      ",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "66-116"
          }
        ]
      }
    ]
  },
  {
    "target_function": "WinIOCallback::~WinIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
    "lines": "61-64",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "WinIOCallback::~WinIOCallback"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "WinIOCallback::~WinIOCallback",
            "snippet": "WinIOCallback::~WinIOCallback()\n{\n  close();\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "61-64"
          }
        ]
      }
    ]
  },
  {
    "target_function": "WinIOCallback::WinIOCallback",
    "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
    "lines": "55-59",
    "num_chains": 1,
    "chains": [
      {
        "call_sequence": [
          "WinIOCallback::WinIOCallback"
        ],
        "length": 1,
        "snippets": [
          {
            "qualified_name": "WinIOCallback::WinIOCallback",
            "snippet": "WinIOCallback::WinIOCallback(const wchar_t* Path, const open_mode aMode, DWORD dwFlags)\n  :mFile(NULL), mOk(false)\n{\n  mOk = open(Path, aMode, dwFlags);\n}",
            "file": "/home/michele/Desktop/ricerca/output_repos_cpp/CVE-2015-8790/repo/src/platform/win32/WinIOCallback.cpp",
            "lines": "55-59"
          }
        ]
      }
    ]
  }
]